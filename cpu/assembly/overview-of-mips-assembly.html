<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Overview of MIPS Assembly | Sanketh’s Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Overview of MIPS Assembly" />
<meta name="author" content="Sanketh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance." />
<meta property="og:description" content="MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance." />
<link rel="canonical" href="http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly" />
<meta property="og:url" content="http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly" />
<meta property="og:site_name" content="Sanketh’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-07-12T20:38:05+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Overview of MIPS Assembly" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sanketh"},"dateModified":"2024-07-12T20:38:05+05:30","datePublished":"2024-07-12T20:38:05+05:30","description":"MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.","headline":"Overview of MIPS Assembly","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly"},"url":"http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Sanketh&apos;s Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Sanketh&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

<link rel="stylesheet" href="/blog/assets/custom.css" />

<article class="post">
  <header class="post-header">
    <h1 class="post-title">Overview of MIPS Assembly</h1>
  </header>

  <div class="categories">
    
    <a
      href="/blog/categories/cpu"
      class="category-capsule"
      >cpu</a
    >
    
    <a
      href="/blog/categories/assembly"
      class="category-capsule"
      >assembly</a
    >
    
  </div>

  <div class="post-content"><p>MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.</p>

<h2 id="history">History</h2>

<p>The first MIPS processor, the R2000, was introduced. It implemented the MIPS I architecture, which was one of the earliest commercial RISC processors. There are multiple versions of MIPS: including MIPS I, II, III, IV, and V; as well as five releases of MIPS32/64. MIPS I had 32-bit architecture with basic instruction set and addressing modes. MIPS III introduced 64-bit architecture in 1991, increasing the address space and register width.</p>

<p>MIPS32 and MIPS64 are modern versions of the architecture, maintaining backward compatibility while introducing enhancements for modern computing needs. MicroMIPS is a compact version of the MIPS instruction set, designed for embedded systems with limited memory. MIPS processors are commonly used in embedded systems, such as routers, printers, and smart home devices, where their efficiency and performance are crucial. In the automotive industry, MIPS processors are employed in various control systems and infotainment systems, benefiting from their reliable and efficient processing capabilities. MIPS processors are increasingly found in IoT devices, providing the necessary computational power and energy efficiency for smart sensors, wearables, and other connected devices.</p>

<p>MIPS is built on RISC principles, which embrace simplicity and efficiency, making it an ideal choice for learning about CPU architecture in general. Some principles of RISC are:</p>

<ol>
  <li>Simple Instructions: RISC architectures use a small, highly optimized set of instructions. Each instruction is designed to be simple and execute in a single clock cycle (under ideal conditions in a pipelined processor).</li>
  <li>Load/Store Architecture: RISC separates memory access and data processing instructions. Only load and store instructions can access memory, while all other operations are performed on registers. This simplifies the instruction set and execution.</li>
  <li>Fixed-Length Instructions: Instructions in RISC architectures are of uniform length, typically 32 bits. This uniformity simplifies instruction decoding and pipeline design.</li>
  <li>Simple Addressing Modes: RISC architectures use a small number of simple addressing modes to keep instruction execution fast and efficient. Common addressing modes include register, immediate, and displacement.</li>
  <li>Pipelining: RISC architectures are designed to efficiently support pipelining. Instructions are broken down into stages (fetch, decode, execute, memory access, write-back) that can be processed simultaneously for different instructions.</li>
</ol>

<h2 id="mips32-and-mips64">MIPS32 and MIPS64</h2>

<p>MIPS32 and MIPS64 are ISAs designed for 32-bit and 64-bit CPUs, respectively. The primary distinctions between modern MIPS32 and MIPS64 architectures are found in their register size, memory addressing capabilities, and support for larger data and address spaces. Unlike ARM and x86, both MIPS32 and MIPS64 utilize 32-bit-wide instructions, regardless of whether they are operating on 32-bit or 64-bit processors.</p>

<p>MIPS32 is designed for 32-bit applications, with 32-bit registers and a 32-bit address space suitable embedded systems, microcontrollers, and other applications where 32-bit processing capabilities are sufficient. MIPS64 extends the architecture to 64-bit, offering larger 64-bit registers and a 64-bit address space, suitable for high-performance computing and large-scale applications.</p>

<p>Softwares written for MIPS32 can often run on MIPS64 processors without modification due to their shared instruction set, facilitating a smooth transition to 64-bit computing, while the reverse is not possible. MIPS is very efficient ISA for compiler to target because in most cases it can be well predicted how much time a sequence of instructions will take.</p>

<h2 id="registers">Registers</h2>

<h3 id="general-purpose-registers">General Purpose Registers</h3>

<p>General Purpose registers are meant to be used by programmers and compilers for whatver operations required and has no special meaning to CPU. General-purpose registers are versatile storage locations within the CPU used for a wide range of tasks like holding intermediate data, operands and results of computations, and store temporary values during program execution. They are meant to be utilized by programmers and compilers as needed, without any special significance to the CPU itself.</p>

<p>MIPS has 32 general purpose registers (R0 - R31), 32 floating point registers (F0 - F31) that can hold either a 32-bit single-precision number or a 64-bit double-precision number. General Purpose Registers (GPRs) in MIPS architectures are used for storing immediate values, temporary data, function arguments, and return values. They also facilitate address calculation for memory operations and control flow in branching and jumping instructions.</p>

<p>In MIPS, most registers are truly general-purpose, meaning they can be used for any purpose. MIPS programmers adhere to agreed-upon guidelines specifying how registers should be utilized. For instance, the stack pointer ($sp), global pointer ($gp), and frame pointer ($fp) are conventions rather than hardware-enforced roles, unlike in other Assembly languages like x86. The stack pointer is purely a software convention; no push instruction implicitly uses it. Using $t0 instead of $t3 as a temporary register isn’t inherently faster or better. However, there’s one notable exception: the jal instruction implicitly writes the return address to $31 (the link register).</p>

<table>
  <thead>
    <tr>
      <th>Register</th>
      <th>Name</th>
      <th>Description</th>
      <th>Preserved Across Function Calls?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0</td>
      <td>zero</td>
      <td>This register is hardwired to the value 0. It always returns 0 regardless of what is written to it.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$1</td>
      <td>at</td>
      <td>Reserved for the assembler. It is used for pseudo-instructions and not typically used by programmers.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$2-$3</td>
      <td>v0-v1</td>
      <td>Used to hold function return values.</td>
      <td>No      <em>**</em></td>
    </tr>
    <tr>
      <td>$4-$7</td>
      <td>a0-a3</td>
      <td>Used to pass the first four arguments to functions.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$8-$15</td>
      <td>t0-t7</td>
      <td>Temporary registers used for holding intermediate values. They are not preserved across function calls.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$16-$23</td>
      <td>s0-s7</td>
      <td>Saved registers, which must be preserved across function calls. They are used to store values that should not be changed by a function.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$24-$25</td>
      <td>t8-t9</td>
      <td>More temporary registers, similar to t0-t7.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$26-$27</td>
      <td>k0-k1</td>
      <td>Reserved for the operating system kernel.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$28</td>
      <td>gp</td>
      <td>Global pointer, used to access static data.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$29</td>
      <td>sp</td>
      <td>Stack pointer, used to point to the top of the stack.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$30</td>
      <td>fp</td>
      <td>Frame pointer, used to manage stack frames in some calling conventions.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$31</td>
      <td>ra</td>
      <td>Return address, used to store the return address for function calls.</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>

<p>When we say that saved registers must be “preserved across function calls,” it means that the values in these registers should remain unchanged when a function (subroutine) returns to its caller. In other words, if a function uses these registers, it must ensure that any values stored in them before the function call are restored when the function completes. This is typically enforced through a process called “register saving” and “register restoring.”</p>

<h3 id="special-purpose-registers">Special Purpose Registers</h3>

<p>Special purpose register’s values are closely tied to the working of processor. For this purpose they may not be directly writeable by normal instructions like add, move, etc. Instead, some special registers in some processor architectures require special instructions to modify them. For instance, in many architectures, modifying the program counter necessitates instructions such as return from subroutine, jump, or branch. Similarly, condition code registers are typically updated exclusively through compare instructions, eg: CPSR register in ARM. This design ensures precise control over essential processor operations and status updates, safeguarding against unintended modifications that could disrupt program execution or system stability.</p>

<p>In MIPS architecture, several special registers play crucial roles in managing the CPU’s state, controlling operations, and handling exceptions. Here are the main special registers used in MIPS:</p>

<ul>
  <li><strong>Program Counter (PC):</strong> Holds the address of the next instruction to be executed.</li>
  <li><strong>Hi and Lo Registers:</strong> Store the results of multiplication and division operations. If the result of an operation involving 32-bit operands is more than 32-bits, MIPS processors store the lower 32 bits of the result in the Lo register and the upper 32 bits in the Hi register.</li>
  <li><strong>CP0:</strong> CP0 refers to the control processor, which handles various system control and status registers (CSRs) that are crucial for system operation and control.
    <ul>
      <li><strong>Status Register (SR):</strong> Controls the operating mode of the processor (user mode, kernel mode) and enables/disables interrupts.</li>
      <li><strong>Cause Register (Cause):</strong> Stores exception cause information.</li>
      <li><strong>EPC (Exception Program Counter):</strong> Holds the address of the instruction that caused an exception.</li>
      <li><strong>EntryHi and EntryLo Registers:</strong> Used for managing TLB (Translation Lookaside Buffer) entries.</li>
    </ul>
  </li>
</ul>

<h2 id="data-types-in-mips">Data Types in MIPS</h2>

<ol>
  <li><strong>Byte (8-bit):</strong> Represented as .byte in MIPS assembly. Each byte consists of 8 bits.</li>
  <li><strong>Halfword (16-bit):</strong> Represented as .half or .hword in MIPS assembly. Each halfword consists of 16 bits or 2 bytes.</li>
  <li><strong>Word (32-bit):</strong> Represented as .word in MIPS assembly. Each word consists of 32 bits or 4 bytes. This is the default data type for many operations in MIPS32.</li>
  <li><strong>Doubleword (64-bit):</strong> Represented as .dword in MIPS assembly. Each doubleword consists of 64 bits or 8 bytes. This is especially relevant in MIPS64 architecture.</li>
  <li><strong>Float (32-bit floating-point):</strong> Represented as .float in MIPS assembly. This follows the IEEE 754 standard for single-precision floating-point numbers.</li>
  <li><strong>Double (64-bit floating-point):</strong> Represented as .double in MIPS assembly. This follows the IEEE 754 standard for double-precision floating-point numbers.</li>
</ol>

<h2 id="addressing-modes-in-mips">Addressing Modes in MIPS</h2>

<p>Addressing mode refers to the way in which the operand of an instruction is specified. Different addressing modes provide different ways to access operands, allowing for more flexible and efficient programming.</p>

<p>MIPS supports several addressing modes:</p>

<ol>
  <li><strong>Immediate Addressing:</strong> The operand is a constant value embedded within the instruction itself.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $t0, $t1, 5  # $t0 = $t1 + 5
</code></pre></div>    </div>
  </li>
  <li><strong>Register Direct Addressing:</strong> The operand is stored in a register.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add $t0, $t1, $t2  # $t0 = $t1 + $t2
</code></pre></div>    </div>
  </li>
  <li><strong>Register Indirect with Displacement</strong> The operand is a memory location and the address of that memory location is given by the sum of the register and a constant displacement encoded in the ins. This is commonly used for loading and storing the array elements.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lw $t0, 8($t1), $t0 = MEM[Rt1 + 8]
</code></pre></div>    </div>
  </li>
  <li><strong>PC-Relative Addressing:</strong> The operand’s address is the sum of the program counter (PC) and a constant displacement.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beq $t0, $t1, label  # branches to the label if the values in registers $t0 and $t1 are equal, with the address computed relative to the current value of the PC.
</code></pre></div>    </div>
  </li>
  <li><strong>Pseudo-Direct Addressing:</strong> Used in jump instructions where the target address is partially specified in the instruction and partially from the PC. To form the full 32-bit address, the 26-bit address from the instruction is combined with the upper 4 bits of the current program counter (PC). This is because, in a 32-bit address, the upper 4 bits are often the same for instructions within a relatively small range (within the same 256MB segment).
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>j target # jumps to an address formed by combining the upper bits of the current PC with the target address specified in the instruction.
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="memory-alignment-and-endianness">Memory Alignment and Endianness</h2>

<p>Memory alignment refers to the arrangement of data in memory according to specific boundaries. Proper memory alignment means that data is stored at memory addresses that are multiples of the data’s size. In MIPS, data must be properly aligned in memory to be accessed correctly. Attempting to access misaligned data in MIPS can lead to alignment exceptions, causing the program to crash or behave unpredictably. In contrast, x86 architecture is more flexible with memory alignment. While aligned data access is more efficient and generally recommended, x86 CPUs can handle misaligned data access without causing exceptions. The CPU might perform additional internal operations to handle the misaligned access, potentially resulting in a slight performance penalty compared to aligned accesses.</p>

<p><strong>Data Types and Alignment:</strong></p>

<ul>
  <li>1-byte (char): No alignment requirement.</li>
  <li>2-byte (short): Must be aligned to 2-byte boundaries. Eg: valid addresses are 0, 2, 4,..</li>
  <li>4-byte (int, float): Must be aligned to 4-byte boundaries. Eg: valid addresses are 0, 4, 8,..</li>
  <li>8-byte (double, long long): Must be aligned to 8-byte boundaries. Eg: valid addresses are 0, 8, 16,..</li>
</ul>

<p>MIPS instructions are 32 bits (4 bytes) long and must be word-aligned. This means that the address of any instruction must be a multiple of 4. For example, valid instruction addresses in MIPS could be 0, 4, 8, and so on.</p>

<p>The <code class="language-plaintext highlighter-rouge">.align</code> directive in the MIPS assembler is used to specify the alignment of data in memory. While the assembler does automatically align data to the proper boundaries, the <code class="language-plaintext highlighter-rouge">.align</code> directive gives programmers explicit control over alignment, which can be useful for various reasons:</p>

<p><strong>Endianness:</strong> When the data stored to be stored is more than 1 byte, the sequence of bytes forming the data can be stored in two possible orders in memory:</p>
<ol>
  <li><strong>Big-endian:</strong> The most significant byte (MSB) is stored at the lowest memory address.
Example: For a 32-bit integer 0x12345678, the byte order in memory would be:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Address:   0x00   0x01   0x02   0x03
Value:     0x12   0x34   0x56   0x78
</code></pre></div>    </div>
  </li>
  <li><strong>Little-endian:</strong>  The least significant byte (LSB) is stored at the lowest memory address.
Example: For a 32-bit integer 0x12345678, the byte order in memory would be:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Address:   0x00   0x01   0x02   0x03
Value:     0x78   0x56   0x34   0x12
</code></pre></div>    </div>
  </li>
</ol>

<p>Endianness affects how data is interpreted and exchanged between systems. If two systems with different endianness exchange data without proper handling, the data can be misinterpreted, leading to errors. Therefore, it is crucial to ensure that data is correctly converted between different endian formats when necessary.</p>

<p>Most modern personal computers, including those using x86 and x86-64 architectures, use little-endian format. MIPS processors can operate in both big-endian (BE) and little-endian (LE) modes. The Status register in CP0 has a bit called RE (Reverse Endian) which, when set, changes the endianness mode for user mode, such processors are called Bi-endian processors, some other examples for Bi-endian processors are ARM, PowerPC, Alpha, SPARC V9, etc.</p>

<h2 id="instruction-formats-in-mips">Instruction Formats in MIPS</h2>

<p>MIPS uses three main instruction formats: R-type, I-type, and J-type. Each format is designed to accommodate different types of instructions and their operands.</p>

<h3 id="1-r-type">1. R-type</h3>

<p>R-type instructions are used for operations that involve only registers, such as arithmetic and logical operations.</p>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-21</th>
      <th>20-16</th>
      <th>15-11</th>
      <th>10-6</th>
      <th>5-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>rs</td>
      <td>rt</td>
      <td>rd</td>
      <td>shamt</td>
      <td>funct</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code that specifies the operation to be performed.</li>
  <li><strong>rs: 5 bits</strong> - The first source register.</li>
  <li><strong>rt: 5 bits</strong> - The second source register.</li>
  <li><strong>rd: 5 bits</strong> - The destination register.</li>
  <li><strong>shamt: 5 bits</strong>- The shift amount (used in shift instructions).</li>
  <li><strong>funct: 6 bits</strong> - The function code that specifies the exact operation (used in conjunction with the opcode).</li>
</ul>

<p>Each of the register field is 5 bits as there are 32 (2<sup>5</sup>) registers.</p>

<p>Eg: <code class="language-plaintext highlighter-rouge">add $t1, $t2, $t3</code></p>

<h3 id="2-i-type">2. I-type</h3>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-21</th>
      <th>20-16</th>
      <th>15-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>rs</td>
      <td>rt</td>
      <td>immediate</td>
    </tr>
  </tbody>
</table>

<p>I-type instructions are used for operations that involve an immediate value (a constant), as well as for memory access and branches.</p>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code.</li>
  <li><strong>rs: 5 bits</strong> - The source register.</li>
  <li><strong>rt: 5 bits</strong> - The destination register (or another source register for branches).</li>
  <li><strong>Immediate: 16 bits</strong> - The immediate value, which can be a constant, address offset, or immediate operand.</li>
</ul>

<p>Eg:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $t1, $t2, 10    # $t1 = $t2 + 10
lw $t0, 4($t1)       # $t0 = Memory[$t1 + 4]
andi $t0, $t1, 0xFF  # $t0 = $t1 &amp; 0xFF
</code></pre></div></div>

<h3 id="3-j-type">3. J-type</h3>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>address</td>
    </tr>
  </tbody>
</table>

<p>J-type instructions are used for jump instructions that require a target address.</p>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code.</li>
  <li><strong>Address: 26 bits</strong> - The target address for the jump. This address is combined with the upper bits of the program counter (PC) to form the full jump address.</li>
</ul>

<p>In MIPS32, we observe that only 26 bits are used for the target address of jump instructions, even though the address space of MIPS32 spans 4GB (2<sup>32</sup>). Because all MIPS instructions are 32 bits wide, they are word-aligned. This word alignment means the last 2 bits of any instruction address are always 00. Thus, only 28 bits are effectively used to form the target address. To construct the full 32-bit address, the upper 4 bits of the current program counter (PC) — which is the address of the instruction following the jump — are combined with the 28-bit target address. This results in a maximum addressable jump distance of 256MB (2<sup>28</sup>).</p>

<p>However, within a 4GB address space, it’s possible that the target instruction may be farther away than this 256MB limit. Modern assemblers employ various strategies to address this limitation, some of which we will explore later.</p>

<h2 id="pros-and-cons-of-uniform-instruction-width-and-dedicated-opcode-spots-in-mips">Pros and Cons of Uniform Instruction Width and Dedicated Opcode Spots in MIPS</h2>

<h3 id="pros">Pros</h3>

<ol>
  <li>
    <p><strong>Simplicity in Instruction Fetching:</strong> With a uniform instruction width (32 bits) for an implementation that fetches a single instruction per cycle, a single aligned memory/cache access of the fixed size is guaranteed to provide one (and only one) instruction, so no buffering or shifting is required. There is also no concern about crossing a cache line or page boundary within a single instruction.</p>
  </li>
  <li>
    <p><strong>Predictable Instruction Fetching:</strong> With a uniform instruction width, the instruction pointer increments by a fixed amount (32 bits) for each instruction (except for control flow instructions like jumps and branches). This predictability allows the CPU to know the location of the next instruction early, reducing the need for partial decoding. It also simplifies the process of fetching and parsing multiple instructions per cycle, enhancing overall efficiency. (The need for partial decoding arises when the length of instructions varies. The CPU must determine the length of each instruction before it can identify where the next instruction begins. This requires the CPU to decode at least part of the current instruction to find out its length, a process known as partial decoding. This extra step can complicate the instruction fetching process and introduce additional overhead.)</p>
  </li>
  <li>
    <p><strong>Simplified Parsing and Early Register Reading:</strong> The uniform instruction format in MIPS enables straightforward parsing of instruction components, such as immediate values, opcodes, and register names. This is particularly beneficial for timing-critical tasks like parsing source register names. With fixed positions for these components, the CPU can begin reading register values immediately after fetching the instruction, even before fully determining the instruction type. This speculative register reading does not require special recovery if incorrect, although it consumes extra energy. In the MIPS R2000’s classic 5-stage pipeline, this approach allows register values to be read right after instruction fetch, providing ample time to compare values and resolve branches, thus avoiding stalls without needing branch prediction. Parsing out the opcode is slightly less timing-critical than parsing source register names, but extracting the opcode sooner accelerates the start of execution. Simple parsing of the destination register name facilitates dependency detection across instructions, particularly beneficial when executing multiple instructions per cycle.</p>
  </li>
  <li>
    <p><strong>Usage of Fewer Bits for Target Addresses:</strong> In uniform instruction sets, the alignment of instructions allows the use of fewer bits to specify target addresses. For example, in a 32-bit wide instruction set, the last 2 bits of any instruction address are always 0 due to word alignment. This means that only 30 bits are needed to represent the address instead of 32. This reduction in required bits can be exploited in certain ISAs, such as MIPS/MIPS16, to provide additional storage space for other purposes, like indicating a mode with smaller or variable-length instructions. This efficient use of addressing allows for more compact encoding of instructions and can enhance the flexibility of the instruction set by supporting different modes.</p>
  </li>
</ol>

<h2 id="cons">Cons</h2>

<ol>
  <li>
    <p><strong>Low Code Density:</strong> Uniform instruction width can lead to inefficient use of memory when instructions are shorter than the fixed width. For example, if you have a 32-bit instruction width but some instructions only require a few bits, the extra bits in each instruction are wasted. This can lead to larger code sizes and increased memory consumption.</p>
  </li>
  <li>
    <p><strong>Decreased Flexibility due to Implicity Operands:</strong> Strict uniform formatting tends to exclude the use of implicit operands, which are operands not explicitly specified in the instruction but implied by the operation. For instance, even though MIPS mostly avoids implicit operands, it still uses an implicit destination register for the link register ($ra), which stores the return address for function calls. (When a function call is made in MIPS, the jal (jump and link) instruction is used. This instruction not only jumps to the target function address but also implicitly stores the return address (the address of the instruction following the jal) in the link register $ra (which is register $31). This behavior is implicit in the sense that the jal instruction does not need to specify that the return address should be stored in $ra; it is automatically understood and handled by the instruction.)</p>
  </li>
  <li><strong>Cannot Handle Large Values of Immediate:</strong> Fixed-length instructions present challenges when dealing with large immediate values (constants embedded directly within instructions). In MIPS immediate values to 16 bits within a single instruction. If a constant exceeds this 16-bit limit, additional steps are required to handle the larger value.
    <ol>
      <li><strong>Loading as Data:</strong> One method to handle large constants is to load them from memory. This approach involves:
        <ul>
          <li>An extra load instruction.</li>
          <li>Overhead associated with address calculation, register usage, address translation, and tag checking.</li>
        </ul>
      </li>
      <li><strong>Multiple Instructions:</strong> MIPS provides two instructions <code class="language-plaintext highlighter-rouge">lui</code> (load upper immediate) to load the upper 16 bits of a constant and <code class="language-plaintext highlighter-rouge">ori</code> (or immediate) which performs bitwise OR on lower 16 bits this effectively loading a 32-bit immediate. These instructions do not involve memory access. The 32-bit immediate value is constructed directly within the CPU using two instructions. This is faster and avoids the overhead of accessing memory. Using two instructions to handle a large immediate introduces more overhead compared to a single instruction. Modern processor designs can mitigate some of this overhead. For example, Intel’s macro-op fusion combines certain pairs of instructions at the front-end of the pipeline, effectively reducing the execution overhead.</li>
    </ol>
  </li>
  <li>
    <p><strong>Challenges in Extending the ISA:</strong> New features may require addition of new instructions to the ISA. Fixed-length instructions present a significant challenge when it comes to extending an instruction set. The number of distinct operations (opcodes) that can be represented is limited. For example, with a 6-bit opcode field (as in MIPS), there are only 64 possible opcodes. It also poses a challenge when we have to increase number of available registers as adding more registers requires more bits to encode the register addresses. To extend the instruction set without breaking compatibility, additional modes or instruction formats might be needed. This can complicate the CPU design and increase the complexity of the instruction decoder.</p>
  </li>
  <li><strong>Limited Address Bound for Branching Instructions:</strong> In MIPS, the jump instruction uses only 26 bits to specify the immediate target address. Due to memory alignment, the last 2 bits are always zero, effectively giving 28 bits for the target address. The upper 4 bits of the Program Counter (PC) are combined with these 28 bits to form a full 32-bit address, which limits the addressable range to 256 MB. Consequently, the assembly programmer or compiler must ensure that the target address of the jump instruction lies within this 256 MB boundary. If the target address exceeds this limit, other options must be employed, such as using the <code class="language-plaintext highlighter-rouge">jr</code> (jump to the address stored in register) instruction, which can specify a full 32-bit address by storing the address in a register. In some versions, the assembler will issue a warning if the target address of a <code class="language-plaintext highlighter-rouge">j</code> instruction exceeds the 256 MB bound. In other cases, the assembler might automatically replace the <code class="language-plaintext highlighter-rouge">j</code> instruction with a <code class="language-plaintext highlighter-rouge">jr</code> instruction to handle the full address space correctly.</li>
</ol>

<h2 id="overview-of-mips-instructions">Overview of MIPS Instructions</h2>

<h3 id="1-memory-access-instructions">1. Memory Access Instructions</h3>

<p>Memory access instructions in MIPS facilitate moving data between registers and memory, as well as between integer, floating-point (FP), or special registers. Most of the memory access instructions are I-type and use register indirect with displacement as addressing mode.</p>

<h4 id="1-load-family-of-instructions">1. Load Family of Instructions</h4>

<p>All of the load instructions in MIPS are I-type instructions, and they follow this general format:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD &lt;rt&gt;, offset(base)
</code></pre></div></div>

<ul>
  <li><strong>LOAD</strong> is the opcode for the specific load instruction (e.g., LB, LBU, LH, LHU, LW, LWU, LD, L.S, L.D).</li>
  <li>**<rt>** is the target register where the data will be loaded.</rt></li>
  <li><strong>offset</strong> is a 16-bit signed immediate value representing the displacement.</li>
  <li><strong>base</strong> is the base register whose contents are added to the offset to form the effective memory address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>LB</strong></td>
      <td>Load Byte</td>
      <td>Loads a byte from memory into a register, sign-extended.</td>
    </tr>
    <tr>
      <td><strong>LBU</strong></td>
      <td>Load Byte Unsigned</td>
      <td>Loads a byte from memory into a register, zero-extended.</td>
    </tr>
    <tr>
      <td><strong>LH</strong></td>
      <td>Load Halfword</td>
      <td>Loads a halfword from memory into a register, sign-extended.</td>
    </tr>
    <tr>
      <td><strong>LHU</strong></td>
      <td>Load Halfword Unsigned</td>
      <td>Loads a halfword from memory into a register, zero-extended.</td>
    </tr>
    <tr>
      <td><strong>LW</strong></td>
      <td>Load Word</td>
      <td>Loads a word from memory into a register.</td>
    </tr>
    <tr>
      <td><strong>LWU</strong></td>
      <td>Load Word Unsigned</td>
      <td>Loads a word from memory into a register, zero-extended (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>LD</strong></td>
      <td>Load Doubleword</td>
      <td>Loads a doubleword from memory into a register (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>L.S</strong></td>
      <td>Load Single Precision Float</td>
      <td>Loads a single precision floating-point value from memory into an FP register.</td>
    </tr>
    <tr>
      <td><strong>L.D</strong></td>
      <td>Load Double Precision Float</td>
      <td>Loads a double precision floating-point value from memory into an FP register.</td>
    </tr>
  </tbody>
</table>

</div>

  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sanketh&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sanketh B K</li><li><a class="u-email" href="mailto:sankethbk.1611@gmail.com">sankethbk.1611@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Sankethbk</span></a></li><li><a href="https://www.linkedin.com/in/sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">sankethbk</span></a></li><li><a href="https://www.twitter.com/Sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Sankethbk</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog! I have started this blog to document my journey of learning low-level areas of computer science.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
