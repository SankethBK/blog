<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Overview of MIPS Assembly | Sanketh’s Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Overview of MIPS Assembly" />
<meta name="author" content="Sanketh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance." />
<meta property="og:description" content="MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance." />
<link rel="canonical" href="http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly" />
<meta property="og:url" content="http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly" />
<meta property="og:site_name" content="Sanketh’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-07-12T20:38:05+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Overview of MIPS Assembly" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sanketh"},"dateModified":"2024-07-12T20:38:05+05:30","datePublished":"2024-07-12T20:38:05+05:30","description":"MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.","headline":"Overview of MIPS Assembly","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly"},"url":"http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Sanketh&apos;s Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Sanketh&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

<link rel="stylesheet" href="/blog/assets/custom.css" />

<article class="post">
  <header class="post-header">
    <h1 class="post-title">Overview of MIPS Assembly</h1>
  </header>

  <div class="categories">
    
    <a
      href="/blog/categories/cpu"
      class="category-capsule"
      >cpu</a
    >
    
    <a
      href="/blog/categories/assembly"
      class="category-capsule"
      >assembly</a
    >
    
  </div>

  <div class="post-content"><p>MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.</p>

<h2 id="history">History</h2>

<p>The first MIPS processor, the R2000, was introduced. It implemented the MIPS I architecture, which was one of the earliest commercial RISC processors. There are multiple versions of MIPS: including MIPS I, II, III, IV, and V; as well as five releases of MIPS32/64. MIPS I had 32-bit architecture with basic instruction set and addressing modes. MIPS III introduced 64-bit architecture in 1991, increasing the address space and register width.</p>

<p>MIPS32 and MIPS64 are modern versions of the architecture, maintaining backward compatibility while introducing enhancements for modern computing needs. MicroMIPS is a compact version of the MIPS instruction set, designed for embedded systems with limited memory. MIPS processors are commonly used in embedded systems, such as routers, printers, and smart home devices, where their efficiency and performance are crucial. In the automotive industry, MIPS processors are employed in various control systems and infotainment systems, benefiting from their reliable and efficient processing capabilities. MIPS processors are increasingly found in IoT devices, providing the necessary computational power and energy efficiency for smart sensors, wearables, and other connected devices.</p>

<p>MIPS is built on RISC principles, which embrace simplicity and efficiency, making it an ideal choice for learning about CPU architecture in general. Some principles of RISC are:</p>

<ol>
  <li><strong>Simple Instructions:</strong> RISC architectures use a small, highly optimized set of instructions. Each instruction is designed to be simple and execute in a single clock cycle (under ideal conditions in a pipelined processor).</li>
  <li><strong>Load/Store Architecture:</strong> RISC separates memory access and data processing instructions. Only load and store instructions can access memory, while all other operations are performed on registers. This simplifies the instruction set and execution.</li>
  <li><strong>Fixed-Length Instructions:</strong> Instructions in RISC architectures are of uniform length, typically 32 bits. This uniformity simplifies instruction decoding and pipeline design.</li>
  <li><strong>Simple Addressing Modes:</strong> RISC architectures use a small number of simple addressing modes to keep instruction execution fast and efficient. Common addressing modes include register, immediate, and displacement.</li>
  <li><strong>Pipelining:</strong> RISC architectures are designed to efficiently support pipelining. Instructions are broken down into stages (fetch, decode, execute, memory access, write-back) that can be processed simultaneously for different instructions.</li>
</ol>

<h2 id="mips32-and-mips64">MIPS32 and MIPS64</h2>

<p>MIPS32 and MIPS64 are ISAs designed for 32-bit and 64-bit CPUs, respectively. The primary distinctions between modern MIPS32 and MIPS64 architectures are found in their register size, memory addressing capabilities, and support for larger data and address spaces. Unlike ARM and x86, both MIPS32 and MIPS64 utilize 32-bit-wide instructions, regardless of whether they are operating on 32-bit or 64-bit processors.</p>

<p>MIPS32 is designed for 32-bit applications, with 32-bit registers and a 32-bit address space suitable embedded systems, microcontrollers, and other applications where 32-bit processing capabilities are sufficient. MIPS64 extends the architecture to 64-bit, offering larger 64-bit registers and a 64-bit address space, suitable for high-performance computing and large-scale applications.</p>

<p>Softwares written for MIPS32 can often run on MIPS64 processors without modification due to their shared instruction set, facilitating a smooth transition to 64-bit computing, while the reverse is not possible. MIPS is very efficient ISA for compiler to target because in most cases it can be well predicted how much time a sequence of instructions will take.</p>

<h2 id="registers">Registers</h2>

<h3 id="general-purpose-registers">General Purpose Registers</h3>

<p>General Purpose registers are meant to be used by programmers and compilers for whatever operations required and has no special meaning to CPU. General-purpose registers are versatile storage locations within the CPU used for a wide range of tasks like holding intermediate data, operands and results of computations, and store temporary values during program execution. They are meant to be utilized by programmers and compilers as needed, without any special significance to the CPU itself.</p>

<p>MIPS has 32 general purpose registers (R0 - R31), 32 floating point registers (F0 - F31) that can hold either a 32-bit single-precision number or a 64-bit double-precision number. General Purpose Registers (GPRs) in MIPS architectures are used for storing immediate values, temporary data, function arguments, and return values. They also facilitate address calculation for memory operations and control flow in branching and jumping instructions.</p>

<p>In MIPS, most registers are truly general-purpose, meaning they can be used for any purpose. MIPS programmers adhere to agreed-upon guidelines specifying how registers should be utilized. For instance, the stack pointer <code class="language-plaintext highlighter-rouge">($sp)</code>, global pointer <code class="language-plaintext highlighter-rouge">($gp)</code>, and frame pointer <code class="language-plaintext highlighter-rouge">($fp)</code> are conventions rather than hardware-enforced roles, unlike in other Assembly languages like x86. The stack pointer is purely a software convention; no push instruction implicitly uses it. Using <code class="language-plaintext highlighter-rouge">$t0</code> instead of <code class="language-plaintext highlighter-rouge">$t3</code> as a temporary register isn’t inherently faster or better. However, there’s one notable exception: the <code class="language-plaintext highlighter-rouge">jal</code> instruction implicitly writes the return address to <code class="language-plaintext highlighter-rouge">$31</code> (the link register).</p>

<table>
  <thead>
    <tr>
      <th>Register</th>
      <th>Name</th>
      <th>Description</th>
      <th>Preserved Across Function Calls?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0</td>
      <td>zero</td>
      <td>This register is hardwired to the value 0. It always returns 0 regardless of what is written to it.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$1</td>
      <td>at</td>
      <td>Reserved for the assembler. It is used for pseudo-instructions and not typically used by programmers.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$2-$3</td>
      <td>v0-v1</td>
      <td>Used to hold function return values.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$4-$7</td>
      <td>a0-a3</td>
      <td>Used to pass the first four arguments to functions.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$8-$15</td>
      <td>t0-t7</td>
      <td>Temporary registers used for holding intermediate values. They are not preserved across function calls.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$16-$23</td>
      <td>s0-s7</td>
      <td>Saved registers, which must be preserved across function calls. They are used to store values that should not be changed by a function.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$24-$25</td>
      <td>t8-t9</td>
      <td>More temporary registers, similar to t0-t7.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$26-$27</td>
      <td>k0-k1</td>
      <td>Reserved for the operating system kernel.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$28</td>
      <td>gp</td>
      <td>Global pointer, used to access static data.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$29</td>
      <td>sp</td>
      <td>Stack pointer, used to point to the top of the stack.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$30</td>
      <td>fp</td>
      <td>Frame pointer, used to manage stack frames in some calling conventions.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$31</td>
      <td>ra</td>
      <td>Return address, used to store the return address for function calls.</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>

<p>When we say that saved registers must be “preserved across function calls,” it means that the values in these registers should remain unchanged when a function (subroutine) returns to its caller. In other words, if a function uses these registers, it must ensure that any values stored in them before the function call are restored when the function completes. This is typically enforced through a process called “register saving” and “register restoring”. The callee function first identifies which registers it uses that need to be preserved across function calls. These are known as “callee-saved” or “non-volatile” registers. The callee then saves the values of these registers by pushing them onto the stack. After the callee subroutine completes its task, it pops the saved register values off the stack, restoring the registers to their original state before returning control to the caller.</p>

<h3 id="special-purpose-registers">Special Purpose Registers</h3>

<p>Special purpose register’s values are closely tied to the working of processor. For this purpose they may not be directly writeable by normal instructions like add, move, etc. Instead, some special registers in some processor architectures require special instructions to modify them. For instance, in many architectures, modifying the program counter necessitates instructions such as return from subroutine, jump, or branch. Similarly, condition code registers are typically updated exclusively through compare instructions, eg: CPSR register in ARM. This design ensures precise control over essential processor operations and status updates, safeguarding against unintended modifications that could disrupt program execution or system stability.</p>

<p>In MIPS architecture, several special registers play crucial roles in managing the CPU’s state, controlling operations, and handling exceptions. Here are the main special registers used in MIPS:</p>

<ul>
  <li><strong>Program Counter (PC):</strong> Holds the address of the next instruction to be executed.</li>
  <li><strong>Hi and Lo Registers:</strong> Store the results of multiplication and division operations. If the result of an operation involving 32-bit operands is more than 32-bits, MIPS processors store the lower 32 bits of the result in the Lo register and the upper 32 bits in the Hi register.</li>
  <li><strong>CP0:</strong> CP0 refers to the control processor, which handles various system control and status registers (CSRs) that are crucial for system operation and control.
    <ul>
      <li><strong>Status Register (SR):</strong> Controls the operating mode of the processor (user mode, kernel mode) and enables/disables interrupts.</li>
      <li><strong>Cause Register (Cause):</strong> Stores exception cause information.</li>
      <li><strong>EPC (Exception Program Counter):</strong> Holds the address of the instruction that caused an exception.</li>
      <li><strong>EntryHi and EntryLo Registers:</strong> Used for managing TLB (Translation Lookaside Buffer) entries.</li>
    </ul>
  </li>
</ul>

<h2 id="data-types-in-mips">Data Types in MIPS</h2>

<ol>
  <li><strong>Byte (8-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.byte</code> in MIPS assembly. Each byte consists of 8 bits.</li>
  <li><strong>Halfword (16-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.half</code> or <code class="language-plaintext highlighter-rouge">.hword</code> in MIPS assembly. Each halfword consists of 16 bits or 2 bytes.</li>
  <li><strong>Word (32-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.word</code> in MIPS assembly. Each word consists of 32 bits or 4 bytes. This is the default data type for many operations in MIPS32.</li>
  <li><strong>Doubleword (64-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.dword</code> in MIPS assembly. Each doubleword consists of 64 bits or 8 bytes. This is especially relevant in MIPS64 architecture.</li>
  <li><strong>Float (32-bit floating-point):</strong> Represented as <code class="language-plaintext highlighter-rouge">.float</code> in MIPS assembly. This follows the IEEE 754 standard for single-precision floating-point numbers.</li>
  <li><strong>Double (64-bit floating-point):</strong> Represented as <code class="language-plaintext highlighter-rouge">.double</code> in MIPS assembly. This follows the IEEE 754 standard for double-precision floating-point numbers.</li>
</ol>

<h2 id="addressing-modes-in-mips">Addressing Modes in MIPS</h2>

<p>Addressing mode refers to the way in which the operand of an instruction is specified. Different addressing modes provide different ways to access operands, allowing for more flexible and efficient programming.</p>

<p>MIPS supports several addressing modes:</p>

<ol>
  <li><strong>Immediate Addressing:</strong> The operand is a constant value embedded within the instruction itself.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $t0, $t1, 5  # $t0 = $t1 + 5
</code></pre></div>    </div>
  </li>
  <li><strong>Register Direct Addressing:</strong> The operand is stored in a register.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add $t0, $t1, $t2  # $t0 = $t1 + $t2
</code></pre></div>    </div>
  </li>
  <li><strong>Register Indirect with Displacement</strong> The operand is a memory location and the address of that memory location is given by the sum of the register and a constant displacement encoded in the ins. This is commonly used for loading and storing the array elements.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lw $t0, 8($t1), $t0 = MEM[Rt1 + 8]
</code></pre></div>    </div>
  </li>
  <li><strong>PC-Relative Addressing:</strong> The operand’s address is the sum of the program counter (PC) and a constant displacement.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beq $t0, $t1, label  # branches to the label if the values in registers $t0 and $t1 are equal, with the address computed relative to the current value of the PC.
</code></pre></div>    </div>
  </li>
  <li><strong>Pseudo-Direct Addressing:</strong> Used in jump instructions where the target address is partially specified in the instruction and partially from the PC. To form the full 32-bit address, the 26-bit address from the instruction is combined with the upper 4 bits of the current program counter (PC). This is because, in a 32-bit address, the upper 4 bits are often the same for instructions within a relatively small range (within the same 256MB segment).
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>j target # jumps to an address formed by combining the upper bits of the current PC with the target address specified in the instruction.
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="memory-alignment-and-endianness">Memory Alignment and Endianness</h2>

<p>Memory alignment refers to the arrangement of data in memory according to specific boundaries. Proper memory alignment means that data is stored at memory addresses that are multiples of the data’s size. In MIPS, data must be properly aligned in memory to be accessed correctly. Attempting to access misaligned data in MIPS can lead to alignment exceptions, causing the program to crash or behave unpredictably. In contrast, x86 architecture is more flexible with memory alignment. While aligned data access is more efficient and generally recommended, x86 CPUs can handle misaligned data access without causing exceptions. The CPU might perform additional internal operations to handle the misaligned access, potentially resulting in a slight performance penalty compared to aligned accesses.</p>

<p><strong>Data Types and Alignment:</strong></p>

<ul>
  <li>1-byte (char): No alignment requirement.</li>
  <li>2-byte (short): Must be aligned to 2-byte boundaries. Eg: valid addresses are 0, 2, 4,..</li>
  <li>4-byte (int, float): Must be aligned to 4-byte boundaries. Eg: valid addresses are 0, 4, 8,..</li>
  <li>8-byte (double, long long): Must be aligned to 8-byte boundaries. Eg: valid addresses are 0, 8, 16,..</li>
</ul>

<p>MIPS instructions are 32 bits (4 bytes) long and must be word-aligned. This means that the address of any instruction must be a multiple of 4. For example, valid instruction addresses in MIPS could be 0, 4, 8, and so on.</p>

<p>The <code class="language-plaintext highlighter-rouge">.align</code> directive in the MIPS assembler is used to specify the alignment of data in memory. While the assembler does automatically align data to the proper boundaries, the <code class="language-plaintext highlighter-rouge">.align</code> directive gives programmers explicit control over alignment, which can be useful for various reasons:</p>

<p><strong>Endianness:</strong> When the data stored to be stored is more than 1 byte, the sequence of bytes forming the data can be stored in two possible orders in memory:</p>
<ol>
  <li><strong>Big-endian:</strong> The most significant byte (MSB) is stored at the lowest memory address.
Example: For a 32-bit integer 0x12345678, the byte order in memory would be:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Address:   0x00   0x01   0x02   0x03
Value:     0x12   0x34   0x56   0x78
</code></pre></div>    </div>
  </li>
  <li><strong>Little-endian:</strong>  The least significant byte (LSB) is stored at the lowest memory address.
Example: For a 32-bit integer 0x12345678, the byte order in memory would be:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Address:   0x00   0x01   0x02   0x03
Value:     0x78   0x56   0x34   0x12
</code></pre></div>    </div>
  </li>
</ol>

<p>Endianness affects how data is interpreted and exchanged between systems. If two systems with different endianness exchange data without proper handling, the data can be misinterpreted, leading to errors. Therefore, it is crucial to ensure that data is correctly converted between different endian formats when necessary.</p>

<p>Most modern personal computers, including those using x86 and x86-64 architectures, use little-endian format. MIPS processors can operate in both big-endian (BE) and little-endian (LE) modes. The Status register in CP0 has a bit called RE (Reverse Endian) which, when set, changes the endianness mode for user mode, such processors are called Bi-endian processors, some other examples for Bi-endian processors are ARM, PowerPC, Alpha, SPARC V9, etc.</p>

<h2 id="instruction-formats-in-mips">Instruction Formats in MIPS</h2>

<p>MIPS uses three main instruction formats: R-type, I-type, and J-type. Each format is designed to accommodate different types of instructions and their operands.</p>

<h3 id="1-r-type">1. R-type</h3>

<p>R-type instructions are used for operations that involve only registers, such as arithmetic and logical operations.</p>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-21</th>
      <th>20-16</th>
      <th>15-11</th>
      <th>10-6</th>
      <th>5-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>rs</td>
      <td>rt</td>
      <td>rd</td>
      <td>shamt</td>
      <td>funct</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code that specifies the operation to be performed.</li>
  <li><strong>rs: 5 bits</strong> - The first source register.</li>
  <li><strong>rt: 5 bits</strong> - The second source register.</li>
  <li><strong>rd: 5 bits</strong> - The destination register.</li>
  <li><strong>shamt: 5 bits</strong>- The shift amount (used in shift instructions).</li>
  <li><strong>funct: 6 bits</strong> - The function code that specifies the exact operation (used in conjunction with the opcode).</li>
</ul>

<p>Each of the register field is 5 bits as there are 32 (2<sup>5</sup>) registers.</p>

<p>Eg: <code class="language-plaintext highlighter-rouge">add $t1, $t2, $t3</code></p>

<h3 id="2-i-type">2. I-type</h3>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-21</th>
      <th>20-16</th>
      <th>15-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>rs</td>
      <td>rt</td>
      <td>immediate</td>
    </tr>
  </tbody>
</table>

<p>I-type instructions are used for operations that involve an immediate value (a constant), as well as for memory access and branches.</p>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code.</li>
  <li><strong>rs: 5 bits</strong> - The source register.</li>
  <li><strong>rt: 5 bits</strong> - The destination register (or another source register for branches).</li>
  <li><strong>Immediate: 16 bits</strong> - The immediate value, which can be a constant, address offset, or immediate operand.</li>
</ul>

<p>Eg:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $t1, $t2, 10    # $t1 = $t2 + 10
lw $t0, 4($t1)       # $t0 = Memory[$t1 + 4]
andi $t0, $t1, 0xFF  # $t0 = $t1 &amp; 0xFF
</code></pre></div></div>

<h3 id="3-j-type">3. J-type</h3>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>address</td>
    </tr>
  </tbody>
</table>

<p>J-type instructions are used for jump instructions that require a target address.</p>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code.</li>
  <li><strong>Address: 26 bits</strong> - The target address for the jump. This address is combined with the upper bits of the program counter (PC) to form the full jump address.</li>
</ul>

<p>In MIPS32, we observe that only 26 bits are used for the target address of jump instructions, even though the address space of MIPS32 spans 4GB (2<sup>32</sup>). Because all MIPS instructions are 32 bits wide, they are word-aligned. This word alignment means the last 2 bits of any instruction address are always 00. Thus, only 28 bits are effectively used to form the target address. To construct the full 32-bit address, the upper 4 bits of the current program counter (PC) — which is the address of the instruction following the jump — are combined with the 28-bit target address. This results in a maximum addressable jump distance of 256MB (2<sup>28</sup>).</p>

<p>However, within a 4GB address space, it’s possible that the target instruction may be farther away than this 256MB limit. Modern assemblers employ various strategies to address this limitation, some of which we will explore later.</p>

<h2 id="pros-and-cons-of-uniform-instruction-width-and-dedicated-opcode-spots-in-mips">Pros and Cons of Uniform Instruction Width and Dedicated Opcode Spots in MIPS</h2>

<h3 id="pros">Pros</h3>

<ol>
  <li>
    <p><strong>Simplicity in Instruction Fetching:</strong> With a uniform instruction width (32 bits) for an implementation that fetches a single instruction per cycle, a single aligned memory/cache access of the fixed size is guaranteed to provide one (and only one) instruction, so no buffering or shifting is required. There is also no concern about crossing a cache line or page boundary within a single instruction.</p>
  </li>
  <li>
    <p><strong>Predictable Instruction Fetching:</strong> With a uniform instruction width, the instruction pointer increments by a fixed amount (32 bits) for each instruction (except for control flow instructions like jumps and branches). This predictability allows the CPU to know the location of the next instruction early, reducing the need for partial decoding. It also simplifies the process of fetching and parsing multiple instructions per cycle, enhancing overall efficiency. (The need for partial decoding arises when the length of instructions varies. The CPU must determine the length of each instruction before it can identify where the next instruction begins. This requires the CPU to decode at least part of the current instruction to find out its length, a process known as partial decoding. This extra step can complicate the instruction fetching process and introduce additional overhead.)</p>
  </li>
  <li>
    <p><strong>Simplified Parsing and Early Register Reading:</strong> The uniform instruction format in MIPS enables straightforward parsing of instruction components, such as immediate values, opcodes, and register names. This is particularly beneficial for timing-critical tasks like parsing source register names. With fixed positions for these components, the CPU can begin reading register values immediately after fetching the instruction, even before fully determining the instruction type. This speculative register reading does not require special recovery if incorrect, although it consumes extra energy. In the MIPS R2000’s classic 5-stage pipeline, this approach allows register values to be read right after instruction fetch, providing ample time to compare values and resolve branches, thus avoiding stalls without needing branch prediction. Parsing out the opcode is slightly less timing-critical than parsing source register names, but extracting the opcode sooner accelerates the start of execution. Simple parsing of the destination register name facilitates dependency detection across instructions, particularly beneficial when executing multiple instructions per cycle.</p>
  </li>
  <li>
    <p><strong>Usage of Fewer Bits for Target Addresses:</strong> In uniform instruction sets, the alignment of instructions allows the use of fewer bits to specify target addresses. For example, in a 32-bit wide instruction set, the last 2 bits of any instruction address are always 0 due to word alignment. This means that only 30 bits are needed to represent the address instead of 32. This reduction in required bits can be exploited in certain ISAs, such as MIPS/MIPS16, to provide additional storage space for other purposes, like indicating a mode with smaller or variable-length instructions. This efficient use of addressing allows for more compact encoding of instructions and can enhance the flexibility of the instruction set by supporting different modes.</p>
  </li>
</ol>

<h2 id="cons">Cons</h2>

<ol>
  <li>
    <p><strong>Low Code Density:</strong> Uniform instruction width can lead to inefficient use of memory when instructions are shorter than the fixed width. For example, if you have a 32-bit instruction width but some instructions only require a few bits, the extra bits in each instruction are wasted. This can lead to larger code sizes and increased memory consumption.</p>
  </li>
  <li>
    <p><strong>Decreased Flexibility due to Implicit Operands:</strong> Strict uniform formatting tends to exclude the use of implicit operands, which are operands not explicitly specified in the instruction but implied by the operation. For instance, even though MIPS mostly avoids implicit operands, it still uses an implicit destination register for the link register (<code class="language-plaintext highlighter-rouge">$ra</code>), which stores the return address for function calls. (When a function call is made in MIPS, the jal (jump and link) instruction is used. This instruction not only jumps to the target function address but also implicitly stores the return address (the address of the instruction following the <code class="language-plaintext highlighter-rouge">jal</code>) in the link register <code class="language-plaintext highlighter-rouge">$ra</code> (which is register <code class="language-plaintext highlighter-rouge">$31</code>). This behavior is implicit in the sense that the <code class="language-plaintext highlighter-rouge">jal</code> instruction does not need to specify that the return address should be stored in <code class="language-plaintext highlighter-rouge">$ra</code>; it is automatically understood and handled by the instruction.)</p>
  </li>
  <li><strong>Cannot Handle Large Values of Immediate:</strong> Fixed-length instructions present challenges when dealing with large immediate values (constants embedded directly within instructions). In MIPS immediate values can be upto 16-bits within a single instruction. If a constant exceeds this 16-bit limit, additional steps are required to handle the larger value.
    <ol>
      <li><strong>Loading as Data:</strong> One method to handle large constants is to load them from memory. This approach involves:
        <ul>
          <li>An extra load instruction.</li>
          <li>Overhead associated with address calculation, register usage, address translation, and tag checking.</li>
        </ul>
      </li>
      <li><strong>Multiple Instructions:</strong> MIPS provides two instructions <code class="language-plaintext highlighter-rouge">lui</code> (load upper immediate) to load the upper 16 bits of a constant and <code class="language-plaintext highlighter-rouge">ori</code> (or immediate) which performs bitwise OR on lower 16 bits this effectively loading a 32-bit immediate. These instructions do not involve memory access. The 32-bit immediate value is constructed directly within the CPU using two instructions. This is faster and avoids the overhead of accessing memory. Using two instructions to handle a large immediate introduces more overhead compared to a single instruction. Modern processor designs can mitigate some of this overhead. For example, Intel’s macro-op fusion combines certain pairs of instructions at the front-end of the pipeline, effectively reducing the execution overhead.</li>
    </ol>
  </li>
  <li>
    <p><strong>Challenges in Extending the ISA:</strong> New features may require addition of new instructions to the ISA. Fixed-length instructions present a significant challenge when it comes to extending an instruction set. The number of distinct operations (opcodes) that can be represented is limited. For example, with a 6-bit opcode field (as in MIPS), there are only 64 possible opcodes. It also poses a challenge when we have to increase number of available registers as adding more registers requires more bits to encode the register addresses. To extend the instruction set without breaking compatibility, additional modes or instruction formats might be needed. This can complicate the CPU design and increase the complexity of the instruction decoder.</p>
  </li>
  <li><strong>Limited Address Bound for Branching Instructions:</strong> In MIPS, the jump instruction uses only 26 bits to specify the immediate target address. Due to memory alignment, the last 2 bits are always zero, effectively giving 28 bits for the target address. The upper 4 bits of the Program Counter (PC) are combined with these 28 bits to form a full 32-bit address, which limits the addressable range to 256 MB. Consequently, the assembly programmer or compiler must ensure that the target address of the jump instruction lies within this 256 MB boundary. If the target address exceeds this limit, other options must be employed, such as using the <code class="language-plaintext highlighter-rouge">jr</code> (jump to the address stored in register) instruction, which can specify a full 32-bit address by storing the address in a register. In some versions, the assembler will issue a warning if the target address of a <code class="language-plaintext highlighter-rouge">j</code> instruction exceeds the 256 MB bound. In other cases, the assembler might automatically replace the <code class="language-plaintext highlighter-rouge">j</code> instruction with a <code class="language-plaintext highlighter-rouge">jr</code> instruction to handle the full address space correctly.</li>
</ol>

<h2 id="coprocessors-in-mips">Coprocessors in MIPS</h2>

<p>MIPS is a modular architecture supporting up to four coprocessors (CP0/1/2/3). Coprocessors are specialized processing units that work alongside the main CPU to handle specific types of operations, such as floating-point arithmetic, system control, or other specialized tasks. MIPS typically defines up to four coprocessors, though not all are always implemented in every MIPS processor. These coprocessors are numbered CP0 through CP3.</p>

<ol>
  <li>
    <p><strong>Coprocessor 0 (CP0) - System Control Coprocessor:</strong> CP0 is responsible for managing system control functions, including exception handling, memory management, and processor status. It plays a critical role in configuring and controlling the behavior of the MIPS processor. CP0 contains a set of special-purpose registers used for various control tasks, such as the Status Register, Cause Register, EPC (Exception Program Counter), and TLB (Translation Lookaside Buffer) management registers.</p>
  </li>
  <li>
    <p><strong>Coprocessor 1 (CP1) - Floating-Point Unit (FPU)</strong>: CP1 is dedicated to handling floating-point arithmetic operations, such as addition, subtraction, multiplication, division, and square root operations on floating-point numbers. This offloads complex calculations from the main CPU, improving overall performance for tasks requiring floating-point computations. CP1 includes 32 floating-point registers (<code class="language-plaintext highlighter-rouge">$f0</code> to <code class="language-plaintext highlighter-rouge">$f31</code>), which are used to store floating-point operands and results. Additionally, CP1 contains the Floating-Point Control and Status Register (FCSR), which holds various status flags and control bits related to floating-point operations. The FCSR also contains the comparison bit, which is set by floating-point comparison instructions and can be used for conditional branching.</p>
  </li>
  <li>
    <p><strong>Coprocessor 2 and 3 (Optional):</strong> CP2 and CP3 are optional coprocessors that can be used for application-specific purposes, such as vector processing, digital signal processing (DSP), or other specialized tasks. For example, in the PlayStation video game console, CP2 is the Geometry Transformation Engine (GTE), which accelerates the processing of geometry in 3D computer graphics.</p>
  </li>
</ol>

<h2 id="overview-of-mips-instructions">Overview of MIPS Instructions</h2>

<h3 id="1-memory-access-instructions">1. Memory Access Instructions</h3>

<p>Memory access instructions in MIPS facilitate moving data between registers and memory, as well as between general purpose, floating-point (FP), or special registers. Most of the memory access instructions are I-type and use register indirect with displacement as addressing mode.</p>

<h4 id="1-load-family-of-instructions">1. Load Family of Instructions</h4>

<p>All of the load instructions in MIPS are I-type instructions, and they follow this general format:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD &lt;rt&gt;, offset(base)
</code></pre></div></div>

<ul>
  <li><strong>LOAD</strong> is the opcode for the specific load instruction (e.g., LB, LBU, LH, LHU, LW, LWU, LD, L.S, L.D).</li>
  <li><strong>&lt;rt&gt;</strong> is the target register where the data will be loaded.</li>
  <li><strong>offset</strong> is a 16-bit signed immediate value representing the displacement.</li>
  <li><strong>base</strong> is the base register whose contents are added to the offset to form the effective memory address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>LB</strong></td>
      <td>Load Byte</td>
      <td>Loads a byte from memory into a register, sign-extended.</td>
    </tr>
    <tr>
      <td><strong>LBU</strong></td>
      <td>Load Byte Unsigned</td>
      <td>Loads a byte from memory into a register, zero-extended.</td>
    </tr>
    <tr>
      <td><strong>LH</strong></td>
      <td>Load Halfword</td>
      <td>Loads a halfword from memory into a register, sign-extended.</td>
    </tr>
    <tr>
      <td><strong>LHU</strong></td>
      <td>Load Halfword Unsigned</td>
      <td>Loads a halfword from memory into a register, zero-extended.</td>
    </tr>
    <tr>
      <td><strong>LW</strong></td>
      <td>Load Word</td>
      <td>Loads a word from memory into a register.</td>
    </tr>
    <tr>
      <td><strong>LWU</strong></td>
      <td>Load Word Unsigned</td>
      <td>Loads a word from memory into a register, zero-extended (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>LD</strong></td>
      <td>Load Doubleword</td>
      <td>Loads a doubleword from memory into a register (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>L.S</strong></td>
      <td>Load Single Precision Float</td>
      <td>Loads a single precision floating-point value from memory into an FP register.</td>
    </tr>
    <tr>
      <td><strong>L.D</strong></td>
      <td>Load Double Precision Float</td>
      <td>Loads a double precision floating-point value from memory into an FP register.</td>
    </tr>
    <tr>
      <td><strong>LUI</strong></td>
      <td>Load Upper Immediate</td>
      <td>Loads a 16-bit immediate value into the upper 16 bits of a register, with the lower 16 bits set to zero. Unlike other load instructions, LUI does not interact with memory.</td>
    </tr>
  </tbody>
</table>

<h4 id="2-store-family-of-instructions">2. Store Family of Instructions</h4>

<p>The store family of instructions in MIPS transfers data from a register to a specified memory location. All of the store instructions in MIPS are I-type instructions, and they follow this general format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STORE &lt;rt&gt;, offset(base)
</code></pre></div></div>

<ul>
  <li><strong>STORE</strong> is the opcode for the specific store instruction (e.g., SB, SH, SW, SD, S.S, S.D).</li>
  <li><strong>&lt;rt&gt;</strong> is the source register whose data will be stored in memory.</li>
  <li><strong>offset</strong> is a 16-bit signed immediate value representing the displacement.</li>
  <li><strong>base</strong> is the base register whose contents are added to the offset to form the effective memory address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>SB</strong></td>
      <td>Store Byte</td>
      <td>Stores a byte from a register into memory.</td>
    </tr>
    <tr>
      <td><strong>SH</strong></td>
      <td>Store Halfword</td>
      <td>Stores a halfword from a register into memory.</td>
    </tr>
    <tr>
      <td><strong>SW</strong></td>
      <td>Store Word</td>
      <td>Stores a word from a register into memory.</td>
    </tr>
    <tr>
      <td><strong>SD</strong></td>
      <td>Store Doubleword</td>
      <td>Stores a doubleword from a register into memory (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>S.S</strong></td>
      <td>Store Single Precision Float</td>
      <td>Stores a single precision floating-point value from an FP register into memory.</td>
    </tr>
    <tr>
      <td><strong>S.D</strong></td>
      <td>Store Double Precision Float</td>
      <td>Stores a double precision floating-point value from an FP register into memory.</td>
    </tr>
  </tbody>
</table>

<h4 id="3-register-data-transfer-instructions">3. Register Data Transfer Instructions</h4>

<p>These instructions facilitate the transfer of data between different types of registers, such as general-purpose registers (GPRs), floating-point registers (FPRs), and special-purpose registers. These instructions are critical in operations where data needs to be moved from one part of the CPU to another, enabling interaction between different processing units.</p>

<p>These instructions facilitate the transfer of data between two general-purpose registers.</p>

<ul>
  <li><strong>MFHI:</strong> Move From HI register. Transfers the content from the HI special register to a GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFHI $d  # $d = HI
</code></pre></div>    </div>
  </li>
  <li><strong>MFLO:</strong> Move From LO register. Transfers the content from the LO special register to a GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFLO $d  # $d = LO
</code></pre></div>    </div>
  </li>
  <li><strong>MOV.S:</strong> Move single-precision floating-point value.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOV.S $f1, $f2  # $f1 = $f2
</code></pre></div>    </div>
  </li>
  <li><strong>MOV.D:</strong> Move double-precision floating-point value.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOV.D $f1, $f2  # $f1 = $f2
</code></pre></div>    </div>
  </li>
  <li><strong>MFC0 (Move From Coprocessor 0):</strong> This instruction moves data from a specific CP0 register to a general-purpose register (GPR). It’s often used to read system control information, such as the contents of the status register, exception handling registers, or memory management configuration.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFC0 $t, $c0_reg, $sel
</code></pre></div>    </div>
  </li>
  <li>$t: The destination general-purpose register.</li>
  <li>$c0_reg: The CP0 register number.</li>
  <li>$sel: The select field, which allows accessing different parts or subsets of the CP0 register.
Example:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFC0 $t0, $12  # Move the contents of CP0 Status register (register 12) to $t0
</code></pre></div>    </div>
  </li>
  <li><strong>MTC0 (Move To Coprocessor 0):</strong> This instruction moves data from a general-purpose register (GPR) to a specific CP0 register.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MTC0 $t0, $13  # Move the contents of $t0 into CP0 Cause register (register 13)
</code></pre></div>    </div>
  </li>
  <li><strong>MFC1:</strong>  Move From Coprocessor 1 (FPR) to GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFC1 $t, $f  # $t = $f
</code></pre></div>    </div>
  </li>
  <li><strong>MTC1:</strong> Move To Coprocessor 1 (FPR) from GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MTC1 $f, $t  # $f = $t
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="2-arithmetic-instructions-integers">2. Arithmetic instructions (Integers)</h3>

<p>Arithmetic instructions in MIPS perform basic mathematical operations such as addition, subtraction, multiplication, and division. These instructions operate on values stored in general-purpose registers (GPRs) and often involve signed and unsigned integers.</p>

<p>Majority of arithmetic instructions are R-type, they follow this general format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ARITHMETIC $rd, $rs, $rt
</code></pre></div></div>
<ul>
  <li><strong>ARITHMETIC</strong> is the opcode for the specific arithmetic instruction (e.g., ADD, ADDU, SUB, MULT).</li>
  <li><strong>$rd</strong> is the destination register where the result of the operation will be stored.</li>
  <li><strong>$rs</strong> is the source register containing the first operand.</li>
  <li><strong>$rt</strong> is the source register containing the second operand.</li>
</ul>

<p>(Note: The storage format for R-type instructions is <code class="language-plaintext highlighter-rouge">&lt;opcode&gt; &lt;rs&gt; &lt;rt&gt; &lt;rd&gt; &lt;shamt&gt; &lt;funct&gt;</code>. However, when writing the instruction in assembly language, it is written as <code class="language-plaintext highlighter-rouge">&lt;opcode&gt; $rd, $rs, $rt.</code>)</p>

<p>Immediate operations follow I-type, the format is slightly different:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ARITHMETIC_IMM $rt, $rs, immediate
</code></pre></div></div>

<ul>
  <li><strong>ARITHMETIC_IMM</strong> is the opcode for the specific arithmetic instruction that uses an immediate value (e.g., ADDI, ADDIU).</li>
  <li><strong>$rt</strong> is the destination register where the result will be stored.</li>
  <li><strong>$rs</strong> is the source register containing the first operand.</li>
  <li><strong>immediate</strong> is a 16-bit signed value that is added to the contents of <code class="language-plaintext highlighter-rouge">$rs</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ADD</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADD $rd, $rs, $rt</code></td>
      <td>Adds the contents of <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>. Raises an exception on overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADD $t0, $t1, $t2  # $t0 = $t1 + $t2</code></td>
    </tr>
    <tr>
      <td><strong>ADDU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADDU $rd, $rs, $rt</code></td>
      <td>Adds the contents of <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code> without checking for overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADDU $t0, $t1, $t2  # $t0 = $t1 + $t2 (no overflow check)</code></td>
    </tr>
    <tr>
      <td><strong>ADDI</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADDI $rt, $rs, immediate</code></td>
      <td>Adds an immediate value to <code class="language-plaintext highlighter-rouge">$rs</code>, stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>. Raises an exception on overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADDI $t0, $t1, 10  # $t0 = $t1 + 10</code></td>
    </tr>
    <tr>
      <td><strong>ADDIU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADDIU $rt, $rs, immediate</code></td>
      <td>Adds an immediate value to <code class="language-plaintext highlighter-rouge">$rs</code> without checking for overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADDIU $t0, $t1, 10  # $t0 = $t1 + 10 (no overflow check)</code></td>
    </tr>
    <tr>
      <td><strong>SUB</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SUB $rd, $rs, $rt</code></td>
      <td>Subtracts <code class="language-plaintext highlighter-rouge">$rt</code> from <code class="language-plaintext highlighter-rouge">$rs</code>, stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>. Raises an exception on overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">SUB $t0, $t1, $t2  # $t0 = $t1 - $t2</code></td>
    </tr>
    <tr>
      <td><strong>SUBU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SUBU $rd, $rs, $rt</code></td>
      <td>Subtracts <code class="language-plaintext highlighter-rouge">$rt</code> from <code class="language-plaintext highlighter-rouge">$rs</code> without checking for overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">SUBU $t0, $t1, $t2  # $t0 = $t1 - $t2 (no overflow check)</code></td>
    </tr>
    <tr>
      <td><strong>MULT</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MULT $rs, $rt</code></td>
      <td>Multiplies <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, result stored in <code class="language-plaintext highlighter-rouge">HI</code> and <code class="language-plaintext highlighter-rouge">LO</code> registers.</td>
      <td><code class="language-plaintext highlighter-rouge">MULT $t1, $t2  # Result in HI:LO = $t1 * $t2</code></td>
    </tr>
    <tr>
      <td><strong>MULTU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MULTU $rs, $rt</code></td>
      <td>Multiplies unsigned integers <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, result stored in <code class="language-plaintext highlighter-rouge">HI</code> and <code class="language-plaintext highlighter-rouge">LO</code> registers.</td>
      <td><code class="language-plaintext highlighter-rouge">MULTU $t1, $t2  # Unsigned result in HI:LO</code></td>
    </tr>
    <tr>
      <td><strong>DIV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DIV $rs, $rt</code></td>
      <td>Divides <code class="language-plaintext highlighter-rouge">$rs</code> by <code class="language-plaintext highlighter-rouge">$rt</code>, quotient stored in <code class="language-plaintext highlighter-rouge">LO</code>, remainder in <code class="language-plaintext highlighter-rouge">HI</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">DIV $t1, $t2  # LO = $t1 / $t2; HI = $t1 % $t2</code></td>
    </tr>
    <tr>
      <td><strong>DIVU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DIVU $rs, $rt</code></td>
      <td>Divides unsigned integers <code class="language-plaintext highlighter-rouge">$rs</code> by <code class="language-plaintext highlighter-rouge">$rt</code>, quotient stored in <code class="language-plaintext highlighter-rouge">LO</code>, remainder in <code class="language-plaintext highlighter-rouge">HI</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">DIVU $t1, $t2  # Unsigned LO = $t1 / $t2; HI = $t1 % $t2</code></td>
    </tr>
  </tbody>
</table>

<p>The above instructions are for MIPS32. MIPS64 has similar instructions with a prefix letter “D” added to each instruction. The “D” indicates “Doubleword,” e.g., DADD, DADDI, DADDU, DADDIU.</p>

<h3 id="3-logical-instructions-integers">3. Logical instructions (Integers)</h3>

<p>Logical instructions in MIPS are used to perform bitwise operations on the binary representations of data stored in registers.</p>

<p>Logical Instructions follow the R-type format. In this format, the instructions operate on registers and involve three operands: two source registers and one destination register.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOGICAL $rd, $rs, $rt
</code></pre></div></div>
<ul>
  <li><strong>LOGICAL:</strong> is the opcode for logical instruction (e.g., AND, OR, XOR, NOR)</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rs</strong> and <strong>$rt</strong> are the source registers.</li>
</ul>

<p>Some instructions have immediate variants as well, which follow the I-type format.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOGICAL_IMM $rd, $rs, $rt
</code></pre></div></div>

<ul>
  <li><strong>LOGICAL_IMM:</strong> is the opcode for logical instruction (e.g., ANDI, ORI, XORI)</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rs</strong> and <strong>$rt</strong> are the source registers.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>AND</strong></td>
      <td>Bitwise AND</td>
      <td>Performs a bitwise AND operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>OR</strong></td>
      <td>Bitwise OR</td>
      <td>Performs a bitwise OR operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>XOR</strong></td>
      <td>Bitwise XOR</td>
      <td>Performs a bitwise XOR operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>NOR</strong></td>
      <td>Bitwise NOR</td>
      <td>Performs a bitwise NOR operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>ANDI</strong></td>
      <td>Bitwise AND Immediate</td>
      <td>Performs a bitwise AND operation between the value in <code class="language-plaintext highlighter-rouge">$rs</code> and an immediate value, and stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
    </tr>
    <tr>
      <td><strong>ORI</strong></td>
      <td>Bitwise OR Immediate</td>
      <td>Performs a bitwise OR operation between the value in <code class="language-plaintext highlighter-rouge">$rs</code> and an immediate value, and stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
    </tr>
    <tr>
      <td><strong>XORI</strong></td>
      <td>Bitwise XOR Immediate</td>
      <td>Performs a bitwise XOR operation between the value in <code class="language-plaintext highlighter-rouge">$rs</code> and an immediate value, and stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
    </tr>
  </tbody>
</table>

<h3 id="4-shift-instructions">4. Shift Instructions</h3>

<p>Shift instructions in MIPS perform bitwise shifts on operands stored in registers. Shift instructions are all R-type and follow this general format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHIFT $rd, $rt, shamt 
</code></pre></div></div>

<ul>
  <li><strong>SHIFT</strong> is the opcode for the specific variable shift instruction (e.g., SLL, SRL, SRA).</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rt</strong> is the source register that contains the value to be shifted.</li>
  <li><strong>shamt</strong> (shift amount) is the number of bit positions to shift the value in <code class="language-plaintext highlighter-rouge">$rt</code>.</li>
</ul>

<p>Another type of shift instruction follows this format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHIFT $rd, $rt, $rs
</code></pre></div></div>

<ul>
  <li><strong>SHIFT</strong> is the opcode for the specific variable shift instruction (e.g., SLLV, SRLV, SRAV).</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rt</strong> is the source register that contains the value to be shifted.</li>
  <li><strong>$rs</strong> is the register that specifies the shift amount.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>SLL</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLL $rd, $rt, shamt</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> left by <code class="language-plaintext highlighter-rouge">shamt</code> bits, stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLL $t0, $t1, 2 # $t0 = $t1 &lt;&lt; 2</code></td>
    </tr>
    <tr>
      <td><strong>SRL</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRL $rd, $rt, shamt</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> right by <code class="language-plaintext highlighter-rouge">shamt</code> bits (logical), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>. It does not preserve the sign bit (MSB). It treats the value as an unsigned number, so the MSB is replaced with a zero.</td>
      <td><code class="language-plaintext highlighter-rouge">SRL $t0, $t1, 2 # $t0 = $t1 &gt;&gt; 2</code></td>
    </tr>
    <tr>
      <td><strong>SRA</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRA $rd, $rt, shamt</code></td>
      <td>Shifts the contents of $rt right by shamt bits (arithmetic) and stores the result in $rd. It preserves the sign bit (MSB), meaning the sign bit remains unchanged during the shift operation.</td>
      <td><code class="language-plaintext highlighter-rouge">SRA $t0, $t1, 2 # $t0 = $t1 &gt;&gt; 2</code></td>
    </tr>
    <tr>
      <td><strong>SLLV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLLV $rd, $rt, $rs</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> left by the value in <code class="language-plaintext highlighter-rouge">$rs</code> (variable shift), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLLV $t0, $t1, $t2 # $t0 = $t1 &lt;&lt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SRLV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRLV $rd, $rt, $rs</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> right by the value in <code class="language-plaintext highlighter-rouge">$rs</code> (logical, variable shift), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SRLV $t0, $t1, $t2 # $t0 = $t1 &gt;&gt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SRAV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRAV $rd, $rt, $rs</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> right by the value in <code class="language-plaintext highlighter-rouge">$rs</code> (arithmetic, variable shift), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SRAV $t0, $t1, $t2 # $t0 = $t1 &gt;&gt; $t2</code></td>
    </tr>
  </tbody>
</table>

<p>In a left shift operation, the sign bit (MSB) is treated like any other bit. The intuition behind a logical left shift is that each shift operation corresponds to multiplication by 2. For example: <code class="language-plaintext highlighter-rouge">0000 1111 &lt;&lt; 1 = 0001 1110</code>, which is 15 * 2 = 30.</p>

<p>Similarly, a logical right shift corresponds to division by 2. For example: <code class="language-plaintext highlighter-rouge">0001 1110 &gt;&gt; 1 = 0000 1111</code>, which is 30 / 2 = 15. However, when applying logical right shift to negative numbers (in two’s complement representation), such as <code class="language-plaintext highlighter-rouge">1110 0010</code> (which represents -30), performing a logical right shift results in <code class="language-plaintext highlighter-rouge">0111 0001</code> (113), which is not intuitive. In contrast, applying an arithmetic right shift, which preserves the sign bit, results in <code class="language-plaintext highlighter-rouge">1111 0001</code> (-15), which is more intuitive and useful.</p>

<h3 id="5-comparision-instruction">5. Comparision Instruction</h3>

<p>These instructions compare the values in registers (or between a register and an immediate value) and set the destination register based on whether the condition is met.</p>

<p>Comparision instructions follow the R-type format, they follow this general format:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COMPARISION $rd, $rs, $rt
</code></pre></div></div>
<ul>
  <li><strong>COMPARISION:</strong> is the opcode for logical instruction (e.g., SLT, SLTU)</li>
  <li><strong>$rd:</strong> Destination register where the result (1 or 0) will be stored.</li>
  <li><strong>$rs:</strong> First source register.</li>
  <li><strong>$rt:</strong> Second source register.</li>
</ul>

<p>They also have I-type variants</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COMPARISION_IMM $rt, $rs, immediate
</code></pre></div></div>
<ul>
  <li><strong>COMPARISION_IMM:</strong> is the opcode for logical instruction (e.g., SLTI, SLTIU)</li>
  <li><strong>$rt:</strong> Destination register where the result (1 or 0) will be stored</li>
  <li><strong>$rs:</strong> Source register.</li>
  <li><strong>immediate:</strong> 16-bit signed or unsigned immediate value.</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>Instruction</strong></th>
      <th><strong>Syntax</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Example</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>SLT</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLT $rd, $rs, $rt</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rd</code> to <code class="language-plaintext highlighter-rouge">1</code> if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the value in <code class="language-plaintext highlighter-rouge">$rt</code>, otherwise sets it to <code class="language-plaintext highlighter-rouge">0</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLT $t0, $t1, $t2</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SLTI</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLTI $rt, $rs, immediate</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rt</code> to <code class="language-plaintext highlighter-rouge">1</code> if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the immediate value, otherwise sets it to <code class="language-plaintext highlighter-rouge">0</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLTI $t0, $t1, 10</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; 10</code></td>
    </tr>
    <tr>
      <td><strong>SLTU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLTU $rd, $rs, $rt</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rd</code> to <code class="language-plaintext highlighter-rouge">1</code> if the unsigned value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the unsigned value in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLTU $t0, $t1, $t2</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SLTIU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLTIU $rt, $rs, immediate</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rt</code> to <code class="language-plaintext highlighter-rouge">1</code> if the unsigned value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the unsigned immediate value.</td>
      <td><code class="language-plaintext highlighter-rouge">SLTIU $t0, $t1, 10</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; 10</code></td>
    </tr>
  </tbody>
</table>

<h3 id="6-control-instructions">6. Control Instructions</h3>

<p>Control instructions in MIPS manage the flow of execution by altering the program counter (PC) based on conditions, performing unconditional jumps, and handling exceptions. These instructions are crucial for implementing loops, conditional execution, and function calls.</p>

<p>Control instructions in MIPS can be either I-type or J-type and follow these general formats:</p>

<p><strong>I-Type Branch Instructions</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BRANCH $rs, $rt, offset
</code></pre></div></div>
<ul>
  <li><strong>BRANCH:</strong> is the opcode for the specific branch instruction (e.g., <code class="language-plaintext highlighter-rouge">BEQ</code>, <code class="language-plaintext highlighter-rouge">BNE</code>, <code class="language-plaintext highlighter-rouge">BEQZ</code>, <code class="language-plaintext highlighter-rouge">BNEZ</code>).</li>
  <li><strong>$rs:</strong> The first source register.</li>
  <li><strong>$rt:</strong> The second source register (or immediate zero for <code class="language-plaintext highlighter-rouge">BEQZ</code>/<code class="language-plaintext highlighter-rouge">BNEZ</code>).</li>
  <li><strong>offset:</strong> The 16-bit signed offset from <code class="language-plaintext highlighter-rouge">PC + 4</code> to which the program will branch if the condition is met.</li>
</ul>

<p><strong>J-Type Jump Instructions</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JUMP target
</code></pre></div></div>
<ul>
  <li><strong>JUMP:</strong> is the opcode for the specific jump instruction (e.g., <code class="language-plaintext highlighter-rouge">J</code>, <code class="language-plaintext highlighter-rouge">JAL</code>).</li>
  <li><strong>target:</strong> The 26-bit immediate value specifying the address to jump to, relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>. It can also be the source register containing the target address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>Instruction</strong></th>
      <th><strong>Syntax</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Example</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>BEQZ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BEQZ $rs, offset</code></td>
      <td>Branches if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is equal to zero. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BEQZ $t0, label</code></td>
    </tr>
    <tr>
      <td><strong>BNEZ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BNEZ $rs, offset</code></td>
      <td>Branches if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is not equal to zero. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BNEZ $t0, label</code></td>
    </tr>
    <tr>
      <td><strong>BEQ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BEQ $rs, $rt, offset</code></td>
      <td>Branches if the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code> are equal. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BEQ $t0, $t1, label</code></td>
    </tr>
    <tr>
      <td><strong>BNE</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BNE $rs, $rt, offset</code></td>
      <td>Branches if the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code> are not equal. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BNE $t0, $t1, label</code></td>
    </tr>
    <tr>
      <td><strong>BC1T</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BC1T offset</code></td>
      <td>Branches if the floating-point comparison bit is true. The comparison bit is located in the Floating-Point Control and Status Register (FCSR) in Coprocessor 1 (CP1). This bit is set by floating-point comparison instructions. The offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BC1T label</code></td>
    </tr>
    <tr>
      <td><strong>BC1F</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BC1F offset</code></td>
      <td>Branches if the floating-point comparison bit is false. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BC1F label</code></td>
    </tr>
    <tr>
      <td><strong>MOVN</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MOVN $rd, $rs, $rt</code></td>
      <td>Copies the value in <code class="language-plaintext highlighter-rouge">$rs</code> to <code class="language-plaintext highlighter-rouge">$rd</code> if the value in <code class="language-plaintext highlighter-rouge">$rt</code> is not zero.</td>
      <td><code class="language-plaintext highlighter-rouge">MOVN $t0, $t1, $t2</code></td>
    </tr>
    <tr>
      <td><strong>MOVZ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MOVZ $rd, $rs, $rt</code></td>
      <td>Copies the value in <code class="language-plaintext highlighter-rouge">$rs</code> to <code class="language-plaintext highlighter-rouge">$rd</code> if the value in <code class="language-plaintext highlighter-rouge">$rt</code> is zero.</td>
      <td><code class="language-plaintext highlighter-rouge">MOVZ $t0, $t1, $t2</code></td>
    </tr>
    <tr>
      <td><strong>J</strong></td>
      <td><code class="language-plaintext highlighter-rouge">J target</code></td>
      <td>Unconditionally jumps to the target address. The target is a 26-bit immediate value relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">J label</code></td>
    </tr>
    <tr>
      <td><strong>JR</strong></td>
      <td><code class="language-plaintext highlighter-rouge">JR $rs</code></td>
      <td>Unconditionally jumps to the address contained in <code class="language-plaintext highlighter-rouge">$rs</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">JR $t0</code></td>
    </tr>
    <tr>
      <td><strong>JAL</strong></td>
      <td><code class="language-plaintext highlighter-rouge">JAL target</code></td>
      <td>Jumps to the target address and stores the return address (<code class="language-plaintext highlighter-rouge">PC + 4</code>) in <code class="language-plaintext highlighter-rouge">$ra</code> (register 31).</td>
      <td><code class="language-plaintext highlighter-rouge">JAL label</code></td>
    </tr>
    <tr>
      <td><strong>JALR</strong></td>
      <td><code class="language-plaintext highlighter-rouge">JALR $rd, $rs</code></td>
      <td>Jumps to the address in <code class="language-plaintext highlighter-rouge">$rs</code> and stores the return address (<code class="language-plaintext highlighter-rouge">PC + 4</code>) in <code class="language-plaintext highlighter-rouge">$rd</code> (usually <code class="language-plaintext highlighter-rouge">$ra</code>).</td>
      <td><code class="language-plaintext highlighter-rouge">JALR $ra, $t0</code></td>
    </tr>
    <tr>
      <td><strong>TRAP</strong></td>
      <td><code class="language-plaintext highlighter-rouge">TRAP code</code></td>
      <td>Triggers a software interrupt, transferring control to the operating system at a predefined vectored address. This instruction is used for implementing system calls or exceptions where the program needs to request services from the operating system or handle specific conditions. The code parameter is a 16-bit immediate value called system call number, it specifies the type of service or the particular action to be performed by the operating system.</td>
      <td><code class="language-plaintext highlighter-rouge">TRAP 0x7</code></td>
    </tr>
    <tr>
      <td><strong>ERET</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ERET</code></td>
      <td>Returns from an exception, restoring the state and returning to user mode. An “exception” generally refers to any condition that disrupts the normal execution flow of a program and requires special handling by the operating system or the CPU. These can include both software interrupt which are intentional exceptions triggered by the program, often using a TRAP instruction, to request a service from the operating system or hardware exceptions like a program tries to divide a number by zero, triggering a divide-by-zero exception. The CPU catches this, and the operating system’s exception handler is invoked. After handling the exception (perhaps by terminating the program or skipping the instruction), ERET is used to return control to the next appropriate point in the program.</td>
      <td><code class="language-plaintext highlighter-rouge">ERET</code></td>
    </tr>
  </tbody>
</table>

<p>Note: The relative offset for branching is considered from <code class="language-plaintext highlighter-rouge">PC + 4</code> instead of <code class="language-plaintext highlighter-rouge">PC</code> because, in MIPS, the Program Counter (PC) is incremented by 4 immediately after fetching the current instruction. This means that by the time the branch or jump instruction is executed, the PC already points to the next instruction.</p>

<p><strong>Translation of Labels in Machine Code</strong></p>

<p>When writing assembly code, we often use labels as targets for jumps or branches. These labels are symbolic names representing memory addresses. During the assembly process, the assembler converts these labels into actual memory locations. This allows the code to be more readable and maintainable, as labels can be used instead of hard-coded memory addresses.</p>

<p>For e.g., if the assembly code is</p>

<pre><code class="language-assembly">start:
    ADD $t0, $t1, $t2
    BEQ $t0, $zero, end
    SUB $t3, $t4, $t5
end:
    NOP
</code></pre>

<p>when it’s converted to machine code by the assembler, it will be like this (except everything including opcodes will be binary numbers)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ADD $t0, $t1, $t2
    BEQ $t0, $zero, 0x00400010  # The label 'end' is converted to the memory address 0x00400010
    SUB $t3, $t4, $t5
    NOP
</code></pre></div></div>

<p>During assembly, the assembler replaces each referenced label with the corresponding memory location of the code associated with that label. The assembler can calculate these addresses even before the program is loaded into memory for execution because they are virtual addresses, not physical addresses. In fact, a program does not need to be concerned with physical addresses, as the Memory Management Unit (MMU) handles the translation of virtual addresses to physical addresses.</p>

<p>The assembler assumes a starting address for the program (often specified by the operating system or a linker script). As it processes the code, it assigns virtual memory addresses to each instruction and data element, incrementing the address by the size of each instruction or data element. These addresses are used for the purposes of assembly and linking, not for direct physical memory access.</p>

<h3 id="7-floating-point-instructions">7. Floating-Point Instructions</h3>

<p>In MIPS, floating-point operations are performed using the Floating-Point Unit (FPU), also known as Coprocessor 1 (CP1). The FPU handles calculations on floating-point numbers in three formats: single-precision (SP), double-precision (DP), and paired-single (PS). These operations can involve basic arithmetic like addition, subtraction, multiplication, and division, as well as more complex operations like multiply-add and conversion between different data types.</p>
<ul>
  <li><strong>Single-Precision (SP):</strong> 32-bit floating-point numbers.</li>
  <li><strong>Double-Precision (DP):</strong> 64-bit floating-point numbers.</li>
  <li><strong>Paired-Single (PS):</strong> Two 32-bit floating-point values packed into a single 64-bit register. This format allows SIMD (Single Instruction, Multiple Data) operations, enabling parallel processing of the two 32-bit values.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction Group</th>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Addition</strong></td>
      <td>ADD.[D/S/PS] $fd, $fs, $ft</td>
      <td>Adds the values in $fs and $ft, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">ADD.D $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Subtraction</strong></td>
      <td>SUB.[D/S/PS] $fd, $fs, $ft</td>
      <td>Subtracts the value in $ft from $fs, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">SUB.S $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Multiplication</strong></td>
      <td>MUL.[D/S/PS] $fd, $fs, $ft</td>
      <td>Multiplies the values in $fs and $ft, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">MUL.PS $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Multiply-Add</strong></td>
      <td>MADD.[D/S/PS] $fd, $fs, $ft</td>
      <td>Multiplies $fs and $ft, then adds the result to $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">MADD.D $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Division</strong></td>
      <td>DIV.[D/S/PS] $fd, $fs, $ft</td>
      <td>Divides the value in $fs by $ft, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">DIV.S $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Conversion</strong></td>
      <td>CVT.[x].[y] $fd, $fs</td>
      <td>Converts the value in $fs from format x to format y, storing the result in $fd. Formats include L, W, D, and S.</td>
      <td><code class="language-plaintext highlighter-rouge">CVT.S.D $f0, $f1</code></td>
    </tr>
    <tr>
      <td><strong>Comparison</strong></td>
      <td>C.[cond].[D/S] $fs, $ft</td>
      <td>Compares the values in $fs and $ft. The condition (cond) can be LT, GT, LE, GE, EQ, or NE. Sets a bit in the FCSR based on the result.</td>
      <td><code class="language-plaintext highlighter-rouge">C.LE.S $f0, $f1</code></td>
    </tr>
  </tbody>
</table>

</div>

  
  <footer class="post-footer">
    <h2>References</h2>
    <ul>
      
      <li><a href="https://en.wikipedia.org/wiki/MIPS_architecture" target="_blank">https://en.wikipedia.org/wiki/MIPS_architecture</a></li>
      
      <li><a href="https://mathcs.holycross.edu/~csci226/MIPS/summaryHO.pdf" target="_blank">https://mathcs.holycross.edu/~csci226/MIPS/summaryHO.pdf</a></li>
      
      <li><a href="https://profile.iiita.ac.in/bibhas.ghoshal/COA_2021/lecture_slides/MIPS_Programming.pdf" target="_blank">https://profile.iiita.ac.in/bibhas.ghoshal/COA_2021/lecture_slides/MIPS_Programming.pdf</a></li>
      
      <li><a href="https://ablconnect.harvard.edu/files/ablconnect/files/mips_instruction_set.pdf" target="_blank">https://ablconnect.harvard.edu/files/ablconnect/files/mips_instruction_set.pdf</a></li>
      
      <li><a href="https://www.comp.nus.edu.sg/~adi-yoga/CS2100/ch08/" target="_blank">https://www.comp.nus.edu.sg/~adi-yoga/CS2100/ch08/</a></li>
      
      <li><a href="https://en.wikibooks.org/wiki/MIPS_Assembly/Instruction_Formats" target="_blank">https://en.wikibooks.org/wiki/MIPS_Assembly/Instruction_Formats</a></li>
      
      <li><a href="https://stackoverflow.com/questions/48509093/using-different-registers-in-mips" target="_blank">https://stackoverflow.com/questions/48509093/using-different-registers-in-mips</a></li>
      
      <li><a href="https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call" target="_blank">https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call</a></li>
      
      <li><a href="https://stackoverflow.com/questions/9609721/how-far-can-the-jjump-instruction-jump-in-memory-mips" target="_blank">https://stackoverflow.com/questions/9609721/how-far-can-the-jjump-instruction-jump-in-memory-mips</a></li>
      
      <li><a href="https://electronics.stackexchange.com/questions/162976/range-of-mips-j-instruction" target="_blank">https://electronics.stackexchange.com/questions/162976/range-of-mips-j-instruction</a></li>
      
      <li><a href="https://stackoverflow.com/questions/6950230/how-to-calculate-jump-target-address-and-branch-target-address" target="_blank">https://stackoverflow.com/questions/6950230/how-to-calculate-jump-target-address-and-branch-target-address</a></li>
      
      <li><a href="https://stackoverflow.com/questions/44694957/the-difference-between-logical-shift-right-arithmetic-shift-right-and-rotate-r" target="_blank">https://stackoverflow.com/questions/44694957/the-difference-between-logical-shift-right-arithmetic-shift-right-and-rotate-r</a></li>
      
    </ul>
  </footer>
  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sanketh&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sanketh B K</li><li><a class="u-email" href="mailto:sankethbk.1611@gmail.com">sankethbk.1611@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Sankethbk</span></a></li><li><a href="https://www.linkedin.com/in/sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">sankethbk</span></a></li><li><a href="https://www.twitter.com/Sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Sankethbk</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog! I have started this blog to document my journey of learning low-level areas of computer science.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
