<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Execution Flow of an Assembly Program | Sanketh’s Blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Execution Flow of an Assembly Program" />
<meta name="author" content="Sanketh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="High-level compiled languages like C, Go, and Rust are translated into low-level assembly language by their respective compilers. However, the journey of an assembly program doesn’t end there. Although developers typically write code in high-level languages, assembly language remains the go-to choice in specialized fields such as embedded systems, operating system kernels, firmware development, and other areas where performance is crucial. Unlike high-level languages, where much of the complexity is abstracted away, assembly language offers developers a detailed view of what happens under the hood. In this blog post, we will go through the complete lifecycle of an assembly program from writing and assembling the code to linking, loading, and finally executing it on the hardware." />
<meta property="og:description" content="High-level compiled languages like C, Go, and Rust are translated into low-level assembly language by their respective compilers. However, the journey of an assembly program doesn’t end there. Although developers typically write code in high-level languages, assembly language remains the go-to choice in specialized fields such as embedded systems, operating system kernels, firmware development, and other areas where performance is crucial. Unlike high-level languages, where much of the complexity is abstracted away, assembly language offers developers a detailed view of what happens under the hood. In this blog post, we will go through the complete lifecycle of an assembly program from writing and assembling the code to linking, loading, and finally executing it on the hardware." />
<link rel="canonical" href="http://localhost:4000/blog/assembly/execution-flow-of-an-assembly-program" />
<meta property="og:url" content="http://localhost:4000/blog/assembly/execution-flow-of-an-assembly-program" />
<meta property="og:site_name" content="Sanketh’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-17T01:30:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Execution Flow of an Assembly Program" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sanketh"},"dateModified":"2024-08-17T01:30:00+05:30","datePublished":"2024-08-17T01:30:00+05:30","description":"High-level compiled languages like C, Go, and Rust are translated into low-level assembly language by their respective compilers. However, the journey of an assembly program doesn’t end there. Although developers typically write code in high-level languages, assembly language remains the go-to choice in specialized fields such as embedded systems, operating system kernels, firmware development, and other areas where performance is crucial. Unlike high-level languages, where much of the complexity is abstracted away, assembly language offers developers a detailed view of what happens under the hood. In this blog post, we will go through the complete lifecycle of an assembly program from writing and assembling the code to linking, loading, and finally executing it on the hardware.","headline":"Execution Flow of an Assembly Program","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/assembly/execution-flow-of-an-assembly-program"},"url":"http://localhost:4000/blog/assembly/execution-flow-of-an-assembly-program"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Sanketh&apos;s Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Sanketh&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>

<link rel="stylesheet" href="/blog/assets/custom.css" />

<article class="post">
  <header class="post-header">
    <h1 class="post-title">Execution Flow of an Assembly Program</h1>
  </header>

  <div class="categories">
    
    <a
      href="/blog/categories/assembly"
      class="category-capsule"
      >assembly</a
    >
    
  </div>

  <div class="post-content"><p>High-level compiled languages like C, Go, and Rust are translated into low-level assembly language by their respective compilers. However, the journey of an assembly program doesn’t end there. Although developers typically write code in high-level languages, assembly language remains the go-to choice in specialized fields such as embedded systems, operating system kernels, firmware development, and other areas where performance is crucial. Unlike high-level languages, where much of the complexity is abstracted away, assembly language offers developers a detailed view of what happens under the hood. In this blog post, we will go through the complete lifecycle of an assembly program from writing and assembling the code to linking, loading, and finally executing it on the hardware.</p>

<div style="text-align: center;">
    <strong>Execution Flow of an Assembly Program: From Source Code to Execution</strong>
</div>
<p><br /></p>

<p><img src="/blog/assets/images/execution-flow-3.png" alt="Execution Cycle of an Assembly Program" height="800" /></p>

<h4 id="hello-world-program-in-mips-assembly">‘Hello World’ Program in MIPS Assembly</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.data
message: .asciiz "Hello, World!\n"

.text
.globl main

main:
    li $v0, 4         # syscall for printing a string
    la $a0, message   # load address of message into $a0
    syscall           # make syscall

    li $v0, 10        # syscall for exiting the program
    syscall           # make syscall
</code></pre></div></div>

<p>Breaking down the above program</p>

<p><strong>1. Data Segment</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.data
message: .asciiz "Hello, World!\n"
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.data:</code> This directive starts the data segment of the program. The data segment is where you define and store data that your program will use, such as strings, integers, etc.</li>
  <li><code class="language-plaintext highlighter-rouge">message:</code> This is a label that serves as a reference to the memory location where the string “Hello, World!\n” is stored. Labels are used to access data or instructions.</li>
  <li><code class="language-plaintext highlighter-rouge">.asciiz "Hello, World!\n":</code> This directive stores a null-terminated ASCII string in memory. The <code class="language-plaintext highlighter-rouge">\n</code> at the end of the string adds a newline character, which moves the cursor to the next line after printing the string.</li>
</ul>

<p><strong>2. Text Segment</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text
.globl main
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.text:</code> This directive starts the text segment of the program. The text segment is where the actual code (instructions) of the program is written.</li>
  <li><code class="language-plaintext highlighter-rouge">.globl main:</code> This directive declares the label main as a global symbol, meaning it can be accessed from outside the file (useful when linking multiple files). The label main is typically used as the entry point of the program, similar to the <code class="language-plaintext highlighter-rouge">main()</code> function in C.</li>
</ul>

<p><strong>3. Main Procedure</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
    li $v0, 4         # syscall for printing a string
    la $a0, message   # load address of message into $a0
    syscall           # make syscall
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">main:</code> This is a label marking the start of the main procedure.</li>
  <li><code class="language-plaintext highlighter-rouge">li $v0, 4:</code> The instruction li stands for “load immediate.” It’s a pseudo instruction that loads the immediate value 4 into register <code class="language-plaintext highlighter-rouge">$v0</code>. In MIPS, the value 4 in <code class="language-plaintext highlighter-rouge">$v0</code> indicates a system call for printing a string.</li>
  <li><code class="language-plaintext highlighter-rouge">la $a0, message:</code> The instruction la stands for “load address.” It loads the address of the label message into register <code class="language-plaintext highlighter-rouge">$a0</code>. In MIPS, the <code class="language-plaintext highlighter-rouge">$a0</code> register is used to pass the first argument to system calls, which in this case is the address of the string we want to print.</li>
  <li><code class="language-plaintext highlighter-rouge">syscall:</code> This instruction triggers a system call. The system call number (in <code class="language-plaintext highlighter-rouge">$v0</code>) and arguments (in <code class="language-plaintext highlighter-rouge">$a0</code>, <code class="language-plaintext highlighter-rouge">$a1</code>, etc.) tell the operating system what service to perform. Here, it prints the string pointed to by <code class="language-plaintext highlighter-rouge">$a0</code>.</li>
</ul>

<p><strong>4. Exit Program</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>li $v0, 10        # syscall for exiting the program
syscall           # make syscall
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">li $v0, 10:</code> This pseudo-instruction loads the immediate value 10 into register <code class="language-plaintext highlighter-rouge">$v0</code>. The value 10 is the system call code for terminating the program.</li>
  <li><code class="language-plaintext highlighter-rouge">syscall:</code> This makes a system call to exit the program.</li>
</ul>

<h2 id="components-involved-in-execution-of-a-program">Components Involved in Execution of a Program</h2>

<h3 id="1-compiler">1. Compiler</h3>

<p>A compiler is responsible for translating high-level source code written in languages like C, Go, or Rust into a lower-level language, typically assembly language. Beyond simple translation, a compiler performs several important tasks:</p>

<ul>
  <li><strong>Preprocessing:</strong> Handles directives like #include and #define, expanding macros and including header files.</li>
  <li><strong>Lexical Analysis:</strong> Converts the source code into tokens, which are the basic elements of the programming language (keywords, identifiers, symbols).</li>
  <li><strong>Parsing:</strong> Analyzes the tokens to ensure they adhere to the language’s grammar rules, constructing a syntax tree.</li>
  <li><strong>Semantic Analysis:</strong> Ensures that the syntax tree follows the semantic rules of the language, checking for type errors, scope resolution, and other logical aspects.</li>
  <li><strong>Intermediate Code Generation:</strong> Converts the syntax tree into an intermediate representation, which is easier to optimize and translate into machine code.</li>
  <li><strong>Code Optimization:</strong> Refines the intermediate code to improve performance and reduce resource usage, such as minimizing instruction count or memory usage.</li>
  <li><strong>Code Generation:</strong> Translates the optimized intermediate code into assembly code specific to the target CPU architecture (e.g., MIPS).</li>
</ul>

<h3 id="2-assembler">2. Assembler</h3>

<p>The assembler takes the assembly language code produced by the compiler and translates it into machine code (binary format) that the CPU can execute directly. During this process, the assembler converts symbolic labels into actual memory addresses and translates mnemonic instructions into binary opcodes.</p>
</div>

  
  <footer class="post-footer">
    <h2>References</h2>
    <ul>
      
      <li><a href="https://www.doc.ic.ac.uk/lab/secondyear/spim/node8.html" target="_blank">https://www.doc.ic.ac.uk/lab/secondyear/spim/node8.html</a></li>
      
    </ul>
  </footer>
  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Sanketh&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Sanketh B K</li><li><a class="u-email" href="mailto:sankethbk.1611@gmail.com">sankethbk.1611@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Sankethbk</span></a></li><li><a href="https://www.linkedin.com/in/sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">sankethbk</span></a></li><li><a href="https://www.twitter.com/Sankethbk"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">Sankethbk</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my blog! I have started this blog to document my journey of learning low-level areas of computer science.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
