<p>High-level compiled languages like C, Go, and Rust are translated into low-level assembly language by their respective compilers. However, the journey of an assembly program doesn’t end there. Although developers typically write code in high-level languages, assembly language remains the go-to choice in specialized fields such as embedded systems, operating system kernels, firmware development, and other areas where performance is crucial. Unlike high-level languages, where much of the complexity is abstracted away, assembly language offers developers a detailed view of what happens under the hood. In this blog post, we will go through the complete lifecycle of an assembly program from writing and assembling the code to linking, loading, and finally executing it on the hardware.</p>

<div style="text-align: center;">
    <strong>Execution Flow of an Assembly Program: From Source Code to Execution</strong>
</div>
<p><br /></p>

<p><img src="/blog/assets/images/execution-flow.png" alt="Execution Cycle of an Assembly Program" height="800" /></p>

<h4 id="hello-world-program-in-mips-assembly">‘Hello World’ Program in MIPS Assembly</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.data
message: .asciiz "Hello, World!\n"

.text
.globl main

main:
    li $v0, 4         # syscall for printing a string
    la $a0, message   # load address of message into $a0
    syscall           # make syscall

    li $v0, 10        # syscall for exiting the program
    syscall           # make syscall
</code></pre></div></div>

<p>Breaking down the above program</p>

<p><strong>1. Data Segment</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.data
message: .asciiz "Hello, World!\n"
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.data:</code> This directive starts the data segment of the program. The data segment is where you define and store data that your program will use, such as strings, integers, etc.</li>
  <li><code class="language-plaintext highlighter-rouge">message:</code> This is a label that serves as a reference to the memory location where the string “Hello, World!\n” is stored. Labels are used to access data or instructions.</li>
  <li><code class="language-plaintext highlighter-rouge">.asciiz "Hello, World!\n":</code> This directive stores a null-terminated ASCII string in memory. The <code class="language-plaintext highlighter-rouge">\n</code> at the end of the string adds a newline character, which moves the cursor to the next line after printing the string.</li>
</ul>

<p><strong>2. Text Segment</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text
.globl main
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.text:</code> This directive starts the text segment of the program. The text segment is where the actual code (instructions) of the program is written.</li>
  <li><code class="language-plaintext highlighter-rouge">.globl main:</code> This directive declares the label main as a global symbol, meaning it can be accessed from outside the file (useful when linking multiple files). The label main is typically used as the entry point of the program, similar to the <code class="language-plaintext highlighter-rouge">main()</code> function in C.</li>
</ul>

<p><strong>3. Main Procedure</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
    li $v0, 4         # syscall for printing a string
    la $a0, message   # load address of message into $a0
    syscall           # make syscall
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">main:</code> This is a label marking the start of the main procedure.</li>
  <li><code class="language-plaintext highlighter-rouge">li $v0, 4:</code> The instruction li stands for “load immediate.” It’s a pseudo instruction that loads the immediate value 4 into register <code class="language-plaintext highlighter-rouge">$v0</code>. In MIPS, the value 4 in <code class="language-plaintext highlighter-rouge">$v0</code> indicates a system call for printing a string.</li>
  <li><code class="language-plaintext highlighter-rouge">la $a0, message:</code> The instruction la stands for “load address.” It loads the address of the label message into register <code class="language-plaintext highlighter-rouge">$a0</code>. In MIPS, the <code class="language-plaintext highlighter-rouge">$a0</code> register is used to pass the first argument to system calls, which in this case is the address of the string we want to print.</li>
  <li><code class="language-plaintext highlighter-rouge">syscall:</code> This instruction triggers a system call. The system call number (in <code class="language-plaintext highlighter-rouge">$v0</code>) and arguments (in <code class="language-plaintext highlighter-rouge">$a0</code>, <code class="language-plaintext highlighter-rouge">$a1</code>, etc.) tell the operating system what service to perform. Here, it prints the string pointed to by <code class="language-plaintext highlighter-rouge">$a0</code>.</li>
</ul>

<p><strong>4. Exit Program</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>li $v0, 10        # syscall for exiting the program
syscall           # make syscall
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">li $v0, 10:</code> This pseudo-instruction loads the immediate value 10 into register <code class="language-plaintext highlighter-rouge">$v0</code>. The value 10 is the system call code for terminating the program.</li>
  <li><code class="language-plaintext highlighter-rouge">syscall:</code> This makes a system call to exit the program.</li>
</ul>

<h2 id="components-involved-in-execution-of-a-program">Components Involved in Execution of a Program</h2>

<h3 id="1-compiler">1. Compiler</h3>

<p>A compiler is responsible for translating high-level source code written in languages like C, Go, or Rust into a lower-level language, typically assembly language. Beyond simple translation, a compiler performs several important tasks:</p>

<ul>
  <li><strong>Preprocessing:</strong> Handles directives like #include and #define, expanding macros and including header files.</li>
  <li><strong>Lexical Analysis:</strong> Converts the source code into tokens, which are the basic elements of the programming language (keywords, identifiers, symbols).</li>
  <li><strong>Parsing:</strong> Analyzes the tokens to ensure they adhere to the language’s grammar rules, constructing a syntax tree.</li>
  <li><strong>Semantic Analysis:</strong> Ensures that the syntax tree follows the semantic rules of the language, checking for type errors, scope resolution, and other logical aspects.</li>
  <li><strong>Intermediate Code Generation:</strong> Converts the syntax tree into an intermediate representation, which is easier to optimize and translate into machine code.</li>
  <li><strong>Code Optimization:</strong> Refines the intermediate code to improve performance and reduce resource usage, such as minimizing instruction count or memory usage.</li>
  <li><strong>Code Generation:</strong> Translates the optimized intermediate code into assembly code specific to the target CPU architecture (e.g., MIPS).</li>
</ul>

<p>Let’s consider the hello world program in C</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Since I don’t have a CPU with MIPS architecture, I am using a cross compiler to convert C code to MIPS Assembly. The cross compiler I am using is mips-linux-gnu-gcc on Ubuntu. Other options include SPIM, MARS, QEMU, mips-none-elf-gcc, or websites like <a href="https://godbolt.org/">Godbolt</a>.</p>

<p>This is the MIPS Assembly generated from the above C code, using the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mips-linux-gnu-gcc -S hello_world.c -o hello_world.s
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.file	1 "hello.c"
	.section .mdebug.abi32
	.previous
	.nan	legacy
	.module	fp=xx
	.module	nooddspreg
	.module	arch=mips32r2
	.abicalls
	.text
	.rdata
	.align	2
$LC0:
	.ascii	"Hello, World!\000"
	.text
	.align	2
	.globl	main
	.set	nomips16
	.set	nomicromips
	.ent	main
	.type	main, @function
main:
	.frame	$fp,32,$31		# vars= 0, regs= 2/0, args= 16, gp= 8
	.mask	0xc0000000,-4
	.fmask	0x00000000,0
	.set	noreorder
	.set	nomacro
	addiu	$sp,$sp,-32
	sw	$31,28($sp)
	sw	$fp,24($sp)
	move	$fp,$sp
	lui	$28,%hi(__gnu_local_gp)
	addiu	$28,$28,%lo(__gnu_local_gp)
	.cprestore	16
	lui	$2,%hi($LC0)
	addiu	$4,$2,%lo($LC0)
	lw	$2,%call16(puts)($28)
	move	$25,$2
	.reloc	1f,R_MIPS_JALR,puts
1:	jalr	$25
	nop

	lw	$28,16($fp)
	move	$2,$0
	move	$sp,$fp
	lw	$31,28($sp)
	lw	$fp,24($sp)
	addiu	$sp,$sp,32
	jr	$31
	nop

	.set	macro
	.set	reorder
	.end	main
	.size	main, .-main
	.ident	"GCC: (Ubuntu 12.3.0-17ubuntu1) 12.3.0"
	.section	.note.GNU-stack,"",@progbits
</code></pre></div></div>

<p>Although this is lot of code just for printing the “hello world”, let’s look at the code directly responsible for printing hello world and decode it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$LC0:
    .ascii  "Hello, World!\000"
</code></pre></div></div>

<p>This section defines the string “Hello, World!” as a null-terminated string in the program’s data segment.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lui    $2, %hi($LC0)
addiu  $4, $2, %lo($LC0)
</code></pre></div></div>

<ul>
  <li>These two instructions load the address of the string “Hello, World!” into register <code class="language-plaintext highlighter-rouge">$4</code> (which is $a0), used as the first argument to the <code class="language-plaintext highlighter-rouge">puts</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">lui</code> (Load Upper Immediate) instruction is used to load a 16-bit immediate value into the upper 16 bits of a register. In this case, <code class="language-plaintext highlighter-rouge">$2</code> (which is $v0) is loaded with the upper 16 bits of the address of the string “Hello, World!”, labeled as <code class="language-plaintext highlighter-rouge">$LC0</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">%lo($LC0)</code> macro extracts the lower 16 bits of the address of <code class="language-plaintext highlighter-rouge">$LC0</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">addiu</code> (Add Immediate Unsigned) instruction adds an immediate value to a register and stores the result in another register. Here, it combines the upper 16 bits (already stored in <code class="language-plaintext highlighter-rouge">$2</code>) with the lower 16 bits of the address of <code class="language-plaintext highlighter-rouge">$LC0</code>.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lw     $2, %call16(puts)($28)
move   $25, $2
jalr   $25
nop
</code></pre></div></div>

<p>These instructions load the address of the <code class="language-plaintext highlighter-rouge">puts</code> function into register <code class="language-plaintext highlighter-rouge">$25</code>, then jump to this function using <code class="language-plaintext highlighter-rouge">jalr $25</code>, effectively calling <code class="language-plaintext highlighter-rouge">puts</code> to print the string.</p>

<h3 id="2-assembler">2. Assembler</h3>

<p>The assembler takes the assembly language code produced by the compiler and translates it into machine code (binary format) that the CPU can execute directly. During this process, the assembler converts symbolic labels into actual memory addresses and translates mnemonic instructions into binary opcodes.</p>
