<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Chess Engines on Sanketh's Blog</title><link>https://sankethbk.github.io/blog/categories/chess-engines/</link><description>Recent content in Chess Engines on Sanketh's Blog</description><generator>Hugo -- 0.155.0</generator><language>en-us</language><lastBuildDate>Thu, 29 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://sankethbk.github.io/blog/categories/chess-engines/index.xml" rel="self" type="application/rss+xml"/><item><title>Magic Bitboards and PEXT</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/</link><pubDate>Thu, 29 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/</guid><description>&lt;h1 id="magic-bitboards-and-pext"&gt;Magic Bitboards and PEXT&lt;/h1&gt;
&lt;h2 id="the-problem-sliding-piece-attacks"&gt;The Problem: Sliding Piece Attacks&lt;/h2&gt;
&lt;h3 id="why-sliding-pieces-are-hard"&gt;Why Sliding Pieces Are Hard&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Non-sliding pieces (knight, king, pawn):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fixed attack pattern regardless of board state&lt;/li&gt;
&lt;li&gt;Can pre-compute all attacks at startup&lt;/li&gt;
&lt;li&gt;Simple lookup: &lt;code&gt;StepAttacksBB[piece][square]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sliding pieces (rook, bishop, queen):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attack pattern depends on blocking pieces&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t pre-compute all possibilities (too many combinations)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="the-challenge"&gt;The Challenge&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Rook on e4 - different scenarios:
Scenario 1: Empty board
8 . . . . X . . .
7 . . . . X . . .
6 . . . . X . . .
5 . . . . X . . .
4 X X X X R X X X ← Attacks entire rank and file
3 . . . . X . . .
2 . . . . X . . .
1 . . . . X . . .
a b c d e f g h
Scenario 2: Blocked by pieces
8 . . . . . . . .
7 . . . . . . . .
6 . . . . X . . .
5 . . . . X . . .
4 . . X X R X . . ← Blocked at c4 and f4
3 . . . . X . . .
2 . . . . . . . .
1 . . . . . . . .
a b c d e f g h
(Pieces at: c4, e2, e6, f4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The question: How do we efficiently compute attacks for ANY occupancy pattern?&lt;/p&gt;</description></item><item><title>PSQT (Piece-Square Tables)</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-25-psqt/</link><pubDate>Sun, 25 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-25-psqt/</guid><description>&lt;h1 id="psqt-piece-square-tables"&gt;PSQT (Piece-Square Tables)&lt;/h1&gt;
&lt;h2 id="1-what-is-psqt"&gt;1. What is PSQT?&lt;/h2&gt;
&lt;p&gt;It is a traditional evaluation technique where every piece gets:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a base material value (pawn = 100, queen = 900…)&lt;/li&gt;
&lt;li&gt;plus a square bonus/penalty depending on where it stands&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example intuition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Knights are better in the center → bonus on d4/e4&lt;/li&gt;
&lt;li&gt;Pawns advanced are better → bonus on 6th/7th rank&lt;/li&gt;
&lt;li&gt;King is safer in corner early → penalty for being central in middlegame&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So evaluation includes:&lt;/p&gt;</description></item><item><title>Game Mechanics</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/</link><pubDate>Mon, 12 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/</guid><description>&lt;p&gt;We will go through some of the functions which are part of core game mechanics&lt;/p&gt;
&lt;h1 id="game-mechanics"&gt;Game Mechanics&lt;/h1&gt;
&lt;h2 id="1-piece-movement"&gt;1. Piece Movement&lt;/h2&gt;
&lt;h3 id="1-do_move"&gt;1. do_move&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Purpose&lt;/strong&gt;: Execute a move and update all position state incrementally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Critical for performance&lt;/strong&gt;: This function is called &lt;strong&gt;millions of times per second&lt;/strong&gt; during search. Every optimization matters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Preconditions&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Move &lt;code&gt;m&lt;/code&gt; must be &lt;strong&gt;legal&lt;/strong&gt; (pseudo-legal moves should be filtered first)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newSt&lt;/code&gt; must be a &lt;strong&gt;different&lt;/strong&gt; StateInfo object than current state&lt;/li&gt;
&lt;li&gt;Caller provides &lt;code&gt;givesCheck&lt;/code&gt; flag (optional optimization to avoid recalculating)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="function-structure-overview"&gt;Function Structure Overview&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Setup and assertions&lt;/li&gt;
&lt;li&gt;Copy old state → new state&lt;/li&gt;
&lt;li&gt;Increment counters&lt;/li&gt;
&lt;li&gt;Handle castling (special case)&lt;/li&gt;
&lt;li&gt;Handle captures&lt;/li&gt;
&lt;li&gt;Update position hash&lt;/li&gt;
&lt;li&gt;Reset en passant&lt;/li&gt;
&lt;li&gt;Update castling rights&lt;/li&gt;
&lt;li&gt;Move the piece&lt;/li&gt;
&lt;li&gt;Handle pawn moves (en passant, promotion)&lt;/li&gt;
&lt;li&gt;Update incremental scores&lt;/li&gt;
&lt;li&gt;Finalize state&lt;/li&gt;
&lt;li&gt;Flip side to move&lt;/li&gt;
&lt;li&gt;Compute check info&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// Position::do_move() makes a move, and saves all information necessary
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// to a StateInfo object. The move is assumed to be legal. Pseudo-legal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// moves should be filtered out before this function is called.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;::&lt;/span&gt;do_move(Move m, StateInfo&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; newSt, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; givesCheck) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(is_ok(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;nodes;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key k &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;key &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;side;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Copy some fields of the old state to our new StateInfo object except the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// ones which are going to be recalculated from scratch anyway and then switch
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// our state pointer to point to the new (ready to be updated) state.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;memcpy(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt, st, offsetof(StateInfo, key));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; newSt.previous &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Increment ply counters. In particular, rule50 will be reset to zero later on
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// in case of a capture or a pawn move.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;gamePly;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pliesFromNull;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color us &lt;span style="color:#f92672"&gt;=&lt;/span&gt; sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color them &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;us;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square from &lt;span style="color:#f92672"&gt;=&lt;/span&gt; from_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square to &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece pc &lt;span style="color:#f92672"&gt;=&lt;/span&gt; piece_on(from);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece captured &lt;span style="color:#f92672"&gt;=&lt;/span&gt; type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT &lt;span style="color:#f92672"&gt;?&lt;/span&gt; make_piece(them, PAWN) &lt;span style="color:#f92672"&gt;:&lt;/span&gt; piece_on(to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(color_of(pc) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; us);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(captured &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NO_PIECE &lt;span style="color:#f92672"&gt;||&lt;/span&gt; color_of(captured) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; CASTLING &lt;span style="color:#f92672"&gt;?&lt;/span&gt; them : us));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(type_of(captured) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; KING);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; CASTLING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(pc &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(us, KING));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(captured &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(us, ROOK));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square rfrom, rto;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; do_castling&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;true&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(us, from, to, rfrom, rto);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rto] &lt;span style="color:#f92672"&gt;-&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rfrom];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rfrom] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rto];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; captured &lt;span style="color:#f92672"&gt;=&lt;/span&gt; NO_PIECE;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (captured)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square capsq &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// If the captured piece is a pawn, update pawn hash key, otherwise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// update non-pawn material.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(captured) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; PAWN)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; capsq &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; pawn_push(us);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(pc &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(us, PAWN));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(to &lt;span style="color:#f92672"&gt;==&lt;/span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(relative_rank(us, to) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; RANK_6);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(piece_on(to) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NO_PIECE);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(piece_on(capsq) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(them, PAWN));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; board[capsq] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; NO_PIECE; &lt;span style="color:#75715e"&gt;// Not done by remove_piece()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][capsq];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;nonPawnMaterial[them] &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; PieceValue[MG][captured];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update board and piece lists
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; remove_piece(captured, capsq);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update material hash key and prefetch access to materialTable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][capsq];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][pieceCount[captured]];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; prefetch(thisThread&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialTable[st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialKey]);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update incremental scores
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][capsq];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Reset rule 50 counter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update hash key
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][from] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Reset en passant square
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; SQ_NONE)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;enpassant[file_of(st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare)];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare &lt;span style="color:#f92672"&gt;=&lt;/span&gt; SQ_NONE;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update castling rights if needed
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;castlingRights &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (castlingRightsMask[from] &lt;span style="color:#f92672"&gt;|&lt;/span&gt; castlingRightsMask[to]))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; cr &lt;span style="color:#f92672"&gt;=&lt;/span&gt; castlingRightsMask[from] &lt;span style="color:#f92672"&gt;|&lt;/span&gt; castlingRightsMask[to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;castling[st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;castlingRights &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; cr];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;castlingRights &lt;span style="color:#f92672"&gt;&amp;amp;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;cr;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Move the piece. The tricky Chess960 castling is handled earlier
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; CASTLING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; move_piece(pc, from, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// If the moving piece is a pawn do some special extra work
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(pc) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; PAWN)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Set en-passant square if the moved pawn can be captured
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; ( (&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(to) &lt;span style="color:#f92672"&gt;^&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(from)) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (attacks_from&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PAWN&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(to &lt;span style="color:#f92672"&gt;-&lt;/span&gt; pawn_push(us), us) &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pieces(them, PAWN)))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (from &lt;span style="color:#f92672"&gt;+&lt;/span&gt; to) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;enpassant[file_of(st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare)];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; PROMOTION)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece promotion &lt;span style="color:#f92672"&gt;=&lt;/span&gt; make_piece(us, promotion_type(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(relative_rank(us, to) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; RANK_8);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(type_of(promotion) &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; KNIGHT &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; type_of(promotion) &lt;span style="color:#f92672"&gt;&amp;lt;=&lt;/span&gt; QUEEN);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; remove_piece(pc, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; put_piece(promotion, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update hash keys
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[promotion][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[promotion][pieceCount[promotion]&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][pieceCount[pc]];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update incremental score
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[promotion][to] &lt;span style="color:#f92672"&gt;-&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update material
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;nonPawnMaterial[us] &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PieceValue[MG][promotion];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update pawn hash key and prefetch access to pawnsTable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][from] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; prefetch(thisThread&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnsTable[st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey]);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Reset rule 50 draw counter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update incremental scores
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to] &lt;span style="color:#f92672"&gt;-&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][from];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Set capture piece
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;capturedPiece &lt;span style="color:#f92672"&gt;=&lt;/span&gt; captured;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update the key with the final value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;key &lt;span style="color:#f92672"&gt;=&lt;/span&gt; k;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Calculate checkers bitboard (if move gives check)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;checkersBB &lt;span style="color:#f92672"&gt;=&lt;/span&gt; givesCheck &lt;span style="color:#f92672"&gt;?&lt;/span&gt; attackers_to(square&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;KING&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(them)) &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pieces(us) &lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sideToMove &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update king attacks used for fast check detection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; set_check_info(st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(pos_is_ok());
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="phase-1-sanity-checks-and-bookkeeping"&gt;Phase 1: Sanity checks and bookkeeping&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(is_ok(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;nodes;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Key k &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;key &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;side;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Ensures the move encoding is valid&lt;/li&gt;
&lt;li&gt;Ensures we don’t overwrite the current state&lt;/li&gt;
&lt;li&gt;Increments node counter (used for search statistics)&lt;/li&gt;
&lt;li&gt;Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="phase-2-stateinfo-chaining-undo-mechanism"&gt;Phase 2: StateInfo chaining (undo mechanism)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;memcpy(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt, st, offsetof(StateInfo, key));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;newSt.previous &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;st &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Copies all fields up to key&lt;/li&gt;
&lt;li&gt;Fields after key will be recomputed&lt;/li&gt;
&lt;li&gt;Links the new state to the previous one (stack-style undo)&lt;/li&gt;
&lt;li&gt;Advances the st pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="phase-3-ply-counters"&gt;Phase 3: Ply counters&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;gamePly;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pliesFromNull;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;gamePly: depth from game start&lt;/li&gt;
&lt;li&gt;rule50: increments unless reset later&lt;/li&gt;
&lt;li&gt;pliesFromNull: prevents consecutive null moves&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="phase-4-decode-move-and-involved-pieces"&gt;Phase 4: Decode move and involved pieces&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Color us &lt;span style="color:#f92672"&gt;=&lt;/span&gt; sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Color them &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;us;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Square from &lt;span style="color:#f92672"&gt;=&lt;/span&gt; from_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Square to &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Piece pc &lt;span style="color:#f92672"&gt;=&lt;/span&gt; piece_on(from);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Piece captured &lt;span style="color:#f92672"&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT &lt;span style="color:#f92672"&gt;?&lt;/span&gt; make_piece(them, PAWN) &lt;span style="color:#f92672"&gt;:&lt;/span&gt; piece_on(to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(color_of(pc) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; us);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(captured &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NO_PIECE &lt;span style="color:#f92672"&gt;||&lt;/span&gt; color_of(captured) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; CASTLING &lt;span style="color:#f92672"&gt;?&lt;/span&gt; them : us));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(type_of(captured) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; KING);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Determines moving side&lt;/li&gt;
&lt;li&gt;Determines source and destination squares&lt;/li&gt;
&lt;li&gt;Determines captured piece (special handling for en passant)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assertions ensure:&lt;/p&gt;</description></item><item><title>Zobrist Hashing</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/</link><pubDate>Sat, 10 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/</guid><description>&lt;h1 id="zobrist-hashing"&gt;Zobrist Hashing&lt;/h1&gt;
&lt;h2 id="what-problem-zobrist-hashing-solves"&gt;What problem Zobrist hashing solves&lt;/h2&gt;
&lt;p&gt;In a chess engine, we constantly need to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identify identical positions reached via different move orders&lt;/li&gt;
&lt;li&gt;Detect threefold repetition&lt;/li&gt;
&lt;li&gt;Cache evaluations in a transposition table (TT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Comparing full board state is too slow&lt;/li&gt;
&lt;li&gt;Copying board state is too expensive&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-core-idea"&gt;The Core Idea&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt; Convert a chess position into a single 64-bit number (the &amp;ldquo;hash&amp;rdquo; or &amp;ldquo;key&amp;rdquo;) that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Uniquely identifies the position (with very high probability)&lt;/li&gt;
&lt;li&gt;Can be incrementally updated when making moves&lt;/li&gt;
&lt;li&gt;Enables O(1) position comparison&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="what-a-zobrist-key-represents"&gt;What a Zobrist key represents&lt;/h2&gt;
&lt;p&gt;A Zobrist key is a 64-bit integer (Key in Stockfish) representing:&lt;/p&gt;</description></item><item><title>Representation of The Game State</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/</link><pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/</guid><description>&lt;h1 id="representation-of-the-game-state"&gt;Representation of The Game State&lt;/h1&gt;
&lt;h2 id="the-position-class"&gt;The Position Class&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Position&lt;/code&gt; class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Position&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;public&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;static&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; init();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position() &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;operator&lt;/span&gt;&lt;span style="color:#f92672"&gt;=&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// FEN string input/output
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; set(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;string&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; fenStr, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; isChess960, StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; si, Thread&lt;span style="color:#f92672"&gt;*&lt;/span&gt; th);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;string fen() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Position representation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(PieceType pt) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(PieceType pt1, PieceType pt2) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(Color c, PieceType pt) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(Color c, PieceType pt1, PieceType pt2) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece &lt;span style="color:#a6e22e"&gt;piece_on&lt;/span&gt;(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square &lt;span style="color:#a6e22e"&gt;ep_square&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;empty&lt;/span&gt;(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType Pt&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; count(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType Pt&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Square&lt;span style="color:#f92672"&gt;*&lt;/span&gt; squares(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType Pt&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; Square square(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Castling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;can_castle&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;can_castle&lt;/span&gt;(CastlingRight cr) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;castling_impeded&lt;/span&gt;(CastlingRight cr) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square &lt;span style="color:#a6e22e"&gt;castling_rook_square&lt;/span&gt;(CastlingRight cr) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Checking
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;checkers&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;discovered_check_candidates&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pinned_pieces&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;check_squares&lt;/span&gt;(PieceType pt) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Attacks to/from a given square
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;attackers_to&lt;/span&gt;(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;attackers_to&lt;/span&gt;(Square s, Bitboard occupied) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;attacks_from&lt;/span&gt;(Piece pc, Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; Bitboard attacks_from(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; Bitboard attacks_from(Square s, Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;slider_blockers&lt;/span&gt;(Bitboard sliders, Square s, Bitboard&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pinners) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Properties of moves
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;legal&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pseudo_legal&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;capture&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;capture_or_promotion&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;gives_check&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;advanced_pawn_push&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece &lt;span style="color:#a6e22e"&gt;moved_piece&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece &lt;span style="color:#a6e22e"&gt;captured_piece&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Piece specific
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pawn_passed&lt;/span&gt;(Color c, Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;opposite_bishops&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Doing and undoing moves
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;do_move&lt;/span&gt;(Move m, StateInfo&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; st, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; givesCheck);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;undo_move&lt;/span&gt;(Move m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;do_null_move&lt;/span&gt;(StateInfo&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;undo_null_move&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Static Exchange Evaluation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;see_ge&lt;/span&gt;(Move m, Value value) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Accessing hash keys
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;key&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;key_after&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;material_key&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;pawn_key&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Other properties of the position
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color &lt;span style="color:#a6e22e"&gt;side_to_move&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Phase &lt;span style="color:#a6e22e"&gt;game_phase&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;game_ply&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;is_chess960&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Thread&lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;this_thread&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint64_t&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;nodes_searched&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;is_draw&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rule50_count&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Score &lt;span style="color:#a6e22e"&gt;psq_score&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Value &lt;span style="color:#a6e22e"&gt;non_pawn_material&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Position consistency check, for debugging
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pos_is_ok&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; failedStep &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;nullptr&lt;/span&gt;) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;flip&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;private&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Initialization helpers (used while setting up a position)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; set_castling_right(Color c, Square rfrom);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;set_state&lt;/span&gt;(StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; si) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;set_check_info&lt;/span&gt;(StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; si) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Other helpers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;put_piece&lt;/span&gt;(Piece pc, Square s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;remove_piece&lt;/span&gt;(Piece pc, Square s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;move_piece&lt;/span&gt;(Piece pc, Square from, Square to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; Do&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; do_castling(Color us, Square from, Square&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; to, Square&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; rfrom, Square&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; rto);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Data members
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece board[SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard byTypeBB[PIECE_TYPE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard byColorBB[COLOR_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; pieceCount[PIECE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square pieceList[PIECE_NB][&lt;span style="color:#ae81ff"&gt;16&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; index[SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; castlingRightsMask[SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square castlingRookSquare[CASTLING_RIGHT_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard castlingPath[CASTLING_RIGHT_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint64_t&lt;/span&gt; nodes;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; gamePly;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Thread&lt;span style="color:#f92672"&gt;*&lt;/span&gt; thisThread;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; st;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; chess960;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="class-design-decisions"&gt;Class Design Decisions&lt;/h3&gt;
&lt;h4 id="1-non-copyable"&gt;1. Non-Copyable&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Position(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;operator&lt;/span&gt;&lt;span style="color:#f92672"&gt;=&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Cannot be copied (copy constructor and assignment deleted)&lt;/li&gt;
&lt;li&gt;Why? Positions are heavy objects with complex state&lt;/li&gt;
&lt;li&gt;Must be moved or passed by reference/pointer&lt;/li&gt;
&lt;li&gt;Prevents accidental expensive copies&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-default-constructor"&gt;2. Default Constructor&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Position() &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Creates uninitialized position&lt;/li&gt;
&lt;li&gt;Must call &lt;code&gt;set()&lt;/code&gt; to initialize with FEN string&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="core-data-members"&gt;Core Data Members&lt;/h3&gt;
&lt;h4 id="1-board-representation---mailbox"&gt;1. Board Representation - MailBox&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Piece board[SQUARE_NB]; &lt;span style="color:#75715e"&gt;// SQUARE_NB = 64
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Mailbox representation: Direct lookup &amp;ldquo;what piece is on square X?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;board[e4]&lt;/code&gt; → returns &lt;code&gt;W_KNIGHT&lt;/code&gt; or &lt;code&gt;NO_PIECE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Fast for: &amp;ldquo;piece_on(Square s)&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-bitboard-representation"&gt;2. Bitboard Representation&lt;/h4&gt;
&lt;p&gt;Technically we need 12 bitboards to represent the all the pieces on chessboard.&lt;/p&gt;</description></item><item><title>C++ Used in Stockfish</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/</link><pubDate>Mon, 05 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/</guid><description>&lt;h1 id="c-used-in-stockfish"&gt;C++ Used in Stockfish&lt;/h1&gt;
&lt;p&gt;Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.&lt;/p&gt;
&lt;h2 id="enums-as-core-types"&gt;Enums as Core Types&lt;/h2&gt;
&lt;p&gt;Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values.&lt;/p&gt;</description></item><item><title>Bitboard representation of Chess Board</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/</link><pubDate>Sun, 04 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/</guid><description>&lt;h2 id="bitboard-based-game-representation-in-stockfish"&gt;Bitboard-Based Game Representation in Stockfish&lt;/h2&gt;
&lt;p&gt;Stockfish represents the chessboard using &lt;strong&gt;bitboards&lt;/strong&gt;: 64-bit unsigned integers where each bit corresponds to a square on the board.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;uint64_t&lt;/span&gt; Bitboard;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Bit 0 (LSB) → &lt;strong&gt;A1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Bit 63 (MSB) → &lt;strong&gt;H8&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="piece-encoding"&gt;Piece Encoding&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;enum&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Piece&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; NO_PIECE,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; W_PAWN &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; B_PAWN &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;9&lt;/span&gt;, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; PIECE_NB &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="numeric-structure"&gt;Numeric Structure&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Piece&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Binary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;W_PAWN&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;W_KING&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B_PAWN&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B_KING&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Key observations:&lt;/p&gt;</description></item><item><title>History of Chess Engines</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-02-claude-shannons-paper/</link><pubDate>Fri, 02 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-02-claude-shannons-paper/</guid><description>&lt;h1 id="history-of-chess-engines"&gt;History of Chess Engines&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://vision.unipv.it/IA1/ProgrammingaComputerforPlayingChess.pdf"&gt;Programming a Computer for Playing Chess (1950) by Claude Shannon&lt;/a&gt; is the foundational paper of computer chess and one of the earliest works in artificial intelligence. Written at a time when programmable computers were still experimental, the paper does not attempt to build a chess program, but instead asks a deeper question: what would it even mean for a machine to play chess intelligently under severe computational limits? Shannon shows that perfect play is theoretically possible but practically impossible, and develops a principled framework based on approximate evaluation, game-tree search, selectivity, and bounded rationality. Nearly every major idea used in modern chess engines—minimax, heuristic evaluation, quiescence, selective search, opening books, randomness, and even learning—appears here in conceptual form. The paper remains important not as a historical curiosity, but because it correctly identifies the permanent constraints and core ideas that still govern strong chess-playing programs today.&lt;/p&gt;</description></item></channel></rss>