<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2024-08-16T19:34:21+05:30</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">Sanketh’s Blog</title><subtitle>Welcome to my blog! I have started this blog to document my journey of learning low-level areas of computer science.</subtitle><author><name>Sanketh B K</name></author><entry><title type="html">Representation of Negative Numbers in Hardware</title><link href="http://localhost:4000/blog/cpu/representation-of-negative-numbers" rel="alternate" type="text/html" title="Representation of Negative Numbers in Hardware" /><published>2024-07-21T20:51:00+05:30</published><updated>2024-07-21T20:51:00+05:30</updated><id>http://localhost:4000/blog/cpu/representation-of-negative-numbers</id><content type="html" xml:base="http://localhost:4000/blog/cpu/representation-of-negative-numbers"><![CDATA[<p>Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.</p>

<h2 id="characteristics-of-an-ideal-representation">Characteristics of an Ideal Representation</h2>

<ol>
  <li><strong>Simple Arithmetic Operations:</strong> The representation should simplify the implementation of basic arithmetic operations (addition, subtraction, multiplication, and division) without needing special handling for positive and negative numbers in electronic circuits.</li>
  <li><strong>Single Representation for Zero:</strong> There should be only one binary representation for zero to avoid ambiguity and simplify comparison operations.</li>
  <li><strong>Symmetry:</strong> The range of representable positive and negative numbers should be symmetric around zero, meaning that the total number of positive and negative values should be as close as possible if not the same.</li>
  <li><strong>Overflow Detection:</strong> The representation should allow for easy detection of overflow conditions during arithmetic operations.</li>
  <li><strong>Bitwise Consistency:</strong> The representation should be consistent with bitwise logical operations such as AND, OR, and NOT, ensuring that these operations work correctly without special cases for negative numbers.</li>
  <li><strong>Ease of Conversion:</strong> The method for converting between positive and negative representations should be simple and intuitive.</li>
  <li><strong>Sign Interpretation:</strong> The responsibility for interpreting whether an operand is positive or negative should lie with the compiler, not the CPU. This ensures that the CPU does not need to perform additional checks during instruction decode and execution phase.</li>
  <li><strong>Unambiguous Interpretation:</strong> The representation should ensure that arithmetic operations yield correct results whether a number starting with 1 is interpreted as a negative number or as a large unsigned positive number. For example, in C, <code class="language-plaintext highlighter-rouge">1001</code> can be interpreted as <code class="language-plaintext highlighter-rouge">-7</code> in signed integers and <code class="language-plaintext highlighter-rouge">9</code> in unsigned integers. Since the CPU does not inherently know whether a number is positive or negative, the arithmetic results should be consistent and correct under both interpretations.</li>
</ol>

<h2 id="common-methods-for-representing-negative-numbers">Common Methods for Representing Negative Numbers</h2>

<ol>
  <li>Sign and Magnitude</li>
  <li>One’s Complement</li>
  <li>Two’s Complement</li>
  <li>Excess-N (Offset Binary)</li>
</ol>

<h3 id="1-sign-and-magnitude">1. Sign and Magnitude</h3>

<p>The most common approach is using a reserved sign bit to indicate whether a binary number is positive or negative and the remaining bits represent the magnitude (absolute value) of the number. In sign and magnitude, the Most Signinificant Bit (MSB) is reserved as sign-bit. A <code class="language-plaintext highlighter-rouge">0</code> in the MSB indicates a positive number and <code class="language-plaintext highlighter-rouge">1</code> indicates negative number,</p>

<p><strong>Range of Representation</strong></p>

<p>For an n-bit number, the range of representable values is 
\(-(2^{(n-1)} - 1) \text{ to } 2^{(n-1)} - 1\)</p>

<p>If we consider a 4-bit system, these are all the possible representations</p>

<table>
  <thead>
    <tr>
      <th>Binary Representation</th>
      <th>Decimal Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1111</td>
      <td>-7</td>
    </tr>
    <tr>
      <td>1110</td>
      <td>-6</td>
    </tr>
    <tr>
      <td>1101</td>
      <td>-5</td>
    </tr>
    <tr>
      <td>1100</td>
      <td>-4</td>
    </tr>
    <tr>
      <td>1011</td>
      <td>-3</td>
    </tr>
    <tr>
      <td>1010</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>1001</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>-0</td>
    </tr>
    <tr>
      <td>0000</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0001</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0010</td>
      <td>2</td>
    </tr>
    <tr>
      <td>0011</td>
      <td>3</td>
    </tr>
    <tr>
      <td>0100</td>
      <td>4</td>
    </tr>
    <tr>
      <td>0101</td>
      <td>5</td>
    </tr>
    <tr>
      <td>0110</td>
      <td>6</td>
    </tr>
    <tr>
      <td>0111</td>
      <td>7</td>
    </tr>
  </tbody>
</table>

<p><strong>Pros</strong></p>

<ul>
  <li>Easy to understand and visualize since the sign and magnitude are separated.</li>
  <li>Converting from positive to negative is simple: just flip the MSB.</li>
</ul>

<p><strong>Cons</strong></p>

<ul>
  <li>
    <p><strong>Complex Arithmetic Operations:</strong> Addition and subtraction require special handling of the sign bit, making the implementation of these operations more complex in hardware. Adder circuits used for adding positive numbers cannot be used directly for operations involving mixed signs. For eg: <code class="language-plaintext highlighter-rouge">add 5 (-2)</code> will result in <code class="language-plaintext highlighter-rouge">-7</code> (<code class="language-plaintext highlighter-rouge">0101</code> + <code class="language-plaintext highlighter-rouge">1010</code> = <code class="language-plaintext highlighter-rouge">1111</code>) which is not correct.  To handle such cases correctly, the CPU must first check the most significant bit (MSB) of both operands to determine their signs. It must then use a separate circuit to handle subtraction. This will cause performance overhead as CPU can no longer just rely on opcode for determining the type of operation but also the sign of operands.</p>
  </li>
  <li>
    <p><strong>Dual Zero Representations:</strong> Sign and magnitude representation has two different representations for zero: positive zero (<code class="language-plaintext highlighter-rouge">0000</code>) and negative zero (<code class="language-plaintext highlighter-rouge">1000</code>). This redundancy complicates the design of comparison operations. For example, checking for zero requires additional logic to account for both representations, and ensuring consistent behavior across arithmetic operations becomes more challenging. Having two representations for zeros also introduces error in airthemtic operations.</p>
  </li>
  <li>
    <p><strong>Lack of Support for Unsigned Integers:</strong> In sign and magnitude representation, the most significant bit (MSB) is always reserved for the sign bit. This means the CPU relies on the MSB along with the opcode to determine the operation. As a result, we can’t have support for unsigned integers, because a large unsigned integer starting with <code class="language-plaintext highlighter-rouge">1</code> will be mistakenly interpreted as a negative number by the CPU. This limitation makes it difficult to handle a mix of signed and unsigned data in the same system efficiently.</p>
  </li>
</ul>

<h3 id="2-ones-complement">2. One’s Complement</h3>

<p>In One’s Complement system, positive numbers are represented the same way as in standard binary, while negative numbers are represented by inverting all the bits of the corresponding positive number (flipping all 0s to 1s and all 1s to 0s). For instance, in an 8-bit system, the number +5 is represented as <code class="language-plaintext highlighter-rouge">00000101</code>, and -5 is represented as <code class="language-plaintext highlighter-rouge">11111010</code>.</p>

<p><strong>Range of Representation</strong></p>

<p>For an n-bit number, the range of representable values is 
\(-(2^{(n-1)} - 1) \text{ to } 2^{(n-1)} - 1\)</p>

<table>
  <thead>
    <tr>
      <th>Binary Representation</th>
      <th>Decimal Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000</td>
      <td>-7</td>
    </tr>
    <tr>
      <td>1001</td>
      <td>-6</td>
    </tr>
    <tr>
      <td>1010</td>
      <td>-5</td>
    </tr>
    <tr>
      <td>1011</td>
      <td>-4</td>
    </tr>
    <tr>
      <td>1100</td>
      <td>-3</td>
    </tr>
    <tr>
      <td>1101</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>1110</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>1111</td>
      <td>-0</td>
    </tr>
    <tr>
      <td>0000</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0001</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0010</td>
      <td>2</td>
    </tr>
    <tr>
      <td>0011</td>
      <td>3</td>
    </tr>
    <tr>
      <td>0100</td>
      <td>4</td>
    </tr>
    <tr>
      <td>0101</td>
      <td>5</td>
    </tr>
    <tr>
      <td>0110</td>
      <td>6</td>
    </tr>
    <tr>
      <td>0111</td>
      <td>7</td>
    </tr>
  </tbody>
</table>

<p><strong>Adding 2 numbers</strong></p>

<p>Adding two values is straightforward. Simply align the values on the least significant bit and add, propagating any carry to the bit one position left. If the carry extends past the end of the word it is said to have “wrapped around”, a condition called an “end-around carry”. When this occurs, the bit must be added back in at the right-most bit. This phenomenon does not occur in two’s complement arithmetic. The value of MSB has no special significance to the CPU.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0111      7
+  1001     -6
=======   ====
 1|0000      1
      1
=======
   0001 
</code></pre></div></div>

<p><strong>Pros</strong></p>

<p>One’s complement solves some of the problems of sign and magnitude approach, they are</p>

<ul>
  <li><strong>Unified Adder Circuit:</strong> Unlike the sign and magnitude representation, the same adder circuit can be used for both positive and negative numbers in one’s complement. The primary modification needed is the addition of logic to handle end-around carry when an overflow occurs. This change is consistent across all cases, meaning there is no extra overhead for negative numbers specifically.</li>
  <li><strong>Theoretical Support for Unsigned Integers:</strong> Since the value of MSB has no special significance to CPU, it is theoretically possible to support unsigned integers. However, a genuine overflow can lead to incorrect results due to the wrap-around carry.</li>
</ul>

<p><strong>Cons</strong></p>

<p>One’s complement retains the issue of dual zero representations from the sign and magnitude approach. The reason one’s complement performs wrap-around carry is to compensate for the shift in one digit along the number line caused by the presence of negative zero. This introduces an additional step in arithmetic operations to handle this anomaly, slightly complicating the overall design.</p>

<h3 id="3-twos-complement">3. Two’s complement</h3>

<p>Two’s complement is the most widely used method for representing signed integers in binary systems. Two’s complement of a number is calculated by flipping the bits and adding <code class="language-plaintext highlighter-rouge">1</code> to the Least Significant Bit (LSB).</p>

<p><strong>Range of Representation</strong></p>

<p>For an n-bit number, the range of representable values is 
\(-2^{(n-1)} \text{ to } 2^{(n-1)} - 1\)</p>

<table>
  <thead>
    <tr>
      <th>Binary Representation</th>
      <th>Decimal Value (signed)</th>
      <th>Decimal Value (unsigned)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000</td>
      <td>-8</td>
      <td>8</td>
    </tr>
    <tr>
      <td>1001</td>
      <td>-7</td>
      <td>9</td>
    </tr>
    <tr>
      <td>1010</td>
      <td>-6</td>
      <td>10</td>
    </tr>
    <tr>
      <td>1011</td>
      <td>-5</td>
      <td>11</td>
    </tr>
    <tr>
      <td>1100</td>
      <td>-4</td>
      <td>12</td>
    </tr>
    <tr>
      <td>1101</td>
      <td>-3</td>
      <td>13</td>
    </tr>
    <tr>
      <td>1110</td>
      <td>-2</td>
      <td>14</td>
    </tr>
    <tr>
      <td>1111</td>
      <td>-1</td>
      <td>15</td>
    </tr>
    <tr>
      <td>0000</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0001</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0010</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>0011</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <td>0100</td>
      <td>4</td>
      <td>4</td>
    </tr>
    <tr>
      <td>0101</td>
      <td>5</td>
      <td>5</td>
    </tr>
    <tr>
      <td>0110</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <td>0111</td>
      <td>7</td>
      <td>7</td>
    </tr>
  </tbody>
</table>

<p><strong>Intuition Behind Two’s Complement</strong></p>

<p>In one’s complement approach we saw that whenever a negative number is involved in addition the result could generate a carry which we have to wrap around to get correct answer. The reason for this is whenever result falls on positive side of the number line it has to cross two zero’s. Because of this, the result will fall short by one number on the number line. Two’s complement solves this by adding <code class="language-plaintext highlighter-rouge">1</code> to the one’s complement of a number which effectively removes <code class="language-plaintext highlighter-rouge">-0</code> from the binary number line threby giving correct result.</p>

<p>Sum of any n-bit number and its one’s complement gives the highest possible number that can be represented by those n-bits. For eg:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0010 (2 in 4 bit system)
+1101 (1's complement of 2)
___________________________
 1111  (the highest number that we can represent with 4 bits)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">1111</code> is <code class="language-plaintext highlighter-rouge">-0</code> in one’s complement. Now what will happen if we try to add <code class="language-plaintext highlighter-rouge">1</code> more to the result. It will results in an overflow.</p>

<p>The result will be <code class="language-plaintext highlighter-rouge">10000</code> which is <code class="language-plaintext highlighter-rouge">0</code>. Because we ignore the overflow bit in two’s complement.</p>

<p>So the statement can be generalized as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Any n-bit number + its one's complement = max n-bit number
Any n-bit number + its one's complement + 1 = 0
</code></pre></div></div>

<p>Adding <code class="language-plaintext highlighter-rouge">1</code> to the one’s complement itself is called as two’s complement as it involves one more additional step to one’s complement. So the statement can also be written as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Any n-bit number + its two's complement = 0
</code></pre></div></div>

<p>The rationale behind two’s complement can be understood by comparing it with the unsigned binary interpretation:</p>

<p>Taking an 8-bit value a<sub>7</sub> a<sub>6</sub> a<sub>5</sub> a<sub>4</sub> a<sub>3</sub> a<sub>2</sub> a<sub>1</sub> a<sub>0</sub></p>

<p>The usual unsigned binary interpretation is:</p>

\[2^7 \cdot a_7 + 2^6 \cdot a_6 + 2^5 \cdot a_5 + 2^4 \cdot a_4 + 2^3 \cdot a_3 + 2^2 \cdot a_2 + 2^1 \cdot a_1 + 2^0 \cdot a_0\]

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11111111 = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255
</code></pre></div></div>

<p>In the two’s complement representation, all negative numbers have the MSB set to 1. To get the negative number represented by the two’s complement of a value, we need to multiply the MSB with -1. The formula for two’s complement is:</p>

\[-2^7 \cdot a_7 + 2^6 \cdot a_6 + 2^5 \cdot a_5 + 2^4 \cdot a_4 + 2^3 \cdot a_3 + 2^2 \cdot a_2 + 2^1 \cdot a_1 + 2^0 \cdot a_0\]

<p>For eg: negative number represented by <code class="language-plaintext highlighter-rouge">11111111</code> is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11111111 = -128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = -1
</code></pre></div></div>

<p>It’s important to note that while <code class="language-plaintext highlighter-rouge">11111111</code> represents <code class="language-plaintext highlighter-rouge">-1</code> in the signed two’s complement system, it can also be interpreted as <code class="language-plaintext highlighter-rouge">255</code> in unsigned integers, as the CPU does not enforce any restriction. The interpretation is determined by the compiler.</p>

<p><strong>Pros</strong></p>

<p>Two’s complement solves all the limitations from sign and magnitude and one’s complement representations:</p>

<ol>
  <li>
    <p><strong>Single Representation for Zero:</strong> In two’s complement, zero has only one unique representation. This eliminates the problem of having two distinct representations for zero, which was a limitation in the one’s complement system. By having a single, consistent zero, two’s complement simplifies arithmetic operations and avoids the issue of shifting results by one number.</p>
  </li>
  <li>
    <p><strong>Natural Support for Unsigned Integers:</strong> Since MSB has no special significance and there is no change in the process of addition (unlike wrap around carry in one’s complement). Two’s complement naturally enables support for unsigned integers.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">For</span> <span class="n">example</span> <span class="n">in</span> <span class="n">C</span>

 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                             <span class="mo">0010</span>
 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>                            <span class="o">+</span><span class="mi">1001</span>
 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="cm">/* result is 11 */</span>  <span class="o">==</span>  <span class="mi">1011</span>  

 <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                                      <span class="mo">0010</span>
 <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">;</span>                                    <span class="o">+</span><span class="mi">1001</span>
 <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="cm">/* result is -5 */</span>           <span class="o">==</span>  <span class="mi">1011</span>
</code></pre></div>    </div>

    <p>We can see that even though result is <code class="language-plaintext highlighter-rouge">1011</code> in both cases. Compiler interprets it as <code class="language-plaintext highlighter-rouge">11</code> in the first case and <code class="language-plaintext highlighter-rouge">-5</code> in the second case.</p>

    <p>In both cases, the binary result is <code class="language-plaintext highlighter-rouge">1011</code>. However, the interpretation differs based on whether the numbers are treated as unsigned or signed. The compiler interprets <code class="language-plaintext highlighter-rouge">1011</code> as <code class="language-plaintext highlighter-rouge">11</code> when dealing with unsigned integers and as <code class="language-plaintext highlighter-rouge">-5</code> for signed integers. This flexibility is possible because the CPU treats the binary numbers uniformly without needing special handling for the sign.</p>
  </li>
  <li>
    <p><strong>Sign Extension in Two’s Complement:</strong> Two’s complement numbers can be sign-extended to match the size of the storage medium while preserving their value. For example, consider the 4-bit representation <code class="language-plaintext highlighter-rouge">1110</code>, which corresponds to <code class="language-plaintext highlighter-rouge">-2</code>. To store this in a 32-bit register, we simply extend the MSB across the additional bits. The resulting 32-bit representation would be <code class="language-plaintext highlighter-rouge">1111 1111 1111 1111 1111 1111 1111 1110</code>. This extension ensures that the value <code class="language-plaintext highlighter-rouge">-2</code> is maintained accurately in arithmetic operations, regardless of the bit width of the register.</p>
  </li>
</ol>

<h3 id="3-excess-n-offset-binary-representation">3. Excess-N (Offset Binary) Representation</h3>

<p>In excess-N notation, a fixed value, called the bias or offset (N), is added to the actual integer value to form the encoded value. This approach shifts the range of representable numbers, ensuring that all encoded values are non-negative. The value of bias K is usually choosen as 2<sup>n-1</sup> so that the representation is symmetric around 0. For example, with a bias = 3, the number -3 would be represented as 0, 0 would be represented as 3 and 3 would be represented as 6 and so on.</p>

<p>This representation simplifies certain types of arithmetic operations and is particularly useful in applications such as floating-point arithmetic and digital signal processing. Excess-N encoding simplifies comparison and subtraction operations, as the encoded values can be compared directly without considering the sign. This representation is widely used in the exponent field of IEEE 754 floating-point numbers, where it helps manage the range of representable exponents efficiently.</p>

<table>
  <thead>
    <tr>
      <th>Binary Representation</th>
      <th>Decimal Value (Excess-8)</th>
      <th>Decimal Value (Unsigned)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0000</td>
      <td>-8</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0001</td>
      <td>-7</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0010</td>
      <td>-6</td>
      <td>2</td>
    </tr>
    <tr>
      <td>0011</td>
      <td>-5</td>
      <td>3</td>
    </tr>
    <tr>
      <td>0100</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <td>0101</td>
      <td>-3</td>
      <td>5</td>
    </tr>
    <tr>
      <td>0110</td>
      <td>-2</td>
      <td>6</td>
    </tr>
    <tr>
      <td>0111</td>
      <td>-1</td>
      <td>7</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>0</td>
      <td>8</td>
    </tr>
    <tr>
      <td>1001</td>
      <td>1</td>
      <td>9</td>
    </tr>
    <tr>
      <td>1010</td>
      <td>2</td>
      <td>10</td>
    </tr>
    <tr>
      <td>1011</td>
      <td>3</td>
      <td>11</td>
    </tr>
    <tr>
      <td>1100</td>
      <td>4</td>
      <td>12</td>
    </tr>
    <tr>
      <td>1101</td>
      <td>5</td>
      <td>13</td>
    </tr>
    <tr>
      <td>1110</td>
      <td>6</td>
      <td>14</td>
    </tr>
    <tr>
      <td>1111</td>
      <td>7</td>
      <td>15</td>
    </tr>
  </tbody>
</table>

<p><strong>Range of Representation</strong></p>

<p>For an n-bit number with bias as K, range of representation can be given by 
\(-k \text{ to } (2^n - 1) - k.\)</p>]]></content><author><name>Sanketh</name></author><category term="cpu" /><summary type="html"><![CDATA[Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.]]></summary></entry><entry><title type="html">Overview of MIPS Assembly</title><link href="http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly" rel="alternate" type="text/html" title="Overview of MIPS Assembly" /><published>2024-07-12T20:38:05+05:30</published><updated>2024-07-12T20:38:05+05:30</updated><id>http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly</id><content type="html" xml:base="http://localhost:4000/blog/cpu/assembly/overview-of-mips-assembly"><![CDATA[<p>MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.</p>

<h2 id="history">History</h2>

<p>The first MIPS processor, the R2000, was introduced. It implemented the MIPS I architecture, which was one of the earliest commercial RISC processors. There are multiple versions of MIPS: including MIPS I, II, III, IV, and V; as well as five releases of MIPS32/64. MIPS I had 32-bit architecture with basic instruction set and addressing modes. MIPS III introduced 64-bit architecture in 1991, increasing the address space and register width.</p>

<p>MIPS32 and MIPS64 are modern versions of the architecture, maintaining backward compatibility while introducing enhancements for modern computing needs. MicroMIPS is a compact version of the MIPS instruction set, designed for embedded systems with limited memory. MIPS processors are commonly used in embedded systems, such as routers, printers, and smart home devices, where their efficiency and performance are crucial. In the automotive industry, MIPS processors are employed in various control systems and infotainment systems, benefiting from their reliable and efficient processing capabilities. MIPS processors are increasingly found in IoT devices, providing the necessary computational power and energy efficiency for smart sensors, wearables, and other connected devices.</p>

<p>MIPS is built on RISC principles, which embrace simplicity and efficiency, making it an ideal choice for learning about CPU architecture in general. Some principles of RISC are:</p>

<ol>
  <li><strong>Simple Instructions:</strong> RISC architectures use a small, highly optimized set of instructions. Each instruction is designed to be simple and execute in a single clock cycle (under ideal conditions in a pipelined processor).</li>
  <li><strong>Load/Store Architecture:</strong> RISC separates memory access and data processing instructions. Only load and store instructions can access memory, while all other operations are performed on registers. This simplifies the instruction set and execution.</li>
  <li><strong>Fixed-Length Instructions:</strong> Instructions in RISC architectures are of uniform length, typically 32 bits. This uniformity simplifies instruction decoding and pipeline design.</li>
  <li><strong>Simple Addressing Modes:</strong> RISC architectures use a small number of simple addressing modes to keep instruction execution fast and efficient. Common addressing modes include register, immediate, and displacement.</li>
  <li><strong>Pipelining:</strong> RISC architectures are designed to efficiently support pipelining. Instructions are broken down into stages (fetch, decode, execute, memory access, write-back) that can be processed simultaneously for different instructions.</li>
</ol>

<h2 id="mips32-and-mips64">MIPS32 and MIPS64</h2>

<p>MIPS32 and MIPS64 are ISAs designed for 32-bit and 64-bit CPUs, respectively. The primary distinctions between modern MIPS32 and MIPS64 architectures are found in their register size, memory addressing capabilities, and support for larger data and address spaces. Unlike ARM and x86, both MIPS32 and MIPS64 utilize 32-bit-wide instructions, regardless of whether they are operating on 32-bit or 64-bit processors.</p>

<p>MIPS32 is designed for 32-bit applications, with 32-bit registers and a 32-bit address space suitable embedded systems, microcontrollers, and other applications where 32-bit processing capabilities are sufficient. MIPS64 extends the architecture to 64-bit, offering larger 64-bit registers and a 64-bit address space, suitable for high-performance computing and large-scale applications.</p>

<p>Softwares written for MIPS32 can often run on MIPS64 processors without modification due to their shared instruction set, facilitating a smooth transition to 64-bit computing, while the reverse is not possible. MIPS is very efficient ISA for compiler to target because in most cases it can be well predicted how much time a sequence of instructions will take.</p>

<h2 id="registers">Registers</h2>

<h3 id="general-purpose-registers">General Purpose Registers</h3>

<p>General Purpose registers are meant to be used by programmers and compilers for whatever operations required and has no special meaning to CPU. General-purpose registers are versatile storage locations within the CPU used for a wide range of tasks like holding intermediate data, operands and results of computations, and store temporary values during program execution. They are meant to be utilized by programmers and compilers as needed, without any special significance to the CPU itself.</p>

<p>MIPS has 32 general purpose registers (R0 - R31), 32 floating point registers (F0 - F31) that can hold either a 32-bit single-precision number or a 64-bit double-precision number. General Purpose Registers (GPRs) in MIPS architectures are used for storing immediate values, temporary data, function arguments, and return values. They also facilitate address calculation for memory operations and control flow in branching and jumping instructions.</p>

<p>In MIPS, most registers are truly general-purpose, meaning they can be used for any purpose. MIPS programmers adhere to agreed-upon guidelines specifying how registers should be utilized. For instance, the stack pointer <code class="language-plaintext highlighter-rouge">($sp)</code>, global pointer <code class="language-plaintext highlighter-rouge">($gp)</code>, and frame pointer <code class="language-plaintext highlighter-rouge">($fp)</code> are conventions rather than hardware-enforced roles, unlike in other Assembly languages like x86. The stack pointer is purely a software convention; no push instruction implicitly uses it. Using <code class="language-plaintext highlighter-rouge">$t0</code> instead of <code class="language-plaintext highlighter-rouge">$t3</code> as a temporary register isn’t inherently faster or better. However, there’s one notable exception: the <code class="language-plaintext highlighter-rouge">jal</code> instruction implicitly writes the return address to <code class="language-plaintext highlighter-rouge">$31</code> (the link register).</p>

<table>
  <thead>
    <tr>
      <th>Register</th>
      <th>Name</th>
      <th>Description</th>
      <th>Preserved Across Function Calls?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$0</td>
      <td>zero</td>
      <td>This register is hardwired to the value 0. It always returns 0 regardless of what is written to it.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$1</td>
      <td>at</td>
      <td>Reserved for the assembler. It is used for pseudo-instructions and not typically used by programmers.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$2-$3</td>
      <td>v0-v1</td>
      <td>Used to hold function return values.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$4-$7</td>
      <td>a0-a3</td>
      <td>Used to pass the first four arguments to functions.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$8-$15</td>
      <td>t0-t7</td>
      <td>Temporary registers used for holding intermediate values. They are not preserved across function calls.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$16-$23</td>
      <td>s0-s7</td>
      <td>Saved registers, which must be preserved across function calls. They are used to store values that should not be changed by a function.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$24-$25</td>
      <td>t8-t9</td>
      <td>More temporary registers, similar to t0-t7.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$26-$27</td>
      <td>k0-k1</td>
      <td>Reserved for the operating system kernel.</td>
      <td>No</td>
    </tr>
    <tr>
      <td>$28</td>
      <td>gp</td>
      <td>Global pointer, used to access static data.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$29</td>
      <td>sp</td>
      <td>Stack pointer, used to point to the top of the stack.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$30</td>
      <td>fp</td>
      <td>Frame pointer, used to manage stack frames in some calling conventions.</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>$31</td>
      <td>ra</td>
      <td>Return address, used to store the return address for function calls.</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>

<p>When we say that saved registers must be “preserved across function calls,” it means that the values in these registers should remain unchanged when a function (subroutine) returns to its caller. In other words, if a function uses these registers, it must ensure that any values stored in them before the function call are restored when the function completes. This is typically enforced through a process called “register saving” and “register restoring”. The callee function first identifies which registers it uses that need to be preserved across function calls. These are known as “callee-saved” or “non-volatile” registers. The callee then saves the values of these registers by pushing them onto the stack. After the callee subroutine completes its task, it pops the saved register values off the stack, restoring the registers to their original state before returning control to the caller.</p>

<h3 id="special-purpose-registers">Special Purpose Registers</h3>

<p>Special purpose register’s values are closely tied to the working of processor. For this purpose they may not be directly writeable by normal instructions like add, move, etc. Instead, some special registers in some processor architectures require special instructions to modify them. For instance, in many architectures, modifying the program counter necessitates instructions such as return from subroutine, jump, or branch. Similarly, condition code registers are typically updated exclusively through compare instructions, eg: CPSR register in ARM. This design ensures precise control over essential processor operations and status updates, safeguarding against unintended modifications that could disrupt program execution or system stability.</p>

<p>In MIPS architecture, several special registers play crucial roles in managing the CPU’s state, controlling operations, and handling exceptions. Here are the main special registers used in MIPS:</p>

<ul>
  <li><strong>Program Counter (PC):</strong> Holds the address of the next instruction to be executed.</li>
  <li><strong>Hi and Lo Registers:</strong> Store the results of multiplication and division operations. If the result of an operation involving 32-bit operands is more than 32-bits, MIPS processors store the lower 32 bits of the result in the Lo register and the upper 32 bits in the Hi register.</li>
  <li><strong>CP0:</strong> CP0 refers to the control processor, which handles various system control and status registers (CSRs) that are crucial for system operation and control.
    <ul>
      <li><strong>Status Register (SR):</strong> Controls the operating mode of the processor (user mode, kernel mode) and enables/disables interrupts.</li>
      <li><strong>Cause Register (Cause):</strong> Stores exception cause information.</li>
      <li><strong>EPC (Exception Program Counter):</strong> Holds the address of the instruction that caused an exception.</li>
      <li><strong>EntryHi and EntryLo Registers:</strong> Used for managing TLB (Translation Lookaside Buffer) entries.</li>
    </ul>
  </li>
</ul>

<h2 id="data-types-in-mips">Data Types in MIPS</h2>

<ol>
  <li><strong>Byte (8-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.byte</code> in MIPS assembly. Each byte consists of 8 bits.</li>
  <li><strong>Halfword (16-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.half</code> or <code class="language-plaintext highlighter-rouge">.hword</code> in MIPS assembly. Each halfword consists of 16 bits or 2 bytes.</li>
  <li><strong>Word (32-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.word</code> in MIPS assembly. Each word consists of 32 bits or 4 bytes. This is the default data type for many operations in MIPS32.</li>
  <li><strong>Doubleword (64-bit):</strong> Represented as <code class="language-plaintext highlighter-rouge">.dword</code> in MIPS assembly. Each doubleword consists of 64 bits or 8 bytes. This is especially relevant in MIPS64 architecture.</li>
  <li><strong>Float (32-bit floating-point):</strong> Represented as <code class="language-plaintext highlighter-rouge">.float</code> in MIPS assembly. This follows the IEEE 754 standard for single-precision floating-point numbers.</li>
  <li><strong>Double (64-bit floating-point):</strong> Represented as <code class="language-plaintext highlighter-rouge">.double</code> in MIPS assembly. This follows the IEEE 754 standard for double-precision floating-point numbers.</li>
</ol>

<h2 id="addressing-modes-in-mips">Addressing Modes in MIPS</h2>

<p>Addressing mode refers to the way in which the operand of an instruction is specified. Different addressing modes provide different ways to access operands, allowing for more flexible and efficient programming.</p>

<p>MIPS supports several addressing modes:</p>

<ol>
  <li><strong>Immediate Addressing:</strong> The operand is a constant value embedded within the instruction itself.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $t0, $t1, 5  # $t0 = $t1 + 5
</code></pre></div>    </div>
  </li>
  <li><strong>Register Direct Addressing:</strong> The operand is stored in a register.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add $t0, $t1, $t2  # $t0 = $t1 + $t2
</code></pre></div>    </div>
  </li>
  <li><strong>Register Indirect with Displacement</strong> The operand is a memory location and the address of that memory location is given by the sum of the register and a constant displacement encoded in the ins. This is commonly used for loading and storing the array elements.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lw $t0, 8($t1), $t0 = MEM[Rt1 + 8]
</code></pre></div>    </div>
  </li>
  <li><strong>PC-Relative Addressing:</strong> The operand’s address is the sum of the program counter (PC) and a constant displacement.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beq $t0, $t1, label  # branches to the label if the values in registers $t0 and $t1 are equal, with the address computed relative to the current value of the PC.
</code></pre></div>    </div>
  </li>
  <li><strong>Pseudo-Direct Addressing:</strong> Used in jump instructions where the target address is partially specified in the instruction and partially from the PC. To form the full 32-bit address, the 26-bit address from the instruction is combined with the upper 4 bits of the current program counter (PC). This is because, in a 32-bit address, the upper 4 bits are often the same for instructions within a relatively small range (within the same 256MB segment).
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>j target # jumps to an address formed by combining the upper bits of the current PC with the target address specified in the instruction.
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="memory-alignment-and-endianness">Memory Alignment and Endianness</h2>

<p>Memory alignment refers to the arrangement of data in memory according to specific boundaries. Proper memory alignment means that data is stored at memory addresses that are multiples of the data’s size. In MIPS, data must be properly aligned in memory to be accessed correctly. Attempting to access misaligned data in MIPS can lead to alignment exceptions, causing the program to crash or behave unpredictably. In contrast, x86 architecture is more flexible with memory alignment. While aligned data access is more efficient and generally recommended, x86 CPUs can handle misaligned data access without causing exceptions. The CPU might perform additional internal operations to handle the misaligned access, potentially resulting in a slight performance penalty compared to aligned accesses.</p>

<p><strong>Data Types and Alignment:</strong></p>

<ul>
  <li>1-byte (char): No alignment requirement.</li>
  <li>2-byte (short): Must be aligned to 2-byte boundaries. Eg: valid addresses are 0, 2, 4,..</li>
  <li>4-byte (int, float): Must be aligned to 4-byte boundaries. Eg: valid addresses are 0, 4, 8,..</li>
  <li>8-byte (double, long long): Must be aligned to 8-byte boundaries. Eg: valid addresses are 0, 8, 16,..</li>
</ul>

<p>MIPS instructions are 32 bits (4 bytes) long and must be word-aligned. This means that the address of any instruction must be a multiple of 4. For example, valid instruction addresses in MIPS could be 0, 4, 8, and so on.</p>

<p>The <code class="language-plaintext highlighter-rouge">.align</code> directive in the MIPS assembler is used to specify the alignment of data in memory. While the assembler does automatically align data to the proper boundaries, the <code class="language-plaintext highlighter-rouge">.align</code> directive gives programmers explicit control over alignment, which can be useful for various reasons:</p>

<p><strong>Endianness:</strong> When the data stored to be stored is more than 1 byte, the sequence of bytes forming the data can be stored in two possible orders in memory:</p>
<ol>
  <li><strong>Big-endian:</strong> The most significant byte (MSB) is stored at the lowest memory address.
Example: For a 32-bit integer 0x12345678, the byte order in memory would be:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Address:   0x00   0x01   0x02   0x03
Value:     0x12   0x34   0x56   0x78
</code></pre></div>    </div>
  </li>
  <li><strong>Little-endian:</strong>  The least significant byte (LSB) is stored at the lowest memory address.
Example: For a 32-bit integer 0x12345678, the byte order in memory would be:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Address:   0x00   0x01   0x02   0x03
Value:     0x78   0x56   0x34   0x12
</code></pre></div>    </div>
  </li>
</ol>

<p>Endianness affects how data is interpreted and exchanged between systems. If two systems with different endianness exchange data without proper handling, the data can be misinterpreted, leading to errors. Therefore, it is crucial to ensure that data is correctly converted between different endian formats when necessary.</p>

<p>Most modern personal computers, including those using x86 and x86-64 architectures, use little-endian format. MIPS processors can operate in both big-endian (BE) and little-endian (LE) modes. The Status register in CP0 has a bit called RE (Reverse Endian) which, when set, changes the endianness mode for user mode, such processors are called Bi-endian processors, some other examples for Bi-endian processors are ARM, PowerPC, Alpha, SPARC V9, etc.</p>

<h2 id="instruction-formats-in-mips">Instruction Formats in MIPS</h2>

<p>MIPS uses three main instruction formats: R-type, I-type, and J-type. Each format is designed to accommodate different types of instructions and their operands.</p>

<h3 id="1-r-type">1. R-type</h3>

<p>R-type instructions are used for operations that involve only registers, such as arithmetic and logical operations.</p>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-21</th>
      <th>20-16</th>
      <th>15-11</th>
      <th>10-6</th>
      <th>5-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>rs</td>
      <td>rt</td>
      <td>rd</td>
      <td>shamt</td>
      <td>funct</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code that specifies the operation to be performed.</li>
  <li><strong>rs: 5 bits</strong> - The first source register.</li>
  <li><strong>rt: 5 bits</strong> - The second source register.</li>
  <li><strong>rd: 5 bits</strong> - The destination register.</li>
  <li><strong>shamt: 5 bits</strong>- The shift amount (used in shift instructions).</li>
  <li><strong>funct: 6 bits</strong> - The function code that specifies the exact operation (used in conjunction with the opcode).</li>
</ul>

<p>Each of the register field is 5 bits as there are 32 (2<sup>5</sup>) registers.</p>

<p>Eg: <code class="language-plaintext highlighter-rouge">add $t1, $t2, $t3</code></p>

<h3 id="2-i-type">2. I-type</h3>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-21</th>
      <th>20-16</th>
      <th>15-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>rs</td>
      <td>rt</td>
      <td>immediate</td>
    </tr>
  </tbody>
</table>

<p>I-type instructions are used for operations that involve an immediate value (a constant), as well as for memory access and branches.</p>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code.</li>
  <li><strong>rs: 5 bits</strong> - The source register.</li>
  <li><strong>rt: 5 bits</strong> - The destination register (or another source register for branches).</li>
  <li><strong>Immediate: 16 bits</strong> - The immediate value, which can be a constant, address offset, or immediate operand.</li>
</ul>

<p>Eg:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $t1, $t2, 10    # $t1 = $t2 + 10
lw $t0, 4($t1)       # $t0 = Memory[$t1 + 4]
andi $t0, $t1, 0xFF  # $t0 = $t1 &amp; 0xFF
</code></pre></div></div>

<h3 id="3-j-type">3. J-type</h3>

<table>
  <thead>
    <tr>
      <th>31-26</th>
      <th>25-0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>opcode</td>
      <td>address</td>
    </tr>
  </tbody>
</table>

<p>J-type instructions are used for jump instructions that require a target address.</p>

<ul>
  <li><strong>Opcode: 6 bits</strong> - The operation code.</li>
  <li><strong>Address: 26 bits</strong> - The target address for the jump. This address is combined with the upper bits of the program counter (PC) to form the full jump address.</li>
</ul>

<p>In MIPS32, we observe that only 26 bits are used for the target address of jump instructions, even though the address space of MIPS32 spans 4GB (2<sup>32</sup>). Because all MIPS instructions are 32 bits wide, they are word-aligned. This word alignment means the last 2 bits of any instruction address are always 00. Thus, only 28 bits are effectively used to form the target address. To construct the full 32-bit address, the upper 4 bits of the current program counter (PC) — which is the address of the instruction following the jump — are combined with the 28-bit target address. This results in a maximum addressable jump distance of 256MB (2<sup>28</sup>).</p>

<p>However, within a 4GB address space, it’s possible that the target instruction may be farther away than this 256MB limit. Modern assemblers employ various strategies to address this limitation, some of which we will explore later.</p>

<h2 id="pros-and-cons-of-uniform-instruction-width-and-dedicated-opcode-spots-in-mips">Pros and Cons of Uniform Instruction Width and Dedicated Opcode Spots in MIPS</h2>

<h3 id="pros">Pros</h3>

<ol>
  <li>
    <p><strong>Simplicity in Instruction Fetching:</strong> With a uniform instruction width (32 bits) for an implementation that fetches a single instruction per cycle, a single aligned memory/cache access of the fixed size is guaranteed to provide one (and only one) instruction, so no buffering or shifting is required. There is also no concern about crossing a cache line or page boundary within a single instruction.</p>
  </li>
  <li>
    <p><strong>Predictable Instruction Fetching:</strong> With a uniform instruction width, the instruction pointer increments by a fixed amount (32 bits) for each instruction (except for control flow instructions like jumps and branches). This predictability allows the CPU to know the location of the next instruction early, reducing the need for partial decoding. It also simplifies the process of fetching and parsing multiple instructions per cycle, enhancing overall efficiency. (The need for partial decoding arises when the length of instructions varies. The CPU must determine the length of each instruction before it can identify where the next instruction begins. This requires the CPU to decode at least part of the current instruction to find out its length, a process known as partial decoding. This extra step can complicate the instruction fetching process and introduce additional overhead.)</p>
  </li>
  <li>
    <p><strong>Simplified Parsing and Early Register Reading:</strong> The uniform instruction format in MIPS enables straightforward parsing of instruction components, such as immediate values, opcodes, and register names. This is particularly beneficial for timing-critical tasks like parsing source register names. With fixed positions for these components, the CPU can begin reading register values immediately after fetching the instruction, even before fully determining the instruction type. This speculative register reading does not require special recovery if incorrect, although it consumes extra energy. In the MIPS R2000’s classic 5-stage pipeline, this approach allows register values to be read right after instruction fetch, providing ample time to compare values and resolve branches, thus avoiding stalls without needing branch prediction. Parsing out the opcode is slightly less timing-critical than parsing source register names, but extracting the opcode sooner accelerates the start of execution. Simple parsing of the destination register name facilitates dependency detection across instructions, particularly beneficial when executing multiple instructions per cycle.</p>
  </li>
  <li>
    <p><strong>Usage of Fewer Bits for Target Addresses:</strong> In uniform instruction sets, the alignment of instructions allows the use of fewer bits to specify target addresses. For example, in a 32-bit wide instruction set, the last 2 bits of any instruction address are always 0 due to word alignment. This means that only 30 bits are needed to represent the address instead of 32. This reduction in required bits can be exploited in certain ISAs, such as MIPS/MIPS16, to provide additional storage space for other purposes, like indicating a mode with smaller or variable-length instructions. This efficient use of addressing allows for more compact encoding of instructions and can enhance the flexibility of the instruction set by supporting different modes.</p>
  </li>
</ol>

<h2 id="cons">Cons</h2>

<ol>
  <li>
    <p><strong>Low Code Density:</strong> Uniform instruction width can lead to inefficient use of memory when instructions are shorter than the fixed width. For example, if you have a 32-bit instruction width but some instructions only require a few bits, the extra bits in each instruction are wasted. This can lead to larger code sizes and increased memory consumption.</p>
  </li>
  <li>
    <p><strong>Decreased Flexibility due to Implicit Operands:</strong> Strict uniform formatting tends to exclude the use of implicit operands, which are operands not explicitly specified in the instruction but implied by the operation. For instance, even though MIPS mostly avoids implicit operands, it still uses an implicit destination register for the link register (<code class="language-plaintext highlighter-rouge">$ra</code>), which stores the return address for function calls. (When a function call is made in MIPS, the jal (jump and link) instruction is used. This instruction not only jumps to the target function address but also implicitly stores the return address (the address of the instruction following the <code class="language-plaintext highlighter-rouge">jal</code>) in the link register <code class="language-plaintext highlighter-rouge">$ra</code> (which is register <code class="language-plaintext highlighter-rouge">$31</code>). This behavior is implicit in the sense that the <code class="language-plaintext highlighter-rouge">jal</code> instruction does not need to specify that the return address should be stored in <code class="language-plaintext highlighter-rouge">$ra</code>; it is automatically understood and handled by the instruction.)</p>
  </li>
  <li><strong>Cannot Handle Large Values of Immediate:</strong> Fixed-length instructions present challenges when dealing with large immediate values (constants embedded directly within instructions). In MIPS immediate values can be upto 16-bits within a single instruction. If a constant exceeds this 16-bit limit, additional steps are required to handle the larger value.
    <ol>
      <li><strong>Loading as Data:</strong> One method to handle large constants is to load them from memory. This approach involves:
        <ul>
          <li>An extra load instruction.</li>
          <li>Overhead associated with address calculation, register usage, address translation, and tag checking.</li>
        </ul>
      </li>
      <li><strong>Multiple Instructions:</strong> MIPS provides two instructions <code class="language-plaintext highlighter-rouge">lui</code> (load upper immediate) to load the upper 16 bits of a constant and <code class="language-plaintext highlighter-rouge">ori</code> (or immediate) which performs bitwise OR on lower 16 bits this effectively loading a 32-bit immediate. These instructions do not involve memory access. The 32-bit immediate value is constructed directly within the CPU using two instructions. This is faster and avoids the overhead of accessing memory. Using two instructions to handle a large immediate introduces more overhead compared to a single instruction. Modern processor designs can mitigate some of this overhead. For example, Intel’s macro-op fusion combines certain pairs of instructions at the front-end of the pipeline, effectively reducing the execution overhead.</li>
    </ol>
  </li>
  <li>
    <p><strong>Challenges in Extending the ISA:</strong> New features may require addition of new instructions to the ISA. Fixed-length instructions present a significant challenge when it comes to extending an instruction set. The number of distinct operations (opcodes) that can be represented is limited. For example, with a 6-bit opcode field (as in MIPS), there are only 64 possible opcodes. It also poses a challenge when we have to increase number of available registers as adding more registers requires more bits to encode the register addresses. To extend the instruction set without breaking compatibility, additional modes or instruction formats might be needed. This can complicate the CPU design and increase the complexity of the instruction decoder.</p>
  </li>
  <li><strong>Limited Address Bound for Branching Instructions:</strong> In MIPS, the jump instruction uses only 26 bits to specify the immediate target address. Due to memory alignment, the last 2 bits are always zero, effectively giving 28 bits for the target address. The upper 4 bits of the Program Counter (PC) are combined with these 28 bits to form a full 32-bit address, which limits the addressable range to 256 MB. Consequently, the assembly programmer or compiler must ensure that the target address of the jump instruction lies within this 256 MB boundary. If the target address exceeds this limit, other options must be employed, such as using the <code class="language-plaintext highlighter-rouge">jr</code> (jump to the address stored in register) instruction, which can specify a full 32-bit address by storing the address in a register. In some versions, the assembler will issue a warning if the target address of a <code class="language-plaintext highlighter-rouge">j</code> instruction exceeds the 256 MB bound. In other cases, the assembler might automatically replace the <code class="language-plaintext highlighter-rouge">j</code> instruction with a <code class="language-plaintext highlighter-rouge">jr</code> instruction to handle the full address space correctly.</li>
</ol>

<h2 id="coprocessors-in-mips">Coprocessors in MIPS</h2>

<p>MIPS is a modular architecture supporting up to four coprocessors (CP0/1/2/3). Coprocessors are specialized processing units that work alongside the main CPU to handle specific types of operations, such as floating-point arithmetic, system control, or other specialized tasks. MIPS typically defines up to four coprocessors, though not all are always implemented in every MIPS processor. These coprocessors are numbered CP0 through CP3.</p>

<ol>
  <li>
    <p><strong>Coprocessor 0 (CP0) - System Control Coprocessor:</strong> CP0 is responsible for managing system control functions, including exception handling, memory management, and processor status. It plays a critical role in configuring and controlling the behavior of the MIPS processor. CP0 contains a set of special-purpose registers used for various control tasks, such as the Status Register, Cause Register, EPC (Exception Program Counter), and TLB (Translation Lookaside Buffer) management registers.</p>
  </li>
  <li>
    <p><strong>Coprocessor 1 (CP1) - Floating-Point Unit (FPU)</strong>: CP1 is dedicated to handling floating-point arithmetic operations, such as addition, subtraction, multiplication, division, and square root operations on floating-point numbers. This offloads complex calculations from the main CPU, improving overall performance for tasks requiring floating-point computations. CP1 includes 32 floating-point registers (<code class="language-plaintext highlighter-rouge">$f0</code> to <code class="language-plaintext highlighter-rouge">$f31</code>), which are used to store floating-point operands and results. Additionally, CP1 contains the Floating-Point Control and Status Register (FCSR), which holds various status flags and control bits related to floating-point operations. The FCSR also contains the comparison bit, which is set by floating-point comparison instructions and can be used for conditional branching.</p>
  </li>
  <li>
    <p><strong>Coprocessor 2 and 3 (Optional):</strong> CP2 and CP3 are optional coprocessors that can be used for application-specific purposes, such as vector processing, digital signal processing (DSP), or other specialized tasks. For example, in the PlayStation video game console, CP2 is the Geometry Transformation Engine (GTE), which accelerates the processing of geometry in 3D computer graphics.</p>
  </li>
</ol>

<h2 id="overview-of-mips-instructions">Overview of MIPS Instructions</h2>

<h3 id="1-memory-access-instructions">1. Memory Access Instructions</h3>

<p>Memory access instructions in MIPS facilitate moving data between registers and memory, as well as between general purpose, floating-point (FP), or special registers. Most of the memory access instructions are I-type and use register indirect with displacement as addressing mode.</p>

<h4 id="1-load-family-of-instructions">1. Load Family of Instructions</h4>

<p>All of the load instructions in MIPS are I-type instructions, and they follow this general format:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD &lt;rt&gt;, offset(base)
</code></pre></div></div>

<ul>
  <li><strong>LOAD</strong> is the opcode for the specific load instruction (e.g., LB, LBU, LH, LHU, LW, LWU, LD, L.S, L.D).</li>
  <li><strong>&lt;rt&gt;</strong> is the target register where the data will be loaded.</li>
  <li><strong>offset</strong> is a 16-bit signed immediate value representing the displacement.</li>
  <li><strong>base</strong> is the base register whose contents are added to the offset to form the effective memory address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>LB</strong></td>
      <td>Load Byte</td>
      <td>Loads a byte from memory into a register, sign-extended.</td>
    </tr>
    <tr>
      <td><strong>LBU</strong></td>
      <td>Load Byte Unsigned</td>
      <td>Loads a byte from memory into a register, zero-extended.</td>
    </tr>
    <tr>
      <td><strong>LH</strong></td>
      <td>Load Halfword</td>
      <td>Loads a halfword from memory into a register, sign-extended.</td>
    </tr>
    <tr>
      <td><strong>LHU</strong></td>
      <td>Load Halfword Unsigned</td>
      <td>Loads a halfword from memory into a register, zero-extended.</td>
    </tr>
    <tr>
      <td><strong>LW</strong></td>
      <td>Load Word</td>
      <td>Loads a word from memory into a register.</td>
    </tr>
    <tr>
      <td><strong>LWU</strong></td>
      <td>Load Word Unsigned</td>
      <td>Loads a word from memory into a register, zero-extended (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>LD</strong></td>
      <td>Load Doubleword</td>
      <td>Loads a doubleword from memory into a register (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>L.S</strong></td>
      <td>Load Single Precision Float</td>
      <td>Loads a single precision floating-point value from memory into an FP register.</td>
    </tr>
    <tr>
      <td><strong>L.D</strong></td>
      <td>Load Double Precision Float</td>
      <td>Loads a double precision floating-point value from memory into an FP register.</td>
    </tr>
    <tr>
      <td><strong>LUI</strong></td>
      <td>Load Upper Immediate</td>
      <td>Loads a 16-bit immediate value into the upper 16 bits of a register, with the lower 16 bits set to zero. Unlike other load instructions, LUI does not interact with memory.</td>
    </tr>
  </tbody>
</table>

<h4 id="2-store-family-of-instructions">2. Store Family of Instructions</h4>

<p>The store family of instructions in MIPS transfers data from a register to a specified memory location. All of the store instructions in MIPS are I-type instructions, and they follow this general format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STORE &lt;rt&gt;, offset(base)
</code></pre></div></div>

<ul>
  <li><strong>STORE</strong> is the opcode for the specific store instruction (e.g., SB, SH, SW, SD, S.S, S.D).</li>
  <li><strong>&lt;rt&gt;</strong> is the source register whose data will be stored in memory.</li>
  <li><strong>offset</strong> is a 16-bit signed immediate value representing the displacement.</li>
  <li><strong>base</strong> is the base register whose contents are added to the offset to form the effective memory address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>SB</strong></td>
      <td>Store Byte</td>
      <td>Stores a byte from a register into memory.</td>
    </tr>
    <tr>
      <td><strong>SH</strong></td>
      <td>Store Halfword</td>
      <td>Stores a halfword from a register into memory.</td>
    </tr>
    <tr>
      <td><strong>SW</strong></td>
      <td>Store Word</td>
      <td>Stores a word from a register into memory.</td>
    </tr>
    <tr>
      <td><strong>SD</strong></td>
      <td>Store Doubleword</td>
      <td>Stores a doubleword from a register into memory (MIPS64).</td>
    </tr>
    <tr>
      <td><strong>S.S</strong></td>
      <td>Store Single Precision Float</td>
      <td>Stores a single precision floating-point value from an FP register into memory.</td>
    </tr>
    <tr>
      <td><strong>S.D</strong></td>
      <td>Store Double Precision Float</td>
      <td>Stores a double precision floating-point value from an FP register into memory.</td>
    </tr>
  </tbody>
</table>

<h4 id="3-register-data-transfer-instructions">3. Register Data Transfer Instructions</h4>

<p>These instructions facilitate the transfer of data between different types of registers, such as general-purpose registers (GPRs), floating-point registers (FPRs), and special-purpose registers. These instructions are critical in operations where data needs to be moved from one part of the CPU to another, enabling interaction between different processing units.</p>

<p>These instructions facilitate the transfer of data between two general-purpose registers.</p>

<ul>
  <li><strong>MFHI:</strong> Move From HI register. Transfers the content from the HI special register to a GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFHI $d  # $d = HI
</code></pre></div>    </div>
  </li>
  <li><strong>MFLO:</strong> Move From LO register. Transfers the content from the LO special register to a GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFLO $d  # $d = LO
</code></pre></div>    </div>
  </li>
  <li><strong>MOV.S:</strong> Move single-precision floating-point value.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOV.S $f1, $f2  # $f1 = $f2
</code></pre></div>    </div>
  </li>
  <li><strong>MOV.D:</strong> Move double-precision floating-point value.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOV.D $f1, $f2  # $f1 = $f2
</code></pre></div>    </div>
  </li>
  <li><strong>MFC0 (Move From Coprocessor 0):</strong> This instruction moves data from a specific CP0 register to a general-purpose register (GPR). It’s often used to read system control information, such as the contents of the status register, exception handling registers, or memory management configuration.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFC0 $t, $c0_reg, $sel
</code></pre></div>    </div>
  </li>
  <li>$t: The destination general-purpose register.</li>
  <li>$c0_reg: The CP0 register number.</li>
  <li>$sel: The select field, which allows accessing different parts or subsets of the CP0 register.
Example:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFC0 $t0, $12  # Move the contents of CP0 Status register (register 12) to $t0
</code></pre></div>    </div>
  </li>
  <li><strong>MTC0 (Move To Coprocessor 0):</strong> This instruction moves data from a general-purpose register (GPR) to a specific CP0 register.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MTC0 $t0, $13  # Move the contents of $t0 into CP0 Cause register (register 13)
</code></pre></div>    </div>
  </li>
  <li><strong>MFC1:</strong>  Move From Coprocessor 1 (FPR) to GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MFC1 $t, $f  # $t = $f
</code></pre></div>    </div>
  </li>
  <li><strong>MTC1:</strong> Move To Coprocessor 1 (FPR) from GPR.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MTC1 $f, $t  # $f = $t
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="2-arithmetic-instructions-integers">2. Arithmetic instructions (Integers)</h3>

<p>Arithmetic instructions in MIPS perform basic mathematical operations such as addition, subtraction, multiplication, and division. These instructions operate on values stored in general-purpose registers (GPRs) and often involve signed and unsigned integers.</p>

<p>Majority of arithmetic instructions are R-type, they follow this general format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ARITHMETIC $rd, $rs, $rt
</code></pre></div></div>
<ul>
  <li><strong>ARITHMETIC</strong> is the opcode for the specific arithmetic instruction (e.g., ADD, ADDU, SUB, MULT).</li>
  <li><strong>$rd</strong> is the destination register where the result of the operation will be stored.</li>
  <li><strong>$rs</strong> is the source register containing the first operand.</li>
  <li><strong>$rt</strong> is the source register containing the second operand.</li>
</ul>

<p>(Note: The storage format for R-type instructions is <code class="language-plaintext highlighter-rouge">&lt;opcode&gt; &lt;rs&gt; &lt;rt&gt; &lt;rd&gt; &lt;shamt&gt; &lt;funct&gt;</code>. However, when writing the instruction in assembly language, it is written as <code class="language-plaintext highlighter-rouge">&lt;opcode&gt; $rd, $rs, $rt.</code>)</p>

<p>Immediate operations follow I-type, the format is slightly different:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ARITHMETIC_IMM $rt, $rs, immediate
</code></pre></div></div>

<ul>
  <li><strong>ARITHMETIC_IMM</strong> is the opcode for the specific arithmetic instruction that uses an immediate value (e.g., ADDI, ADDIU).</li>
  <li><strong>$rt</strong> is the destination register where the result will be stored.</li>
  <li><strong>$rs</strong> is the source register containing the first operand.</li>
  <li><strong>immediate</strong> is a 16-bit signed value that is added to the contents of <code class="language-plaintext highlighter-rouge">$rs</code>.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>ADD</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADD $rd, $rs, $rt</code></td>
      <td>Adds the contents of <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>. Raises an exception on overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADD $t0, $t1, $t2  # $t0 = $t1 + $t2</code></td>
    </tr>
    <tr>
      <td><strong>ADDU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADDU $rd, $rs, $rt</code></td>
      <td>Adds the contents of <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code> without checking for overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADDU $t0, $t1, $t2  # $t0 = $t1 + $t2 (no overflow check)</code></td>
    </tr>
    <tr>
      <td><strong>ADDI</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADDI $rt, $rs, immediate</code></td>
      <td>Adds an immediate value to <code class="language-plaintext highlighter-rouge">$rs</code>, stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>. Raises an exception on overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADDI $t0, $t1, 10  # $t0 = $t1 + 10</code></td>
    </tr>
    <tr>
      <td><strong>ADDIU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ADDIU $rt, $rs, immediate</code></td>
      <td>Adds an immediate value to <code class="language-plaintext highlighter-rouge">$rs</code> without checking for overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">ADDIU $t0, $t1, 10  # $t0 = $t1 + 10 (no overflow check)</code></td>
    </tr>
    <tr>
      <td><strong>SUB</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SUB $rd, $rs, $rt</code></td>
      <td>Subtracts <code class="language-plaintext highlighter-rouge">$rt</code> from <code class="language-plaintext highlighter-rouge">$rs</code>, stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>. Raises an exception on overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">SUB $t0, $t1, $t2  # $t0 = $t1 - $t2</code></td>
    </tr>
    <tr>
      <td><strong>SUBU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SUBU $rd, $rs, $rt</code></td>
      <td>Subtracts <code class="language-plaintext highlighter-rouge">$rt</code> from <code class="language-plaintext highlighter-rouge">$rs</code> without checking for overflow.</td>
      <td><code class="language-plaintext highlighter-rouge">SUBU $t0, $t1, $t2  # $t0 = $t1 - $t2 (no overflow check)</code></td>
    </tr>
    <tr>
      <td><strong>MULT</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MULT $rs, $rt</code></td>
      <td>Multiplies <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, result stored in <code class="language-plaintext highlighter-rouge">HI</code> and <code class="language-plaintext highlighter-rouge">LO</code> registers.</td>
      <td><code class="language-plaintext highlighter-rouge">MULT $t1, $t2  # Result in HI:LO = $t1 * $t2</code></td>
    </tr>
    <tr>
      <td><strong>MULTU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MULTU $rs, $rt</code></td>
      <td>Multiplies unsigned integers <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, result stored in <code class="language-plaintext highlighter-rouge">HI</code> and <code class="language-plaintext highlighter-rouge">LO</code> registers.</td>
      <td><code class="language-plaintext highlighter-rouge">MULTU $t1, $t2  # Unsigned result in HI:LO</code></td>
    </tr>
    <tr>
      <td><strong>DIV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DIV $rs, $rt</code></td>
      <td>Divides <code class="language-plaintext highlighter-rouge">$rs</code> by <code class="language-plaintext highlighter-rouge">$rt</code>, quotient stored in <code class="language-plaintext highlighter-rouge">LO</code>, remainder in <code class="language-plaintext highlighter-rouge">HI</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">DIV $t1, $t2  # LO = $t1 / $t2; HI = $t1 % $t2</code></td>
    </tr>
    <tr>
      <td><strong>DIVU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">DIVU $rs, $rt</code></td>
      <td>Divides unsigned integers <code class="language-plaintext highlighter-rouge">$rs</code> by <code class="language-plaintext highlighter-rouge">$rt</code>, quotient stored in <code class="language-plaintext highlighter-rouge">LO</code>, remainder in <code class="language-plaintext highlighter-rouge">HI</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">DIVU $t1, $t2  # Unsigned LO = $t1 / $t2; HI = $t1 % $t2</code></td>
    </tr>
  </tbody>
</table>

<p>The above instructions are for MIPS32. MIPS64 has similar instructions with a prefix letter “D” added to each instruction. The “D” indicates “Doubleword,” e.g., DADD, DADDI, DADDU, DADDIU.</p>

<h3 id="3-logical-instructions-integers">3. Logical instructions (Integers)</h3>

<p>Logical instructions in MIPS are used to perform bitwise operations on the binary representations of data stored in registers.</p>

<p>Logical Instructions follow the R-type format. In this format, the instructions operate on registers and involve three operands: two source registers and one destination register.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOGICAL $rd, $rs, $rt
</code></pre></div></div>
<ul>
  <li><strong>LOGICAL:</strong> is the opcode for logical instruction (e.g., AND, OR, XOR, NOR)</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rs</strong> and <strong>$rt</strong> are the source registers.</li>
</ul>

<p>Some instructions have immediate variants as well, which follow the I-type format.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOGICAL_IMM $rd, $rs, $rt
</code></pre></div></div>

<ul>
  <li><strong>LOGICAL_IMM:</strong> is the opcode for logical instruction (e.g., ANDI, ORI, XORI)</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rs</strong> and <strong>$rt</strong> are the source registers.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>AND</strong></td>
      <td>Bitwise AND</td>
      <td>Performs a bitwise AND operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>OR</strong></td>
      <td>Bitwise OR</td>
      <td>Performs a bitwise OR operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>XOR</strong></td>
      <td>Bitwise XOR</td>
      <td>Performs a bitwise XOR operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>NOR</strong></td>
      <td>Bitwise NOR</td>
      <td>Performs a bitwise NOR operation between the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code>, and stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
    </tr>
    <tr>
      <td><strong>ANDI</strong></td>
      <td>Bitwise AND Immediate</td>
      <td>Performs a bitwise AND operation between the value in <code class="language-plaintext highlighter-rouge">$rs</code> and an immediate value, and stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
    </tr>
    <tr>
      <td><strong>ORI</strong></td>
      <td>Bitwise OR Immediate</td>
      <td>Performs a bitwise OR operation between the value in <code class="language-plaintext highlighter-rouge">$rs</code> and an immediate value, and stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
    </tr>
    <tr>
      <td><strong>XORI</strong></td>
      <td>Bitwise XOR Immediate</td>
      <td>Performs a bitwise XOR operation between the value in <code class="language-plaintext highlighter-rouge">$rs</code> and an immediate value, and stores the result in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
    </tr>
  </tbody>
</table>

<h3 id="4-shift-instructions">4. Shift Instructions</h3>

<p>Shift instructions in MIPS perform bitwise shifts on operands stored in registers. Shift instructions are all R-type and follow this general format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHIFT $rd, $rt, shamt 
</code></pre></div></div>

<ul>
  <li><strong>SHIFT</strong> is the opcode for the specific variable shift instruction (e.g., SLL, SRL, SRA).</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rt</strong> is the source register that contains the value to be shifted.</li>
  <li><strong>shamt</strong> (shift amount) is the number of bit positions to shift the value in <code class="language-plaintext highlighter-rouge">$rt</code>.</li>
</ul>

<p>Another type of shift instruction follows this format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SHIFT $rd, $rt, $rs
</code></pre></div></div>

<ul>
  <li><strong>SHIFT</strong> is the opcode for the specific variable shift instruction (e.g., SLLV, SRLV, SRAV).</li>
  <li><strong>$rd</strong> is the destination register.</li>
  <li><strong>$rt</strong> is the source register that contains the value to be shifted.</li>
  <li><strong>$rs</strong> is the register that specifies the shift amount.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction</th>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>SLL</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLL $rd, $rt, shamt</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> left by <code class="language-plaintext highlighter-rouge">shamt</code> bits, stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLL $t0, $t1, 2 # $t0 = $t1 &lt;&lt; 2</code></td>
    </tr>
    <tr>
      <td><strong>SRL</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRL $rd, $rt, shamt</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> right by <code class="language-plaintext highlighter-rouge">shamt</code> bits (logical), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>. It does not preserve the sign bit (MSB). It treats the value as an unsigned number, so the MSB is replaced with a zero.</td>
      <td><code class="language-plaintext highlighter-rouge">SRL $t0, $t1, 2 # $t0 = $t1 &gt;&gt; 2</code></td>
    </tr>
    <tr>
      <td><strong>SRA</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRA $rd, $rt, shamt</code></td>
      <td>Shifts the contents of $rt right by shamt bits (arithmetic) and stores the result in $rd. It preserves the sign bit (MSB), meaning the sign bit remains unchanged during the shift operation.</td>
      <td><code class="language-plaintext highlighter-rouge">SRA $t0, $t1, 2 # $t0 = $t1 &gt;&gt; 2</code></td>
    </tr>
    <tr>
      <td><strong>SLLV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLLV $rd, $rt, $rs</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> left by the value in <code class="language-plaintext highlighter-rouge">$rs</code> (variable shift), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLLV $t0, $t1, $t2 # $t0 = $t1 &lt;&lt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SRLV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRLV $rd, $rt, $rs</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> right by the value in <code class="language-plaintext highlighter-rouge">$rs</code> (logical, variable shift), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SRLV $t0, $t1, $t2 # $t0 = $t1 &gt;&gt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SRAV</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SRAV $rd, $rt, $rs</code></td>
      <td>Shifts the contents of <code class="language-plaintext highlighter-rouge">$rt</code> right by the value in <code class="language-plaintext highlighter-rouge">$rs</code> (arithmetic, variable shift), stores the result in <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SRAV $t0, $t1, $t2 # $t0 = $t1 &gt;&gt; $t2</code></td>
    </tr>
  </tbody>
</table>

<p>In a left shift operation, the sign bit (MSB) is treated like any other bit. The intuition behind a logical left shift is that each shift operation corresponds to multiplication by 2. For example: <code class="language-plaintext highlighter-rouge">0000 1111 &lt;&lt; 1 = 0001 1110</code>, which is 15 * 2 = 30.</p>

<p>Similarly, a logical right shift corresponds to division by 2. For example: <code class="language-plaintext highlighter-rouge">0001 1110 &gt;&gt; 1 = 0000 1111</code>, which is 30 / 2 = 15. However, when applying logical right shift to negative numbers (in two’s complement representation), such as <code class="language-plaintext highlighter-rouge">1110 0010</code> (which represents -30), performing a logical right shift results in <code class="language-plaintext highlighter-rouge">0111 0001</code> (113), which is not intuitive. In contrast, applying an arithmetic right shift, which preserves the sign bit, results in <code class="language-plaintext highlighter-rouge">1111 0001</code> (-15), which is more intuitive and useful.</p>

<h3 id="5-comparision-instruction">5. Comparision Instruction</h3>

<p>These instructions compare the values in registers (or between a register and an immediate value) and set the destination register based on whether the condition is met.</p>

<p>Comparision instructions follow the R-type format, they follow this general format:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COMPARISION $rd, $rs, $rt
</code></pre></div></div>
<ul>
  <li><strong>COMPARISION:</strong> is the opcode for logical instruction (e.g., SLT, SLTU)</li>
  <li><strong>$rd:</strong> Destination register where the result (1 or 0) will be stored.</li>
  <li><strong>$rs:</strong> First source register.</li>
  <li><strong>$rt:</strong> Second source register.</li>
</ul>

<p>They also have I-type variants</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COMPARISION_IMM $rt, $rs, immediate
</code></pre></div></div>
<ul>
  <li><strong>COMPARISION_IMM:</strong> is the opcode for logical instruction (e.g., SLTI, SLTIU)</li>
  <li><strong>$rt:</strong> Destination register where the result (1 or 0) will be stored</li>
  <li><strong>$rs:</strong> Source register.</li>
  <li><strong>immediate:</strong> 16-bit signed or unsigned immediate value.</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>Instruction</strong></th>
      <th><strong>Syntax</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Example</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>SLT</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLT $rd, $rs, $rt</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rd</code> to <code class="language-plaintext highlighter-rouge">1</code> if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the value in <code class="language-plaintext highlighter-rouge">$rt</code>, otherwise sets it to <code class="language-plaintext highlighter-rouge">0</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLT $t0, $t1, $t2</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SLTI</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLTI $rt, $rs, immediate</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rt</code> to <code class="language-plaintext highlighter-rouge">1</code> if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the immediate value, otherwise sets it to <code class="language-plaintext highlighter-rouge">0</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLTI $t0, $t1, 10</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; 10</code></td>
    </tr>
    <tr>
      <td><strong>SLTU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLTU $rd, $rs, $rt</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rd</code> to <code class="language-plaintext highlighter-rouge">1</code> if the unsigned value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the unsigned value in <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">SLTU $t0, $t1, $t2</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; $t2</code></td>
    </tr>
    <tr>
      <td><strong>SLTIU</strong></td>
      <td><code class="language-plaintext highlighter-rouge">SLTIU $rt, $rs, immediate</code></td>
      <td>Sets <code class="language-plaintext highlighter-rouge">$rt</code> to <code class="language-plaintext highlighter-rouge">1</code> if the unsigned value in <code class="language-plaintext highlighter-rouge">$rs</code> is less than the unsigned immediate value.</td>
      <td><code class="language-plaintext highlighter-rouge">SLTIU $t0, $t1, 10</code>  # <code class="language-plaintext highlighter-rouge">$t0 = $t1 &lt; 10</code></td>
    </tr>
  </tbody>
</table>

<h3 id="6-control-instructions">6. Control Instructions</h3>

<p>Control instructions in MIPS manage the flow of execution by altering the program counter (PC) based on conditions, performing unconditional jumps, and handling exceptions. These instructions are crucial for implementing loops, conditional execution, and function calls.</p>

<p>Control instructions in MIPS can be either I-type or J-type and follow these general formats:</p>

<p><strong>I-Type Branch Instructions</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BRANCH $rs, $rt, offset
</code></pre></div></div>
<ul>
  <li><strong>BRANCH:</strong> is the opcode for the specific branch instruction (e.g., <code class="language-plaintext highlighter-rouge">BEQ</code>, <code class="language-plaintext highlighter-rouge">BNE</code>, <code class="language-plaintext highlighter-rouge">BEQZ</code>, <code class="language-plaintext highlighter-rouge">BNEZ</code>).</li>
  <li><strong>$rs:</strong> The first source register.</li>
  <li><strong>$rt:</strong> The second source register (or immediate zero for <code class="language-plaintext highlighter-rouge">BEQZ</code>/<code class="language-plaintext highlighter-rouge">BNEZ</code>).</li>
  <li><strong>offset:</strong> The 16-bit signed offset from <code class="language-plaintext highlighter-rouge">PC + 4</code> to which the program will branch if the condition is met.</li>
</ul>

<p><strong>J-Type Jump Instructions</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JUMP target
</code></pre></div></div>
<ul>
  <li><strong>JUMP:</strong> is the opcode for the specific jump instruction (e.g., <code class="language-plaintext highlighter-rouge">J</code>, <code class="language-plaintext highlighter-rouge">JAL</code>).</li>
  <li><strong>target:</strong> The 26-bit immediate value specifying the address to jump to, relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>. It can also be the source register containing the target address.</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>Instruction</strong></th>
      <th><strong>Syntax</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Example</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>BEQZ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BEQZ $rs, offset</code></td>
      <td>Branches if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is equal to zero. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BEQZ $t0, label</code></td>
    </tr>
    <tr>
      <td><strong>BNEZ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BNEZ $rs, offset</code></td>
      <td>Branches if the value in <code class="language-plaintext highlighter-rouge">$rs</code> is not equal to zero. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BNEZ $t0, label</code></td>
    </tr>
    <tr>
      <td><strong>BEQ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BEQ $rs, $rt, offset</code></td>
      <td>Branches if the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code> are equal. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BEQ $t0, $t1, label</code></td>
    </tr>
    <tr>
      <td><strong>BNE</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BNE $rs, $rt, offset</code></td>
      <td>Branches if the values in <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code> are not equal. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BNE $t0, $t1, label</code></td>
    </tr>
    <tr>
      <td><strong>BC1T</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BC1T offset</code></td>
      <td>Branches if the floating-point comparison bit is true. The comparison bit is located in the Floating-Point Control and Status Register (FCSR) in Coprocessor 1 (CP1). This bit is set by floating-point comparison instructions. The offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BC1T label</code></td>
    </tr>
    <tr>
      <td><strong>BC1F</strong></td>
      <td><code class="language-plaintext highlighter-rouge">BC1F offset</code></td>
      <td>Branches if the floating-point comparison bit is false. Offset is 16-bit signed and relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">BC1F label</code></td>
    </tr>
    <tr>
      <td><strong>MOVN</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MOVN $rd, $rs, $rt</code></td>
      <td>Copies the value in <code class="language-plaintext highlighter-rouge">$rs</code> to <code class="language-plaintext highlighter-rouge">$rd</code> if the value in <code class="language-plaintext highlighter-rouge">$rt</code> is not zero.</td>
      <td><code class="language-plaintext highlighter-rouge">MOVN $t0, $t1, $t2</code></td>
    </tr>
    <tr>
      <td><strong>MOVZ</strong></td>
      <td><code class="language-plaintext highlighter-rouge">MOVZ $rd, $rs, $rt</code></td>
      <td>Copies the value in <code class="language-plaintext highlighter-rouge">$rs</code> to <code class="language-plaintext highlighter-rouge">$rd</code> if the value in <code class="language-plaintext highlighter-rouge">$rt</code> is zero.</td>
      <td><code class="language-plaintext highlighter-rouge">MOVZ $t0, $t1, $t2</code></td>
    </tr>
    <tr>
      <td><strong>J</strong></td>
      <td><code class="language-plaintext highlighter-rouge">J target</code></td>
      <td>Unconditionally jumps to the target address. The target is a 26-bit immediate value relative to <code class="language-plaintext highlighter-rouge">PC + 4</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">J label</code></td>
    </tr>
    <tr>
      <td><strong>JR</strong></td>
      <td><code class="language-plaintext highlighter-rouge">JR $rs</code></td>
      <td>Unconditionally jumps to the address contained in <code class="language-plaintext highlighter-rouge">$rs</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">JR $t0</code></td>
    </tr>
    <tr>
      <td><strong>JAL</strong></td>
      <td><code class="language-plaintext highlighter-rouge">JAL target</code></td>
      <td>Jumps to the target address and stores the return address (<code class="language-plaintext highlighter-rouge">PC + 4</code>) in <code class="language-plaintext highlighter-rouge">$ra</code> (register 31).</td>
      <td><code class="language-plaintext highlighter-rouge">JAL label</code></td>
    </tr>
    <tr>
      <td><strong>JALR</strong></td>
      <td><code class="language-plaintext highlighter-rouge">JALR $rd, $rs</code></td>
      <td>Jumps to the address in <code class="language-plaintext highlighter-rouge">$rs</code> and stores the return address (<code class="language-plaintext highlighter-rouge">PC + 4</code>) in <code class="language-plaintext highlighter-rouge">$rd</code> (usually <code class="language-plaintext highlighter-rouge">$ra</code>).</td>
      <td><code class="language-plaintext highlighter-rouge">JALR $ra, $t0</code></td>
    </tr>
    <tr>
      <td><strong>TRAP</strong></td>
      <td><code class="language-plaintext highlighter-rouge">TRAP code</code></td>
      <td>Triggers a software interrupt, transferring control to the operating system at a predefined vectored address. This instruction is used for implementing system calls or exceptions where the program needs to request services from the operating system or handle specific conditions. The code parameter is a 16-bit immediate value called system call number, it specifies the type of service or the particular action to be performed by the operating system.</td>
      <td><code class="language-plaintext highlighter-rouge">TRAP 0x7</code></td>
    </tr>
    <tr>
      <td><strong>ERET</strong></td>
      <td><code class="language-plaintext highlighter-rouge">ERET</code></td>
      <td>Returns from an exception, restoring the state and returning to user mode. An “exception” generally refers to any condition that disrupts the normal execution flow of a program and requires special handling by the operating system or the CPU. These can include both software interrupt which are intentional exceptions triggered by the program, often using a TRAP instruction, to request a service from the operating system or hardware exceptions like a program tries to divide a number by zero, triggering a divide-by-zero exception. The CPU catches this, and the operating system’s exception handler is invoked. After handling the exception (perhaps by terminating the program or skipping the instruction), ERET is used to return control to the next appropriate point in the program.</td>
      <td><code class="language-plaintext highlighter-rouge">ERET</code></td>
    </tr>
  </tbody>
</table>

<p>Note: The relative offset for branching is considered from <code class="language-plaintext highlighter-rouge">PC + 4</code> instead of <code class="language-plaintext highlighter-rouge">PC</code> because, in MIPS, the Program Counter (PC) is incremented by 4 immediately after fetching the current instruction. This means that by the time the branch or jump instruction is executed, the PC already points to the next instruction.</p>

<p><strong>Translation of Labels in Machine Code</strong></p>

<p>When writing assembly code, we often use labels as targets for jumps or branches. These labels are symbolic names representing memory addresses. During the assembly process, the assembler converts these labels into actual memory locations. This allows the code to be more readable and maintainable, as labels can be used instead of hard-coded memory addresses.</p>

<p>For e.g., if the assembly code is</p>

<pre><code class="language-assembly">start:
    ADD $t0, $t1, $t2
    BEQ $t0, $zero, end
    SUB $t3, $t4, $t5
end:
    NOP
</code></pre>

<p>when it’s converted to machine code by the assembler, it will be like this (except everything including opcodes will be binary numbers)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ADD $t0, $t1, $t2
    BEQ $t0, $zero, 0x00400010  # The label 'end' is converted to the memory address 0x00400010
    SUB $t3, $t4, $t5
    NOP
</code></pre></div></div>

<p>During assembly, the assembler replaces each referenced label with the corresponding memory location of the code associated with that label. The assembler can calculate these addresses even before the program is loaded into memory for execution because they are virtual addresses, not physical addresses. In fact, a program does not need to be concerned with physical addresses, as the Memory Management Unit (MMU) handles the translation of virtual addresses to physical addresses.</p>

<p>The assembler assumes a starting address for the program (often specified by the operating system or a linker script). As it processes the code, it assigns virtual memory addresses to each instruction and data element, incrementing the address by the size of each instruction or data element. These addresses are used for the purposes of assembly and linking, not for direct physical memory access.</p>

<h3 id="7-floating-point-instructions">7. Floating-Point Instructions</h3>

<p>In MIPS, floating-point operations are performed using the Floating-Point Unit (FPU), also known as Coprocessor 1 (CP1). The FPU handles calculations on floating-point numbers in three formats: single-precision (SP), double-precision (DP), and paired-single (PS). These operations can involve basic arithmetic like addition, subtraction, multiplication, and division, as well as more complex operations like multiply-add and conversion between different data types.</p>
<ul>
  <li><strong>Single-Precision (SP):</strong> 32-bit floating-point numbers.</li>
  <li><strong>Double-Precision (DP):</strong> 64-bit floating-point numbers.</li>
  <li><strong>Paired-Single (PS):</strong> Two 32-bit floating-point values packed into a single 64-bit register. This format allows SIMD (Single Instruction, Multiple Data) operations, enabling parallel processing of the two 32-bit values.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Instruction Group</th>
      <th>Syntax</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Addition</strong></td>
      <td>ADD.[D/S/PS] $fd, $fs, $ft</td>
      <td>Adds the values in $fs and $ft, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">ADD.D $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Subtraction</strong></td>
      <td>SUB.[D/S/PS] $fd, $fs, $ft</td>
      <td>Subtracts the value in $ft from $fs, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">SUB.S $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Multiplication</strong></td>
      <td>MUL.[D/S/PS] $fd, $fs, $ft</td>
      <td>Multiplies the values in $fs and $ft, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">MUL.PS $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Multiply-Add</strong></td>
      <td>MADD.[D/S/PS] $fd, $fs, $ft</td>
      <td>Multiplies $fs and $ft, then adds the result to $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">MADD.D $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Division</strong></td>
      <td>DIV.[D/S/PS] $fd, $fs, $ft</td>
      <td>Divides the value in $fs by $ft, storing the result in $fd. Supports DP, SP, and PS formats.</td>
      <td><code class="language-plaintext highlighter-rouge">DIV.S $f0, $f1, $f2</code></td>
    </tr>
    <tr>
      <td><strong>Conversion</strong></td>
      <td>CVT.[x].[y] $fd, $fs</td>
      <td>Converts the value in $fs from format x to format y, storing the result in $fd. Formats include L, W, D, and S.</td>
      <td><code class="language-plaintext highlighter-rouge">CVT.S.D $f0, $f1</code></td>
    </tr>
    <tr>
      <td><strong>Comparison</strong></td>
      <td>C.[cond].[D/S] $fs, $ft</td>
      <td>Compares the values in $fs and $ft. The condition (cond) can be LT, GT, LE, GE, EQ, or NE. Sets a bit in the FCSR based on the result.</td>
      <td><code class="language-plaintext highlighter-rouge">C.LE.S $f0, $f1</code></td>
    </tr>
  </tbody>
</table>

<h2 id="pseudo-instructions-in-mips">Pseudo-Instructions in MIPS</h2>

<p>Pseudo-instructions are higher-level assembly language instructions that simplify coding for the programmer. These pseudo-instructions are not actual MIPS machine instructions but are translated by the assembler into one or more real MIPS instructions during assembly. This translation helps make the code more readable and easier to write without worrying about the specific details of the underlying machine instructions.</p>

<p>Some of the commonly used pseudo-instructions in MIPS are</p>

<table>
  <thead>
    <tr>
      <th>Pseudo-Instruction</th>
      <th>Description</th>
      <th>Actual Instructions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">move $rd, $rs</code></td>
      <td>Copy the value from register <code class="language-plaintext highlighter-rouge">$rs</code> to <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">add $rd, $rs, $zero</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">li $rd, imm</code></td>
      <td>Load an immediate value <code class="language-plaintext highlighter-rouge">imm</code> into register <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td>If <code class="language-plaintext highlighter-rouge">imm</code> is small: <code class="language-plaintext highlighter-rouge">addi $rd, $zero, imm</code><br />If <code class="language-plaintext highlighter-rouge">imm</code> is large: <code class="language-plaintext highlighter-rouge">lui $rd, upper(imm)</code> + <code class="language-plaintext highlighter-rouge">ori $rd, $rd, lower(imm)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">la $rd, label</code></td>
      <td>Load the address of <code class="language-plaintext highlighter-rouge">label</code> into register <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">lui $rd, upper(label)</code> + <code class="language-plaintext highlighter-rouge">ori $rd, $rd, lower(label)</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">b label</code></td>
      <td>Unconditional branch to <code class="language-plaintext highlighter-rouge">label</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">beq $zero, $zero, label</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">blt $rs, $rt, label</code></td>
      <td>Branch to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">$rs</code> is less than <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">slt $at, $rs, $rt</code> + <code class="language-plaintext highlighter-rouge">bne $at, $zero, label</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bgt $rs, $rt, label</code></td>
      <td>Branch to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">$rs</code> is greater than <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">slt $at, $rt, $rs</code> + <code class="language-plaintext highlighter-rouge">bne $at, $zero, label</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bge $rs, $rt, label</code></td>
      <td>Branch to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">$rs</code> is greater than or equal to <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">slt $at, $rs, $rt</code> + <code class="language-plaintext highlighter-rouge">beq $at, $zero, label</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ble $rs, $rt, label</code></td>
      <td>Branch to <code class="language-plaintext highlighter-rouge">label</code> if <code class="language-plaintext highlighter-rouge">$rs</code> is less than or equal to <code class="language-plaintext highlighter-rouge">$rt</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">slt $at, $rt, $rs</code> + <code class="language-plaintext highlighter-rouge">beq $at, $zero, label</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">nop</code></td>
      <td>No operation; does nothing for one cycle.</td>
      <td><code class="language-plaintext highlighter-rouge">sll $zero, $zero, 0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">li $rd, 0ximm</code></td>
      <td>Load an immediate hexadecimal value into <code class="language-plaintext highlighter-rouge">$rd</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">lui $rd, high(imm)</code> + <code class="language-plaintext highlighter-rouge">ori $rd, $rd, low(imm)</code></td>
    </tr>
  </tbody>
</table>

<p>The register <code class="language-plaintext highlighter-rouge">$1</code> (also known as <code class="language-plaintext highlighter-rouge">$at</code>, short for “assembler temporary”) is used by the assembler as a temporary register to hold intermediate values. Many pseudo-instructions require multiple steps to achieve the desired result. For example, the pseudo-instruction <code class="language-plaintext highlighter-rouge">bgt</code> (branch if greater than) is not a real MIPS instruction and needs to be translated into a combination of other instructions like <code class="language-plaintext highlighter-rouge">slt</code> (set less than) and <code class="language-plaintext highlighter-rouge">bne</code> (branch if not equal). The assembler uses <code class="language-plaintext highlighter-rouge">$at</code> to temporarily hold values during this process.</p>

<p>For eg: the pseudo-instruction</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bgt $t0, $t1, label
</code></pre></div></div>

<p>needs to be translated by the assembler because there is no direct <code class="language-plaintext highlighter-rouge">bgt</code> instruction in MIPS. The assembler expands it as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slt $at, $t1, $t0      # Set $at to 1 if $t1 &lt; $t0
bne $at, $zero, label  # Branch to label if $at is not zero
</code></pre></div></div>

<h2 id="directives-in-mips">Directives in MIPS</h2>

<p>Directives in MIPS are special instructions that guide the assembler during the assembly process. Unlike typical assembly instructions, directives do not correspond to machine instructions; instead, they control the organization and management of the code and data. These directives help define the structure of the program, allocate memory, and manage sections within the assembly code.</p>

<p><strong>Directives are used for following:</strong></p>

<ol>
  <li>
    <p><strong>Introducing Sections:</strong> A process in operating system consists of following segments: <strong>text</strong>, <strong>data</strong>, <strong>heap</strong> and <strong>stack</strong>. The <strong>text</strong> segment contains the executable instructions of a program, which are the compiled code that the CPU executes. It is typically marked as read-only to prevent accidental or malicious modifications.  The <strong>data</strong> segment stores global and static variables that are initialized before the program starts. It has separate sub-segments for storing initialized and uninitialized data (BSS). It is a read-write segment, allowing variables to be modified during execution.. Directives like <code class="language-plaintext highlighter-rouge">.data</code> and <code class="language-plaintext highlighter-rouge">.text</code> introduce the data and text sections of the program, respectively. The <code class="language-plaintext highlighter-rouge">.data</code> section is for declaring variables and data, while the <code class="language-plaintext highlighter-rouge">.text</code> section contains the actual code (instructions). A MIPS program can have multiple .data and .text sections. These sections can be defined at different points in the source code to organize data and instructions. The assembler processes these sections and groups all the .data sections into a single data segment and all the .text sections into a single text segment in the final binary.</p>
  </li>
  <li>
    <p><strong>Assembling Values:</strong> Assembling refers to the process of initializing and placing specific values into the memory sections of the program. Directives like <code class="language-plaintext highlighter-rouge">.byte</code>, <code class="language-plaintext highlighter-rouge">.half</code>, <code class="language-plaintext highlighter-rouge">.word</code>, <code class="language-plaintext highlighter-rouge">.ascii</code>, and <code class="language-plaintext highlighter-rouge">.double</code> assemble specific values into the current section. For example, <code class="language-plaintext highlighter-rouge">.byte</code> and <code class="language-plaintext highlighter-rouge">.half</code> store 8-bit and 16-bit values, respectively, while <code class="language-plaintext highlighter-rouge">.double</code> calculates and stores IEEE 64-bit double-precision floating-point values.</p>

    <table>
      <thead>
        <tr>
          <th><strong>Directive</strong></th>
          <th><strong>Data Type</strong></th>
          <th><strong>Size</strong></th>
          <th><strong>Memory Alignment</strong></th>
          <th><strong>Example</strong></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.byte</code></td>
          <td>8-bit integer</td>
          <td>1 byte</td>
          <td>None (can be at any address)</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">val4: .byte 0x12</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.half</code></td>
          <td>16-bit integer</td>
          <td>2 bytes</td>
          <td>Even addresses (2-byte boundary)</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">.align 1</code> <br /> <code class="language-plaintext highlighter-rouge">val3: .half 0x1234</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.word</code></td>
          <td>32-bit integer</td>
          <td>4 bytes</td>
          <td>4-byte boundary</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">.align 2</code> <br /> <code class="language-plaintext highlighter-rouge">val1: .word 0x12345678</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.double</code></td>
          <td>64-bit double-precision floating point</td>
          <td>8 bytes</td>
          <td>8-byte boundary</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">.align 3</code> <br /> <code class="language-plaintext highlighter-rouge">val2: .double 3.141592653589793</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.space</code></td>
          <td>Reserved memory space</td>
          <td>N/A</td>
          <td>N/A</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">buffer: .space 64</code> (reserves 64 bytes of space)</td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.ascii</code></td>
          <td>ASCII string without null terminator</td>
          <td>Variable</td>
          <td>None (can be at any address)</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">val5: .ascii "hello"</code></td>
        </tr>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">.asciiz</code></td>
          <td>ASCII string with null terminator</td>
          <td>Variable</td>
          <td>None (can be at any address)</td>
          <td><code class="language-plaintext highlighter-rouge">.data</code> <br /> <code class="language-plaintext highlighter-rouge">val6: .asciiz "world"</code></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p><strong>Global and External Symbols:</strong> Directives like <code class="language-plaintext highlighter-rouge">.globl</code> and <code class="language-plaintext highlighter-rouge">.extern</code> are used to manage symbol visibility and accessibility across multiple assembly files or modules. These directives are essential in modular programming, allowing different parts of a program to share and link symbols.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">.globl sym:</code> Declares the label <code class="language-plaintext highlighter-rouge">sym</code> as global, making it accessible from other assembly files or modules. This ensures that the label can be referenced during the linking process, enabling inter-file communication.</li>
      <li><code class="language-plaintext highlighter-rouge">.extern sym size:</code> Declares the label <code class="language-plaintext highlighter-rouge">sym</code> as an external symbol, indicating that it is defined in another file or module. The <code class="language-plaintext highlighter-rouge">size</code> parameter specifies the symbol’s size in bytes. This directive is used to reference symbols that are not defined within the current assembly file but are needed for linking.</li>
    </ul>
  </li>
  <li>
    <p><strong>Memory Alignment:</strong> The MIPS assembler automatically aligns data in memory according to the data type’s natural alignment requirements.The <code class="language-plaintext highlighter-rouge">.align</code> directive is used to ensure that the data in memory is aligned on a specific boundary, which can be critical for performance or correctness in certain architectures. The directive takes an argument that specifies the power of two for the alignment (e.g., <code class="language-plaintext highlighter-rouge">.align</code> 2 aligns the data on a 4-byte boundary). This is particularly useful when dealing with data types that require specific alignment for efficient access. The <code class="language-plaintext highlighter-rouge">.align 0</code> directive can be used to turn off automatic alignment. 
For example: <code class="language-plaintext highlighter-rouge">.align 3</code> aligns the data on an 8-byte boundary, suitable for 64-bit data types.</p>
  </li>
</ol>]]></content><author><name>Sanketh</name></author><category term="cpu" /><category term="assembly" /><summary type="html"><![CDATA[MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.]]></summary></entry><entry><title type="html">The Fetch Decode Execute Cycle</title><link href="http://localhost:4000/blog/cpu/the-fetch-decode-execute-cycle" rel="alternate" type="text/html" title="The Fetch Decode Execute Cycle" /><published>2024-06-30T19:32:40+05:30</published><updated>2024-06-30T19:32:40+05:30</updated><id>http://localhost:4000/blog/cpu/the-fetch-decode-execute-cycle</id><content type="html" xml:base="http://localhost:4000/blog/cpu/the-fetch-decode-execute-cycle"><![CDATA[<p>The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.</p>

<h2 id="what-is-machine-code">What is Machine Code?</h2>

<p>Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation.</p>

<p>Machine code is loaded into RAM before execution and stored in code segment of the process. Machine code instructions typically follow a specific format that is closely related to the architecture’s Instruction Set Architecture (ISA). Depending on the processor, a computer’s instruction sets might either be of uniform length or vary in length, eg: In MIPS all instructions are 32 bits long, x86 instructions can range from 1 to 15 bytes. Machine code instructions typically follow a specific format that is closely related to the architecture’s Instruction Set Architecture (ISA). While the exact format can vary between different ISAs, a general pattern for machine code instructions can be described as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;opcode&gt; &lt;destination register&gt;, &lt;source register 1&gt;, &lt;source register 2&gt;
</code></pre></div></div>
<ul>
  <li>opcode: The operation code specifies the operation to be performed (e.g., ADD, SUB, LOAD, STORE). This is the mnemonic representation of the binary code that the CPU understands.</li>
  <li>destination register: The register where the result of the operation will be stored.</li>
  <li>source register 1: The first operand register.</li>
  <li>source register 2: The second operand register (if applicable)</li>
</ul>

<h3 id="assembly">Assembly</h3>

<p>Machine code is difficult for humans to read and interpret. To bridge this gap, a disassembler converts machine code into assembly language. Assembly language provides a direct mapping between numerical machine code and a human-readable version, replacing numerical opcodes and operands with readable strings. Additionally, programmers can write code in assembly language, which an assembler then converts back into machine code for the CPU to execute.</p>

<h2 id="the-fetch-decode-execute-cycle">The Fetch, Decode, Execute Cycle</h2>

<p>Different components of the CPU work together in order to execute a program each performing a distinct function. By dividing the work into separate stages, multiple instructions can be processed simultaneously at different stages of the cycle, this is called <strong>pipelining</strong>.  Pipelining increases the throughput of the CPU, as one instruction can be fetched while another is decoded, another is executed, and another is writing back.</p>

<h3 id="1-fetch">1. Fetch</h3>

<p>The Program Counter (PC) is a special purpose register that always holds the address of the next instruction to be executed. During the fetch stage, the address stored in the PC is copied to the Memory Address Register (MAR). The PC is then incremented to point to the memory address of the subsequent instruction. The CPU retrieves the instruction at the memory address specified by the MAR and copies it into the Memory Data Register (MDR). The instruction is copied to Instruction Register (IR) at the end of fetch cycle.</p>

<p>The PC is incremented immediately after the address stored in it is copied to the MAR and doesn’t wait for the current instruction to complete because in a pipelined CPU, multiple instructions are processed simultaneously at different stages of the instruction cycle. Incrementing the PC right away allows the next instruction to enter the fetch stage while the current instruction is moving through the decode and execute stages. This overlap increases overall instruction throughput.</p>

<p>The control unit orchestrates the entire process, sending signals to the other components to ensure they operate in the correct sequence. It ensures the address is sent to memory, the instruction is fetched, and the PC is incremented.</p>

<p>The initial instruction cycle starts immediately when the system is powered on, using a predefined PC value specific to the system’s architecture (for example, in Intel IA-32 CPUs, the predefined PC value is 0xfffffff0). This address usually points to a set of instructions stored in read-only memory (ROM), which initiates the loading or booting of the operating system.</p>

<h3 id="2-decode">2. Decode</h3>

<p>The decode stage involves interpreting the fetched instruction and preparing the necessary components of the CPU for the execution stage. The Instruction Decoder interprets the opcode and determines the type of operation to be performed (e.g., addition, subtraction, load, store), opcode is also used to decide number of operands to be fetched. If the instruction is a memory operation, the decoder also identifies the addressing mode and determines the effective memory address to be used in the following execute stage.</p>

<h3 id="3-execute">3. Execute</h3>

<p>In the execute stage, the CPU carries out the instruction decoded in the previous stage. Depending on the type of instruction, different components of the CPU are involved: If the instruction is an arithmetic or logic operation (such as addition, subtraction, or bitwise operations), the Arithmetic Logic Unit (ALU) is activated. If the instruction involves data transfer (such as loading data from memory into a register or storing data from a register into memory), the CPU will interact with the memory unit. For a load instruction, the CPU sends the memory address to the Memory Address Register (MAR) and retrieves the data from that address into the Memory Data Register (MDR). For a store instruction, it writes the data from the register to the specified memory address. If the instruction is a control operation (such as a jump, branch, or call), the Program Counter (PC) is updated to reflect the new address for the next instruction. This may involve adding an offset to the current PC value or directly loading a new address into the PC.</p>]]></content><author><name>Sanketh</name></author><category term="cpu" /><summary type="html"><![CDATA[The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.]]></summary></entry><entry><title type="html">Measuring CPU Performance</title><link href="http://localhost:4000/blog/cpu/measuring-cpu-performance" rel="alternate" type="text/html" title="Measuring CPU Performance" /><published>2024-06-21T01:14:25+05:30</published><updated>2024-06-21T01:14:25+05:30</updated><id>http://localhost:4000/blog/cpu/measuring-cpu-performance</id><content type="html" xml:base="http://localhost:4000/blog/cpu/measuring-cpu-performance"><![CDATA[<p>CPU Manufacturers publish several metrics related to CPU like clock speed, number of cores, cache sizes, ISA, performance per Watt, number of transistors and more. Measuring CPU performance is complex, and it cannot be summarized by a single metric. In this post, I’ll explore each of these metrics and discuss some standard benchmarking software and their limitations.</p>

<h2 id="what-is-clock-speed-how-does-it-affects-cpu-performance">What is Clock Speed, How does it Affects CPU Performance?</h2>

<p>All Synchronous digital electronic circuits require an externally generated time reference. This is usually a square wave signal provided to the circuit called as clock. A <strong>clock cycle</strong> is the fundamental unit of time measurement for a CPU. A clock cycle is a single electrical pulse in a CPU, during which the CPU can execute a fundamental operation such as accessing memory, writing data, or fetching a new set of instructions. A clock cycle is measured as the amount of time between two pulses of an oscillator. The clock speed of a CPU is measured in Hertz (Hz), which signifies the number of clock cycles it can complete in one second. Common units are Megahertz (MHz) and Gigahertz (GHz).</p>

<h3 id="major-functionalities-of-cpu-clocks">Major functionalities of CPU clocks</h3>

<ul>
  <li>The clock signal ensures that all parts of the circuit change their state in a coordinated manner, ensuring reliable and predictable operation.</li>
  <li>In sequential logic circuits, where the output depends not just on the current inputs but also on the history of inputs, a clock is necessary to sequence the operations correctly.</li>
  <li>The clock signal allows precise control over the timing of data transfers between different parts of the circuit. The clock ensures that the data is stable and settled before being transferred to the next stage of the circuit.</li>
</ul>

<h3 id="does-higher-clock-speed-means-higher-cpu-performance">Does Higher Clock Speed Means Higher CPU Performance?</h3>

<p>Let’s say we have 2 CPU’s with A and B with clock speed 3.4 GHz and 3.6 GHz respectively. While CPU B can generate more clock pulses compared to A, it does not necessarily mean that it has better performance than A. There are several other factors which come into play while determining the overall performance. If an instruction took “x” number of cycles in CPU A and if it takes same number of cycles in CPU B, then CPU B is indeed faster as it means that the instruction is taking less time to complete on CPU B. But in real life it’s difficult to decrease the time of instruction execution. Some things like register access are very fast but things like memory access, ALU operations, floating point operations are complex in nature and cannot be optimized by merely increasing clock speed. Thus, comparing the clock speeds of two CPUs is only relevant if the CPUs belong to the same family, like Intel i5 and i7, or Mac M1 and M4.</p>

<h3 id="why-cpu-clock-speed-has-barely-changed-in-past-two-decades">Why CPU Clock speed has barely changed in past two decades?</h3>

<p>The clock speed of consumer-grade CPUs has barely changed in the past two decades. For example, the Intel Pentium 4, which came out in the early 2000s, achieved a clock speed of 3.8 GHz, while the recent Apple M3 released in 2023 runs at 4.05 GHz. Despite the similar clock speeds, the Apple M3 is far more powerful than the Intel Pentium 4.</p>

<p>The primary reason manufacturers haven’t increased clock speed is that higher frequency CPUs consume more power and generate more heat. This can lead to thermal throttling, where the CPU reduces its frequency to prevent overheating, negating the benefits of the higher frequency. As a result, manufacturers have shifted focus to other parameters to enhance performance:</p>

<ol>
  <li>
    <p><strong>Cycles per Instruction (CPI):</strong> Cycles per Instruction refers to the average number of cycles taken by a particular instruction to complete. Ideal value of CPI is 1, as each instruction needs at least one clock cycle to complete. But in real world scenario, even the simplest instruction will take multiple cycles to complete, depending on the architecture. Techniques such as pipelining and out-of-order execution are used to optimize CPI and improve overall performance.</p>
  </li>
  <li>
    <p><strong>Number of Cores and Threads:</strong> A multi-core CPU can perform several tasks in parallel, with each core functioning as an independent processing unit. Technologies like simultaneous multithreading (SMT), or Intel’s Hyper-Threading, allow a CPU core to support multiple hardware threads, each with its own Program Counter (PC) and registers allowing independent execution. Hyper-threading works by sharing functional units of a core among multiple hardware threads. Hardware threads are different from threads provided by OS which are known as software threads. In case of software threads, concurrency is achieved by context switching between multiple threads. In SMT, hardware threads may appear as independent cores to the operating system and applications, even though they share some physical resources.</p>
  </li>
  <li>
    <p><strong>Instruction Set Architecture (ISA):</strong> ISA is a set of instructions that a processor can understand and execute. ISA are classified into two types: Reduced Instruction Set Computer (RISC) and Complex Instruction Set Computer (CISC). RISC architectures use a small, highly optimized set of instructions that are all of uniform length and are executed in a single clock cycle. This simplicity and efficiency make RISC architectures easier to pipeline and more power-efficient. Some examples RISC ISA’s are MIPS, ARM. CISC architectures have a large and complex set of instructions, some of which can execute multi-step operations in a single instruction. This allows for more functionality per instruction but often results in more complex hardware and potentially slower performance for individual instructions, example: x86.</p>
  </li>
  <li>
    <p><strong>Dynamic Frequency Scaling:</strong> Dynamic frequency scaling allows the CPU to adjust its clock speed based on the current workload and thermal conditions. By lowering the clock speed when full performance is not needed, the CPU can save power and reduce heat generation, which helps in maintaining performance efficiency and longevity. In some modern day processors like Intel I7, it’s possible to increase the clock frequency beyond the base clock frequency. This will help in executing CPU intensive workloads efficiently provided there is enough thermal as well as power capacity. This is also known as overclocking.</p>
  </li>
</ol>

<h2 id="the-cpu-performance-equation">The CPU Performance Equation</h2>

<p>The CPU performance can be calculated using the equation</p>

\[T = N_{\text{instr}} \cdot \text{CPI} \cdot t_{\text{cycle}}\]

<p>where:</p>
<ul>
  <li>N<sub>instr</sub> = Number of instructions executed</li>
  <li>CPI = Cycles per Instruction</li>
  <li>t<sub>cycle</sub> = Duration of a clock cycle</li>
  <li>T = CPU time consumed by the program</li>
</ul>

<p>Cycles per Instruction (CPI) is a critical metric in evaluating CPU performance. Different types of instructions take different numbers of cycles to complete, and even the same type of instruction can take varying numbers of cycles depending on factors like pipeline stalls or cache hits/misses. Because of this variability, CPI is often represented as an average value for each type of instruction. This average CPI helps in estimating the overall performance of a CPU when executing a mix of different instructions.</p>

<p>From the above equation we can see that CPU time consumed by a program can be decreased by decreasing one of the three paramaters N<sub>instr</sub>, CPI or t<sub>cycle</sub>. However, these three parameters are not completely independent of each other. For example, if we try to reduce N<sub>instr</sub> by optimizing the Assembly code to produce fewer instructions, we may have to increase the complexity of instructions which would in turn increase CPI for those instructions.</p>

<h2 id="historical-laws-related-to-cpu-performance">Historical Laws Related to CPU Performance</h2>

<h3 id="amdahls-law">Amdahl’s Law</h3>

<p>Amdahl’s law provides a formula to calculate maximum theoretical speedup that can be obtained by parallelizing the CPU workload on multiple processing units.</p>

\[S = \frac{1}{(1 - P) + \frac{P}{N}}\]

<p>where:</p>
<ul>
  <li>S is the theoretical speedup of the execution of the whole task;</li>
  <li>P is the proportion of the program that can be parallelized;</li>
  <li>N is the number of processors.</li>
</ul>

<p><a title="Daniels220 at English Wikipedia, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:AmdahlsLaw.svg"><img width="512" alt="AmdahlsLaw" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/AmdahlsLaw.svg/512px-AmdahlsLaw.svg.png?20170324202600" /></a></p>

<p>Using Amdahl’s Law, we can calculate that if 50% of the total workload is parallelizable, then the maximum speedup achieved will be 2 no matter how many processors we use. This demonstrates the limitation of parallel processing, highlighting that the non-parallelizable portion of the task significantly impacts the overall speedup.</p>

<h3 id="gustafsons-law">Gustafson’s Law</h3>

<p>While Amdahl’s Law focuses on the limitations of parallelism for a fixed workload, Gustafson’s Law presents a less pessimistic view by considering the scalability of parallelism by allowing the problem size to grow with the number of processors. Gustafson’s Law is expressed as:</p>

\[S = 1 + (N - 1)P\]

<p>where:</p>
<ul>
  <li>S is the speedup,</li>
  <li>N is the number of processors,</li>
  <li>P is the proportion of the parallel part of the workload.</li>
</ul>

<p><a title="Peahihawaii, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Gustafson.png"><img width="512" alt="Gustafson" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Gustafson.png/512px-Gustafson.png?20110108143519" /></a></p>

<p>Gustafson’s Law suggests that as we increase the number of processors, the overall problem size can increase proportionally, thus making better use of the additional computational power. This perspective is more optimistic because it implies that large-scale problems can achieve significant performance gains through parallel processing, provided there is sufficient parallelizable work.</p>

<p>In essence, Amdahl’s Law highlights the diminishing returns of parallelism due to the serial portion of a task, while Gustafson’s Law emphasizes the potential for increased problem sizes to fully utilize the power of multiple processors. Together, these laws offer valuable insights into the challenges and opportunities of parallel computing.</p>

<h2 id="cpu-benchmarking-softwares">CPU Benchmarking Softwares</h2>

<p>There are no universal benchmarks for measuring CPU performance. Over the past five decades, manufacturers and researchers have used various benchmarks to describe CPU performance. CPU benchmarks can be broadly classified into two types:</p>

<p><strong>1. Synthetic Benchmarks:</strong> Synthetic benchmarks emulate CPU-intensive workloads such as file compression, cryptography, floating-point operations, and 3D rendering. While they are not exact predictors of performance, synthetic benchmarks are useful for testing individual components and comparing specific aspects of CPU performance.</p>

<p><strong>2. Application Benchmarks:</strong> Application benchmarks run real-world programs that perform CPU-intensive workloads on the system. These benchmarks are less biased and provide a more accurate representation of CPU metrics, offering a clearer picture of how a CPU will perform in practical scenarios.</p>]]></content><author><name>Sanketh</name></author><category term="cpu" /><summary type="html"><![CDATA[CPU Manufacturers publish several metrics related to CPU like clock speed, number of cores, cache sizes, ISA, performance per Watt, number of transistors and more. Measuring CPU performance is complex, and it cannot be summarized by a single metric. In this post, I’ll explore each of these metrics and discuss some standard benchmarking software and their limitations.]]></summary></entry><entry><title type="html">Key Differences between 32-bit and 64-bit CPU architectures</title><link href="http://localhost:4000/blog/cpu/processor-bit-size" rel="alternate" type="text/html" title="Key Differences between 32-bit and 64-bit CPU architectures" /><published>2024-06-02T12:35:25+05:30</published><updated>2024-06-02T12:35:25+05:30</updated><id>http://localhost:4000/blog/cpu/processor-bit-size</id><content type="html" xml:base="http://localhost:4000/blog/cpu/processor-bit-size"><![CDATA[<p>The terms 32 bit and 64 bit specifically relate to the size of the data and address registers within the CPU, which determines the maximum amount of memory that can be directly accessed and the range of values that can be processed.</p>

<ol>
  <li>Registers and Data Width:
    <ul>
      <li>Since all calculations take place in registers, when performing operations such as addition or subtraction, variables are loaded from memory into registers if they are not already there.</li>
      <li>A 32-bit CPU has 32-bit wide registers, meaning it can process 32 bits of data in a single instruction.</li>
    </ul>
  </li>
  <li>Memory Addressing:
    <ul>
      <li>32-bit CPU can address up to 2<sup>32</sup> unique memory locations translates to a maximum of 4 GB of addressable memory (RAM). 64-bit CPU can address up to 2<sup>64</sup> unique memory locations allowing for a theoretical maximum of 16 exabytes of addressable memory.</li>
      <li>This limitation comes from the fact that a 32-CPU can only load integers that are 32 bits long, thus limiting the maximum addressable memory space.</li>
    </ul>
  </li>
  <li>Data Transfer Speeds:
    <ul>
      <li>The memory bus width in 64-bit CPU is often 64 bits or more, meaning the physical path between the CPU and RAM can handle 64 bits of data in parallel. This helps in efficiently loading data into the cache but does not restrict the CPU to always reading 64 bits.</li>
      <li>Despite the ability to handle 64 bits of data in parallel, the CPU is not restricted to always reading 64 bits at a time. It can access smaller data sizes (e.g., 8-bit, 16-bit, 32-bit) as needed, depending on the specific instruction and data type.</li>
    </ul>
  </li>
  <li>Performance:
    <ul>
      <li>64-bit CPU’s perform better than 32-bit CPU’s. This performance difference comes up from various factors like size of registers, addressable memory space, larger bus width</li>
      <li>Some RISC architectures support SIMD (Single Instruction, Multiple Data) instructions that allow for parallel processing of multiple smaller data types within larger registers. For example, ARM’s NEON technology can operate on multiple 32-bit integers within 64-bit registers, which enable the parallel processing of smaller data types within larger registers.</li>
    </ul>
  </li>
  <li>Application Compatibility:
    <ul>
      <li>64-bit operating systems typically include backward compatibility to run 32-bit software seamlessly.</li>
      <li>These compatibility layers allow 32-bit applications to execute on 64-bit systems without any major issues. However, 32-bit applications may not fully utilize the advantages of 64-bit systems, such as increased memory addressing capabilities.</li>
    </ul>
  </li>
</ol>]]></content><author><name>Sanketh</name></author><category term="cpu" /><summary type="html"><![CDATA[The terms 32 bit and 64 bit specifically relate to the size of the data and address registers within the CPU, which determines the maximum amount of memory that can be directly accessed and the range of values that can be processed.]]></summary></entry><entry><title type="html">Components of CPU</title><link href="http://localhost:4000/blog/cpu/components-of-cpu" rel="alternate" type="text/html" title="Components of CPU" /><published>2024-05-31T01:05:25+05:30</published><updated>2024-05-31T01:05:25+05:30</updated><id>http://localhost:4000/blog/cpu/components-of-cpu</id><content type="html" xml:base="http://localhost:4000/blog/cpu/components-of-cpu"><![CDATA[<p>Before learning Assembly, I think it would be useful to learn a bit about different components of CPU in general. If we think of CPU as a black box its main function is to fetch instructions from RAM which are in the form of <a href="https://en.wikipedia.org/wiki/Machine_code">machine code</a> and execute them.</p>

<h2 id="components-of-cpu">Components of CPU</h2>

<ol>
  <li>Arithmetic Logic Unit (ALU)</li>
  <li>Memory Management Unit (MMU)</li>
  <li>Control Unit (CU)</li>
  <li>Registers</li>
  <li>Clock</li>
  <li>Cache</li>
  <li>Buses</li>
</ol>

<h3 id="1-arithmetic-logic-unit-alu">1. Arithmetic Logic Unit (ALU)</h3>

<p>ALU is an electronic circuit made of NAND gates responsible for performing arithmetic and logical operations on integer binary numbers. It takes two operands as inputs and an opcode to indicate the type of operation to be performed. Operations supported by ALU are Add, Subtract, Negation, Two’s complement, AND, OR, XOR, bit shift, etc.</p>

<h3 id="2-memory-management-unit-mmu">2. Memory Management Unit (MMU)</h3>

<p>The primary function of the MMU is to translate virtual addresses generated by the CPU into physical addresses used by the underlying hardware memory. It acts as a bridge between CPU and RAM, managing how the CPU accesses data stored in memory and provides an illusion of infinite memory space for programs. MMU utilizes different stragies such as the branch and bound registers, segmentation, page tables, TLB’s, etc to facilitate address translation.</p>

<h3 id="3-control-unit-cu">3. Control Unit (CU)</h3>

<p>CU’s primary function is to direct the operations of the CPU by interpreting instructions and generating control signals to execute them.</p>

<ol>
  <li>Instruction Fetching:
    <ul>
      <li>The CU fetches instructions from the memory unit (RAM) based on the Program Counter (PC) value.</li>
      <li>It reads the instruction from memory and stores it temporarily in the Instruction Register (IR) for decoding.</li>
    </ul>
  </li>
  <li>Instruction Decoding:
    <ul>
      <li>The CU interprets the fetched instruction from the IR.</li>
      <li>It breaks down the instruction into its constituent parts (opcode, operands) and sends control signals to other CPU components.</li>
    </ul>
  </li>
  <li>Operand Fetching:
    <ul>
      <li>If the instruction requires operands from memory or registers, the CU initiates the necessary data transfers.</li>
      <li>It interacts with the memory address register (MAR) and memory data register (MDR) to fetch data from memory.</li>
    </ul>
  </li>
  <li>Execution Control:
    <ul>
      <li>The CU generates control signals to coordinate the execution of the instruction.</li>
      <li>It activates specific functional units within the CPU, such as the ALU, to perform arithmetic, logic, or data manipulation operations.</li>
    </ul>
  </li>
  <li>Exception Handling:
    <ul>
      <li>The CU detects and handles exceptions, interrupts, or other abnormal conditions that occur during program execution.</li>
      <li>It may suspend the current instruction stream, save the current CPU state, and transfer control to an appropriate exception handler routine.</li>
    </ul>
  </li>
  <li>Synchronization and Control:
    <ul>
      <li>The CU synchronizes the activities of different CPU components and ensures that instructions are executed in the correct sequence.</li>
      <li>It generates timing signals, clock pulses, and control signals to coordinate the operation of the CPU and maintain system integrity.</li>
    </ul>
  </li>
</ol>

<h4 id="purpose-of-ir-mar-and-mdr-registers">Purpose of IR, MAR and MDR registers</h4>

<p><strong>Instruction Register (IR):</strong></p>

<ul>
  <li>After fetching an instruction from memory, the CPU places it into the IR for decoding and execution.</li>
  <li>The CU (Control Unit) interacts with the IR to decode the instruction and generate control signals for its execution.</li>
</ul>

<p><strong>Memory Address Register (MAR):</strong></p>

<ul>
  <li>When the CPU needs to read or write data or instructions from/to memory, it places the memory address into the MAR to specify the location in memory.</li>
  <li>The CU interacts with the MAR when initiating memory read or write operations. It provides the memory address to the MAR, which is used to access the desired location in memory.</li>
</ul>

<p><strong>Memory Data Register (MDR):</strong></p>

<ul>
  <li>When the CPU reads data from memory, it is stored temporarily in the MDR before being processed further. Similarly, when the CPU writes data to memory, it places the data into the MDR before it is transferred to the memory module.</li>
  <li>The CU interacts with the MDR during memory read or write operations. After fetching data from memory (or before writing data to memory), the data is transferred between the MDR and the CPU’s internal registers for processing.</li>
</ul>

<h3 id="4-registers">4. Registers</h3>

<p>Registers are small, fast storage locations within the CPU that hold data and instructions temporarily during processing.</p>

<h4 id="types-of-registers">Types of Registers</h4>

<ol>
  <li>General-Purpose Registers (GPRs):
    <ul>
      <li>Used to store temporary data and intermediate results during computation.</li>
      <li>In x86 architecture, common GPRs include EAX, EBX, ECX, and EDX.</li>
    </ul>
  </li>
  <li>Special-Purpose Registers
    <ul>
      <li>Program Counter (PC): Holds the address of the next instruction to be executed.</li>
      <li>Instruction Register (IR): Holds the current instruction being decoded and executed.</li>
      <li>Memory Address Register (MAR): Holds the memory address of data that needs to be accessed.</li>
      <li>Memory Data Register (MDR): Holds the data fetched from or to be written to memory.</li>
      <li>Instruction Register (IR): Holds the current instruction to be executed.</li>
    </ul>
  </li>
  <li>Index and Base Registers
    <ul>
      <li>Used for addressing modes, particularly in complex addressing calculations like indexed and based addressing.</li>
    </ul>
  </li>
  <li>Stack Pointer (SP) and Base Pointer (BP)
    <ul>
      <li>Used for stack operations. The SP points to the top of the stack, and the BP is often used to reference the base of the stack frame.</li>
    </ul>
  </li>
</ol>

<h3 id="5-clock">5. Clock</h3>

<p>CPU clocks generates regular electrical pulses known as clock cycleswhich synchronize the operations of the CPU and other components in the computer system. Synchronization ensures that tasks are performed in the correct order and at the right times, enabling the smooth and efficient execution of instructions.</p>

<ul>
  <li>The clock synchronizes the activities of various components within the CPU, such as the Control Unit (CU), Arithmetic Logic Unit (ALU), registers, and memory interfaces.</li>
  <li>Each stage of the instruction cycle (fetch, decode, execute, and write-back) is typically completed in one or more clock cycles, depending on the complexity of the instruction and the CPU architecture.</li>
</ul>

<h3 id="6-cache">6. Cache</h3>

<p>Cache in a CPU is a small, high-speed memory located inside the CPU or very close to it. Its main purpose is to temporarily store copies of frequently accessed data from the main memory (RAM), reducing the time it takes for the CPU to access this data.</p>

<p>The cache is significantly faster than the main memory (RAM). It’s built with a special type of memory called Static Random-Access Memory (SRAM), which offers much faster access times compared to the Dynamic Random-Access Memory (DRAM) used in RAM.</p>

<h4 id="types-of-cpu-cache">Types of CPU Cache</h4>

<ol>
  <li>L1 Cache (Level 1)
    <ul>
      <li>Typically located directly on the CPU chip.</li>
      <li>Smallest in size, ranging from a few kilobytes to tens of kilobytes.</li>
    </ul>
  </li>
  <li>L2 Cache (Level 2)
    <ul>
      <li>Larger than L1, ranging from tens of kilobytes to a few megabytes, often shared between multiple CPU cores.</li>
    </ul>
  </li>
  <li>L3 Cache (Level 3)
    <ul>
      <li>Largest and slowest cache, shared by all CPU cores in a multi-core processor.</li>
    </ul>
  </li>
</ol>

<h3 id="7-buses">7. Buses</h3>

<p>In a CPU and computer system, buses are communication pathways that transfer data between different components. These buses are critical for ensuring that data, control signals, and power are efficiently moved within the CPU and between the CPU and other parts of the computer.</p>

<h4 id="types-of-buses">Types of Buses</h4>

<ol>
  <li>Data Bus
    <ul>
      <li>Transfers data between the CPU, memory, and other peripherals.</li>
      <li>The width of the data bus (e.g., 8-bit, 16-bit, 32-bit, 64-bit) determines how much data can be transferred simultaneously. For example, a 32-bit data bus can transfer 32 bits of data at a time.</li>
      <li>Typically bidirectional, allowing data to be read from and written to memory or peripherals.</li>
    </ul>
  </li>
  <li>Address Bus
    <ul>
      <li>Carries addresses from the CPU to memory and other peripherals, indicating where data should be read from or written to.</li>
      <li>The width of the address bus determines the maximum addressable memory. For example, a 32-bit address bus can address 2<sup>32</sup> unique locations.</li>
      <li>Unidirectional, as addresses are only sent from the CPU to other components.</li>
    </ul>
  </li>
  <li>Control Bus
    <ul>
      <li>Carries control signals from the CPU to other components to coordinate and manage their operations.</li>
      <li>Control signals indicate whether data is to be read or written, when to start or stop an operation, and other control functions like interrupt requests.</li>
      <li>Typically bidirectional, as control signals can flow to and from the CPU.</li>
    </ul>
  </li>
</ol>

<h4 id="examples-of-buses-in-cpu-systems">Examples of Buses in CPU Systems</h4>

<ol>
  <li>Front-Side Bus (FSB)
    <ul>
      <li>Connects the CPU to the main memory (RAM) and the chipset.</li>
      <li>Historically, the FSB was the main pathway for data communication between the CPU and memory. Modern systems often use more complex architectures like Direct Media Interface (DMI) or HyperTransport.</li>
    </ul>
  </li>
  <li>Back-Side Bus (BSB)
    <ul>
      <li>Connects the CPU to the L2 or L3 cache.</li>
      <li>The BSB allows for high-speed communication between the CPU and its cache, improving performance.</li>
    </ul>
  </li>
  <li>System Bus
    <ul>
      <li>Combines the data, address, and control buses into a single bus that connects the CPU to memory and peripherals.</li>
      <li>This bus is used for general communication across the system, ensuring all components can interact as needed.</li>
    </ul>
  </li>
  <li>Peripheral Component Interconnect (PCI) Bus
    <ul>
      <li>Connects peripheral devices to the CPU.</li>
      <li>The PCI bus allows the CPU to communicate with hardware devices like network cards, sound cards, and graphics cards.</li>
    </ul>
  </li>
</ol>]]></content><author><name>Sanketh</name></author><category term="cpu" /><summary type="html"><![CDATA[Before learning Assembly, I think it would be useful to learn a bit about different components of CPU in general. If we think of CPU as a black box its main function is to fetch instructions from RAM which are in the form of machine code and execute them.]]></summary></entry><entry><title type="html">My Resources for Learning Operating Systems and Computer Architecture</title><link href="http://localhost:4000/blog/operating-systems/learning-resources/my-study-resources" rel="alternate" type="text/html" title="My Resources for Learning Operating Systems and Computer Architecture" /><published>2024-04-06T20:33:25+05:30</published><updated>2024-04-06T20:33:25+05:30</updated><id>http://localhost:4000/blog/operating-systems/learning-resources/my-study-resources</id><content type="html" xml:base="http://localhost:4000/blog/operating-systems/learning-resources/my-study-resources"><![CDATA[<p>I have previously studied operating systems as a part of my university curriculum, i’ve realized it’s time to revisit the fundamentals and go beyond. I have decided to start with some popular books. I will add more resources as i go along.</p>

<h4 id="text-books">Text Books</h4>

<ol>
  <li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems Three Easy Pieces</a></li>
  <li>Linux System Programming: Talking Directly to the Kernel and C Library by Robert Love</li>
  <li><a href="https://acs.pub.ro/~cpop/SMPA/Computer%20Architecture%20A%20Quantitative%20Approach%20(5th%20edition).pdf">Computer Architecture A Quantitative Approach by Hennessy and Patterson</a></li>
</ol>

<h4 id="links">Links</h4>

<ol>
  <li><a href="https://www.comp.nus.edu.sg/~adi-yoga/CS2100/ch07/">Overview of MIPS Assembly</a></li>
</ol>

<p>There are some great resources mentioned in this <a href="https://www.reddit.com/r/compsci/comments/7sdcaq/best_way_to_learn_os_concepts_properly_so_that_i/">reddit thread</a>, i’ll be exploring them as i progress</p>

<h4 id="playlists">Playlists</h4>

<ol>
  <li><a href="https://www.youtube.com/playlist?list=PLeWkeA7esB-MuCn8XQWAarM7zvimE0yme">Computer Architecture Playlists by Prof. Dr. Ben H. Juurlink</a></li>
</ol>]]></content><author><name>Sanketh</name></author><category term="operating-systems" /><category term="learning-resources" /><summary type="html"><![CDATA[I have previously studied operating systems as a part of my university curriculum, i’ve realized it’s time to revisit the fundamentals and go beyond. I have decided to start with some popular books. I will add more resources as i go along.]]></summary></entry></feed>