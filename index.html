<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.149.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sanketh's Blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://sankethbk.github.io/blog/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.35209f447ca2bd8f0aeed477774f0834b04a48cbf75605da5097d2e25b7d585a.css integrity="sha256-NSCfRHyivY8K7tR3d08INLBKSMv3VgXaUJfS4lt9WFo=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sankethbk.github.io/blog/index.xml><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Sanketh's Blog"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sanketh's Blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Sanketh's Blog","url":"https://sankethbk.github.io/blog/","description":"","logo":"https://sankethbk.github.io/blog/favicon.ico","sameAs":["https://github.com/sankethbk","https://x.com/sankethbk7777","https://thebinaryyard.substack.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>Processor Modes in x86</h2></header><div class=entry-content><p>The 8086 Processor A Brief History The Intel 8086, released in 1978, marked a pivotal moment in computing history as Intel’s first 16-bit microprocessor. Designed by a team led by Stephen Morse, the 8086 was Intel’s answer to the growing demand for more powerful processors that could handle larger programs and address more memory than the existing 8-bit chips of the era.
The processor introduced the x86 architecture that would become the foundation for decades of computing evolution. With its 16-bit registers and 20-bit address bus 1, the 8086 could access up to 1 megabyte of memory—a massive improvement over the 64KB limitation of 8-bit processors. However, it retained backward compatibility concepts that would prove both beneficial and constraining for future generations.
...</p></div><footer class=entry-footer><span title='2025-07-18 00:00:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;62 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to Processor Modes in x86" href=https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Characteristics of MBR Code</h2></header><div class=entry-content><p>BIOS Boot Recap Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the 0x55AA signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR).
...</p></div><footer class=entry-footer><span title='2025-07-12 00:00:00 +0000 UTC'>July 12, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to Characteristics of MBR Code" href=https://sankethbk.github.io/blog/posts/boot/2025-07-07-characteristics-of-mbr-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>What happens when you turn on computer?</h2></header><div class=entry-content><p>1. Power‑On & Hardware Reset 1. Power‑Good Signal The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it’s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it’s volatile.
2. CPU Reset Vector The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically 0xFFFFFFF0 (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard’s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware.
...</p></div><footer class=entry-footer><span title='2025-07-02 00:00:00 +0000 UTC'>July 2, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to What happens when you turn on computer?" href=https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Representation of Negative Numbers in Hardware</h2></header><div class=entry-content><p>Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.
...</p></div><footer class=entry-footer><span title='2024-07-21 00:00:00 +0000 UTC'>July 21, 2024</span>&nbsp;·&nbsp;12 min</footer><a class=entry-link aria-label="post link to Representation of Negative Numbers in Hardware" href=https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Overview of MIPS Assembly</h2></header><div class=entry-content><p>MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA’s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.
History The first MIPS processor, the R2000, was introduced. It implemented the MIPS I architecture, which was one of the earliest commercial RISC processors. There are multiple versions of MIPS: including MIPS I, II, III, IV, and V; as well as five releases of MIPS32/64. MIPS I had 32-bit architecture with basic instruction set and addressing modes. MIPS III introduced 64-bit architecture in 1991, increasing the address space and register width.
...</p></div><footer class=entry-footer><span title='2024-07-12 00:00:00 +0000 UTC'>July 12, 2024</span>&nbsp;·&nbsp;52 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to Overview of MIPS Assembly" href=https://sankethbk.github.io/blog/posts/cpu/2024-07-12-overview-of-mips-assembly/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>The Fetch Decode Execute Cycle</h2></header><div class=entry-content><p>The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.
What is Machine Code? Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation.
...</p></div><footer class=entry-footer><span title='2024-06-30 00:00:00 +0000 UTC'>June 30, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to The Fetch Decode Execute Cycle" href=https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Measuring CPU Performance</h2></header><div class=entry-content><p>CPU Manufacturers publish several metrics related to CPU like clock speed, number of cores, cache sizes, ISA, performance per Watt, number of transistors and more. Measuring CPU performance is complex, and it cannot be summarized by a single metric. In this post, I’ll explore each of these metrics and discuss some standard benchmarking software and their limitations.
What is Clock Speed, How does it Affects CPU Performance? All Synchronous digital electronic circuits require an externally generated time reference. This is usually a square wave signal provided to the circuit called as clock. A clock cycle is the fundamental unit of time measurement for a CPU. A clock cycle is a single electrical pulse in a CPU, during which the CPU can execute a fundamental operation such as accessing memory, writing data, or fetching a new set of instructions. A clock cycle is measured as the amount of time between two pulses of an oscillator. The clock speed of a CPU is measured in Hertz (Hz), which signifies the number of clock cycles it can complete in one second. Common units are Megahertz (MHz) and Gigahertz (GHz).
...</p></div><footer class=entry-footer><span title='2024-06-21 00:00:00 +0000 UTC'>June 21, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to Measuring CPU Performance" href=https://sankethbk.github.io/blog/posts/cpu/2024-06-21-measuring-cpu-performance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Key Differences between 32-bit and 64-bit CPU architectures</h2></header><div class=entry-content><p>The terms 32 bit and 64 bit specifically relate to the size of the data and address registers within the CPU, which determines the maximum amount of memory that can be directly accessed and the range of values that can be processed.
1. Registers and Data Width: Since all calculations take place in registers, when performing operations such as addition or subtraction, variables are loaded from memory into registers if they are not already there. A 32-bit CPU has 32-bit wide registers, meaning it can process 32 bits of data in a single instruction. 2. Memory Addressing: 32-bit CPU can address up to 232 unique memory locations translates to a maximum of 4 GB of addressable memory (RAM). 64-bit CPU can address up to 264 unique memory locations allowing for a theoretical maximum of 16 exabytes of addressable memory. This limitation comes from the fact that a 32-CPU can only load integers that are 32 bits long, thus limiting the maximum addressable memory space. 3. Data Transfer Speeds: The memory bus width in 64-bit CPU is often 64 bits or more, meaning the physical path between the CPU and RAM can handle 64 bits of data in parallel. This helps in efficiently loading data into the cache but does not restrict the CPU to always reading 64 bits. Despite the ability to handle 64 bits of data in parallel, the CPU is not restricted to always reading 64 bits at a time. It can access smaller data sizes (e.g., 8-bit, 16-bit, 32-bit) as needed, depending on the specific instruction and data type. 4. Performance: 64-bit CPU’s perform better than 32-bit CPU’s. This performance difference comes up from various factors like size of registers, addressable memory space, larger bus width Some RISC architectures support SIMD (Single Instruction, Multiple Data) instructions that allow for parallel processing of multiple smaller data types within larger registers. For example, ARM’s NEON technology can operate on multiple 32-bit integers within 64-bit registers, which enable the parallel processing of smaller data types within larger registers. 5. Application Compatibility: 64-bit operating systems typically include backward compatibility to run 32-bit software seamlessly. These compatibility layers allow 32-bit applications to execute on 64-bit systems without any major issues. However, 32-bit applications may not fully utilize the advantages of 64-bit systems, such as increased memory addressing capabilities.</p></div><footer class=entry-footer><span title='2024-06-02 00:00:00 +0000 UTC'>June 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to Key Differences between 32-bit and 64-bit CPU architectures" href=https://sankethbk.github.io/blog/posts/cpu/2024-06-02-processor-bit-size/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Components of CPU</h2></header><div class=entry-content><p>Before learning Assembly, I think it would be useful to learn a bit about different components of CPU in general. If we think of CPU as a black box its main function is to fetch instructions from RAM which are in the form of machine code and execute them.
Components of CPU Arithmetic Logic Unit (ALU) Memory Management Unit (MMU) Control Unit (CU) Registers Clock Cache Buses 1. Arithmetic Logic Unit (ALU) ALU is an electronic circuit made of NAND gates responsible for performing arithmetic and logical operations on integer binary numbers. It takes two operands as inputs and an opcode to indicate the type of operation to be performed. Operations supported by ALU are Add, Subtract, Negation, Two’s complement, AND, OR, XOR, bit shift, etc.
...</p></div><footer class=entry-footer><span title='2024-05-31 00:00:00 +0000 UTC'>May 31, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Sanketh</footer><a class=entry-link aria-label="post link to Components of CPU" href=https://sankethbk.github.io/blog/posts/cpu/2024-05-31-components-of-cpu/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>