<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>X86 on Sanketh's Blog</title><link>https://sankethbk.github.io/blog/tags/x86/</link><description>Recent content in X86 on Sanketh's Blog</description><generator>Hugo -- 0.150.0</generator><language>en-us</language><lastBuildDate>Sat, 09 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sankethbk.github.io/blog/tags/x86/index.xml" rel="self" type="application/rss+xml"/><item><title>How does CPU Communicates With Peripheral Devices</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-08-09-how-does-cpu-communicates-with-peripheral-devices/</link><pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-08-09-how-does-cpu-communicates-with-peripheral-devices/</guid><description>&lt;h1 id="introduction-the-communication-challenges"&gt;Introduction: The Communication Challenges&lt;/h1&gt;
&lt;p&gt;At its core, a CPU is designed for one primary task: processing data and executing instructions at incredible speed. But this processing power becomes meaningful only when it can interact with the rich ecosystem of peripheral devices that extend its capabilities.&lt;/p&gt;
&lt;h2 id="why-cpus-need-to-talk-to-many-different-devices"&gt;Why CPUs Need to Talk to Many Different Devices?&lt;/h2&gt;
&lt;p&gt;Your CPU must read input from your mouse or keyboard, process that input to understand your intent, communicate with memory to load the browser application, send rendering commands to your graphics card, request data from your network interface to load the webpage, and potentially write temporary files to your storage device. Each of these interactions involves a different type of peripheral device, each with its own communication requirements, data formats, and timing constraints.&lt;/p&gt;</description></item><item><title>Processor Modes in x86</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/</link><pubDate>Fri, 18 Jul 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/</guid><description>&lt;h1 id="the-8086-processor"&gt;The 8086 Processor&lt;/h1&gt;
&lt;h2 id="a-brief-history"&gt;A Brief History&lt;/h2&gt;
&lt;p&gt;The Intel 8086, released in 1978, marked a pivotal moment in computing history as Intel&amp;rsquo;s first 16-bit microprocessor. Designed by a team led by Stephen Morse, the 8086 was Intel&amp;rsquo;s answer to the growing demand for more powerful processors that could handle larger programs and address more memory than the existing 8-bit chips of the era.&lt;/p&gt;
&lt;p&gt;The processor introduced the x86 architecture that would become the foundation for decades of computing evolution. With its 16-bit registers and 20-bit address bus &lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;, the 8086 could access up to 1 megabyte of memoryâ€”a massive improvement over the 64KB limitation of 8-bit processors. However, it retained backward compatibility concepts that would prove both beneficial and constraining for future generations.&lt;/p&gt;</description></item></channel></rss>