<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>X86 on Sanketh's Blog</title><link>https://sankethbk.github.io/blog/tags/x86/</link><description>Recent content in X86 on Sanketh's Blog</description><generator>Hugo -- 0.151.0</generator><language>en-us</language><lastBuildDate>Thu, 28 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sankethbk.github.io/blog/tags/x86/index.xml" rel="self" type="application/rss+xml"/><item><title>x86 Assembly Part 1: Registers</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/</guid><description>&lt;p&gt;When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions.&lt;/p&gt;</description></item><item><title>Hello World in Real Mode</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/</link><pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/</guid><description>&lt;p&gt;When your x86 computer first starts up, it&amp;rsquo;s in a surprisingly primitive state:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No operating system&lt;/strong&gt; - Obviously, since we haven&amp;rsquo;t loaded one yet&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No memory management&lt;/strong&gt; - No virtual memory, no protection between processes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No file system&lt;/strong&gt; - Can&amp;rsquo;t open files, no directories, no abstraction layer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No network stack&lt;/strong&gt; - No TCP/IP, no internet connectivity&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No device drivers&lt;/strong&gt; - No USB drivers, no graphics drivers, nothing&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-services-are-available-at-boot-time"&gt;What Services Are Available at Boot Time?&lt;/h2&gt;
&lt;p&gt;Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:&lt;/p&gt;</description></item><item><title>How does CPU Communicates With Peripheral Devices</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-08-09-how-does-cpu-communicates-with-peripheral-devices/</link><pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-08-09-how-does-cpu-communicates-with-peripheral-devices/</guid><description>&lt;h1 id="introduction-the-communication-challenges"&gt;Introduction: The Communication Challenges&lt;/h1&gt;
&lt;p&gt;At its core, a CPU is designed for one primary task: processing data and executing instructions at incredible speed. But this processing power becomes meaningful only when it can interact with the rich ecosystem of peripheral devices that extend its capabilities.&lt;/p&gt;
&lt;h2 id="why-cpus-need-to-talk-to-many-different-devices"&gt;Why CPUs Need to Talk to Many Different Devices?&lt;/h2&gt;
&lt;p&gt;Your CPU must read input from your mouse or keyboard, process that input to understand your intent, communicate with memory to load the browser application, send rendering commands to your graphics card, request data from your network interface to load the webpage, and potentially write temporary files to your storage device. Each of these interactions involves a different type of peripheral device, each with its own communication requirements, data formats, and timing constraints.&lt;/p&gt;</description></item><item><title>Processor Modes in x86</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/</link><pubDate>Fri, 18 Jul 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/</guid><description>&lt;h1 id="the-8086-processor"&gt;The 8086 Processor&lt;/h1&gt;
&lt;h2 id="a-brief-history"&gt;A Brief History&lt;/h2&gt;
&lt;p&gt;The Intel 8086, released in 1978, marked a pivotal moment in computing history as Intel&amp;rsquo;s first 16-bit microprocessor. Designed by a team led by Stephen Morse, the 8086 was Intel&amp;rsquo;s answer to the growing demand for more powerful processors that could handle larger programs and address more memory than the existing 8-bit chips of the era.&lt;/p&gt;
&lt;p&gt;The processor introduced the x86 architecture that would become the foundation for decades of computing evolution. With its 16-bit registers and 20-bit address bus &lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;, the 8086 could access up to 1 megabyte of memory—a massive improvement over the 64KB limitation of 8-bit processors. However, it retained backward compatibility concepts that would prove both beneficial and constraining for future generations.&lt;/p&gt;</description></item></channel></rss>