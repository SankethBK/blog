<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Vulnerabilities on Sanketh's Blog</title><link>https://sankethbk.github.io/blog/tags/vulnerabilities/</link><description>Recent content in Vulnerabilities on Sanketh's Blog</description><generator>Hugo -- 0.155.3</generator><language>en-us</language><lastBuildDate>Wed, 10 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://sankethbk.github.io/blog/tags/vulnerabilities/index.xml" rel="self" type="application/rss+xml"/><item><title>Format String Vulnerability</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/</link><pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/</guid><description>&lt;h1 id="format-string-vulnerabilities"&gt;Format String Vulnerabilities&lt;/h1&gt;
&lt;h2 id="why-information-leaks-matter-in-modern-exploitation"&gt;Why Information Leaks Matter in Modern Exploitation&lt;/h2&gt;
&lt;h3 id="the-aslr-problem"&gt;The ASLR Problem&lt;/h3&gt;
&lt;p&gt;Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stack addresses change every execution&lt;/li&gt;
&lt;li&gt;Heap addresses randomized&lt;/li&gt;
&lt;li&gt;Library (libc) addresses randomized&lt;/li&gt;
&lt;li&gt;Code addresses randomized (with PIE)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;The dilemma:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)&lt;/li&gt;
&lt;li&gt;But you don&amp;rsquo;t know WHERE to point it (shellcode location unknown)&lt;/li&gt;
&lt;li&gt;Even ROP gadget addresses are randomized&lt;/li&gt;
&lt;li&gt;You need to LEAK memory addresses first!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Format string vulnerabilities are one of the most powerful information leak primitives.&lt;/p&gt;</description></item><item><title>Executing Shellcode on Stack</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-30-executing-shellcode-on-stack/</link><pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-30-executing-shellcode-on-stack/</guid><description>&lt;p&gt;Previously we saw how to overwrite the return address of stack by passing extra bytes to an unbounded buffer. But not everytime we will have a convinient function address to overwrite. The next attempt is to place the code we want to execute directly on the stack itself.&lt;/p&gt;
&lt;h1 id="embedding-shellcode-in-a-buffer-overflow"&gt;Embedding Shellcode in a Buffer Overflow&lt;/h1&gt;
&lt;h2 id="1-what-is-shellcode"&gt;1. What is Shellcode?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Shellcode is machine instructions (usually written in assembly) that perform some action — often spawning a shell (/bin/sh), but can be anything.&lt;/li&gt;
&lt;li&gt;It is called “shellcode” not because it must open a shell, but because historically it did.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-why-embed-shellcode-on-the-stack"&gt;2. Why embed shellcode on the stack?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sometimes you don’t know the address of any useful existing function.&lt;/li&gt;
&lt;li&gt;Or the binary doesn’t have functions like system(&amp;quot;/bin/sh&amp;quot;).&lt;/li&gt;
&lt;li&gt;In these cases, the attacker places their own code (shellcode) inside the same buffer that overflows. Then somehow point &lt;code&gt;$rip&lt;/code&gt; register to the location of shellcode on stack so that CPU starts executing it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3-requirements-for-embedding-shellcode"&gt;3. Requirements for embedding shellcode&lt;/h2&gt;
&lt;h3 id="1-executable-stack"&gt;1. Executable stack&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The stack must have executable permissions.&lt;/li&gt;
&lt;li&gt;Many modern systems have NX (Non-Executable) protection → stack is not executable.&lt;/li&gt;
&lt;li&gt;CPU provides setting read, write and executable permissions at individual page level which is enforced at hardware level. This feature has been there since &lt;code&gt;80286&lt;/code&gt; CPU. Executing shellcode on stack will be impossible just by marking stack pages as non-executable.&lt;/li&gt;
&lt;li&gt;For learning, we usually compile with flags &lt;code&gt;-z execstack&lt;/code&gt; which will make the stack executable.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; gcc -fno-pie -no-pie -fno-stack-protector -z execstack main.c -o vuln
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="2-enough-space-in-the-buffer"&gt;2. Enough space in the buffer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Shellcode must fit entirely inside the buffer or adjacent space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-no-null-bytes"&gt;3. No null bytes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;When injecting shellcode via string functions like gets, scanf(&amp;quot;%s&amp;quot;), strcpy, a null byte will terminate input.&lt;/li&gt;
&lt;li&gt;Shellcode must avoid 0x00, 0x0A, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="4-stack-based-shellcode-execution-a-simple-case-without-aslr"&gt;4. Stack-Based Shellcode Execution: A Simple Case Without ASLR&lt;/h2&gt;
&lt;p&gt;To build the payload of overflowed string we need to consider various factors, let&amp;rsquo;s understand it with a simple program:&lt;/p&gt;</description></item><item><title>Stack Based Buffer Overflow Attacks</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/</link><pubDate>Tue, 11 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/</guid><description>&lt;h1 id="stack-based-buffer-overflow-attacks"&gt;Stack Based Buffer Overflow Attacks&lt;/h1&gt;
&lt;p&gt;A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).&lt;/p&gt;
&lt;h2 id="causes-of-buffer-overflow-attacks-in-c"&gt;Causes of Buffer Overflow Attacks in C&lt;/h2&gt;
&lt;p&gt;When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:&lt;/p&gt;</description></item></channel></rss>