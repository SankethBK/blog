<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Sanketh's Blog</title><link>https://sankethbk.github.io/blog/</link><description>Recent content on Sanketh's Blog</description><generator>Hugo -- 0.155.3</generator><language>en-us</language><lastBuildDate>Sun, 15 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://sankethbk.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Move Picker</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/</link><pubDate>Sun, 15 Feb 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/</guid><description>&lt;h1 id="move-picker"&gt;Move Picker&lt;/h1&gt;
&lt;h2 id="stats"&gt;Stats&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// The Stats struct stores moves statistics. According to the template parameter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// the class can store History and Countermoves. History records how often
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// different moves have been successful or unsuccessful during the current search
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// and is used for reduction and move ordering decisions.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// Countermoves store the move that refute a previous one. Entries are stored
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// using only the moving piece and destination square, hence two moves with
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// different origin but same destination and piece will be considered identical.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;typename&lt;/span&gt; T, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; CM &lt;span style="color:#f92672"&gt;=&lt;/span&gt; false&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Stats&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;static&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Value Max &lt;span style="color:#f92672"&gt;=&lt;/span&gt; Value(&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;28&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; T&lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;operator&lt;/span&gt;[](Piece pc) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; { &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; table[pc]; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; T&lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;operator&lt;/span&gt;[](Piece pc) { &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; table[pc]; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;clear&lt;/span&gt;() { std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;memset(table, &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;sizeof&lt;/span&gt;(table)); }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;update&lt;/span&gt;(Piece pc, Square to, Move m) { table[pc][to] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; m; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;update&lt;/span&gt;(Piece pc, Square to, Value v) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (abs(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(v)) &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;324&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; table[pc][to] &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; table[pc][to] &lt;span style="color:#f92672"&gt;*&lt;/span&gt; abs(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(v)) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; (CM &lt;span style="color:#f92672"&gt;?&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;936&lt;/span&gt; &lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;324&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; table[pc][to] &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(v) &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;private&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; T table[PIECE_NB][SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; Stats&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;Move&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; MoveStats;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; Stats&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;Value, false&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; HistoryStats;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; Stats&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;Value, true&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; CounterMoveStats;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; Stats&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;CounterMoveStats&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; CounterMoveHistoryStats;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is a generic 2-D table indexed by (piece, destination square)&lt;/p&gt;</description></item><item><title>Transposition Tables</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/</link><pubDate>Fri, 13 Feb 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/</guid><description>&lt;h1 id="transposition-tables"&gt;Transposition Tables&lt;/h1&gt;
&lt;p&gt;The transposition table is the engine’s memory of previously analyzed positions.
Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.&lt;/p&gt;
&lt;p&gt;Stockfish stores a compact 10-byte entry per position.&lt;/p&gt;
&lt;h2 id="ttentry--what-is-stored"&gt;TTEntry — What is stored&lt;/h2&gt;
&lt;p&gt;Each entry stores just enough info to help pruning and move ordering:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;TTEntry&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;private&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;friend&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;TranspositionTable&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint16_t&lt;/span&gt; key16;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint16_t&lt;/span&gt; move16;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int16_t&lt;/span&gt; value16;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int16_t&lt;/span&gt; eval16;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint8_t&lt;/span&gt; genBound8;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int8_t&lt;/span&gt; depth8;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="c-used-here"&gt;C++ Used here&lt;/h3&gt;
&lt;h4 id="structs-in-c"&gt;Structs in C++&lt;/h4&gt;
&lt;p&gt;In C++, struct and class are almost identical, with one default difference:&lt;/p&gt;</description></item><item><title>Minmax with Alpha Beta Pruning</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/</link><pubDate>Sat, 07 Feb 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/</guid><description>&lt;h1 id="minmax-with-alpha-beta-pruning"&gt;Minmax with Alpha Beta Pruning&lt;/h1&gt;
&lt;h2 id="game-tree-search"&gt;Game Tree Search&lt;/h2&gt;
&lt;h3 id="the-goal-of-a-chess-engine"&gt;The Goal of a Chess Engine&lt;/h3&gt;
&lt;p&gt;A chess engine is solving:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Given a position, what move leads to the best possible future?”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But the engine cannot know the future, so it simulates it.&lt;/p&gt;
&lt;p&gt;This simulation is called search.&lt;/p&gt;
&lt;h3 id="the-game-tree"&gt;The Game Tree&lt;/h3&gt;
&lt;p&gt;Every legal move creates a new position.
From that position, the opponent also has moves.&lt;/p&gt;
&lt;p&gt;This forms a tree:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Position
├── Move A
│ ├── Opp Move A1
│ │ ├── Move A1a
│ │ └── Move A1b
│ └── Opp Move A2
│ └── ...
└── Move B
└── ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is called the game tree.&lt;/p&gt;</description></item><item><title>Move Generation</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/</link><pubDate>Sun, 01 Feb 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/</guid><description>&lt;h1 id="move-generation"&gt;Move Generation&lt;/h1&gt;
&lt;p&gt;Move generation is one of the core responsibilities of a chess engine: given a &lt;code&gt;Position&lt;/code&gt;, the engine must efficiently produce all possible moves available to the side to move.&lt;/p&gt;
&lt;p&gt;In Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.).&lt;/p&gt;</description></item><item><title>Static Exchange Evaluation (SEE)</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-31-see/</link><pubDate>Sat, 31 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-31-see/</guid><description>&lt;h1 id="static-exchange-evaluation-see"&gt;Static Exchange Evaluation (SEE)&lt;/h1&gt;
&lt;p&gt;SEE simulates a capture sequence on a square to calculate the net material gain/loss. It asks: &amp;ldquo;If I make this move and we trade pieces on this square, will I gain at least &lt;code&gt;v&lt;/code&gt; centipawns?&amp;rdquo;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// Position::see_ge (Static Exchange Evaluation Greater or Equal) tests if the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// SEE value of move is greater or equal to the given value. We&amp;#39;ll use an
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// algorithm similar to alpha-beta pruning with a null window.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;::&lt;/span&gt;see_ge(Move m, Value v) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(is_ok(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Castling moves are implemented as king capturing the rook so cannot be
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// handled correctly. Simply assume the SEE value is VALUE_ZERO that is always
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// correct unless in the rare case the rook ends up under attack.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; CASTLING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; VALUE_ZERO &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; v;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square from &lt;span style="color:#f92672"&gt;=&lt;/span&gt; from_sq(m), to &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; PieceType nextVictim &lt;span style="color:#f92672"&gt;=&lt;/span&gt; type_of(piece_on(from));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color stm &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;color_of(piece_on(from)); &lt;span style="color:#75715e"&gt;// First consider opponent&amp;#39;s move
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Value balance; &lt;span style="color:#75715e"&gt;// Values of the pieces taken by us minus opponent&amp;#39;s ones
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard occupied, stmAttackers;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occupied &lt;span style="color:#f92672"&gt;=&lt;/span&gt; SquareBB[to &lt;span style="color:#f92672"&gt;-&lt;/span&gt; pawn_push(&lt;span style="color:#f92672"&gt;~&lt;/span&gt;stm)]; &lt;span style="color:#75715e"&gt;// Remove the captured pawn
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; balance &lt;span style="color:#f92672"&gt;=&lt;/span&gt; PieceValue[MG][PAWN];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; balance &lt;span style="color:#f92672"&gt;=&lt;/span&gt; PieceValue[MG][piece_on(to)];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occupied &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (balance &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; v)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; false;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (nextVictim &lt;span style="color:#f92672"&gt;==&lt;/span&gt; KING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; balance &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; PieceValue[MG][nextVictim];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (balance &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; v)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; true;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; relativeStm &lt;span style="color:#f92672"&gt;=&lt;/span&gt; true; &lt;span style="color:#75715e"&gt;// True if the opponent is to move
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; occupied &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; pieces() &lt;span style="color:#f92672"&gt;^&lt;/span&gt; from &lt;span style="color:#f92672"&gt;^&lt;/span&gt; to;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Find all attackers to the destination square, with the moving piece removed,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// but possibly an X-ray attacker added behind it.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard attackers &lt;span style="color:#f92672"&gt;=&lt;/span&gt; attackers_to(to, occupied) &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; occupied;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (true)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; stmAttackers &lt;span style="color:#f92672"&gt;=&lt;/span&gt; attackers &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pieces(stm);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Don&amp;#39;t allow pinned pieces to attack pieces except the king as long all
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// pinners are on their original square.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#f92672"&gt;!&lt;/span&gt;(st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pinnersForKing[stm] &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;occupied))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; stmAttackers &lt;span style="color:#f92672"&gt;&amp;amp;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;blockersForKing[stm];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (&lt;span style="color:#f92672"&gt;!&lt;/span&gt;stmAttackers)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; relativeStm;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Locate and remove the next least valuable attacker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; nextVictim &lt;span style="color:#f92672"&gt;=&lt;/span&gt; min_attacker&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PAWN&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(byTypeBB, to, stmAttackers, occupied, attackers);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (nextVictim &lt;span style="color:#f92672"&gt;==&lt;/span&gt; KING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; relativeStm &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt;(attackers &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pieces(&lt;span style="color:#f92672"&gt;~&lt;/span&gt;stm));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; balance &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; relativeStm &lt;span style="color:#f92672"&gt;?&lt;/span&gt; PieceValue[MG][nextVictim]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&lt;/span&gt;PieceValue[MG][nextVictim];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; relativeStm &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;!&lt;/span&gt;relativeStm;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (relativeStm &lt;span style="color:#f92672"&gt;==&lt;/span&gt; (balance &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; v))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; relativeStm;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; stm &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;stm;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="the-algorithm"&gt;The Algorithm&lt;/h2&gt;
&lt;h3 id="1-setup-phase"&gt;1. Setup Phase:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(is_ok(m));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Debug check: Verify the move is legal/valid before proceeding.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Castling moves are implemented as king capturing the rook so cannot be
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// handled correctly. Simply assume the SEE value is VALUE_ZERO that is always
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// correct unless in the rare case the rook ends up under attack.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; CASTLING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;return&lt;/span&gt; VALUE_ZERO &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; v;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Castling special case: Internally, castling is coded as &amp;ldquo;king captures own rook,&amp;rdquo; which would confuse the SEE algorithm. Just assume SEE = 0 for castling moves (safe assumption since you&amp;rsquo;re not actually capturing anything).&lt;/p&gt;</description></item><item><title>Magic Bitboards and PEXT</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/</link><pubDate>Thu, 29 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/</guid><description>&lt;h1 id="magic-bitboards-and-pext"&gt;Magic Bitboards and PEXT&lt;/h1&gt;
&lt;h2 id="the-problem-sliding-piece-attacks"&gt;The Problem: Sliding Piece Attacks&lt;/h2&gt;
&lt;h3 id="why-sliding-pieces-are-hard"&gt;Why Sliding Pieces Are Hard&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Non-sliding pieces (knight, king, pawn):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fixed attack pattern regardless of board state&lt;/li&gt;
&lt;li&gt;Can pre-compute all attacks at startup&lt;/li&gt;
&lt;li&gt;Simple lookup: &lt;code&gt;StepAttacksBB[piece][square]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Sliding pieces (rook, bishop, queen):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attack pattern depends on blocking pieces&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t pre-compute all possibilities (too many combinations)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="the-challenge"&gt;The Challenge&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Rook on e4 - different scenarios:
Scenario 1: Empty board
8 . . . . X . . .
7 . . . . X . . .
6 . . . . X . . .
5 . . . . X . . .
4 X X X X R X X X ← Attacks entire rank and file
3 . . . . X . . .
2 . . . . X . . .
1 . . . . X . . .
a b c d e f g h
Scenario 2: Blocked by pieces
8 . . . . . . . .
7 . . . . . . . .
6 . . . . X . . .
5 . . . . X . . .
4 . . X X R X . . ← Blocked at c4 and f4
3 . . . . X . . .
2 . . . . . . . .
1 . . . . . . . .
a b c d e f g h
(Pieces at: c4, e2, e6, f4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The question: How do we efficiently compute attacks for ANY occupancy pattern?&lt;/p&gt;</description></item><item><title>PSQT (Piece-Square Tables)</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-25-psqt/</link><pubDate>Sun, 25 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-25-psqt/</guid><description>&lt;h1 id="psqt-piece-square-tables"&gt;PSQT (Piece-Square Tables)&lt;/h1&gt;
&lt;h2 id="1-what-is-psqt"&gt;1. What is PSQT?&lt;/h2&gt;
&lt;p&gt;It is a traditional evaluation technique where every piece gets:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a base material value (pawn = 100, queen = 900…)&lt;/li&gt;
&lt;li&gt;plus a square bonus/penalty depending on where it stands&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example intuition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Knights are better in the center → bonus on d4/e4&lt;/li&gt;
&lt;li&gt;Pawns advanced are better → bonus on 6th/7th rank&lt;/li&gt;
&lt;li&gt;King is safer in corner early → penalty for being central in middlegame&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So evaluation includes:&lt;/p&gt;</description></item><item><title>Game Mechanics</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/</link><pubDate>Mon, 12 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/</guid><description>&lt;p&gt;We will go through some of the functions which are part of core game mechanics&lt;/p&gt;
&lt;h1 id="game-mechanics"&gt;Game Mechanics&lt;/h1&gt;
&lt;h2 id="1-piece-movement"&gt;1. Piece Movement&lt;/h2&gt;
&lt;h3 id="1-do_move"&gt;1. do_move&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Purpose&lt;/strong&gt;: Execute a move and update all position state incrementally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Critical for performance&lt;/strong&gt;: This function is called &lt;strong&gt;millions of times per second&lt;/strong&gt; during search. Every optimization matters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Preconditions&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Move &lt;code&gt;m&lt;/code&gt; must be &lt;strong&gt;legal&lt;/strong&gt; (pseudo-legal moves should be filtered first)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newSt&lt;/code&gt; must be a &lt;strong&gt;different&lt;/strong&gt; StateInfo object than current state&lt;/li&gt;
&lt;li&gt;Caller provides &lt;code&gt;givesCheck&lt;/code&gt; flag (optional optimization to avoid recalculating)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="function-structure-overview"&gt;Function Structure Overview&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Setup and assertions&lt;/li&gt;
&lt;li&gt;Copy old state → new state&lt;/li&gt;
&lt;li&gt;Increment counters&lt;/li&gt;
&lt;li&gt;Handle castling (special case)&lt;/li&gt;
&lt;li&gt;Handle captures&lt;/li&gt;
&lt;li&gt;Update position hash&lt;/li&gt;
&lt;li&gt;Reset en passant&lt;/li&gt;
&lt;li&gt;Update castling rights&lt;/li&gt;
&lt;li&gt;Move the piece&lt;/li&gt;
&lt;li&gt;Handle pawn moves (en passant, promotion)&lt;/li&gt;
&lt;li&gt;Update incremental scores&lt;/li&gt;
&lt;li&gt;Finalize state&lt;/li&gt;
&lt;li&gt;Flip side to move&lt;/li&gt;
&lt;li&gt;Compute check info&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// Position::do_move() makes a move, and saves all information necessary
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// to a StateInfo object. The move is assumed to be legal. Pseudo-legal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;/// moves should be filtered out before this function is called.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;::&lt;/span&gt;do_move(Move m, StateInfo&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; newSt, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; givesCheck) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(is_ok(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;nodes;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key k &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;key &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;side;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Copy some fields of the old state to our new StateInfo object except the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// ones which are going to be recalculated from scratch anyway and then switch
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// our state pointer to point to the new (ready to be updated) state.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;memcpy(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt, st, offsetof(StateInfo, key));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; newSt.previous &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Increment ply counters. In particular, rule50 will be reset to zero later on
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// in case of a capture or a pawn move.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;gamePly;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pliesFromNull;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color us &lt;span style="color:#f92672"&gt;=&lt;/span&gt; sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color them &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;us;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square from &lt;span style="color:#f92672"&gt;=&lt;/span&gt; from_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square to &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece pc &lt;span style="color:#f92672"&gt;=&lt;/span&gt; piece_on(from);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece captured &lt;span style="color:#f92672"&gt;=&lt;/span&gt; type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT &lt;span style="color:#f92672"&gt;?&lt;/span&gt; make_piece(them, PAWN) &lt;span style="color:#f92672"&gt;:&lt;/span&gt; piece_on(to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(color_of(pc) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; us);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(captured &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NO_PIECE &lt;span style="color:#f92672"&gt;||&lt;/span&gt; color_of(captured) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; CASTLING &lt;span style="color:#f92672"&gt;?&lt;/span&gt; them : us));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(type_of(captured) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; KING);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; CASTLING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(pc &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(us, KING));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(captured &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(us, ROOK));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square rfrom, rto;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; do_castling&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;true&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(us, from, to, rfrom, rto);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rto] &lt;span style="color:#f92672"&gt;-&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rfrom];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rfrom] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][rto];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; captured &lt;span style="color:#f92672"&gt;=&lt;/span&gt; NO_PIECE;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (captured)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square capsq &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// If the captured piece is a pawn, update pawn hash key, otherwise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// update non-pawn material.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(captured) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; PAWN)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; capsq &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; pawn_push(us);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(pc &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(us, PAWN));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(to &lt;span style="color:#f92672"&gt;==&lt;/span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(relative_rank(us, to) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; RANK_6);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(piece_on(to) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NO_PIECE);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(piece_on(capsq) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; make_piece(them, PAWN));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; board[capsq] &lt;span style="color:#f92672"&gt;=&lt;/span&gt; NO_PIECE; &lt;span style="color:#75715e"&gt;// Not done by remove_piece()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][capsq];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;nonPawnMaterial[them] &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; PieceValue[MG][captured];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update board and piece lists
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; remove_piece(captured, capsq);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update material hash key and prefetch access to materialTable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][capsq];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][pieceCount[captured]];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; prefetch(thisThread&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialTable[st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialKey]);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update incremental scores
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;-=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[captured][capsq];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Reset rule 50 counter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update hash key
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][from] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Reset en passant square
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; SQ_NONE)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;enpassant[file_of(st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare)];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare &lt;span style="color:#f92672"&gt;=&lt;/span&gt; SQ_NONE;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update castling rights if needed
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;castlingRights &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (castlingRightsMask[from] &lt;span style="color:#f92672"&gt;|&lt;/span&gt; castlingRightsMask[to]))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; cr &lt;span style="color:#f92672"&gt;=&lt;/span&gt; castlingRightsMask[from] &lt;span style="color:#f92672"&gt;|&lt;/span&gt; castlingRightsMask[to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;castling[st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;castlingRights &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; cr];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;castlingRights &lt;span style="color:#f92672"&gt;&amp;amp;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;cr;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Move the piece. The tricky Chess960 castling is handled earlier
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; CASTLING)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; move_piece(pc, from, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// If the moving piece is a pawn do some special extra work
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; (type_of(pc) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; PAWN)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Set en-passant square if the moved pawn can be captured
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; ( (&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(to) &lt;span style="color:#f92672"&gt;^&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;(from)) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (attacks_from&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PAWN&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(to &lt;span style="color:#f92672"&gt;-&lt;/span&gt; pawn_push(us), us) &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pieces(them, PAWN)))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (from &lt;span style="color:#f92672"&gt;+&lt;/span&gt; to) &lt;span style="color:#f92672"&gt;/&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;enpassant[file_of(st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;epSquare)];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;if&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; PROMOTION)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece promotion &lt;span style="color:#f92672"&gt;=&lt;/span&gt; make_piece(us, promotion_type(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(relative_rank(us, to) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; RANK_8);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(type_of(promotion) &lt;span style="color:#f92672"&gt;&amp;gt;=&lt;/span&gt; KNIGHT &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; type_of(promotion) &lt;span style="color:#f92672"&gt;&amp;lt;=&lt;/span&gt; QUEEN);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; remove_piece(pc, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; put_piece(promotion, to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update hash keys
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; k &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[promotion][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;materialKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[promotion][pieceCount[promotion]&lt;span style="color:#f92672"&gt;-&lt;/span&gt;&lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][pieceCount[pc]];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update incremental score
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[promotion][to] &lt;span style="color:#f92672"&gt;-&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update material
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;nonPawnMaterial[us] &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PieceValue[MG][promotion];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update pawn hash key and prefetch access to pawnsTable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey &lt;span style="color:#f92672"&gt;^=&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][from] &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; prefetch(thisThread&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnsTable[st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pawnKey]);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Reset rule 50 draw counter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update incremental scores
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;psq &lt;span style="color:#f92672"&gt;+=&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][to] &lt;span style="color:#f92672"&gt;-&lt;/span&gt; PSQT&lt;span style="color:#f92672"&gt;::&lt;/span&gt;psq[pc][from];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Set capture piece
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;capturedPiece &lt;span style="color:#f92672"&gt;=&lt;/span&gt; captured;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update the key with the final value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;key &lt;span style="color:#f92672"&gt;=&lt;/span&gt; k;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Calculate checkers bitboard (if move gives check)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;checkersBB &lt;span style="color:#f92672"&gt;=&lt;/span&gt; givesCheck &lt;span style="color:#f92672"&gt;?&lt;/span&gt; attackers_to(square&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;KING&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;(them)) &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pieces(us) &lt;span style="color:#f92672"&gt;:&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; sideToMove &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Update king attacks used for fast check detection
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; set_check_info(st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; assert(pos_is_ok());
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="phase-1-sanity-checks-and-bookkeeping"&gt;Phase 1: Sanity checks and bookkeeping&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(is_ok(m));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;nodes;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Key k &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;key &lt;span style="color:#f92672"&gt;^&lt;/span&gt; Zobrist&lt;span style="color:#f92672"&gt;::&lt;/span&gt;side;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Ensures the move encoding is valid&lt;/li&gt;
&lt;li&gt;Ensures we don’t overwrite the current state&lt;/li&gt;
&lt;li&gt;Increments node counter (used for search statistics)&lt;/li&gt;
&lt;li&gt;Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="phase-2-stateinfo-chaining-undo-mechanism"&gt;Phase 2: StateInfo chaining (undo mechanism)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;memcpy(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt, st, offsetof(StateInfo, key));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;newSt.previous &lt;span style="color:#f92672"&gt;=&lt;/span&gt; st;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;st &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;newSt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Copies all fields up to key&lt;/li&gt;
&lt;li&gt;Fields after key will be recomputed&lt;/li&gt;
&lt;li&gt;Links the new state to the previous one (stack-style undo)&lt;/li&gt;
&lt;li&gt;Advances the st pointer&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="phase-3-ply-counters"&gt;Phase 3: Ply counters&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;gamePly;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;rule50;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;++&lt;/span&gt;st&lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;pliesFromNull;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;gamePly: depth from game start&lt;/li&gt;
&lt;li&gt;rule50: increments unless reset later&lt;/li&gt;
&lt;li&gt;pliesFromNull: prevents consecutive null moves&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="phase-4-decode-move-and-involved-pieces"&gt;Phase 4: Decode move and involved pieces&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Color us &lt;span style="color:#f92672"&gt;=&lt;/span&gt; sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Color them &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;~&lt;/span&gt;us;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Square from &lt;span style="color:#f92672"&gt;=&lt;/span&gt; from_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Square to &lt;span style="color:#f92672"&gt;=&lt;/span&gt; to_sq(m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Piece pc &lt;span style="color:#f92672"&gt;=&lt;/span&gt; piece_on(from);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Piece captured &lt;span style="color:#f92672"&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; type_of(m) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; ENPASSANT &lt;span style="color:#f92672"&gt;?&lt;/span&gt; make_piece(them, PAWN) &lt;span style="color:#f92672"&gt;:&lt;/span&gt; piece_on(to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(color_of(pc) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; us);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(captured &lt;span style="color:#f92672"&gt;==&lt;/span&gt; NO_PIECE &lt;span style="color:#f92672"&gt;||&lt;/span&gt; color_of(captured) &lt;span style="color:#f92672"&gt;==&lt;/span&gt; (type_of(m) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; CASTLING &lt;span style="color:#f92672"&gt;?&lt;/span&gt; them : us));
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;assert(type_of(captured) &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; KING);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Determines moving side&lt;/li&gt;
&lt;li&gt;Determines source and destination squares&lt;/li&gt;
&lt;li&gt;Determines captured piece (special handling for en passant)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Assertions ensure:&lt;/p&gt;</description></item><item><title>Zobrist Hashing</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/</link><pubDate>Sat, 10 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/</guid><description>&lt;h1 id="zobrist-hashing"&gt;Zobrist Hashing&lt;/h1&gt;
&lt;h2 id="what-problem-zobrist-hashing-solves"&gt;What problem Zobrist hashing solves&lt;/h2&gt;
&lt;p&gt;In a chess engine, we constantly need to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identify identical positions reached via different move orders&lt;/li&gt;
&lt;li&gt;Detect threefold repetition&lt;/li&gt;
&lt;li&gt;Cache evaluations in a transposition table (TT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Comparing full board state is too slow&lt;/li&gt;
&lt;li&gt;Copying board state is too expensive&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-core-idea"&gt;The Core Idea&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt; Convert a chess position into a single 64-bit number (the &amp;ldquo;hash&amp;rdquo; or &amp;ldquo;key&amp;rdquo;) that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Uniquely identifies the position (with very high probability)&lt;/li&gt;
&lt;li&gt;Can be incrementally updated when making moves&lt;/li&gt;
&lt;li&gt;Enables O(1) position comparison&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="what-a-zobrist-key-represents"&gt;What a Zobrist key represents&lt;/h2&gt;
&lt;p&gt;A Zobrist key is a 64-bit integer (Key in Stockfish) representing:&lt;/p&gt;</description></item><item><title>Representation of The Game State</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/</link><pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/</guid><description>&lt;h1 id="representation-of-the-game-state"&gt;Representation of The Game State&lt;/h1&gt;
&lt;h2 id="the-position-class"&gt;The Position Class&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Position&lt;/code&gt; class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Position&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;public&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;static&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; init();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position() &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;operator&lt;/span&gt;&lt;span style="color:#f92672"&gt;=&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// FEN string input/output
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; set(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;string&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; fenStr, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; isChess960, StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; si, Thread&lt;span style="color:#f92672"&gt;*&lt;/span&gt; th);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; std&lt;span style="color:#f92672"&gt;::&lt;/span&gt;string fen() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Position representation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(PieceType pt) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(PieceType pt1, PieceType pt2) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(Color c, PieceType pt) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pieces&lt;/span&gt;(Color c, PieceType pt1, PieceType pt2) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece &lt;span style="color:#a6e22e"&gt;piece_on&lt;/span&gt;(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square &lt;span style="color:#a6e22e"&gt;ep_square&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;empty&lt;/span&gt;(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType Pt&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; count(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType Pt&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Square&lt;span style="color:#f92672"&gt;*&lt;/span&gt; squares(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType Pt&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; Square square(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Castling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;can_castle&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;can_castle&lt;/span&gt;(CastlingRight cr) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;castling_impeded&lt;/span&gt;(CastlingRight cr) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square &lt;span style="color:#a6e22e"&gt;castling_rook_square&lt;/span&gt;(CastlingRight cr) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Checking
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;checkers&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;discovered_check_candidates&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;pinned_pieces&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;check_squares&lt;/span&gt;(PieceType pt) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Attacks to/from a given square
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;attackers_to&lt;/span&gt;(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;attackers_to&lt;/span&gt;(Square s, Bitboard occupied) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;attacks_from&lt;/span&gt;(Piece pc, Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; Bitboard attacks_from(Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;PieceType&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt; Bitboard attacks_from(Square s, Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard &lt;span style="color:#a6e22e"&gt;slider_blockers&lt;/span&gt;(Bitboard sliders, Square s, Bitboard&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; pinners) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Properties of moves
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;legal&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pseudo_legal&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;capture&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;capture_or_promotion&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;gives_check&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;advanced_pawn_push&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece &lt;span style="color:#a6e22e"&gt;moved_piece&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece &lt;span style="color:#a6e22e"&gt;captured_piece&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Piece specific
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pawn_passed&lt;/span&gt;(Color c, Square s) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;opposite_bishops&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Doing and undoing moves
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;do_move&lt;/span&gt;(Move m, StateInfo&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; st, &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; givesCheck);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;undo_move&lt;/span&gt;(Move m);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;do_null_move&lt;/span&gt;(StateInfo&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; st);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;undo_null_move&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Static Exchange Evaluation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;see_ge&lt;/span&gt;(Move m, Value value) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Accessing hash keys
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;key&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;key_after&lt;/span&gt;(Move m) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;material_key&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Key &lt;span style="color:#a6e22e"&gt;pawn_key&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Other properties of the position
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color &lt;span style="color:#a6e22e"&gt;side_to_move&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Phase &lt;span style="color:#a6e22e"&gt;game_phase&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;game_ply&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;is_chess960&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Thread&lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;this_thread&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint64_t&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;nodes_searched&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;is_draw&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;rule50_count&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Score &lt;span style="color:#a6e22e"&gt;psq_score&lt;/span&gt;() &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Value &lt;span style="color:#a6e22e"&gt;non_pawn_material&lt;/span&gt;(Color c) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Position consistency check, for debugging
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;pos_is_ok&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;int&lt;/span&gt;&lt;span style="color:#f92672"&gt;*&lt;/span&gt; failedStep &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;nullptr&lt;/span&gt;) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;flip&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;private&lt;/span&gt;&lt;span style="color:#f92672"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Initialization helpers (used while setting up a position)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; set_castling_right(Color c, Square rfrom);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;set_state&lt;/span&gt;(StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; si) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;set_check_info&lt;/span&gt;(StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; si) &lt;span style="color:#66d9ef"&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Other helpers
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;put_piece&lt;/span&gt;(Piece pc, Square s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;remove_piece&lt;/span&gt;(Piece pc, Square s);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;move_piece&lt;/span&gt;(Piece pc, Square from, Square to);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;template&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; Do&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;void&lt;/span&gt; do_castling(Color us, Square from, Square&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; to, Square&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; rfrom, Square&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; rto);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// Data members
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Piece board[SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard byTypeBB[PIECE_TYPE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard byColorBB[COLOR_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; pieceCount[PIECE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square pieceList[PIECE_NB][&lt;span style="color:#ae81ff"&gt;16&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; index[SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; castlingRightsMask[SQUARE_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Square castlingRookSquare[CASTLING_RIGHT_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Bitboard castlingPath[CASTLING_RIGHT_NB];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;uint64_t&lt;/span&gt; nodes;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; gamePly;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Color sideToMove;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; Thread&lt;span style="color:#f92672"&gt;*&lt;/span&gt; thisThread;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; StateInfo&lt;span style="color:#f92672"&gt;*&lt;/span&gt; st;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;bool&lt;/span&gt; chess960;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="class-design-decisions"&gt;Class Design Decisions&lt;/h3&gt;
&lt;h4 id="1-non-copyable"&gt;1. Non-Copyable&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Position(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;operator&lt;/span&gt;&lt;span style="color:#f92672"&gt;=&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;const&lt;/span&gt; Position&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;delete&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Cannot be copied (copy constructor and assignment deleted)&lt;/li&gt;
&lt;li&gt;Why? Positions are heavy objects with complex state&lt;/li&gt;
&lt;li&gt;Must be moved or passed by reference/pointer&lt;/li&gt;
&lt;li&gt;Prevents accidental expensive copies&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-default-constructor"&gt;2. Default Constructor&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Position() &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Creates uninitialized position&lt;/li&gt;
&lt;li&gt;Must call &lt;code&gt;set()&lt;/code&gt; to initialize with FEN string&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="core-data-members"&gt;Core Data Members&lt;/h3&gt;
&lt;h4 id="1-board-representation---mailbox"&gt;1. Board Representation - MailBox&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Piece board[SQUARE_NB]; &lt;span style="color:#75715e"&gt;// SQUARE_NB = 64
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Mailbox representation: Direct lookup &amp;ldquo;what piece is on square X?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;board[e4]&lt;/code&gt; → returns &lt;code&gt;W_KNIGHT&lt;/code&gt; or &lt;code&gt;NO_PIECE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Fast for: &amp;ldquo;piece_on(Square s)&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-bitboard-representation"&gt;2. Bitboard Representation&lt;/h4&gt;
&lt;p&gt;Technically we need 12 bitboards to represent the all the pieces on chessboard.&lt;/p&gt;</description></item><item><title>C++ Used in Stockfish</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/</link><pubDate>Mon, 05 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/</guid><description>&lt;h1 id="c-used-in-stockfish"&gt;C++ Used in Stockfish&lt;/h1&gt;
&lt;p&gt;Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.&lt;/p&gt;
&lt;h2 id="enums-as-core-types"&gt;Enums as Core Types&lt;/h2&gt;
&lt;p&gt;Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values.&lt;/p&gt;</description></item><item><title>Bitboard representation of Chess Board</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/</link><pubDate>Sun, 04 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/</guid><description>&lt;h2 id="bitboard-based-game-representation-in-stockfish"&gt;Bitboard-Based Game Representation in Stockfish&lt;/h2&gt;
&lt;p&gt;Stockfish represents the chessboard using &lt;strong&gt;bitboards&lt;/strong&gt;: 64-bit unsigned integers where each bit corresponds to a square on the board.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;typedef&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;uint64_t&lt;/span&gt; Bitboard;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Bit 0 (LSB) → &lt;strong&gt;A1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Bit 63 (MSB) → &lt;strong&gt;H8&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="piece-encoding"&gt;Piece Encoding&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;enum&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Piece&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; NO_PIECE,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; W_PAWN &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; B_PAWN &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;9&lt;/span&gt;, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; PIECE_NB &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;16&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="numeric-structure"&gt;Numeric Structure&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Piece&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Binary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;W_PAWN&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;W_KING&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;0110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B_PAWN&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;1001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B_KING&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;1110&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Key observations:&lt;/p&gt;</description></item><item><title>History of Chess Engines</title><link>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-02-claude-shannons-paper/</link><pubDate>Fri, 02 Jan 2026 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/chess_engine/2026-01-02-claude-shannons-paper/</guid><description>&lt;h1 id="history-of-chess-engines"&gt;History of Chess Engines&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://vision.unipv.it/IA1/ProgrammingaComputerforPlayingChess.pdf"&gt;Programming a Computer for Playing Chess (1950) by Claude Shannon&lt;/a&gt; is the foundational paper of computer chess and one of the earliest works in artificial intelligence. Written at a time when programmable computers were still experimental, the paper does not attempt to build a chess program, but instead asks a deeper question: what would it even mean for a machine to play chess intelligently under severe computational limits? Shannon shows that perfect play is theoretically possible but practically impossible, and develops a principled framework based on approximate evaluation, game-tree search, selectivity, and bounded rationality. Nearly every major idea used in modern chess engines—minimax, heuristic evaluation, quiescence, selective search, opening books, randomness, and even learning—appears here in conceptual form. The paper remains important not as a historical curiosity, but because it correctly identifies the permanent constraints and core ideas that still govern strong chess-playing programs today.&lt;/p&gt;</description></item><item><title>Format String Vulnerability</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/</link><pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/</guid><description>&lt;h1 id="format-string-vulnerabilities"&gt;Format String Vulnerabilities&lt;/h1&gt;
&lt;h2 id="why-information-leaks-matter-in-modern-exploitation"&gt;Why Information Leaks Matter in Modern Exploitation&lt;/h2&gt;
&lt;h3 id="the-aslr-problem"&gt;The ASLR Problem&lt;/h3&gt;
&lt;p&gt;Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stack addresses change every execution&lt;/li&gt;
&lt;li&gt;Heap addresses randomized&lt;/li&gt;
&lt;li&gt;Library (libc) addresses randomized&lt;/li&gt;
&lt;li&gt;Code addresses randomized (with PIE)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;The dilemma:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)&lt;/li&gt;
&lt;li&gt;But you don&amp;rsquo;t know WHERE to point it (shellcode location unknown)&lt;/li&gt;
&lt;li&gt;Even ROP gadget addresses are randomized&lt;/li&gt;
&lt;li&gt;You need to LEAK memory addresses first!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Format string vulnerabilities are one of the most powerful information leak primitives.&lt;/p&gt;</description></item><item><title>Executing Shellcode on Stack</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-30-executing-shellcode-on-stack/</link><pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-30-executing-shellcode-on-stack/</guid><description>&lt;p&gt;Previously we saw how to overwrite the return address of stack by passing extra bytes to an unbounded buffer. But not everytime we will have a convinient function address to overwrite. The next attempt is to place the code we want to execute directly on the stack itself.&lt;/p&gt;
&lt;h1 id="embedding-shellcode-in-a-buffer-overflow"&gt;Embedding Shellcode in a Buffer Overflow&lt;/h1&gt;
&lt;h2 id="1-what-is-shellcode"&gt;1. What is Shellcode?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Shellcode is machine instructions (usually written in assembly) that perform some action — often spawning a shell (/bin/sh), but can be anything.&lt;/li&gt;
&lt;li&gt;It is called “shellcode” not because it must open a shell, but because historically it did.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-why-embed-shellcode-on-the-stack"&gt;2. Why embed shellcode on the stack?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sometimes you don’t know the address of any useful existing function.&lt;/li&gt;
&lt;li&gt;Or the binary doesn’t have functions like system(&amp;quot;/bin/sh&amp;quot;).&lt;/li&gt;
&lt;li&gt;In these cases, the attacker places their own code (shellcode) inside the same buffer that overflows. Then somehow point &lt;code&gt;$rip&lt;/code&gt; register to the location of shellcode on stack so that CPU starts executing it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3-requirements-for-embedding-shellcode"&gt;3. Requirements for embedding shellcode&lt;/h2&gt;
&lt;h3 id="1-executable-stack"&gt;1. Executable stack&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The stack must have executable permissions.&lt;/li&gt;
&lt;li&gt;Many modern systems have NX (Non-Executable) protection → stack is not executable.&lt;/li&gt;
&lt;li&gt;CPU provides setting read, write and executable permissions at individual page level which is enforced at hardware level. This feature has been there since &lt;code&gt;80286&lt;/code&gt; CPU. Executing shellcode on stack will be impossible just by marking stack pages as non-executable.&lt;/li&gt;
&lt;li&gt;For learning, we usually compile with flags &lt;code&gt;-z execstack&lt;/code&gt; which will make the stack executable.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; gcc -fno-pie -no-pie -fno-stack-protector -z execstack main.c -o vuln
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="2-enough-space-in-the-buffer"&gt;2. Enough space in the buffer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Shellcode must fit entirely inside the buffer or adjacent space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-no-null-bytes"&gt;3. No null bytes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;When injecting shellcode via string functions like gets, scanf(&amp;quot;%s&amp;quot;), strcpy, a null byte will terminate input.&lt;/li&gt;
&lt;li&gt;Shellcode must avoid 0x00, 0x0A, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="4-stack-based-shellcode-execution-a-simple-case-without-aslr"&gt;4. Stack-Based Shellcode Execution: A Simple Case Without ASLR&lt;/h2&gt;
&lt;p&gt;To build the payload of overflowed string we need to consider various factors, let&amp;rsquo;s understand it with a simple program:&lt;/p&gt;</description></item><item><title>CTF – 3 : 45exiles Shuffle</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/</link><pubDate>Fri, 14 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/</guid><description>&lt;h1 id="ctf-writeup-45exiles-shuffle-challenge"&gt;CTF Writeup: 45exiles Shuffle Challenge&lt;/h1&gt;
&lt;h2 id="problem-overview"&gt;Problem Overview&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Challenge Name&lt;/strong&gt;: 45exiles Shuffle&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Core Mechanism&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Program reads user input&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shuffles the input&lt;/strong&gt; using &lt;code&gt;rand()&lt;/code&gt; with a known seed&lt;/li&gt;
&lt;li&gt;Compares the shuffled input against a target string stored in memory&lt;/li&gt;
&lt;li&gt;If they match, you get the flag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Key Insight&lt;/strong&gt;: You can read the target (shuffled) string from memory, but that&amp;rsquo;s NOT the answer you need to input. You must &lt;strong&gt;reverse the shuffle&lt;/strong&gt; to find the original input.&lt;/p&gt;</description></item><item><title>Stack Based Buffer Overflow Attacks</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/</link><pubDate>Tue, 11 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/</guid><description>&lt;h1 id="stack-based-buffer-overflow-attacks"&gt;Stack Based Buffer Overflow Attacks&lt;/h1&gt;
&lt;p&gt;A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).&lt;/p&gt;
&lt;h2 id="causes-of-buffer-overflow-attacks-in-c"&gt;Causes of Buffer Overflow Attacks in C&lt;/h2&gt;
&lt;p&gt;When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:&lt;/p&gt;</description></item><item><title>CTF – 2 : Good Kitty</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-08-ctf-2/</link><pubDate>Sun, 09 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-08-ctf-2/</guid><description>&lt;h1 id="ctf-challenge-good-kitty---writeup"&gt;CTF Challenge: Good Kitty - Writeup&lt;/h1&gt;
&lt;h2 id="challenge-overview"&gt;Challenge Overview&lt;/h2&gt;
&lt;p&gt;This is a reverse engineering CTF challenge where we need to find the correct password by analyzing a binary that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Calculates a value based on Project Euler problem #3&lt;/li&gt;
&lt;li&gt;Encodes it using a custom algorithm&lt;/li&gt;
&lt;li&gt;Compares user input against the encoded value&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="initial-analysis"&gt;Initial Analysis&lt;/h2&gt;
&lt;h3 id="decompiled-code-structure"&gt;Decompiled Code Structure&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;undefined8 &lt;span style="color:#a6e22e"&gt;main&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;void&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; byte bVar1;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;ssize_t&lt;/span&gt; bytes_read;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;long&lt;/span&gt; input_len;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;int&lt;/span&gt; iVar2;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;long&lt;/span&gt; in_FS_OFFSET;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;double&lt;/span&gt; dVar3;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; undefined1 local_be;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; byte is_correct;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; uint index;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;long&lt;/span&gt; flag;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; undefined8 local_b0;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; undefined8 local_a8 [&lt;span style="color:#ae81ff"&gt;4&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; undefined8 local_88;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; undefined8 uStack_80;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; undefined8 local_78;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;char&lt;/span&gt; user_input [&lt;span style="color:#ae81ff"&gt;72&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;long&lt;/span&gt; local_20;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; local_20 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;(&lt;span style="color:#66d9ef"&gt;long&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;)(in_FS_OFFSET &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x28&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; flag &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ppeuler_3&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; dVar3 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;cbrt&lt;/span&gt;((&lt;span style="color:#66d9ef"&gt;double&lt;/span&gt;)flag);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; flag &lt;span style="color:#f92672"&gt;=&lt;/span&gt; (&lt;span style="color:#66d9ef"&gt;long&lt;/span&gt;)dVar3;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; flag &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;factorial&lt;/span&gt;(flag);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; input_len &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; bVar1 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;(byte &lt;span style="color:#f92672"&gt;*&lt;/span&gt;)((&lt;span style="color:#66d9ef"&gt;long&lt;/span&gt;)&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;flag &lt;span style="color:#f92672"&gt;+&lt;/span&gt; input_len);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; ((&lt;span style="color:#ae81ff"&gt;0x19&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; (byte)((bVar1 &lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0xdf&lt;/span&gt;) &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0xbf&lt;/span&gt;)) &lt;span style="color:#f92672"&gt;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style="color:#ae81ff"&gt;9&lt;/span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; (byte)(bVar1 &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x30&lt;/span&gt;))) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; bVar1 &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bVar1 &lt;span style="color:#f92672"&gt;%&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x3e&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; ((byte)(bVar1 &lt;span style="color:#f92672"&gt;-&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;10&lt;/span&gt;) &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x1a&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;(byte &lt;span style="color:#f92672"&gt;*&lt;/span&gt;)((&lt;span style="color:#66d9ef"&gt;long&lt;/span&gt;)&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;flag &lt;span style="color:#f92672"&gt;+&lt;/span&gt; input_len) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bVar1 &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x37&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;if&lt;/span&gt; ((byte)(bVar1 &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x30&lt;/span&gt;) &lt;span style="color:#f92672"&gt;&amp;lt;&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x54&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;(byte &lt;span style="color:#f92672"&gt;*&lt;/span&gt;)((&lt;span style="color:#66d9ef"&gt;long&lt;/span&gt;)&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;flag &lt;span style="color:#f92672"&gt;+&lt;/span&gt; input_len) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bVar1 &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x30&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt;(byte &lt;span style="color:#f92672"&gt;*&lt;/span&gt;)((&lt;span style="color:#66d9ef"&gt;long&lt;/span&gt;)&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;flag &lt;span style="color:#f92672"&gt;+&lt;/span&gt; input_len) &lt;span style="color:#f92672"&gt;=&lt;/span&gt; bVar1 &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;0x3d&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; input_len &lt;span style="color:#f92672"&gt;=&lt;/span&gt; input_len &lt;span style="color:#f92672"&gt;+&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; } &lt;span style="color:#66d9ef"&gt;while&lt;/span&gt; (input_len &lt;span style="color:#f92672"&gt;!=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;8&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#75715e"&gt;// ... rest of code validates input
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="key-concepts-learned"&gt;Key Concepts Learned&lt;/h2&gt;
&lt;h3 id="1-understanding-pointer-arithmetic-on-stack-variables"&gt;1. Understanding Pointer Arithmetic on Stack Variables&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: &lt;code&gt;flag&lt;/code&gt; is declared as &lt;code&gt;long flag;&lt;/code&gt; (not an array), so what does &lt;code&gt;&amp;amp;flag + index&lt;/code&gt; mean?&lt;/p&gt;</description></item><item><title>GDB Notes – Basics &amp; Practical Usage</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-04-gdb-1/</link><pubDate>Sun, 09 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-04-gdb-1/</guid><description>&lt;h1 id="gdb-notes--basics-navigation--memory-inspection"&gt;GDB Notes — Basics, Navigation &amp;amp; Memory Inspection&lt;/h1&gt;
&lt;p&gt;These are concise notes on how to use &lt;strong&gt;GDB (GNU Debugger)&lt;/strong&gt; effectively for analyzing ELF binaries and debugging at both &lt;strong&gt;C source&lt;/strong&gt; and &lt;strong&gt;assembly&lt;/strong&gt; levels.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-starting-gdb"&gt;1. Starting GDB&lt;/h2&gt;
&lt;h3 id="basic-invocation"&gt;Basic invocation&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;gdb ./a.out
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;gdb -q ./program &lt;span style="color:#75715e"&gt;# Quiet mode (no banner)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="with-arguments"&gt;With arguments&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;gdb --args ./program arg1 arg2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="from-inside-gdb"&gt;From inside GDB&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;(&lt;/span&gt;gdb&lt;span style="color:#f92672"&gt;)&lt;/span&gt; run arg1 arg2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="2-compiling-for-debugging"&gt;2. Compiling for Debugging&lt;/h2&gt;
&lt;p&gt;Compile with the &lt;code&gt;-g&lt;/code&gt; flag to include &lt;strong&gt;debug symbols&lt;/strong&gt;:&lt;/p&gt;</description></item><item><title>GDB print Command</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-09-gdb-4/</link><pubDate>Sun, 09 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-09-gdb-4/</guid><description>&lt;h1 id="gdb-print-command-reference-guide"&gt;GDB Print Command Reference Guide&lt;/h1&gt;
&lt;h2 id="basic-print-command"&gt;Basic Print Command&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print variable_name
p variable_name # Short form
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="print-with-format-specifiers"&gt;Print with Format Specifiers&lt;/h2&gt;
&lt;p&gt;Use &lt;code&gt;/format&lt;/code&gt; after print to specify output format:&lt;/p&gt;
&lt;h3 id="hexadecimal"&gt;Hexadecimal&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/x variable # Hex (lowercase)
print/x value # Example: 0x5
p/x 255 # Output: 0xff
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="decimal"&gt;Decimal&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/d variable # Signed decimal
print/u variable # Unsigned decimal
p/d 0xff # Output: 255
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="octal"&gt;Octal&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/o variable # Octal format
p/o 64 # Output: 0100
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="binary"&gt;Binary&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/t variable # Binary (t = &amp;#34;two&amp;#34;)
p/t 5 # Output: 101
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="character"&gt;Character&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/c variable # As ASCII character
p/c 65 # Output: &amp;#39;A&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="floating-point"&gt;Floating Point&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/f variable # Floating point
p/f 3.14159
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="addresspointer"&gt;Address/Pointer&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/a variable # As address
p/a 0x555555555189 # Shows as address
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="string"&gt;String&lt;/h3&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print/s pointer # Interpret as C string
p/s argv[1]
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="working-with-pointers"&gt;Working with Pointers&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;print pointer # Shows address
print *pointer # Dereference (shows value)
print &amp;amp;variable # Shows address of variable
# Example
print argv # Address of argv array
print *argv # First element (argv[0])
print argv[1] # Second element
print *argv[1] # First char of argv[1]
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="array-and-string-operations"&gt;Array and String Operations&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;# Print entire array
print buffer_one
print buffer_two
# Print specific elements
print buffer_one[0]
print buffer_one[3]
# Print array slice (if supported)
print buffer_one@8 # Print 8 elements starting at buffer_one
# View string with length
x/8c buffer_one # First 8 chars
x/s buffer_one # Until null terminator
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="type-casting"&gt;Type Casting&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;# Cast to different types
print (int *)buffer_one # Treat as int pointer
print *(int *)buffer_one # Dereference as int
print (unsigned char)value # Cast to unsigned char
# Example: View buffer as integers
print *(int *)&amp;amp;buffer_one
print *(long *)&amp;amp;buffer_two
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="expressions-and-calculations"&gt;Expressions and Calculations&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;# Arithmetic
print value + 10
print sizeof(buffer_one)
print strlen(buffer_one)
# Address calculations
print &amp;amp;buffer_one - &amp;amp;buffer_two
print (long)&amp;amp;value - (long)&amp;amp;buffer_one
# Pointer arithmetic
print argv[0]
print *(argv + 1)
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id="display-commands-auto-print"&gt;Display Commands (Auto-Print)&lt;/h2&gt;
&lt;p&gt;Set up variables to display automatically after each step:&lt;/p&gt;</description></item><item><title>GDB Layouts</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-07-gdb-2/</link><pubDate>Tue, 04 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-07-gdb-2/</guid><description>&lt;h1 id="debugging-souce-code-with-assembly"&gt;Debugging Souce Code with Assembly&lt;/h1&gt;
&lt;p&gt;If we compile C program with &lt;code&gt;-g&lt;/code&gt; flag, it tells GCC to include debugging symbols inside the resulting binary (a.out by default). These symbols live in a special section of the ELF file (like .debug_info, .debug_line, .debug_str, etc.) and contain metadata that maps machine instructions back to your original source code.&lt;/p&gt;
&lt;p&gt;This allows us to see corresponding source along with assembly while debugging with GDB.&lt;/p&gt;</description></item><item><title>GDB x Command</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-08-gdb-3/</link><pubDate>Tue, 04 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-08-gdb-3/</guid><description>&lt;h2 id="examining-memory-with-x-command"&gt;Examining Memory with &lt;code&gt;x&lt;/code&gt; Command&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;x&lt;/code&gt; (examine) command is more powerful for raw memory:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-gdb" data-lang="gdb"&gt;x/[count][format][size] address
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="size-modifiers"&gt;Size Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; = byte (1 byte)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt; = halfword (2 bytes)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; = word (4 bytes)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; = giant word (8 bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="format-modifiers"&gt;Format Modifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; = hexadecimal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; = decimal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; = unsigned decimal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; = octal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t&lt;/code&gt; = binary&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; = character&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; = string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; = instruction (disassembly)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt;: how many units to display&lt;/p&gt;</description></item><item><title>Radare2 Basic Commands</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-08-radare2-1/</link><pubDate>Tue, 04 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/cheatsheets/2025-11-08-radare2-1/</guid><description>&lt;h1 id="reverse-engineering-with-radare2"&gt;Reverse Engineering with Radare2&lt;/h1&gt;
&lt;p&gt;A powerful framework for reverse engineering.&lt;/p&gt;
&lt;h3 id="core-analysis-commands"&gt;Core Analysis Commands&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;r2 Command&lt;/th&gt;
&lt;th style="text-align: left"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;r2 ./binary&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;Open the binary for analysis.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;aaa&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;A&lt;/strong&gt;nalyze &lt;strong&gt;A&lt;/strong&gt;ll &lt;strong&gt;A&lt;/strong&gt;utomatically. Finds functions, symbols, etc.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;afl&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;A&lt;/strong&gt;nalyze &lt;strong&gt;F&lt;/strong&gt;unction &lt;strong&gt;L&lt;/strong&gt;ist. Shows all identified functions.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;s &amp;lt;address/name&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;S&lt;/strong&gt;eek to a specific address or function name (e.g., &lt;code&gt;s main&lt;/code&gt;).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;pdf&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;P&lt;/strong&gt;rint &lt;strong&gt;D&lt;/strong&gt;isassembled &lt;strong&gt;F&lt;/strong&gt;unction. Shows assembly code.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;pdg&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;P&lt;/strong&gt;rint &lt;strong&gt;D&lt;/strong&gt;ecompiled &lt;strong&gt;G&lt;/strong&gt;hidra. Shows decompiled C-like code.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;afv&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;&lt;strong&gt;A&lt;/strong&gt;nalyze &lt;strong&gt;F&lt;/strong&gt;unction &lt;strong&gt;V&lt;/strong&gt;ariables. Shows local variables, arguments, and their stack offsets.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="additional-useful-commands"&gt;Additional Useful Commands&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;r2 Command&lt;/th&gt;
&lt;th style="text-align: left"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;Show general information about the binary (imports, exports, strings).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;ps&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;Print a summary of the binary&amp;rsquo;s sections.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;Enter visual mode for interactive navigation.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;VV&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;Enter visual graph mode to see the control flow graph.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;?&lt;/code&gt; / &lt;code&gt;??&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;Get help on commands.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description></item><item><title>CTF – 1 : Matryoshka</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/</link><pubDate>Sat, 01 Nov 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/</guid><description>&lt;h1 id="reverse-engineering-and-ctf-challenge-notes"&gt;Reverse Engineering and CTF Challenge Notes&lt;/h1&gt;
&lt;p&gt;Reverse engineering is the process of understanding how software works &lt;strong&gt;without access to its original source code&lt;/strong&gt;.&lt;br&gt;
In security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.&lt;br&gt;
This walkthrough documents my first attempt at such a challenge, focusing on &lt;em&gt;ELF-based reverse engineering&lt;/em&gt; and the reasoning process behind each step.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-static-analysis"&gt;1. Static Analysis&lt;/h2&gt;
&lt;p&gt;Static analysis means inspecting the binary &lt;strong&gt;without running it&lt;/strong&gt;.&lt;/p&gt;</description></item><item><title>ELF Format: Part 3</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-15-elf-format-part-3/</link><pubDate>Wed, 15 Oct 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-15-elf-format-part-3/</guid><description>&lt;h1 id="elf-format-sections-and-section-header-table"&gt;ELF Format: Sections and Section Header Table&lt;/h1&gt;
&lt;p&gt;In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&amp;rsquo;ll look at Section Headers and Sections - the link-time and debugging view.&lt;/p&gt;
&lt;h2 id="what-are-sections"&gt;What Are Sections?&lt;/h2&gt;
&lt;p&gt;Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&amp;rsquo;s contents for:&lt;/p&gt;</description></item><item><title>ELF Format: Part 2</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/</link><pubDate>Mon, 13 Oct 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/</guid><description>&lt;h1 id="elf-format-segments-and-program-header-table"&gt;ELF Format: Segments and Program Header Table&lt;/h1&gt;
&lt;p&gt;After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.&lt;/p&gt;
&lt;h2 id="what-are-segments"&gt;What Are Segments?&lt;/h2&gt;
&lt;p&gt;Segments are the runtime view of an ELF file. While sections (which we&amp;rsquo;ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program.&lt;/p&gt;</description></item><item><title>ELF Format: Part 1</title><link>https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/</link><pubDate>Wed, 01 Oct 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/</guid><description>&lt;h1 id="elf-format-elf-header"&gt;ELF Format: ELF Header&lt;/h1&gt;
&lt;h2 id="what-is-elf"&gt;What is ELF?&lt;/h2&gt;
&lt;p&gt;ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executable files (a.out, /bin/ls)&lt;/li&gt;
&lt;li&gt;Object files (.o)&lt;/li&gt;
&lt;li&gt;Shared libraries (.so)&lt;/li&gt;
&lt;li&gt;Core dumps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It’s a container format that describes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What parts of the file get loaded into memory,&lt;/li&gt;
&lt;li&gt;Where execution starts,&lt;/li&gt;
&lt;li&gt;How relocations and dynamic linking are handled.&lt;/li&gt;
&lt;li&gt;Contains useful information for the debuggers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="general-structure-of-an-elf-file"&gt;General Structure of an ELF File&lt;/h2&gt;
&lt;p&gt;An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution.&lt;/p&gt;</description></item><item><title>x86 Assembly Part 1: Registers</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/</guid><description>&lt;p&gt;When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions.&lt;/p&gt;</description></item><item><title>Hello World in Real Mode</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/</link><pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/</guid><description>&lt;p&gt;When your x86 computer first starts up, it&amp;rsquo;s in a surprisingly primitive state:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No operating system&lt;/strong&gt; - Obviously, since we haven&amp;rsquo;t loaded one yet&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No memory management&lt;/strong&gt; - No virtual memory, no protection between processes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No file system&lt;/strong&gt; - Can&amp;rsquo;t open files, no directories, no abstraction layer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No network stack&lt;/strong&gt; - No TCP/IP, no internet connectivity&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No device drivers&lt;/strong&gt; - No USB drivers, no graphics drivers, nothing&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-services-are-available-at-boot-time"&gt;What Services Are Available at Boot Time?&lt;/h2&gt;
&lt;p&gt;Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:&lt;/p&gt;</description></item><item><title>How does CPU Communicates With Peripheral Devices</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-08-09-how-does-cpu-communicates-with-peripheral-devices/</link><pubDate>Sat, 09 Aug 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-08-09-how-does-cpu-communicates-with-peripheral-devices/</guid><description>&lt;h1 id="introduction-the-communication-challenges"&gt;Introduction: The Communication Challenges&lt;/h1&gt;
&lt;p&gt;At its core, a CPU is designed for one primary task: processing data and executing instructions at incredible speed. But this processing power becomes meaningful only when it can interact with the rich ecosystem of peripheral devices that extend its capabilities.&lt;/p&gt;
&lt;h2 id="why-cpus-need-to-talk-to-many-different-devices"&gt;Why CPUs Need to Talk to Many Different Devices?&lt;/h2&gt;
&lt;p&gt;Your CPU must read input from your mouse or keyboard, process that input to understand your intent, communicate with memory to load the browser application, send rendering commands to your graphics card, request data from your network interface to load the webpage, and potentially write temporary files to your storage device. Each of these interactions involves a different type of peripheral device, each with its own communication requirements, data formats, and timing constraints.&lt;/p&gt;</description></item><item><title>Processor Modes in x86</title><link>https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/</link><pubDate>Fri, 18 Jul 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2025-07-20-processor-modes/</guid><description>&lt;h1 id="the-8086-processor"&gt;The 8086 Processor&lt;/h1&gt;
&lt;h2 id="a-brief-history"&gt;A Brief History&lt;/h2&gt;
&lt;p&gt;The Intel 8086, released in 1978, marked a pivotal moment in computing history as Intel&amp;rsquo;s first 16-bit microprocessor. Designed by a team led by Stephen Morse, the 8086 was Intel&amp;rsquo;s answer to the growing demand for more powerful processors that could handle larger programs and address more memory than the existing 8-bit chips of the era.&lt;/p&gt;
&lt;p&gt;The processor introduced the x86 architecture that would become the foundation for decades of computing evolution. With its 16-bit registers and 20-bit address bus &lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;, the 8086 could access up to 1 megabyte of memory—a massive improvement over the 64KB limitation of 8-bit processors. However, it retained backward compatibility concepts that would prove both beneficial and constraining for future generations.&lt;/p&gt;</description></item><item><title>Characteristics of MBR Code</title><link>https://sankethbk.github.io/blog/posts/boot/2025-07-07-characteristics-of-mbr-code/</link><pubDate>Sat, 12 Jul 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/boot/2025-07-07-characteristics-of-mbr-code/</guid><description>&lt;h1 id="bios-boot-recap"&gt;BIOS Boot Recap&lt;/h1&gt;
&lt;p&gt;Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the &lt;code&gt;0x55AA&lt;/code&gt; signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR).&lt;/p&gt;</description></item><item><title>What happens when you turn on computer?</title><link>https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/</link><pubDate>Wed, 02 Jul 2025 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/</guid><description>&lt;h2 id="1-poweron--hardware-reset"&gt;1. Power‑On &amp;amp; Hardware Reset&lt;/h2&gt;
&lt;h3 id="1-powergood-signal"&gt;1. Power‑Good Signal&lt;/h3&gt;
&lt;p&gt;The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it&amp;rsquo;s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it&amp;rsquo;s volatile.&lt;/p&gt;
&lt;h3 id="2-cpu-reset-vector"&gt;2. CPU Reset Vector&lt;/h3&gt;
&lt;p&gt;The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically &lt;code&gt;0xFFFFFFF0&lt;/code&gt; (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard&amp;rsquo;s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware.&lt;/p&gt;</description></item><item><title>Representation of Negative Numbers in Hardware</title><link>https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/</link><pubDate>Sun, 21 Jul 2024 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/</guid><description>&lt;p&gt;Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.&lt;/p&gt;</description></item><item><title>Overview of MIPS Assembly</title><link>https://sankethbk.github.io/blog/posts/cpu/2024-07-12-overview-of-mips-assembly/</link><pubDate>Fri, 12 Jul 2024 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2024-07-12-overview-of-mips-assembly/</guid><description>&lt;p&gt;MIPS (Microprocessor without Interlocked Pipeline Stages) assembly is one of the RISC ISA&amp;rsquo;s. It was developed in the early 1980s at Stanford University by Professor John L. Hennessy. MIPS is widely used in academic research and industry, particularly in computer architecture courses due to its straightforward design and in various embedded systems applications for its efficiency and performance.&lt;/p&gt;
&lt;h2 id="history"&gt;History&lt;/h2&gt;
&lt;p&gt;The first MIPS processor, the R2000, was introduced. It implemented the MIPS I architecture, which was one of the earliest commercial RISC processors. There are multiple versions of MIPS: including MIPS I, II, III, IV, and V; as well as five releases of MIPS32/64. MIPS I had 32-bit architecture with basic instruction set and addressing modes. MIPS III introduced 64-bit architecture in 1991, increasing the address space and register width.&lt;/p&gt;</description></item><item><title>The Fetch Decode Execute Cycle</title><link>https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/</link><pubDate>Sun, 30 Jun 2024 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/</guid><description>&lt;p&gt;The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.&lt;/p&gt;
&lt;h2 id="what-is-machine-code"&gt;What is Machine Code?&lt;/h2&gt;
&lt;p&gt;Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation.&lt;/p&gt;</description></item><item><title>Measuring CPU Performance</title><link>https://sankethbk.github.io/blog/posts/cpu/2024-06-21-measuring-cpu-performance/</link><pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2024-06-21-measuring-cpu-performance/</guid><description>&lt;p&gt;CPU Manufacturers publish several metrics related to CPU like clock speed, number of cores, cache sizes, ISA, performance per Watt, number of transistors and more. Measuring CPU performance is complex, and it cannot be summarized by a single metric. In this post, I&amp;rsquo;ll explore each of these metrics and discuss some standard benchmarking software and their limitations.&lt;/p&gt;
&lt;h2 id="what-is-clock-speed-how-does-it-affects-cpu-performance"&gt;What is Clock Speed, How does it Affects CPU Performance?&lt;/h2&gt;
&lt;p&gt;All Synchronous digital electronic circuits require an externally generated time reference. This is usually a square wave signal provided to the circuit called as clock. A &lt;strong&gt;clock cycle&lt;/strong&gt; is the fundamental unit of time measurement for a CPU. A clock cycle is a single electrical pulse in a CPU, during which the CPU can execute a fundamental operation such as accessing memory, writing data, or fetching a new set of instructions. A clock cycle is measured as the amount of time between two pulses of an oscillator. The clock speed of a CPU is measured in Hertz (Hz), which signifies the number of clock cycles it can complete in one second. Common units are Megahertz (MHz) and Gigahertz (GHz).&lt;/p&gt;</description></item><item><title>Key Differences between 32-bit and 64-bit CPU architectures</title><link>https://sankethbk.github.io/blog/posts/cpu/2024-06-02-processor-bit-size/</link><pubDate>Sun, 02 Jun 2024 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2024-06-02-processor-bit-size/</guid><description>&lt;p&gt;The terms 32 bit and 64 bit specifically relate to the size of the data and address registers within the CPU, which determines the maximum amount of memory that can be directly accessed and the range of values that can be processed.&lt;/p&gt;
&lt;h3 id="1-registers-and-data-width"&gt;1. Registers and Data Width:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Since all calculations take place in registers, when performing operations such as addition or subtraction, variables are loaded from memory into registers if they are not already there.&lt;/li&gt;
&lt;li&gt;A 32-bit CPU has 32-bit wide registers, meaning it can process 32 bits of data in a single instruction.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-memory-addressing"&gt;2. Memory Addressing:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32-bit CPU can address up to 2&lt;sup&gt;32&lt;/sup&gt; unique memory locations translates to a maximum of 4 GB of addressable memory (RAM). 64-bit CPU can address up to 2&lt;sup&gt;64&lt;/sup&gt; unique memory locations allowing for a theoretical maximum of 16 exabytes of addressable memory.&lt;/li&gt;
&lt;li&gt;This limitation comes from the fact that a 32-CPU can only load integers that are 32 bits long, thus limiting the maximum addressable memory space.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-data-transfer-speeds"&gt;3. Data Transfer Speeds:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The memory bus width in 64-bit CPU is often 64 bits or more, meaning the physical path between the CPU and RAM can handle 64 bits of data in parallel. This helps in efficiently loading data into the cache but does not restrict the CPU to always reading 64 bits.&lt;/li&gt;
&lt;li&gt;Despite the ability to handle 64 bits of data in parallel, the CPU is not restricted to always reading 64 bits at a time. It can access smaller data sizes (e.g., 8-bit, 16-bit, 32-bit) as needed, depending on the specific instruction and data type.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4-performance"&gt;4. Performance:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;64-bit CPU&amp;rsquo;s perform better than 32-bit CPU&amp;rsquo;s. This performance difference comes up from various factors like size of registers, addressable memory space, larger bus width&lt;/li&gt;
&lt;li&gt;Some RISC architectures support SIMD (Single Instruction, Multiple Data) instructions that allow for parallel processing of multiple smaller data types within larger registers. For example, ARM&amp;rsquo;s NEON technology can operate on multiple 32-bit integers within 64-bit registers, which enable the parallel processing of smaller data types within larger registers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="5-application-compatibility"&gt;5. Application Compatibility:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;64-bit operating systems typically include backward compatibility to run 32-bit software seamlessly.&lt;/li&gt;
&lt;li&gt;These compatibility layers allow 32-bit applications to execute on 64-bit systems without any major issues. However, 32-bit applications may not fully utilize the advantages of 64-bit systems, such as increased memory addressing capabilities.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Components of CPU</title><link>https://sankethbk.github.io/blog/posts/cpu/2024-05-31-components-of-cpu/</link><pubDate>Fri, 31 May 2024 00:00:00 +0000</pubDate><guid>https://sankethbk.github.io/blog/posts/cpu/2024-05-31-components-of-cpu/</guid><description>&lt;p&gt;Before learning Assembly, I think it would be useful to learn a bit about different components of CPU in general. If we think of CPU as a black box its main function is to fetch instructions from RAM which are in the form of &lt;a href="https://en.wikipedia.org/wiki/Machine_code"&gt;machine code&lt;/a&gt; and execute them.&lt;/p&gt;
&lt;h2 id="components-of-cpu"&gt;Components of CPU&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Arithmetic Logic Unit (ALU)&lt;/li&gt;
&lt;li&gt;Memory Management Unit (MMU)&lt;/li&gt;
&lt;li&gt;Control Unit (CU)&lt;/li&gt;
&lt;li&gt;Registers&lt;/li&gt;
&lt;li&gt;Clock&lt;/li&gt;
&lt;li&gt;Cache&lt;/li&gt;
&lt;li&gt;Buses&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="1-arithmetic-logic-unit-alu"&gt;1. Arithmetic Logic Unit (ALU)&lt;/h3&gt;
&lt;p&gt;ALU is an electronic circuit made of NAND gates responsible for performing arithmetic and logical operations on integer binary numbers. It takes two operands as inputs and an opcode to indicate the type of operation to be performed. Operations supported by ALU are Add, Subtract, Negation, Two&amp;rsquo;s complement, AND, OR, XOR, bit shift, etc.&lt;/p&gt;</description></item></channel></rss>