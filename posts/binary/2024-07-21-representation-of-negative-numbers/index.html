<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Representation of Negative Numbers in Hardware | Sanketh's Blog</title><meta name=keywords content="binary"><meta name=description content="Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs."><meta name=author content><link rel=canonical href=https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.e2ed8047f83ad264119a8881d8496bb9bd824712cec7cb80665766cf714041fe.css integrity="sha256-4u2AR/g60mQRmoiB2Elrub2CRxLOx8uAZldmz3FAQf4=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Representation of Negative Numbers in Hardware"><meta property="og:description" content="Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-21T00:00:00+00:00"><meta property="article:tag" content="Binary"><meta name=twitter:card content="summary"><meta name=twitter:title content="Representation of Negative Numbers in Hardware"><meta name=twitter:description content="Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Representation of Negative Numbers in Hardware","item":"https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Representation of Negative Numbers in Hardware","name":"Representation of Negative Numbers in Hardware","description":"Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.\n","keywords":["binary"],"articleBody":"Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.\nCharacteristics of an Ideal Representation Simple Arithmetic Operations: The representation should simplify the implementation of basic arithmetic operations (addition, subtraction, multiplication, and division) without needing special handling for positive and negative numbers in electronic circuits. Single Representation for Zero: There should be only one binary representation for zero to avoid ambiguity and simplify comparison operations. Symmetry: The range of representable positive and negative numbers should be symmetric around zero, meaning that the total number of positive and negative values should be as close as possible if not the same. Overflow Detection: The representation should allow for easy detection of overflow conditions during arithmetic operations. Bitwise Consistency: The representation should be consistent with bitwise logical operations such as AND, OR, and NOT, ensuring that these operations work correctly without special cases for negative numbers. Ease of Conversion: The method for converting between positive and negative representations should be simple and intuitive. Sign Interpretation: The responsibility for interpreting whether an operand is positive or negative should lie with the compiler, not the CPU. This ensures that the CPU does not need to perform additional checks during instruction decode and execution phase. Unambiguous Interpretation: The representation should ensure that arithmetic operations yield correct results whether a number starting with 1 is interpreted as a negative number or as a large unsigned positive number. For example, in C, 1001 can be interpreted as -7 in signed integers and 9 in unsigned integers. Since the CPU does not inherently know whether a number is positive or negative, the arithmetic results should be consistent and correct under both interpretations. Common Methods for Representing Negative Numbers Sign and Magnitude One’s Complement Two’s Complement Excess-N (Offset Binary) 1. Sign and Magnitude The most common approach is using a reserved sign bit to indicate whether a binary number is positive or negative and the remaining bits represent the magnitude (absolute value) of the number. In sign and magnitude, the Most Signinificant Bit (MSB) is reserved as sign-bit. A 0 in the MSB indicates a positive number and 1 indicates negative number,\nRange of Representation\nFor an n-bit number, the range of representable values is $$ -(2^{(n-1)} - 1) \\text{ to } 2^{(n-1)} - 1 $$\nIf we consider a 4-bit system, these are all the possible representations\nBinary Representation Decimal Value 1111 -7 1110 -6 1101 -5 1100 -4 1011 -3 1010 -2 1001 -1 1000 -0 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 Pros\nEasy to understand and visualize since the sign and magnitude are separated. Converting from positive to negative is simple: just flip the MSB. Cons\nComplex Arithmetic Operations: Addition and subtraction require special handling of the sign bit, making the implementation of these operations more complex in hardware. Adder circuits used for adding positive numbers cannot be used directly for operations involving mixed signs. For eg: add 5 (-2) will result in -7 (0101 + 1010 = 1111) which is not correct. To handle such cases correctly, the CPU must first check the most significant bit (MSB) of both operands to determine their signs. It must then use a separate circuit to handle subtraction. This will cause performance overhead as CPU can no longer just rely on opcode for determining the type of operation but also the sign of operands.\nDual Zero Representations: Sign and magnitude representation has two different representations for zero: positive zero (0000) and negative zero (1000). This redundancy complicates the design of comparison operations. For example, checking for zero requires additional logic to account for both representations, and ensuring consistent behavior across arithmetic operations becomes more challenging. Having two representations for zeros also introduces error in airthemtic operations.\nLack of Support for Unsigned Integers: In sign and magnitude representation, the most significant bit (MSB) is always reserved for the sign bit. This means the CPU relies on the MSB along with the opcode to determine the operation. As a result, we can’t have support for unsigned integers, because a large unsigned integer starting with 1 will be mistakenly interpreted as a negative number by the CPU. This limitation makes it difficult to handle a mix of signed and unsigned data in the same system efficiently.\n2. One’s Complement In One’s Complement system, positive numbers are represented the same way as in standard binary, while negative numbers are represented by inverting all the bits of the corresponding positive number (flipping all 0s to 1s and all 1s to 0s). For instance, in an 8-bit system, the number +5 is represented as 00000101, and -5 is represented as 11111010.\nRange of Representation\nFor an n-bit number, the range of representable values is $$ -(2^{(n-1)} - 1) \\text{ to } 2^{(n-1)} - 1 $$\nBinary Representation Decimal Value 1000 -7 1001 -6 1010 -5 1011 -4 1100 -3 1101 -2 1110 -1 1111 -0 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 Adding 2 numbers\nAdding two values is straightforward. Simply align the values on the least significant bit and add, propagating any carry to the bit one position left. If the carry extends past the end of the word it is said to have “wrapped around”, a condition called an “end-around carry”. When this occurs, the bit must be added back in at the right-most bit. This phenomenon does not occur in two’s complement arithmetic. The value of MSB has no special significance to the CPU.\n0111 7 + 1001 -6 ======= ==== 1|0000 1 1 ======= 0001 Pros\nOne’s complement solves some of the problems of sign and magnitude approach, they are\nUnified Adder Circuit: Unlike the sign and magnitude representation, the same adder circuit can be used for both positive and negative numbers in one’s complement. The primary modification needed is the addition of logic to handle end-around carry when an overflow occurs. This change is consistent across all cases, meaning there is no extra overhead for negative numbers specifically. Theoretical Support for Unsigned Integers: Since the value of MSB has no special significance to CPU, it is theoretically possible to support unsigned integers. However, a genuine overflow can lead to incorrect results due to the wrap-around carry. Cons\nOne’s complement retains the issue of dual zero representations from the sign and magnitude approach. The reason one’s complement performs wrap-around carry is to compensate for the shift in one digit along the number line caused by the presence of negative zero. This introduces an additional step in arithmetic operations to handle this anomaly, slightly complicating the overall design.\n3. Two’s complement Two’s complement is the most widely used method for representing signed integers in binary systems. Two’s complement of a number is calculated by flipping the bits and adding 1 to the Least Significant Bit (LSB).\nRange of Representation\nFor an n-bit number, the range of representable values is $$ -2^{(n-1)} \\text{ to } 2^{(n-1)} - 1 $$\nBinary Representation Decimal Value (signed) Decimal Value (unsigned) 1000 -8 8 1001 -7 9 1010 -6 10 1011 -5 11 1100 -4 12 1101 -3 13 1110 -2 14 1111 -1 15 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 Intuition Behind Two’s Complement\nIn one’s complement approach we saw that whenever a negative number is involved in addition the result could generate a carry which we have to wrap around to get correct answer. The reason for this is whenever result falls on positive side of the number line it has to cross two zero’s. Because of this, the result will fall short by one number on the number line. Two’s complement solves this by adding 1 to the one’s complement of a number which effectively removes -0 from the binary number line threby giving correct result.\nSum of any n-bit number and its one’s complement gives the highest possible number that can be represented by those n-bits. For eg:\n0010 (2 in 4 bit system) +1101 (1's complement of 2) ___________________________ 1111 (the highest number that we can represent with 4 bits) 1111 is -0 in one’s complement. Now what will happen if we try to add 1 more to the result. It will results in an overflow.\nThe result will be 10000 which is 0. Because we ignore the overflow bit in two’s complement.\nSo the statement can be generalized as\nAny n-bit number + its one's complement = max n-bit number Any n-bit number + its one's complement + 1 = 0 Adding 1 to the one’s complement itself is called as two’s complement as it involves one more additional step to one’s complement. So the statement can also be written as\nAny n-bit number + its two's complement = 0 The rationale behind two’s complement can be understood by comparing it with the unsigned binary interpretation:\nTaking an 8-bit value a7 a6 a5 a4 a3 a2 a1 a0\nThe usual unsigned binary interpretation is:\n$$ 2^7 \\cdot a_7 + 2^6 \\cdot a_6 + 2^5 \\cdot a_5 + 2^4 \\cdot a_4 + 2^3 \\cdot a_3 + 2^2 \\cdot a_2 + 2^1 \\cdot a_1 + 2^0 \\cdot a_0 $$\n11111111 = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255 In the two’s complement representation, all negative numbers have the MSB set to 1. To get the negative number represented by the two’s complement of a value, we need to multiply the MSB with -1. The formula for two’s complement is:\n$$ -2^7 \\cdot a_7 + 2^6 \\cdot a_6 + 2^5 \\cdot a_5 + 2^4 \\cdot a_4 + 2^3 \\cdot a_3 + 2^2 \\cdot a_2 + 2^1 \\cdot a_1 + 2^0 \\cdot a_0 $$\nFor eg: negative number represented by 11111111 is\n11111111 = -128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = -1 It’s important to note that while 11111111 represents -1 in the signed two’s complement system, it can also be interpreted as 255 in unsigned integers, as the CPU does not enforce any restriction. The interpretation is determined by the compiler.\nPros\nTwo’s complement solves all the limitations from sign and magnitude and one’s complement representations:\nSingle Representation for Zero: In two’s complement, zero has only one unique representation. This eliminates the problem of having two distinct representations for zero, which was a limitation in the one’s complement system. By having a single, consistent zero, two’s complement simplifies arithmetic operations and avoids the issue of shifting results by one number.\nNatural Support for Unsigned Integers: Since MSB has no special significance and there is no change in the process of addition (unlike wrap around carry in one’s complement). Two’s complement naturally enables support for unsigned integers.\nFor example in C unsigned int a = 2; 0010 unsigned int b = 9; +1001 unsigned int c = a + b; /* result is 11 */ == 1011 int a = 2; 0010 int b = -7; +1001 int c = a + b; /* result is -5 */ == 1011 We can see that even though result is 1011 in both cases. Compiler interprets it as 11 in the first case and -5 in the second case.\nIn both cases, the binary result is 1011. However, the interpretation differs based on whether the numbers are treated as unsigned or signed. The compiler interprets 1011 as 11 when dealing with unsigned integers and as -5 for signed integers. This flexibility is possible because the CPU treats the binary numbers uniformly without needing special handling for the sign.\nSign Extension in Two’s Complement: Two’s complement numbers can be sign-extended to match the size of the storage medium while preserving their value. For example, consider the 4-bit representation 1110, which corresponds to -2. To store this in a 32-bit register, we simply extend the MSB across the additional bits. The resulting 32-bit representation would be 1111 1111 1111 1111 1111 1111 1111 1110. This extension ensures that the value -2 is maintained accurately in arithmetic operations, regardless of the bit width of the register.\n3. Excess-N (Offset Binary) Representation In excess-N notation, a fixed value, called the bias or offset (N), is added to the actual integer value to form the encoded value. This approach shifts the range of representable numbers, ensuring that all encoded values are non-negative. The value of bias K is usually choosen as 2n-1 so that the representation is symmetric around 0. For example, with a bias = 3, the number -3 would be represented as 0, 0 would be represented as 3 and 3 would be represented as 6 and so on.\nThis representation simplifies certain types of arithmetic operations and is particularly useful in applications such as floating-point arithmetic and digital signal processing. Excess-N encoding simplifies comparison and subtraction operations, as the encoded values can be compared directly without considering the sign. This representation is widely used in the exponent field of IEEE 754 floating-point numbers, where it helps manage the range of representable exponents efficiently.\nBinary Representation Decimal Value (Excess-8) Decimal Value (Unsigned) 0000 -8 0 0001 -7 1 0010 -6 2 0011 -5 3 0100 -4 4 0101 -3 5 0110 -2 6 0111 -1 7 1000 0 8 1001 1 9 1010 2 10 1011 3 11 1100 4 12 1101 5 13 1110 6 14 1111 7 15 Range of Representation\nFor an n-bit number with bias as K, range of representation can be given by $$ -k \\text{ to } (2^n - 1) - k.$$\n","wordCount":"2370","inLanguage":"en","datePublished":"2024-07-21T00:00:00Z","dateModified":"2024-07-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/binary/2024-07-21-representation-of-negative-numbers/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Representation of Negative Numbers in Hardware</h1><div class=post-meta><span title='2024-07-21 00:00:00 +0000 UTC'>July 21, 2024</span>&nbsp;·&nbsp;12 min&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/binary/2024-07-21-representation-of-negative-numbers.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#characteristics-of-an-ideal-representation aria-label="Characteristics of an Ideal Representation">Characteristics of an Ideal Representation</a></li><li><a href=#common-methods-for-representing-negative-numbers aria-label="Common Methods for Representing Negative Numbers">Common Methods for Representing Negative Numbers</a><ul><li><a href=#1-sign-and-magnitude aria-label="1. Sign and Magnitude">1. Sign and Magnitude</a></li><li><a href=#2-ones-complement aria-label="2. One&rsquo;s Complement">2. One&rsquo;s Complement</a></li><li><a href=#3-twos-complement aria-label="3. Two&rsquo;s complement">3. Two&rsquo;s complement</a></li><li><a href=#3-excess-n-offset-binary-representation aria-label="3. Excess-N (Offset Binary) Representation">3. Excess-N (Offset Binary) Representation</a></li></ul></li></ul></div></details></div><div class=post-content><p>Representing negative numbers in binary poses unique challenges due to the inherent nature of binary systems. Unlike decimal systems, which can easily use a minus sign to indicate negative values, binary systems must encode this information within a fixed number of bits. This requirement leads to various methods of representation, each with its own set of advantages and limitations. The main challenge lies in developing a system that can accurately represent both positive and negative values while ensuring that arithmetic operations remain efficient and straightforward. In the following sections, we will explore several common approaches to representing negative numbers in binary, including their respective challenges and trade-offs.</p><h2 id=characteristics-of-an-ideal-representation>Characteristics of an Ideal Representation<a hidden class=anchor aria-hidden=true href=#characteristics-of-an-ideal-representation>#</a></h2><ol><li><strong>Simple Arithmetic Operations:</strong> The representation should simplify the implementation of basic arithmetic operations (addition, subtraction, multiplication, and division) without needing special handling for positive and negative numbers in electronic circuits.</li><li><strong>Single Representation for Zero:</strong> There should be only one binary representation for zero to avoid ambiguity and simplify comparison operations.</li><li><strong>Symmetry:</strong> The range of representable positive and negative numbers should be symmetric around zero, meaning that the total number of positive and negative values should be as close as possible if not the same.</li><li><strong>Overflow Detection:</strong> The representation should allow for easy detection of overflow conditions during arithmetic operations.</li><li><strong>Bitwise Consistency:</strong> The representation should be consistent with bitwise logical operations such as AND, OR, and NOT, ensuring that these operations work correctly without special cases for negative numbers.</li><li><strong>Ease of Conversion:</strong> The method for converting between positive and negative representations should be simple and intuitive.</li><li><strong>Sign Interpretation:</strong> The responsibility for interpreting whether an operand is positive or negative should lie with the compiler, not the CPU. This ensures that the CPU does not need to perform additional checks during instruction decode and execution phase.</li><li><strong>Unambiguous Interpretation:</strong> The representation should ensure that arithmetic operations yield correct results whether a number starting with 1 is interpreted as a negative number or as a large unsigned positive number. For example, in C, <code>1001</code> can be interpreted as <code>-7</code> in signed integers and <code>9</code> in unsigned integers. Since the CPU does not inherently know whether a number is positive or negative, the arithmetic results should be consistent and correct under both interpretations.</li></ol><h2 id=common-methods-for-representing-negative-numbers>Common Methods for Representing Negative Numbers<a hidden class=anchor aria-hidden=true href=#common-methods-for-representing-negative-numbers>#</a></h2><ol><li>Sign and Magnitude</li><li>One&rsquo;s Complement</li><li>Two&rsquo;s Complement</li><li>Excess-N (Offset Binary)</li></ol><h3 id=1-sign-and-magnitude>1. Sign and Magnitude<a hidden class=anchor aria-hidden=true href=#1-sign-and-magnitude>#</a></h3><p>The most common approach is using a reserved sign bit to indicate whether a binary number is positive or negative and the remaining bits represent the magnitude (absolute value) of the number. In sign and magnitude, the Most Signinificant Bit (MSB) is reserved as sign-bit. A <code>0</code> in the MSB indicates a positive number and <code>1</code> indicates negative number,</p><p><strong>Range of Representation</strong></p><p>For an n-bit number, the range of representable values is
$$ -(2^{(n-1)} - 1) \text{ to } 2^{(n-1)} - 1 $$</p><p>If we consider a 4-bit system, these are all the possible representations</p><table><thead><tr><th>Binary Representation</th><th>Decimal Value</th></tr></thead><tbody><tr><td>1111</td><td>-7</td></tr><tr><td>1110</td><td>-6</td></tr><tr><td>1101</td><td>-5</td></tr><tr><td>1100</td><td>-4</td></tr><tr><td>1011</td><td>-3</td></tr><tr><td>1010</td><td>-2</td></tr><tr><td>1001</td><td>-1</td></tr><tr><td>1000</td><td>-0</td></tr><tr><td>0000</td><td>0</td></tr><tr><td>0001</td><td>1</td></tr><tr><td>0010</td><td>2</td></tr><tr><td>0011</td><td>3</td></tr><tr><td>0100</td><td>4</td></tr><tr><td>0101</td><td>5</td></tr><tr><td>0110</td><td>6</td></tr><tr><td>0111</td><td>7</td></tr></tbody></table><p><strong>Pros</strong></p><ul><li>Easy to understand and visualize since the sign and magnitude are separated.</li><li>Converting from positive to negative is simple: just flip the MSB.</li></ul><p><strong>Cons</strong></p><ul><li><p><strong>Complex Arithmetic Operations:</strong> Addition and subtraction require special handling of the sign bit, making the implementation of these operations more complex in hardware. Adder circuits used for adding positive numbers cannot be used directly for operations involving mixed signs. For eg: <code>add 5 (-2)</code> will result in <code>-7</code> (<code>0101</code> + <code>1010</code> = <code>1111</code>) which is not correct. To handle such cases correctly, the CPU must first check the most significant bit (MSB) of both operands to determine their signs. It must then use a separate circuit to handle subtraction. This will cause performance overhead as CPU can no longer just rely on opcode for determining the type of operation but also the sign of operands.</p></li><li><p><strong>Dual Zero Representations:</strong> Sign and magnitude representation has two different representations for zero: positive zero (<code>0000</code>) and negative zero (<code>1000</code>). This redundancy complicates the design of comparison operations. For example, checking for zero requires additional logic to account for both representations, and ensuring consistent behavior across arithmetic operations becomes more challenging. Having two representations for zeros also introduces error in airthemtic operations.</p></li><li><p><strong>Lack of Support for Unsigned Integers:</strong> In sign and magnitude representation, the most significant bit (MSB) is always reserved for the sign bit. This means the CPU relies on the MSB along with the opcode to determine the operation. As a result, we can&rsquo;t have support for unsigned integers, because a large unsigned integer starting with <code>1</code> will be mistakenly interpreted as a negative number by the CPU. This limitation makes it difficult to handle a mix of signed and unsigned data in the same system efficiently.</p></li></ul><h3 id=2-ones-complement>2. One&rsquo;s Complement<a hidden class=anchor aria-hidden=true href=#2-ones-complement>#</a></h3><p>In One&rsquo;s Complement system, positive numbers are represented the same way as in standard binary, while negative numbers are represented by inverting all the bits of the corresponding positive number (flipping all 0s to 1s and all 1s to 0s). For instance, in an 8-bit system, the number +5 is represented as <code>00000101</code>, and -5 is represented as <code>11111010</code>.</p><p><strong>Range of Representation</strong></p><p>For an n-bit number, the range of representable values is
$$ -(2^{(n-1)} - 1) \text{ to } 2^{(n-1)} - 1 $$</p><table><thead><tr><th>Binary Representation</th><th>Decimal Value</th></tr></thead><tbody><tr><td>1000</td><td>-7</td></tr><tr><td>1001</td><td>-6</td></tr><tr><td>1010</td><td>-5</td></tr><tr><td>1011</td><td>-4</td></tr><tr><td>1100</td><td>-3</td></tr><tr><td>1101</td><td>-2</td></tr><tr><td>1110</td><td>-1</td></tr><tr><td>1111</td><td>-0</td></tr><tr><td>0000</td><td>0</td></tr><tr><td>0001</td><td>1</td></tr><tr><td>0010</td><td>2</td></tr><tr><td>0011</td><td>3</td></tr><tr><td>0100</td><td>4</td></tr><tr><td>0101</td><td>5</td></tr><tr><td>0110</td><td>6</td></tr><tr><td>0111</td><td>7</td></tr></tbody></table><p><strong>Adding 2 numbers</strong></p><p>Adding two values is straightforward. Simply align the values on the least significant bit and add, propagating any carry to the bit one position left. If the carry extends past the end of the word it is said to have &ldquo;wrapped around&rdquo;, a condition called an &ldquo;end-around carry&rdquo;. When this occurs, the bit must be added back in at the right-most bit. This phenomenon does not occur in two&rsquo;s complement arithmetic. The value of MSB has no special significance to the CPU.</p><pre tabindex=0><code>   0111      7
+  1001     -6
=======   ====
 1|0000      1
      1
=======
   0001 
</code></pre><p><strong>Pros</strong></p><p>One&rsquo;s complement solves some of the problems of sign and magnitude approach, they are</p><ul><li><strong>Unified Adder Circuit:</strong> Unlike the sign and magnitude representation, the same adder circuit can be used for both positive and negative numbers in one&rsquo;s complement. The primary modification needed is the addition of logic to handle end-around carry when an overflow occurs. This change is consistent across all cases, meaning there is no extra overhead for negative numbers specifically.</li><li><strong>Theoretical Support for Unsigned Integers:</strong> Since the value of MSB has no special significance to CPU, it is theoretically possible to support unsigned integers. However, a genuine overflow can lead to incorrect results due to the wrap-around carry.</li></ul><p><strong>Cons</strong></p><p>One&rsquo;s complement retains the issue of dual zero representations from the sign and magnitude approach. The reason one&rsquo;s complement performs wrap-around carry is to compensate for the shift in one digit along the number line caused by the presence of negative zero. This introduces an additional step in arithmetic operations to handle this anomaly, slightly complicating the overall design.</p><h3 id=3-twos-complement>3. Two&rsquo;s complement<a hidden class=anchor aria-hidden=true href=#3-twos-complement>#</a></h3><p>Two&rsquo;s complement is the most widely used method for representing signed integers in binary systems. Two&rsquo;s complement of a number is calculated by flipping the bits and adding <code>1</code> to the Least Significant Bit (LSB).</p><p><strong>Range of Representation</strong></p><p>For an n-bit number, the range of representable values is
$$ -2^{(n-1)} \text{ to } 2^{(n-1)} - 1 $$</p><table><thead><tr><th>Binary Representation</th><th>Decimal Value (signed)</th><th>Decimal Value (unsigned)</th></tr></thead><tbody><tr><td>1000</td><td>-8</td><td>8</td></tr><tr><td>1001</td><td>-7</td><td>9</td></tr><tr><td>1010</td><td>-6</td><td>10</td></tr><tr><td>1011</td><td>-5</td><td>11</td></tr><tr><td>1100</td><td>-4</td><td>12</td></tr><tr><td>1101</td><td>-3</td><td>13</td></tr><tr><td>1110</td><td>-2</td><td>14</td></tr><tr><td>1111</td><td>-1</td><td>15</td></tr><tr><td>0000</td><td>0</td><td>0</td></tr><tr><td>0001</td><td>1</td><td>1</td></tr><tr><td>0010</td><td>2</td><td>2</td></tr><tr><td>0011</td><td>3</td><td>3</td></tr><tr><td>0100</td><td>4</td><td>4</td></tr><tr><td>0101</td><td>5</td><td>5</td></tr><tr><td>0110</td><td>6</td><td>6</td></tr><tr><td>0111</td><td>7</td><td>7</td></tr></tbody></table><p><strong>Intuition Behind Two&rsquo;s Complement</strong></p><p>In one&rsquo;s complement approach we saw that whenever a negative number is involved in addition the result could generate a carry which we have to wrap around to get correct answer. The reason for this is whenever result falls on positive side of the number line it has to cross two zero&rsquo;s. Because of this, the result will fall short by one number on the number line. Two&rsquo;s complement solves this by adding <code>1</code> to the one&rsquo;s complement of a number which effectively removes <code>-0</code> from the binary number line threby giving correct result.</p><p>Sum of any n-bit number and its one&rsquo;s complement gives the highest possible number that can be represented by those n-bits. For eg:</p><pre tabindex=0><code> 0010 (2 in 4 bit system)
+1101 (1&#39;s complement of 2)
___________________________
 1111  (the highest number that we can represent with 4 bits)
</code></pre><p><code>1111</code> is <code>-0</code> in one&rsquo;s complement. Now what will happen if we try to add <code>1</code> more to the result. It will results in an overflow.</p><p>The result will be <code>10000</code> which is <code>0</code>. Because we ignore the overflow bit in two&rsquo;s complement.</p><p>So the statement can be generalized as</p><pre tabindex=0><code>Any n-bit number + its one&#39;s complement = max n-bit number
Any n-bit number + its one&#39;s complement + 1 = 0
</code></pre><p>Adding <code>1</code> to the one&rsquo;s complement itself is called as two&rsquo;s complement as it involves one more additional step to one&rsquo;s complement. So the statement can also be written as</p><pre tabindex=0><code>Any n-bit number + its two&#39;s complement = 0
</code></pre><p>The rationale behind two&rsquo;s complement can be understood by comparing it with the unsigned binary interpretation:</p><p>Taking an 8-bit value a<sub>7</sub> a<sub>6</sub> a<sub>5</sub> a<sub>4</sub> a<sub>3</sub> a<sub>2</sub> a<sub>1</sub> a<sub>0</sub></p><p>The usual unsigned binary interpretation is:</p><p>$$ 2^7 \cdot a_7 + 2^6 \cdot a_6 + 2^5 \cdot a_5 + 2^4 \cdot a_4 + 2^3 \cdot a_3 + 2^2 \cdot a_2 + 2^1 \cdot a_1 + 2^0 \cdot a_0 $$</p><pre tabindex=0><code>11111111 = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255
</code></pre><p>In the two&rsquo;s complement representation, all negative numbers have the MSB set to 1. To get the negative number represented by the two&rsquo;s complement of a value, we need to multiply the MSB with -1. The formula for two&rsquo;s complement is:</p><p>$$ -2^7 \cdot a_7 + 2^6 \cdot a_6 + 2^5 \cdot a_5 + 2^4 \cdot a_4 + 2^3 \cdot a_3 + 2^2 \cdot a_2 + 2^1 \cdot a_1 + 2^0 \cdot a_0 $$</p><p>For eg: negative number represented by <code>11111111</code> is</p><pre tabindex=0><code>11111111 = -128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = -1
</code></pre><p>It&rsquo;s important to note that while <code>11111111</code> represents <code>-1</code> in the signed two&rsquo;s complement system, it can also be interpreted as <code>255</code> in unsigned integers, as the CPU does not enforce any restriction. The interpretation is determined by the compiler.</p><p><strong>Pros</strong></p><p>Two&rsquo;s complement solves all the limitations from sign and magnitude and one&rsquo;s complement representations:</p><ol><li><p><strong>Single Representation for Zero:</strong> In two&rsquo;s complement, zero has only one unique representation. This eliminates the problem of having two distinct representations for zero, which was a limitation in the one&rsquo;s complement system. By having a single, consistent zero, two&rsquo;s complement simplifies arithmetic operations and avoids the issue of shifting results by one number.</p></li><li><p><strong>Natural Support for Unsigned Integers:</strong> Since MSB has no special significance and there is no change in the process of addition (unlike wrap around carry in one&rsquo;s complement). Two&rsquo;s complement naturally enables support for unsigned integers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>For example in C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;                             <span style=color:#ae81ff>0010</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>;                            <span style=color:#f92672>+</span><span style=color:#ae81ff>1001</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b; <span style=color:#75715e>/* result is 11 */</span>  <span style=color:#f92672>==</span>  <span style=color:#ae81ff>1011</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;                                      <span style=color:#ae81ff>0010</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>7</span>;                                    <span style=color:#f92672>+</span><span style=color:#ae81ff>1001</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b; <span style=color:#75715e>/* result is -5 */</span>           <span style=color:#f92672>==</span>  <span style=color:#ae81ff>1011</span>
</span></span></code></pre></div><p>We can see that even though result is <code>1011</code> in both cases. Compiler interprets it as <code>11</code> in the first case and <code>-5</code> in the second case.</p><p>In both cases, the binary result is <code>1011</code>. However, the interpretation differs based on whether the numbers are treated as unsigned or signed. The compiler interprets <code>1011</code> as <code>11</code> when dealing with unsigned integers and as <code>-5</code> for signed integers. This flexibility is possible because the CPU treats the binary numbers uniformly without needing special handling for the sign.</p></li><li><p><strong>Sign Extension in Two&rsquo;s Complement:</strong> Two&rsquo;s complement numbers can be sign-extended to match the size of the storage medium while preserving their value. For example, consider the 4-bit representation <code>1110</code>, which corresponds to <code>-2</code>. To store this in a 32-bit register, we simply extend the MSB across the additional bits. The resulting 32-bit representation would be <code>1111 1111 1111 1111 1111 1111 1111 1110</code>. This extension ensures that the value <code>-2</code> is maintained accurately in arithmetic operations, regardless of the bit width of the register.</p></li></ol><h3 id=3-excess-n-offset-binary-representation>3. Excess-N (Offset Binary) Representation<a hidden class=anchor aria-hidden=true href=#3-excess-n-offset-binary-representation>#</a></h3><p>In excess-N notation, a fixed value, called the bias or offset (N), is added to the actual integer value to form the encoded value. This approach shifts the range of representable numbers, ensuring that all encoded values are non-negative. The value of bias K is usually choosen as 2<sup>n-1</sup> so that the representation is symmetric around 0. For example, with a bias = 3, the number -3 would be represented as 0, 0 would be represented as 3 and 3 would be represented as 6 and so on.</p><p>This representation simplifies certain types of arithmetic operations and is particularly useful in applications such as floating-point arithmetic and digital signal processing. Excess-N encoding simplifies comparison and subtraction operations, as the encoded values can be compared directly without considering the sign. This representation is widely used in the exponent field of IEEE 754 floating-point numbers, where it helps manage the range of representable exponents efficiently.</p><table><thead><tr><th>Binary Representation</th><th>Decimal Value (Excess-8)</th><th>Decimal Value (Unsigned)</th></tr></thead><tbody><tr><td>0000</td><td>-8</td><td>0</td></tr><tr><td>0001</td><td>-7</td><td>1</td></tr><tr><td>0010</td><td>-6</td><td>2</td></tr><tr><td>0011</td><td>-5</td><td>3</td></tr><tr><td>0100</td><td>-4</td><td>4</td></tr><tr><td>0101</td><td>-3</td><td>5</td></tr><tr><td>0110</td><td>-2</td><td>6</td></tr><tr><td>0111</td><td>-1</td><td>7</td></tr><tr><td>1000</td><td>0</td><td>8</td></tr><tr><td>1001</td><td>1</td><td>9</td></tr><tr><td>1010</td><td>2</td><td>10</td></tr><tr><td>1011</td><td>3</td><td>11</td></tr><tr><td>1100</td><td>4</td><td>12</td></tr><tr><td>1101</td><td>5</td><td>13</td></tr><tr><td>1110</td><td>6</td><td>14</td></tr><tr><td>1111</td><td>7</td><td>15</td></tr></tbody></table><p><strong>Range of Representation</strong></p><p>For an n-bit number with bias as K, range of representation can be given by
$$ -k \text{ to } (2^n - 1) - k.$$</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/binary/>Binary</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html target=_blank rel="noopener noreferrer">Why Inversion and Adding One Works (Cornell)</a></li><li><a href=https://stackoverflow.com/a/1125317/10553747 target=_blank rel="noopener noreferrer">Why Two's Complement Makes Addition and Subtraction Simple (Stackoverflow)</a></li><li><a href="https://www.youtube.com/watch?v=4qH4unVtJkE" target=_blank rel="noopener noreferrer">Negative numbers in binary (Ben Eater)</a></li><li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4" target=_blank rel="noopener noreferrer">Binary Plusses & Minuses (Computerphile)</a></li><li><a href=https://en.wikipedia.org/wiki/Ones%27_complement target=_blank rel="noopener noreferrer">Ones' complement (Wikipedia)</a></li><li><a href=https://en.wikipedia.org/wiki/Two%27s_complement target=_blank rel="noopener noreferrer">Two's complement (Wikipedia)</a></li><li><a href=https://en.wikipedia.org/wiki/Offset_binary target=_blank rel="noopener noreferrer">Offset binary (Wikipedia)</a></li></ul></section></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>