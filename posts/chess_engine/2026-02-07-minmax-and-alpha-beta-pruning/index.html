<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Minmax with Alpha Beta Pruning | Sanketh's Blog</title><meta name=keywords content="minmax,alpha-beta pruning,negamax"><meta name=description content="Minmax with Alpha Beta Pruning
Game Tree Search
The Goal of a Chess Engine
A chess engine is solving:

“Given a position, what move leads to the best possible future?”

But the engine cannot know the future, so it simulates it.
This simulation is called search.
The Game Tree
Every legal move creates a new position.
From that position, the opponent also has moves.
This forms a tree:
Position
 ├── Move A
 │    ├── Opp Move A1
 │    │     ├── Move A1a
 │    │     └── Move A1b
 │    └── Opp Move A2
 │          └── ...
 └── Move B
      └── ...
This is called the game tree."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Minmax with Alpha Beta Pruning"><meta property="og:description" content="Minmax with Alpha Beta Pruning Game Tree Search The Goal of a Chess Engine A chess engine is solving:
“Given a position, what move leads to the best possible future?”
But the engine cannot know the future, so it simulates it.
This simulation is called search.
The Game Tree Every legal move creates a new position. From that position, the opponent also has moves.
This forms a tree:
Position ├── Move A │ ├── Opp Move A1 │ │ ├── Move A1a │ │ └── Move A1b │ └── Opp Move A2 │ └── ... └── Move B └── ... This is called the game tree."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-07T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-07T00:00:00+00:00"><meta property="article:tag" content="Minmax"><meta property="article:tag" content="Alpha-Beta Pruning"><meta property="article:tag" content="Negamax"><meta name=twitter:card content="summary"><meta name=twitter:title content="Minmax with Alpha Beta Pruning"><meta name=twitter:description content="Minmax with Alpha Beta Pruning
Game Tree Search
The Goal of a Chess Engine
A chess engine is solving:

“Given a position, what move leads to the best possible future?”

But the engine cannot know the future, so it simulates it.
This simulation is called search.
The Game Tree
Every legal move creates a new position.
From that position, the opponent also has moves.
This forms a tree:
Position
 ├── Move A
 │    ├── Opp Move A1
 │    │     ├── Move A1a
 │    │     └── Move A1b
 │    └── Opp Move A2
 │          └── ...
 └── Move B
      └── ...
This is called the game tree."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Minmax with Alpha Beta Pruning","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Minmax with Alpha Beta Pruning","name":"Minmax with Alpha Beta Pruning","description":"Minmax with Alpha Beta Pruning Game Tree Search The Goal of a Chess Engine A chess engine is solving:\n“Given a position, what move leads to the best possible future?”\nBut the engine cannot know the future, so it simulates it.\nThis simulation is called search.\nThe Game Tree Every legal move creates a new position. From that position, the opponent also has moves.\nThis forms a tree:\nPosition ├── Move A │ ├── Opp Move A1 │ │ ├── Move A1a │ │ └── Move A1b │ └── Opp Move A2 │ └── ... └── Move B └── ... This is called the game tree.\n","keywords":["minmax","alpha-beta pruning","negamax"],"articleBody":"Minmax with Alpha Beta Pruning Game Tree Search The Goal of a Chess Engine A chess engine is solving:\n“Given a position, what move leads to the best possible future?”\nBut the engine cannot know the future, so it simulates it.\nThis simulation is called search.\nThe Game Tree Every legal move creates a new position. From that position, the opponent also has moves.\nThis forms a tree:\nPosition ├── Move A │ ├── Opp Move A1 │ │ ├── Move A1a │ │ └── Move A1b │ └── Opp Move A2 │ └── ... └── Move B └── ... This is called the game tree.\nEvaluation Function We cannot search until checkmate (too big). So at some depth we stop and estimate who is better\nevaluate(position) → score + positive = good for white + negative = good for black We can also think of it as static evaluation function, because it generates a score just by looking at the current board with no look ahead.\nExample:\n+1.20 → White is winning -0.50 → Black slightly better 0.00 → Equal The Minimax Principle Max player (White): tries to maximize the score Min player (Black): tries to minimize the score Each player assumes the opponent plays optimally At each ply, we alternate between max and min function minimax(position, depth, isMaximizingPlayer): if depth == 0 or position.isGameOver(): return evaluate(position) if isMaximizingPlayer: maxEval = -INFINITY for each move in position.getLegalMoves(): newPosition = position.makeMove(move) eval = minimax(newPosition, depth - 1, false) maxEval = max(maxEval, eval) return maxEval else: minEval = +INFINITY for each move in position.getLegalMoves(): newPosition = position.makeMove(move) eval = minimax(newPosition, depth - 1, true) minEval = min(minEval, eval) return minEval Example\nRoot Position (White to move, MAX, depth=2) Score: ? │ ├── Move A: Nf3 │ │ │ ├── Black Move A1: d5 (MIN, depth=1) │ │ Score: ? │ │ │ │ │ ├── White Move A1a: d4 (MAX, depth=0) │ │ │ └── [EVAL: +0.3] ← Static evaluation here! │ │ │ │ │ └── White Move A1b: e3 (MAX, depth=0) │ │ └── [EVAL: +0.1] ← Static evaluation here! │ │ │ │ → MIN picks lowest: min(+0.3, +0.1) = +0.1 │ │ │ └── Black Move A2: e5 (MIN, depth=1) │ Score: ? │ │ │ ├── White Move A2a: d4 (MAX, depth=0) │ │ └── [EVAL: +0.5] ← Static evaluation here! │ │ │ └── White Move A2b: Nc3 (MAX, depth=0) │ └── [EVAL: +0.2] ← Static evaluation here! │ │ → MIN picks lowest: min(+0.5, +0.2) = +0.2 │ │ → MAX at Move A picks highest: max(+0.1, +0.2) = +0.2 │ ├── Move B: e4 │ │ │ ├── Black Move B1: c5 (MIN, depth=1) │ │ Score: ? │ │ │ │ │ ├── White Move B1a: Nf3 (MAX, depth=0) │ │ │ └── [EVAL: +0.4] ← Static evaluation here! │ │ │ │ │ └── White Move B1b: d4 (MAX, depth=0) │ │ └── [EVAL: +0.6] ← Static evaluation here! │ │ │ │ → MIN picks lowest: min(+0.4, +0.6) = +0.4 │ │ │ └── Black Move B2: e5 (MIN, depth=1) │ Score: ? │ │ │ ├── White Move B2a: Nf3 (MAX, depth=0) │ │ └── [EVAL: +0.3] ← Static evaluation here! │ │ │ └── White Move B2b: Bc4 (MAX, depth=0) │ └── [EVAL: +0.5] ← Static evaluation here! │ │ → MIN picks lowest: min(+0.3, +0.5) = +0.3 │ │ → MAX at Move B picks highest: max(+0.4, +0.3) = +0.4 │ └── Move C: d4 │ ├── Black Move C1: d5 (MIN, depth=1) │ Score: ? │ │ │ ├── White Move C1a: c4 (MAX, depth=0) │ │ └── [EVAL: +0.2] ← Static evaluation here! │ │ │ └── White Move C1b: Nf3 (MAX, depth=0) │ └── [EVAL: +0.1] ← Static evaluation here! │ │ → MIN picks lowest: min(+0.2, +0.1) = +0.1 │ └── Black Move C2: Nf6 (MIN, depth=1) Score: ? │ ├── White Move C2a: c4 (MAX, depth=0) │ └── [EVAL: +0.3] ← Static evaluation here! │ └── White Move C2b: Nc3 (MAX, depth=0) └── [EVAL: +0.4] ← Static evaluation here! → MIN picks lowest: min(+0.3, +0.4) = +0.3 → MAX at Move C picks highest: max(+0.1, +0.3) = +0.3 FINAL DECISION at Root: White chooses: max(+0.2, +0.4, +0.3) = +0.4 → Best move: e4 (Move B) Alpha-Beta Pruning The Problem with Plain Minimax Plain minimax explores every node in the tree, even when we already know some branches won’t affect the final decision.\nExample: You’re looking at move options. You found one that guarantees you a score of +5. Then you start looking at another move, and the opponent’s first response gives you -3. Do you need to check the opponent’s other responses? NO! You already have +5, so you won’t opponent to play this move in the first place.\nThis optimization is called Alpha-Beta Pruning.\nThe Two Parameters Alpha (α): The best score MAX can guarantee so far\nBest score the maximizing side (us) is GUARANTEED so far Starts at -∞ Only MAX updates it (increases it) Represents MAX’s “floor” - the worst MAX will accept Beta (β): The best score MIN can guarantee so far\nBest score the minimizing side (opponent) is GUARANTEED so far Starts at +∞ Only MIN updates it (decreases it) Represents MIN’s “ceiling” - the worst MIN will accept So at any node:\nThe true value of the position must lie inside [α, β]\nIf we ever prove it lies outside this window → stop searching because parent will never choose it.\nThe Two Types of Pruning There are two different situations where we prune, depending on which player discovers the cutoff:\n1. Beta Cutoff Occurs at a node where opponent is choosing (minimizing node).\nMeaning\nWe found a move so good for us that opponent will NEVER allow reaching this position.\nExample\nWe are evaluating Move A at root.\nWe already have:\nalpha = +2 (we can get +2 elsewhere) Now inside this branch opponent analyzes a reply:\nposition score = +5 for us Opponent says:\n“Nope. I will never play a move that gives you +5 when I can choose another line giving you +2.”\nSo this branch is irrelevant.\nTherefore:\nscore \u003e= beta → BETA CUTOFF 2. Alpha Cutoff Occurs at a node where we are choosing (maximizing node).\nMeaning\nWe found a move so bad that we will never play this line.\nExample\nOpponent already has a line giving us:\nbeta = -4 Now we analyze another continuation and find:\nscore = -7 Pseudocode function alphaBeta(position, depth, alpha, beta, isMaximizingPlayer): if depth == 0 or position.isGameOver(): return evaluate(position) if isMaximizingPlayer: maxEval = -INFINITY for each move in position.getLegalMoves(): newPosition = position.makeMove(move) eval = alphaBeta(newPosition, depth - 1, alpha, beta, false) maxEval = max(maxEval, eval) alpha = max(alpha, eval) // ← MAX updates alpha if beta \u003c= alpha: // ← Pruning condition break // Beta cutoff: MIN won't allow this path return maxEval else: // Minimizing player minEval = +INFINITY for each move in position.getLegalMoves(): newPosition = position.makeMove(move) eval = alphaBeta(newPosition, depth - 1, alpha, beta, true) minEval = min(minEval, eval) beta = min(beta, eval) // ← MIN updates beta if beta \u003c= alpha: // ← Pruning condition break // Alpha cutoff: MAX won't allow this path return minEval // Initial call from root bestMove = alphaBeta(position, MAX_DEPTH, -INFINITY, +INFINITY, true) Negamax - A Simpler Way to Write Minimax Negamax is not a different algorithm - it’s just a cleaner way to write minimax.\nInstead of having separate logic for MAX and MIN players, negamax exploits a mathematical symmetry:\n“Your best move is my worst move (negated)”\nThe Key Insight In chess (and most zero-sum games):\nWhat’s good for White (+5) is equally bad for Black (-5) White maximizes the score Black minimizes the score But we can flip the perspective:\nFrom White’s view: position scores +5 From Black’s view: same position scores -5 So instead of:\nWhite (MAX): pick maximum Black (MIN): pick minimum We can do:\nCurrent player: pick maximum FROM THEIR PERSPECTIVE Opponent: negate the score to flip perspective Minimax vs Negamax - Side by Side Regular Minimax\nfunction minimax(position, depth, isMaximizingPlayer): if depth == 0: return evaluate(position) if isMaximizingPlayer: // White's turn maxEval = -INFINITY for each move in position.getLegalMoves(): eval = minimax(makeMove(move), depth - 1, false) maxEval = max(maxEval, eval) return maxEval else: // Black's turn minEval = +INFINITY for each move in position.getLegalMoves(): eval = minimax(makeMove(move), depth - 1, true) minEval = min(minEval, eval) return minEval Negamax - Simplified!\nfunction negamax(position, depth, color): if depth == 0: return color * evaluate(position) # ← Flip perspective! maxEval = -INFINITY for each move in position.getLegalMoves(): eval = -negamax(makeMove(move), depth - 1, -color) // ← Negate! maxEval = max(maxEval, eval) return maxEval // Initial call // color = +1 for White (maximizing) // color = -1 for Black (minimizing) bestScore = negamax(position, depth, +1) Why Negate the Recursive Call?\neval = -negamax(...) Think of it as switching perspective:\nChild node returns score from their perspective We want score from our perspective Our best = opponent’s worst So we negate! Example:\nBlack finds a position worth -5 from White’s view → From Black’s view, that’s +5 (good for Black!) → Negamax returns +5 to Black → White receives -5 (bad for White, correctly)\nLet’s trace a simple tree:\nPosition (White to move, color=+1, depth=2) │ ├── Move A │ │ │ └── Position after A (Black to move, color=-1, depth=1) │ │ │ ├── Move A1 │ │ └── [EVAL from White's view: +3] │ │ color=-1, so return: -1 * (+3) = -3 │ │ To White (parent): -(-3) = +3 │ │ │ └── Move A2 │ └── [EVAL from White's view: +1] │ color=-1, so return: -1 * (+1) = -1 │ To White (parent): -(-1) = +1 │ │ Black picks max(-3, -1) = -1 (best for Black) │ Return to White: -(-1) = +1 │ └── Move B │ └── Position after B (Black to move, color=-1, depth=1) │ ├── Move B1 │ └── [EVAL: +5] │ Returns to Black: -1 * (+5) = -5 │ To White: -(-5) = +5 │ └── Move B2 └── [EVAL: +2] Returns to Black: -1 * (+2) = -2 To White: -(-2) = +2 Black picks max(-5, -2) = -2 Return to White: -(-2) = +2 White picks max(+1, +2) = +2 Best move: B Negamax with Alpha-Beta Pruning function negamax(position, depth, alpha, beta, color): if depth == 0: return color * evaluate(position) maxEval = -INFINITY for each move in position.getLegalMoves(): eval = -negamax(makeMove(move), depth - 1, -beta, -alpha, -color) maxEval = max(maxEval, eval) alpha = max(alpha, eval) if alpha \u003e= beta: break # Prune return maxEval # Initial call bestScore = negamax(position, MAX_DEPTH, -INFINITY, +INFINITY, +1) Why swap alpha and beta?\nAlpha/beta represent a window from current player’s perspective When we flip perspective (negate), we must also flip the window Your alpha becomes opponent’s negative beta, and vice versa Alpha and Beta in Negamax In negamax, alpha and beta always represent the window from the CURRENT player’s perspective.\nAlpha: \"I'm guaranteed at least this score\" Beta: \"My opponent won't let me get more than this\" Both players use the same logic, but when we recurse, we negate and swap the window.\nWhy We Swap Alpha and Beta\nYour alpha = “best I can guarantee”\nFor opponent, this becomes their beta = “worst they’ll allow you” But negated: -alpha Your beta = “best opponent will allow”\nFor opponent, this becomes their alpha = “best they can guarantee” But negated: -beta Step-by-Step Example\nRoot: White's turn (color = +1) alpha = -∞, beta = +∞ \"I want at least -∞, opponent won't give me more than +∞\" ├── Exploring Move A │ │ Call: negamax(positionA, depth-1, -∞, +∞, -1) │ ↓ │ After negation: negamax(..., -beta, -alpha, -color) │ -(+∞) -(-∞) │ -∞ +∞ │ │ Black's turn (color = -1) │ alpha = -∞, beta = +∞ (from Black's perspective) │ \"I (Black) want at least -∞, White won't give me more than +∞\" │ │ ├── Move A1: returns +3 (from Black's view) │ │ alpha = max(-∞, +3) = +3 │ │ \"I now have at least +3 (from my Black perspective)\" │ │ │ ├── Move A2: returns +1 │ │ alpha = max(+3, +1) = +3 (no change) │ │ Black returns: +3 │ │ Back to White: -(+3) = -3 │ White's alpha = max(-∞, -3) = -3 │ \"I (White) now have at least -3\" │ ├── Exploring Move B │ │ White now has alpha = -3, beta = +∞ │ │ Call: negamax(positionB, depth-1, -beta, -alpha, -color) │ -(+∞) -(-3) │ -∞ +3 ← Swapped! │ │ Black's turn │ alpha = -∞, beta = +3 (from Black's perspective) │ \"I want at least -∞, but White won't let me get more than +3\" │ ↑ │ This came from White's alpha = -3 │ │ ├── Move B1: returns +5 (from Black's view) │ │ alpha = max(-∞, +5) = +5 │ │ Check: alpha \u003e= beta? → +5 \u003e= +3? YES! ✂️ │ │ PRUNE! (Beta cutoff) │ │ │ │ Why prune? │ │ Black found +5 for themselves │ │ But White (parent) already has -3 guaranteed │ │ From White's view, +5 for Black = -5 for White │ │ White won't choose this branch (-5 \u003c -3) │ │ └── Move B2: ✂️ Not explored Iterative Deepening Imagine you’re writing a chess engine and give it 10 seconds to find a move.\nNaive approach:\n\"Let me search to depth 6... oh wait, this is taking 15 seconds!\" → Time's up, no move found yet! Better approach (Iterative Deepening):\nDepth 1: 0.001s → Found move: e4 (score: +0.2) Depth 2: 0.01s → Found move: e4 (score: +0.3) Depth 3: 0.1s → Found move: Nf3 (score: +0.4) Depth 4: 1s → Found move: Nf3 (score: +0.5) Depth 5: 8s → Found move: d4 (score: +0.6) [Time's up!] → Return d4 (best move found at depth 5) Iterative Deepening: Search depth 1, then depth 2, then depth 3… until time runs out. Always have a move ready!\nPseudocode Basic Iterative Deepening function iterativeDeepeningSearch(position, maxTime): startTime = currentTime() bestMove = null bestScore = -INFINITY for depth = 1 to INFINITY: # Check if we have time for this depth if currentTime() - startTime \u003e= maxTime: break # Search at current depth score, move = negamax(position, depth, -INF, +INF, +1) # Update best move found so far bestMove = move bestScore = score # Optional: print info print(\"Depth:\", depth, \"Move:\", move, \"Score:\", score) return bestMove With Time Management function iterativeDeepeningSearch(position, maxTime): startTime = currentTime() bestMove = null timeForDepth = [] # Track time per depth for depth = 1 to MAX_DEPTH: depthStartTime = currentTime() # Estimate if we have time for this depth if depth \u003e 2: estimatedTime = predictTimeForDepth(depth, timeForDepth) if currentTime() - startTime + estimatedTime \u003e maxTime: break # Not enough time, use previous result # Search at current depth score, move = alphaBeta(position, depth, -INF, +INF, +1) # Record how long this depth took timeForDepth.append(currentTime() - depthStartTime) # Update best move bestMove = move bestScore = score # Check if time is up if currentTime() - startTime \u003e= maxTime: break return bestMove Why Does This Work? Isn’t searching depth 1, 2, 3… wasteful?\"\nIntuition says: Yes! You’re re-searching the same positions multiple times.\nReality says: No! The time is dominated by the deepest search.\nThe Math Behind It Chess has a branching factor of ~35 (average legal moves per position).\nTime for each depth: Depth 1: 35^1 = 35 nodes Depth 2: 35^2 = 1,225 nodes Depth 3: 35^3 = 42,875 nodes Depth 4: 35^4 = 1,500,625 nodes Depth 5: 35^5 = 52,521,875 nodes Depth 6: 35^6 = 1,838,265,625 nodes Total work with Iterative Deepening to depth 6: Total = 35 + 1,225 + 42,875 + ... + 1,838,265,625 ≈ 1,838,310,235 nodes Just depth 6 alone: 1,838,265,625 nodes Overhead from earlier depths: 44,610 nodes (0.002%!) The overhead is negligible! The deepest search dominates everything.\nGeneral Formula For branching factor b and depth d:\nTime for depth d: b^d\nTotal time with ID:\nb^1 + b^2 + b^3 + ... + b^d = (b^(d+1) - b) / (b - 1) ≈ b^d * (b / (b-1)) For b=35: Overhead factor = 35 / 34 = 1.029 Benefits of Iterative Deepening 1. Time Management # Always have a move ready for depth in 1..∞: if timeUp(): return bestMoveFoundSoFar # ← Always valid! search(depth) 2. Better Move Ordering Results from shallower searches help order moves in deeper searches:\n# Depth 3 found: d4 is best, Nf3 second, e4 third # At depth 4, search in this order first: moves = [d4, Nf3, e4, ...] # ← Previous best first! # → More alpha-beta pruning! This is called Principal Variation (PV) move ordering.\nPrincipal Variation = the line of moves the engine currently believes is best.\nExample after depth 4:\nPV: 1. Nf3 d5 2. d4 Nf6 This dramatically speeds up alpha-beta pruning because\nAlpha-beta is only fast if you search the BEST move first.\nIf the best move is searched late → pruning almost disappears.\n3. Progressive Information Depth 1: e4 (+0.2) [0.001s] Depth 2: e4 (+0.3) [0.01s] Depth 3: Nf3 (+0.4) [0.1s] Depth 4: Nf3 (+0.5) [1s] You see the engine “thinking deeper” in real-time!\n4. Handles Unknown Time Limits Don’t know how long to search? Just keep going deeper until interrupted!\nPsuedocode (Time Limit and PV move Ordering)\nfunction findBestMove(position, maxTime): startTime = now() bestMove = null pvMoves = [] # Principal variation from previous depth for depth = 1 to 100: # Practically infinite # Check time before starting new depth elapsed = now() - startTime if elapsed \u003e maxTime * 0.9: # Leave 10% buffer break # Search at current depth with move ordering result = search(position, depth, pvMoves) # Update best move and PV bestMove = result.move bestScore = result.score pvMoves = result.principalVariation # Log progress print(f\"Depth {depth}: {bestMove} (score: {bestScore}, time: {elapsed}s)\") # Check for forced mate if abs(bestScore) \u003e MATE_THRESHOLD: print(f\"Mate found in {depth} plies!\") break return bestMove function search(position, depth, pvMoves): # Order moves: PV move first, then others moves = orderMoves(position.getLegalMoves(), pvMoves) bestMove = null bestScore = -INFINITY alpha = -INFINITY beta = +INFINITY pv = [] for move in moves: newPos = position.makeMove(move) score = -negamax(newPos, depth - 1, -beta, -alpha, -1) if score \u003e bestScore: bestScore = score bestMove = move pv = [move] + childPV alpha = max(alpha, score) return {move: bestMove, score: bestScore, principalVariation: pv} 5. Iterative Deepening with Aspiration Windows Advanced engines narrow the alpha-beta window using previous depth’s score:\nNormally search starts with:\nalpha = -∞ beta = +∞ Meaning:\n“I have no idea what the position score is — search everything.”\nThis is slow because pruning is weak.\nKey Observation\nFrom iterative deepening, you already know the score from previous depth.\nExample:\nDepth 6 → score = +0.32 Depth 7 → score ≈ probably near +0.32 Chess positions are stable. Score rarely jumps from +0.3 → -5.0 in one extra ply.\nSo instead of searching full range…\nwe search only near the expected value.\nAspiration Window Idea\nInstead of:\nalpha = -∞ beta = +∞ we search:\nalpha = previousScore - margin beta = previousScore + margin Why this is FAST\nAlpha-beta pruning strength depends on window size.\nSmaller window ⇒ way more cutoffs ⇒ exponential speedup\nfunction iterativeDeepening(position, maxTime): previousScore = 0 for depth = 1 to ∞: # Use narrow window around previous score windowSize = 0.5 alpha = previousScore - windowSize beta = previousScore + windowSize score = negamax(position, depth, alpha, beta, +1) # Re-search if score falls outside window if score \u003c= alpha or score \u003e= beta: # Widen window and re-search score = negamax(position, depth, -INF, +INF, +1) previousScore = score if timeUp(): break return bestMove ","wordCount":"3326","inLanguage":"en","datePublished":"2026-02-07T00:00:00Z","dateModified":"2026-02-07T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Minmax with Alpha Beta Pruning</h1><div class=post-meta><span title='2026-02-07 00:00:00 +0000 UTC'>February 7, 2026</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-02-07-minmax-and-alpha-beta-pruning.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#minmax-with-alpha-beta-pruning aria-label="Minmax with Alpha Beta Pruning">Minmax with Alpha Beta Pruning</a><ul><li><a href=#game-tree-search aria-label="Game Tree Search">Game Tree Search</a><ul><li><a href=#the-goal-of-a-chess-engine aria-label="The Goal of a Chess Engine">The Goal of a Chess Engine</a></li><li><a href=#the-game-tree aria-label="The Game Tree">The Game Tree</a></li><li><a href=#evaluation-function aria-label="Evaluation Function">Evaluation Function</a></li></ul></li><li><a href=#the-minimax-principle aria-label="The Minimax Principle">The Minimax Principle</a></li><li><a href=#alpha-beta-pruning aria-label="Alpha-Beta Pruning">Alpha-Beta Pruning</a><ul><li><a href=#the-problem-with-plain-minimax aria-label="The Problem with Plain Minimax">The Problem with Plain Minimax</a></li><li><a href=#the-two-parameters aria-label="The Two Parameters">The Two Parameters</a></li><li><a href=#the-two-types-of-pruning aria-label="The Two Types of Pruning">The Two Types of Pruning</a><ul><li><a href=#1-beta-cutoff aria-label="1. Beta Cutoff">1. Beta Cutoff</a></li><li><a href=#2-alpha-cutoff aria-label="2. Alpha Cutoff">2. Alpha Cutoff</a></li><li><a href=#pseudocode aria-label=Pseudocode>Pseudocode</a></li></ul></li></ul></li><li><a href=#negamax---a-simpler-way-to-write-minimax aria-label="Negamax - A Simpler Way to Write Minimax">Negamax - A Simpler Way to Write Minimax</a><ul><li><a href=#the-key-insight aria-label="The Key Insight">The Key Insight</a></li><li><a href=#minimax-vs-negamax---side-by-side aria-label="Minimax vs Negamax - Side by Side">Minimax vs Negamax - Side by Side</a></li><li><a href=#negamax-with-alpha-beta-pruning aria-label="Negamax with Alpha-Beta Pruning">Negamax with Alpha-Beta Pruning</a><ul><li><a href=#alpha-and-beta-in-negamax aria-label="Alpha and Beta in Negamax">Alpha and Beta in Negamax</a></li></ul></li></ul></li><li><a href=#iterative-deepening aria-label="Iterative Deepening">Iterative Deepening</a><ul><li><a href=#pseudocode-1 aria-label=Pseudocode>Pseudocode</a><ul><li><a href=#basic-iterative-deepening aria-label="Basic Iterative Deepening">Basic Iterative Deepening</a></li><li><a href=#with-time-management aria-label="With Time Management">With Time Management</a></li></ul></li><li><a href=#why-does-this-work aria-label="Why Does This Work?">Why Does This Work?</a><ul><li><a href=#the-math-behind-it aria-label="The Math Behind It">The Math Behind It</a></li><li><a href=#time-for-each-depth aria-label="Time for each depth:">Time for each depth:</a></li><li><a href=#total-work-with-iterative-deepening-to-depth-6 aria-label="Total work with Iterative Deepening to depth 6:">Total work with Iterative Deepening to depth 6:</a></li></ul></li><li><a href=#general-formula aria-label="General Formula">General Formula</a></li><li><a href=#benefits-of-iterative-deepening aria-label="Benefits of Iterative Deepening">Benefits of Iterative Deepening</a><ul><li><a href=#1-time-management aria-label="1. Time Management">1. Time Management</a></li><li><a href=#2-better-move-ordering aria-label="2. Better Move Ordering">2. Better Move Ordering</a></li><li><a href=#3-progressive-information aria-label="3. Progressive Information">3. Progressive Information</a></li><li><a href=#4-handles-unknown-time-limits aria-label="4. Handles Unknown Time Limits">4. Handles Unknown Time Limits</a></li><li><a href=#5-iterative-deepening-with-aspiration-windows aria-label="5. Iterative Deepening with Aspiration Windows">5. Iterative Deepening with Aspiration Windows</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=minmax-with-alpha-beta-pruning>Minmax with Alpha Beta Pruning<a hidden class=anchor aria-hidden=true href=#minmax-with-alpha-beta-pruning>#</a></h1><h2 id=game-tree-search>Game Tree Search<a hidden class=anchor aria-hidden=true href=#game-tree-search>#</a></h2><h3 id=the-goal-of-a-chess-engine>The Goal of a Chess Engine<a hidden class=anchor aria-hidden=true href=#the-goal-of-a-chess-engine>#</a></h3><p>A chess engine is solving:</p><blockquote><p>“Given a position, what move leads to the best possible future?”</p></blockquote><p>But the engine cannot know the future, so it simulates it.</p><p>This simulation is called search.</p><h3 id=the-game-tree>The Game Tree<a hidden class=anchor aria-hidden=true href=#the-game-tree>#</a></h3><p>Every legal move creates a new position.
From that position, the opponent also has moves.</p><p>This forms a tree:</p><pre tabindex=0><code>Position
 ├── Move A
 │    ├── Opp Move A1
 │    │     ├── Move A1a
 │    │     └── Move A1b
 │    └── Opp Move A2
 │          └── ...
 └── Move B
      └── ...
</code></pre><p>This is called the game tree.</p><h3 id=evaluation-function>Evaluation Function<a hidden class=anchor aria-hidden=true href=#evaluation-function>#</a></h3><p>We cannot search until checkmate (too big).
So at some depth we stop and estimate who is better</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>evaluate(position) <span style=color:#960050;background-color:#1e0010>→</span> score
</span></span><span style=display:flex><span><span style=color:#f92672>+</span> positive <span style=color:#f92672>=</span> good <span style=color:#66d9ef>for</span> white
</span></span><span style=display:flex><span><span style=color:#f92672>+</span> negative <span style=color:#f92672>=</span> good <span style=color:#66d9ef>for</span> black
</span></span></code></pre></div><p>We can also think of it as static evaluation function, because it generates a score just by looking at the current board with no look ahead.</p><p>Example:</p><pre tabindex=0><code>+1.20  → White is winning
-0.50  → Black slightly better
0.00   → Equal
</code></pre><h2 id=the-minimax-principle>The Minimax Principle<a hidden class=anchor aria-hidden=true href=#the-minimax-principle>#</a></h2><ul><li>Max player (White): tries to maximize the score</li><li>Min player (Black): tries to minimize the score</li><li>Each player assumes the opponent plays optimally</li><li>At each ply, we alternate between max and min</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>minimax</span>(<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>depth</span>, <span style=color:#a6e22e>isMaximizingPlayer</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#a6e22e>or</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>isGameOver</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>evaluate</span>(<span style=color:#a6e22e>position</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isMaximizingPlayer</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newPosition</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>)
</span></span><span style=display:flex><span>            eval <span style=color:#f92672>=</span> <span style=color:#a6e22e>minimax</span>(<span style=color:#a6e22e>newPosition</span>, <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>maxEval</span>, eval)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>maxEval</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>minEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newPosition</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>)
</span></span><span style=display:flex><span>            eval <span style=color:#f92672>=</span> <span style=color:#a6e22e>minimax</span>(<span style=color:#a6e22e>newPosition</span>, <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>minEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>minEval</span>, eval)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>minEval</span>
</span></span></code></pre></div><p>Example</p><pre tabindex=0><code>Root Position (White to move, MAX, depth=2)
Score: ?
│
├── Move A: Nf3
│   │
│   ├── Black Move A1: d5 (MIN, depth=1)
│   │   Score: ?
│   │   │
│   │   ├── White Move A1a: d4 (MAX, depth=0) 
│   │   │   └── [EVAL: +0.3] ← Static evaluation here!
│   │   │
│   │   └── White Move A1b: e3 (MAX, depth=0)
│   │       └── [EVAL: +0.1] ← Static evaluation here!
│   │   
│   │   → MIN picks lowest: min(+0.3, +0.1) = +0.1
│   │
│   └── Black Move A2: e5 (MIN, depth=1)
│       Score: ?
│       │
│       ├── White Move A2a: d4 (MAX, depth=0)
│       │   └── [EVAL: +0.5] ← Static evaluation here!
│       │
│       └── White Move A2b: Nc3 (MAX, depth=0)
│           └── [EVAL: +0.2] ← Static evaluation here!
│       
│       → MIN picks lowest: min(+0.5, +0.2) = +0.2
│   
│   → MAX at Move A picks highest: max(+0.1, +0.2) = +0.2
│
├── Move B: e4
│   │
│   ├── Black Move B1: c5 (MIN, depth=1)
│   │   Score: ?
│   │   │
│   │   ├── White Move B1a: Nf3 (MAX, depth=0)
│   │   │   └── [EVAL: +0.4] ← Static evaluation here!
│   │   │
│   │   └── White Move B1b: d4 (MAX, depth=0)
│   │       └── [EVAL: +0.6] ← Static evaluation here!
│   │   
│   │   → MIN picks lowest: min(+0.4, +0.6) = +0.4
│   │
│   └── Black Move B2: e5 (MIN, depth=1)
│       Score: ?
│       │
│       ├── White Move B2a: Nf3 (MAX, depth=0)
│       │   └── [EVAL: +0.3] ← Static evaluation here!
│       │
│       └── White Move B2b: Bc4 (MAX, depth=0)
│           └── [EVAL: +0.5] ← Static evaluation here!
│       
│       → MIN picks lowest: min(+0.3, +0.5) = +0.3
│   
│   → MAX at Move B picks highest: max(+0.4, +0.3) = +0.4
│
└── Move C: d4
    │
    ├── Black Move C1: d5 (MIN, depth=1)
    │   Score: ?
    │   │
    │   ├── White Move C1a: c4 (MAX, depth=0)
    │   │   └── [EVAL: +0.2] ← Static evaluation here!
    │   │
    │   └── White Move C1b: Nf3 (MAX, depth=0)
    │       └── [EVAL: +0.1] ← Static evaluation here!
    │   
    │   → MIN picks lowest: min(+0.2, +0.1) = +0.1
    │
    └── Black Move C2: Nf6 (MIN, depth=1)
        Score: ?
        │
        ├── White Move C2a: c4 (MAX, depth=0)
        │   └── [EVAL: +0.3] ← Static evaluation here!
        │
        └── White Move C2b: Nc3 (MAX, depth=0)
            └── [EVAL: +0.4] ← Static evaluation here!
        
        → MIN picks lowest: min(+0.3, +0.4) = +0.3
    
    → MAX at Move C picks highest: max(+0.1, +0.3) = +0.3

FINAL DECISION at Root:
White chooses: max(+0.2, +0.4, +0.3) = +0.4
→ Best move: e4 (Move B)
</code></pre><h2 id=alpha-beta-pruning>Alpha-Beta Pruning<a hidden class=anchor aria-hidden=true href=#alpha-beta-pruning>#</a></h2><h3 id=the-problem-with-plain-minimax>The Problem with Plain Minimax<a hidden class=anchor aria-hidden=true href=#the-problem-with-plain-minimax>#</a></h3><p>Plain minimax explores every node in the tree, even when we already know some branches won&rsquo;t affect the final decision.</p><p><strong>Example:</strong> You&rsquo;re looking at move options. You found one that guarantees you a score of +5. Then you start looking at another move, and the opponent&rsquo;s first response gives you -3. Do you need to check the opponent&rsquo;s other responses? NO! You already have +5, so you won&rsquo;t opponent to play this move in the first place.</p><p>This optimization is called Alpha-Beta Pruning.</p><h3 id=the-two-parameters>The Two Parameters<a hidden class=anchor aria-hidden=true href=#the-two-parameters>#</a></h3><p><strong>Alpha (α):</strong> The best score MAX can guarantee so far</p><ul><li>Best score the maximizing side (us) is GUARANTEED so far</li><li>Starts at -∞</li><li>Only MAX updates it (increases it)</li><li>Represents MAX&rsquo;s &ldquo;floor&rdquo; - the worst MAX will accept</li></ul><p><strong>Beta (β):</strong> The best score MIN can guarantee so far</p><ul><li>Best score the minimizing side (opponent) is GUARANTEED so far</li><li>Starts at +∞</li><li>Only MIN updates it (decreases it)</li><li>Represents MIN&rsquo;s &ldquo;ceiling&rdquo; - the worst MIN will accept</li></ul><p>So at any node:</p><blockquote><p>The true value of the position must lie inside [α, β]</p></blockquote><p>If we ever prove it lies outside this window → stop searching
because parent will never choose it.</p><h3 id=the-two-types-of-pruning>The Two Types of Pruning<a hidden class=anchor aria-hidden=true href=#the-two-types-of-pruning>#</a></h3><p>There are two different situations where we prune, depending on which player discovers the cutoff:</p><h4 id=1-beta-cutoff>1. Beta Cutoff<a hidden class=anchor aria-hidden=true href=#1-beta-cutoff>#</a></h4><p>Occurs at a node where opponent is choosing (minimizing node).</p><p><strong>Meaning</strong></p><p>We found a move so good for us
that opponent will NEVER allow reaching this position.</p><p><strong>Example</strong></p><p>We are evaluating Move A at root.</p><p>We already have:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>alpha <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>   (we can get <span style=color:#f92672>+</span><span style=color:#ae81ff>2</span> elsewhere)
</span></span></code></pre></div><p>Now inside this branch opponent analyzes a reply:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>position score <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>5</span> <span style=color:#66d9ef>for</span> us
</span></span></code></pre></div><p>Opponent says:</p><blockquote><p>“Nope. I will never play a move that gives you +5 when I can choose another line giving you +2.”</p></blockquote><p>So this branch is irrelevant.</p><p>Therefore:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>score <span style=color:#f92672>&gt;=</span> beta  <span style=color:#960050;background-color:#1e0010>→</span>  BETA CUTOFF
</span></span></code></pre></div><h4 id=2-alpha-cutoff>2. Alpha Cutoff<a hidden class=anchor aria-hidden=true href=#2-alpha-cutoff>#</a></h4><p>Occurs at a node where we are choosing (maximizing node).</p><p><strong>Meaning</strong></p><p>We found a move so bad
that we will never play this line.</p><p><strong>Example</strong></p><p>Opponent already has a line giving us:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>beta <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>Now we analyze another continuation and find:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>score <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>7</span>
</span></span></code></pre></div><h4 id=pseudocode>Pseudocode<a hidden class=anchor aria-hidden=true href=#pseudocode>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>alphaBeta</span>(<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>depth</span>, <span style=color:#a6e22e>alpha</span>, <span style=color:#a6e22e>beta</span>, <span style=color:#a6e22e>isMaximizingPlayer</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#a6e22e>or</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>isGameOver</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>evaluate</span>(<span style=color:#a6e22e>position</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isMaximizingPlayer</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newPosition</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>)
</span></span><span style=display:flex><span>            eval <span style=color:#f92672>=</span> <span style=color:#a6e22e>alphaBeta</span>(<span style=color:#a6e22e>newPosition</span>, <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>alpha</span>, <span style=color:#a6e22e>beta</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>maxEval</span>, eval)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>alpha</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>alpha</span>, eval)          <span style=color:#75715e>// ← MAX updates alpha
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>beta</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>alpha</span><span style=color:#f92672>:</span>                 <span style=color:#75715e>// ← Pruning condition
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>  <span style=color:#75715e>// Beta cutoff: MIN won&#39;t allow this path
</span></span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>maxEval</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span><span style=color:#f92672>:</span>  <span style=color:#75715e>// Minimizing player
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>minEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newPosition</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>)
</span></span><span style=display:flex><span>            eval <span style=color:#f92672>=</span> <span style=color:#a6e22e>alphaBeta</span>(<span style=color:#a6e22e>newPosition</span>, <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>alpha</span>, <span style=color:#a6e22e>beta</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>minEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>minEval</span>, eval)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>beta</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>beta</span>, eval)            <span style=color:#75715e>// ← MIN updates beta
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>beta</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>alpha</span><span style=color:#f92672>:</span>                 <span style=color:#75715e>// ← Pruning condition
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>  <span style=color:#75715e>// Alpha cutoff: MAX won&#39;t allow this path
</span></span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>minEval</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Initial call from root
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>bestMove</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>alphaBeta</span>(<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>MAX_DEPTH</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>INFINITY</span>, <span style=color:#f92672>+</span><span style=color:#a6e22e>INFINITY</span>, <span style=color:#66d9ef>true</span>)
</span></span></code></pre></div><h2 id=negamax---a-simpler-way-to-write-minimax>Negamax - A Simpler Way to Write Minimax<a hidden class=anchor aria-hidden=true href=#negamax---a-simpler-way-to-write-minimax>#</a></h2><p>Negamax is not a different algorithm - it&rsquo;s just a cleaner way to write minimax.</p><p>Instead of having separate logic for MAX and MIN players, negamax exploits a mathematical symmetry:</p><blockquote><p>&ldquo;Your best move is my worst move (negated)&rdquo;</p></blockquote><h3 id=the-key-insight>The Key Insight<a hidden class=anchor aria-hidden=true href=#the-key-insight>#</a></h3><p>In chess (and most zero-sum games):</p><ul><li>What&rsquo;s good for White (+5) is equally bad for Black (-5)</li><li>White maximizes the score</li><li>Black minimizes the score</li></ul><p>But we can flip the perspective:</p><ul><li><strong>From White&rsquo;s view:</strong> position scores +5</li><li><strong>From Black&rsquo;s view:</strong> same position scores -5</li></ul><p>So instead of:</p><pre tabindex=0><code>White (MAX): pick maximum
Black (MIN): pick minimum
</code></pre><p>We can do:</p><pre tabindex=0><code>Current player: pick maximum FROM THEIR PERSPECTIVE
Opponent: negate the score to flip perspective
</code></pre><h3 id=minimax-vs-negamax---side-by-side>Minimax vs Negamax - Side by Side<a hidden class=anchor aria-hidden=true href=#minimax-vs-negamax---side-by-side>#</a></h3><p><strong>Regular Minimax</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>minimax</span>(<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>depth</span>, <span style=color:#a6e22e>isMaximizingPlayer</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>evaluate</span>(<span style=color:#a6e22e>position</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isMaximizingPlayer</span><span style=color:#f92672>:</span>  <span style=color:#75715e>// White&#39;s turn
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            eval <span style=color:#f92672>=</span> <span style=color:#a6e22e>minimax</span>(<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>), <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>maxEval</span>, eval)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>maxEval</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span><span style=color:#f92672>:</span>  <span style=color:#75715e>// Black&#39;s turn
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>minEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            eval <span style=color:#f92672>=</span> <span style=color:#a6e22e>minimax</span>(<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>), <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>minEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>min</span>(<span style=color:#a6e22e>minEval</span>, eval)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>minEval</span>
</span></span></code></pre></div><p><strong>Negamax - Simplified!</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>negamax</span>(<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>depth</span>, <span style=color:#a6e22e>color</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>color</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>evaluate</span>(<span style=color:#a6e22e>position</span>)  <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>←</span> <span style=color:#a6e22e>Flip</span> <span style=color:#a6e22e>perspective</span><span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>INFINITY</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>move</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>getLegalMoves</span>()<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        eval <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>negamax</span>(<span style=color:#a6e22e>makeMove</span>(<span style=color:#a6e22e>move</span>), <span style=color:#a6e22e>depth</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#a6e22e>color</span>)  <span style=color:#75715e>// ← Negate!
</span></span></span><span style=display:flex><span>        <span style=color:#a6e22e>maxEval</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>maxEval</span>, eval)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>maxEval</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Initial call
</span></span></span><span style=display:flex><span><span style=color:#75715e>// color = +1 for White (maximizing)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// color = -1 for Black (minimizing)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>bestScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>negamax</span>(<span style=color:#a6e22e>position</span>, <span style=color:#a6e22e>depth</span>, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p><strong>Why Negate the Recursive Call?</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>eval <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>negamax(...)
</span></span></code></pre></div><p>Think of it as <strong>switching perspective</strong>:</p><ul><li>Child node returns score from their perspective</li><li>We want score from our perspective</li><li>Our best = opponent&rsquo;s worst</li><li>So we negate!</li></ul><p><strong>Example:</strong></p><p>Black finds a position worth -5 from White&rsquo;s view
→ From Black&rsquo;s view, that&rsquo;s +5 (good for Black!)
→ Negamax returns +5 to Black
→ White receives -5 (bad for White, correctly)</p><p>Let&rsquo;s trace a simple tree:</p><pre tabindex=0><code>Position (White to move, color=+1, depth=2)
│
├── Move A
│   │
│   └── Position after A (Black to move, color=-1, depth=1)
│       │
│       ├── Move A1
│       │   └── [EVAL from White&#39;s view: +3]
│       │       color=-1, so return: -1 * (+3) = -3
│       │       To White (parent): -(-3) = +3
│       │
│       └── Move A2
│           └── [EVAL from White&#39;s view: +1]
│               color=-1, so return: -1 * (+1) = -1
│               To White (parent): -(-1) = +1
│       
│       Black picks max(-3, -1) = -1 (best for Black)
│       Return to White: -(-1) = +1
│
└── Move B
    │
    └── Position after B (Black to move, color=-1, depth=1)
        │
        ├── Move B1
        │   └── [EVAL: +5]
        │       Returns to Black: -1 * (+5) = -5
        │       To White: -(-5) = +5
        │
        └── Move B2
            └── [EVAL: +2]
                Returns to Black: -1 * (+2) = -2
                To White: -(-2) = +2
        
        Black picks max(-5, -2) = -2
        Return to White: -(-2) = +2

White picks max(+1, +2) = +2
Best move: B
</code></pre><h3 id=negamax-with-alpha-beta-pruning>Negamax with Alpha-Beta Pruning<a hidden class=anchor aria-hidden=true href=#negamax-with-alpha-beta-pruning>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span>function negamax(position, depth, alpha, beta, color):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> color <span style=color:#f92672>*</span> evaluate(position)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    maxEval <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>INFINITY
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> each move <span style=color:#f92672>in</span> position<span style=color:#f92672>.</span>getLegalMoves():
</span></span><span style=display:flex><span>        eval <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>negamax(makeMove(move), depth <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span>beta, <span style=color:#f92672>-</span>alpha, <span style=color:#f92672>-</span>color)
</span></span><span style=display:flex><span>        maxEval <span style=color:#f92672>=</span> max(maxEval, eval)
</span></span><span style=display:flex><span>        alpha <span style=color:#f92672>=</span> max(alpha, eval)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> alpha <span style=color:#f92672>&gt;=</span> beta:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>  <span style=color:#75715e># Prune</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> maxEval
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Initial call</span>
</span></span><span style=display:flex><span>bestScore <span style=color:#f92672>=</span> negamax(position, MAX_DEPTH, <span style=color:#f92672>-</span>INFINITY, <span style=color:#f92672>+</span>INFINITY, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p><strong>Why swap alpha and beta?</strong></p><ul><li>Alpha/beta represent a window from current player&rsquo;s perspective</li><li>When we flip perspective (negate), we must also flip the window</li><li>Your alpha becomes opponent&rsquo;s negative beta, and vice versa</li></ul><h4 id=alpha-and-beta-in-negamax>Alpha and Beta in Negamax<a hidden class=anchor aria-hidden=true href=#alpha-and-beta-in-negamax>#</a></h4><p>In negamax, alpha and beta always represent the window from the CURRENT player&rsquo;s perspective.</p><pre tabindex=0><code>Alpha: &#34;I&#39;m guaranteed at least this score&#34;
Beta:  &#34;My opponent won&#39;t let me get more than this&#34;
</code></pre><p>Both players use the same logic, but when we recurse, we negate and swap the window.</p><p><strong>Why We Swap Alpha and Beta</strong></p><ol><li><p><strong>Your alpha</strong> = &ldquo;best I can guarantee&rdquo;</p><ul><li>For opponent, this becomes <strong>their beta</strong> = &ldquo;worst they&rsquo;ll allow you&rdquo;</li><li>But negated: <code>-alpha</code></li></ul></li><li><p><strong>Your beta</strong> = &ldquo;best opponent will allow&rdquo;</p><ul><li>For opponent, this becomes <strong>their alpha</strong> = &ldquo;best they can guarantee&rdquo;</li><li>But negated: <code>-beta</code></li></ul></li></ol><p><strong>Step-by-Step Example</strong></p><pre tabindex=0><code>Root: White&#39;s turn (color = +1)
      alpha = -∞, beta = +∞
      &#34;I want at least -∞, opponent won&#39;t give me more than +∞&#34;
      
├── Exploring Move A
│   
│   Call: negamax(positionA, depth-1, -∞, +∞, -1)
│                                      ↓
│         After negation: negamax(..., -beta, -alpha, -color)
│                                      -(+∞)  -(-∞)
│                                       -∞     +∞
│   
│   Black&#39;s turn (color = -1)
│   alpha = -∞, beta = +∞  (from Black&#39;s perspective)
│   &#34;I (Black) want at least -∞, White won&#39;t give me more than +∞&#34;
│   
│   ├── Move A1: returns +3 (from Black&#39;s view)
│   │   alpha = max(-∞, +3) = +3
│   │   &#34;I now have at least +3 (from my Black perspective)&#34;
│   │
│   ├── Move A2: returns +1
│   │   alpha = max(+3, +1) = +3 (no change)
│   
│   Black returns: +3
│   
│   Back to White: -(+3) = -3
│   White&#39;s alpha = max(-∞, -3) = -3
│   &#34;I (White) now have at least -3&#34;
│
├── Exploring Move B
│   
│   White now has alpha = -3, beta = +∞
│   
│   Call: negamax(positionB, depth-1, -beta, -alpha, -color)
│                                      -(+∞)  -(-3)
│                                       -∞     +3    ← Swapped!
│   
│   Black&#39;s turn
│   alpha = -∞, beta = +3  (from Black&#39;s perspective)
│   &#34;I want at least -∞, but White won&#39;t let me get more than +3&#34;
│                                                              ↑
│                               This came from White&#39;s alpha = -3
│   
│   ├── Move B1: returns +5 (from Black&#39;s view)
│   │   alpha = max(-∞, +5) = +5
│   │   Check: alpha &gt;= beta? → +5 &gt;= +3? YES! ✂️
│   │   PRUNE! (Beta cutoff)
│   │
│   │   Why prune?
│   │   Black found +5 for themselves
│   │   But White (parent) already has -3 guaranteed
│   │   From White&#39;s view, +5 for Black = -5 for White
│   │   White won&#39;t choose this branch (-5 &lt; -3)
│   
│   └── Move B2: ✂️ Not explored
</code></pre><h2 id=iterative-deepening>Iterative Deepening<a hidden class=anchor aria-hidden=true href=#iterative-deepening>#</a></h2><p>Imagine you&rsquo;re writing a chess engine and give it 10 seconds to find a move.</p><p><strong>Naive approach:</strong></p><pre tabindex=0><code>&#34;Let me search to depth 6... oh wait, this is taking 15 seconds!&#34;
→ Time&#39;s up, no move found yet!
</code></pre><p><strong>Better approach (Iterative Deepening):</strong></p><pre tabindex=0><code>Depth 1: 0.001s → Found move: e4 (score: +0.2)
Depth 2: 0.01s  → Found move: e4 (score: +0.3)
Depth 3: 0.1s   → Found move: Nf3 (score: +0.4)
Depth 4: 1s     → Found move: Nf3 (score: +0.5)
Depth 5: 8s     → Found move: d4 (score: +0.6)
[Time&#39;s up!]
→ Return d4 (best move found at depth 5)
</code></pre><p><strong>Iterative Deepening:</strong> Search depth 1, then depth 2, then depth 3&mldr; until time runs out. Always have a move ready!</p><h3 id=pseudocode-1>Pseudocode<a hidden class=anchor aria-hidden=true href=#pseudocode-1>#</a></h3><h4 id=basic-iterative-deepening>Basic Iterative Deepening<a hidden class=anchor aria-hidden=true href=#basic-iterative-deepening>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span>function iterativeDeepeningSearch(position, maxTime):
</span></span><span style=display:flex><span>    startTime <span style=color:#f92672>=</span> currentTime()
</span></span><span style=display:flex><span>    bestMove <span style=color:#f92672>=</span> null
</span></span><span style=display:flex><span>    bestScore <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>INFINITY
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> to INFINITY:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Check if we have time for this depth</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> currentTime() <span style=color:#f92672>-</span> startTime <span style=color:#f92672>&gt;=</span> maxTime:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Search at current depth</span>
</span></span><span style=display:flex><span>        score, move <span style=color:#f92672>=</span> negamax(position, depth, <span style=color:#f92672>-</span>INF, <span style=color:#f92672>+</span>INF, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Update best move found so far</span>
</span></span><span style=display:flex><span>        bestMove <span style=color:#f92672>=</span> move
</span></span><span style=display:flex><span>        bestScore <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Optional: print info</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Depth:&#34;</span>, depth, <span style=color:#e6db74>&#34;Move:&#34;</span>, move, <span style=color:#e6db74>&#34;Score:&#34;</span>, score)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bestMove
</span></span></code></pre></div><h4 id=with-time-management>With Time Management<a hidden class=anchor aria-hidden=true href=#with-time-management>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span>function iterativeDeepeningSearch(position, maxTime):
</span></span><span style=display:flex><span>    startTime <span style=color:#f92672>=</span> currentTime()
</span></span><span style=display:flex><span>    bestMove <span style=color:#f92672>=</span> null
</span></span><span style=display:flex><span>    timeForDepth <span style=color:#f92672>=</span> []  <span style=color:#75715e># Track time per depth</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> to MAX_DEPTH:
</span></span><span style=display:flex><span>        depthStartTime <span style=color:#f92672>=</span> currentTime()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Estimate if we have time for this depth</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>            estimatedTime <span style=color:#f92672>=</span> predictTimeForDepth(depth, timeForDepth)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> currentTime() <span style=color:#f92672>-</span> startTime <span style=color:#f92672>+</span> estimatedTime <span style=color:#f92672>&gt;</span> maxTime:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>  <span style=color:#75715e># Not enough time, use previous result</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Search at current depth</span>
</span></span><span style=display:flex><span>        score, move <span style=color:#f92672>=</span> alphaBeta(position, depth, <span style=color:#f92672>-</span>INF, <span style=color:#f92672>+</span>INF, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Record how long this depth took</span>
</span></span><span style=display:flex><span>        timeForDepth<span style=color:#f92672>.</span>append(currentTime() <span style=color:#f92672>-</span> depthStartTime)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Update best move</span>
</span></span><span style=display:flex><span>        bestMove <span style=color:#f92672>=</span> move
</span></span><span style=display:flex><span>        bestScore <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Check if time is up</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> currentTime() <span style=color:#f92672>-</span> startTime <span style=color:#f92672>&gt;=</span> maxTime:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bestMove
</span></span></code></pre></div><h3 id=why-does-this-work>Why Does This Work?<a hidden class=anchor aria-hidden=true href=#why-does-this-work>#</a></h3><p>Isn&rsquo;t searching depth 1, 2, 3&mldr; wasteful?"</p><p><strong>Intuition says:</strong> Yes! You&rsquo;re re-searching the same positions multiple times.</p><p><strong>Reality says:</strong> No! The time is dominated by the deepest search.</p><h4 id=the-math-behind-it>The Math Behind It<a hidden class=anchor aria-hidden=true href=#the-math-behind-it>#</a></h4><p>Chess has a <strong>branching factor</strong> of ~35 (average legal moves per position).</p><h4 id=time-for-each-depth>Time for each depth:<a hidden class=anchor aria-hidden=true href=#time-for-each-depth>#</a></h4><pre tabindex=0><code>Depth 1:  35^1  =           35 nodes
Depth 2:  35^2  =        1,225 nodes
Depth 3:  35^3  =       42,875 nodes
Depth 4:  35^4  =    1,500,625 nodes
Depth 5:  35^5  =   52,521,875 nodes
Depth 6:  35^6  = 1,838,265,625 nodes
</code></pre><h4 id=total-work-with-iterative-deepening-to-depth-6>Total work with Iterative Deepening to depth 6:<a hidden class=anchor aria-hidden=true href=#total-work-with-iterative-deepening-to-depth-6>#</a></h4><pre tabindex=0><code>Total = 35 + 1,225 + 42,875 + ... + 1,838,265,625
      ≈ 1,838,310,235 nodes

Just depth 6 alone: 1,838,265,625 nodes
Overhead from earlier depths: 44,610 nodes (0.002%!)
</code></pre><p><strong>The overhead is negligible!</strong> The deepest search dominates everything.</p><h3 id=general-formula>General Formula<a hidden class=anchor aria-hidden=true href=#general-formula>#</a></h3><p>For branching factor <code>b</code> and depth <code>d</code>:</p><p><strong>Time for depth d:</strong> <code>b^d</code></p><p><strong>Total time with ID:</strong></p><pre tabindex=0><code>b^1 + b^2 + b^3 + ... + b^d = (b^(d+1) - b) / (b - 1)
                              ≈ b^d * (b / (b-1))

For b=35:

Overhead factor = 35 / 34 = 1.029
</code></pre><h3 id=benefits-of-iterative-deepening>Benefits of Iterative Deepening<a hidden class=anchor aria-hidden=true href=#benefits-of-iterative-deepening>#</a></h3><h4 id=1-time-management>1. Time Management<a hidden class=anchor aria-hidden=true href=#1-time-management>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#75715e># Always have a move ready</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> depth <span style=color:#f92672>in</span> <span style=color:#ae81ff>1.</span><span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>∞</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> timeUp():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bestMoveFoundSoFar  <span style=color:#75715e># ← Always valid!</span>
</span></span><span style=display:flex><span>    search(depth)
</span></span></code></pre></div><h4 id=2-better-move-ordering>2. Better Move Ordering<a hidden class=anchor aria-hidden=true href=#2-better-move-ordering>#</a></h4><p>Results from shallower searches help order moves in deeper searches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#75715e># Depth 3 found: d4 is best, Nf3 second, e4 third</span>
</span></span><span style=display:flex><span><span style=color:#75715e># At depth 4, search in this order first:</span>
</span></span><span style=display:flex><span>moves <span style=color:#f92672>=</span> [d4, Nf3, e4, <span style=color:#f92672>...</span>]  <span style=color:#75715e># ← Previous best first!</span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e># → More alpha-beta pruning!</span>
</span></span></code></pre></div><p>This is called <strong>Principal Variation (PV) move ordering</strong>.</p><p>Principal Variation = the line of moves the engine currently believes is best.</p><p>Example after depth 4:</p><pre tabindex=0><code>PV: 1. Nf3 d5 2. d4 Nf6
</code></pre><p>This dramatically speeds up alpha-beta pruning because</p><blockquote><p>Alpha-beta is only fast if you search the BEST move first.</p></blockquote><p>If the best move is searched late → pruning almost disappears.</p><h4 id=3-progressive-information>3. Progressive Information<a hidden class=anchor aria-hidden=true href=#3-progressive-information>#</a></h4><pre tabindex=0><code>Depth 1: e4 (+0.2)   [0.001s]
Depth 2: e4 (+0.3)   [0.01s]
Depth 3: Nf3 (+0.4)  [0.1s]
Depth 4: Nf3 (+0.5)  [1s]
</code></pre><p>You see the engine &ldquo;thinking deeper&rdquo; in real-time!</p><h4 id=4-handles-unknown-time-limits>4. Handles Unknown Time Limits<a hidden class=anchor aria-hidden=true href=#4-handles-unknown-time-limits>#</a></h4><p>Don&rsquo;t know how long to search? Just keep going deeper until interrupted!</p><p><strong>Psuedocode (Time Limit and PV move Ordering)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span>function findBestMove(position, maxTime):
</span></span><span style=display:flex><span>    startTime <span style=color:#f92672>=</span> now()
</span></span><span style=display:flex><span>    bestMove <span style=color:#f92672>=</span> null
</span></span><span style=display:flex><span>    pvMoves <span style=color:#f92672>=</span> []  <span style=color:#75715e># Principal variation from previous depth</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> to <span style=color:#ae81ff>100</span>:  <span style=color:#75715e># Practically infinite</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Check time before starting new depth</span>
</span></span><span style=display:flex><span>        elapsed <span style=color:#f92672>=</span> now() <span style=color:#f92672>-</span> startTime
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> elapsed <span style=color:#f92672>&gt;</span> maxTime <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.9</span>:  <span style=color:#75715e># Leave 10% buffer</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Search at current depth with move ordering</span>
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> search(position, depth, pvMoves)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Update best move and PV</span>
</span></span><span style=display:flex><span>        bestMove <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>move
</span></span><span style=display:flex><span>        bestScore <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>score
</span></span><span style=display:flex><span>        pvMoves <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>principalVariation
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Log progress</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Depth </span><span style=color:#e6db74>{</span>depth<span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>bestMove<span style=color:#e6db74>}</span><span style=color:#e6db74> (score: </span><span style=color:#e6db74>{</span>bestScore<span style=color:#e6db74>}</span><span style=color:#e6db74>, time: </span><span style=color:#e6db74>{</span>elapsed<span style=color:#e6db74>}</span><span style=color:#e6db74>s)&#34;</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Check for forced mate</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> abs(bestScore) <span style=color:#f92672>&gt;</span> MATE_THRESHOLD:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Mate found in </span><span style=color:#e6db74>{</span>depth<span style=color:#e6db74>}</span><span style=color:#e6db74> plies!&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bestMove
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function search(position, depth, pvMoves):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Order moves: PV move first, then others</span>
</span></span><span style=display:flex><span>    moves <span style=color:#f92672>=</span> orderMoves(position<span style=color:#f92672>.</span>getLegalMoves(), pvMoves)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    bestMove <span style=color:#f92672>=</span> null
</span></span><span style=display:flex><span>    bestScore <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>INFINITY
</span></span><span style=display:flex><span>    alpha <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>INFINITY
</span></span><span style=display:flex><span>    beta <span style=color:#f92672>=</span> <span style=color:#f92672>+</span>INFINITY
</span></span><span style=display:flex><span>    pv <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> move <span style=color:#f92672>in</span> moves:
</span></span><span style=display:flex><span>        newPos <span style=color:#f92672>=</span> position<span style=color:#f92672>.</span>makeMove(move)
</span></span><span style=display:flex><span>        score <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>negamax(newPos, depth <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span>beta, <span style=color:#f92672>-</span>alpha, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> score <span style=color:#f92672>&gt;</span> bestScore:
</span></span><span style=display:flex><span>            bestScore <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>            bestMove <span style=color:#f92672>=</span> move
</span></span><span style=display:flex><span>            pv <span style=color:#f92672>=</span> [move] <span style=color:#f92672>+</span> childPV
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        alpha <span style=color:#f92672>=</span> max(alpha, score)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {move: bestMove, score: bestScore, principalVariation: pv}
</span></span></code></pre></div><h4 id=5-iterative-deepening-with-aspiration-windows>5. Iterative Deepening with Aspiration Windows<a hidden class=anchor aria-hidden=true href=#5-iterative-deepening-with-aspiration-windows>#</a></h4><p>Advanced engines narrow the alpha-beta window using previous depth&rsquo;s score:</p><p>Normally search starts with:</p><pre tabindex=0><code>alpha = -∞
beta  = +∞
</code></pre><p>Meaning:</p><blockquote><p>“I have no idea what the position score is — search everything.”</p></blockquote><p>This is slow because pruning is weak.</p><p><strong>Key Observation</strong></p><p>From iterative deepening, you already know the score from previous depth.</p><p>Example:</p><pre tabindex=0><code>Depth 6 → score = +0.32
Depth 7 → score ≈ probably near +0.32
</code></pre><p>Chess positions are stable.
Score rarely jumps from +0.3 → -5.0 in one extra ply.</p><p>So instead of searching full range…</p><p>we search only near the expected value.</p><p><strong>Aspiration Window Idea</strong></p><p>Instead of:</p><pre tabindex=0><code>alpha = -∞
beta  = +∞
</code></pre><p>we search:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>alpha <span style=color:#f92672>=</span> previousScore <span style=color:#f92672>-</span> margin
</span></span><span style=display:flex><span>beta  <span style=color:#f92672>=</span> previousScore <span style=color:#f92672>+</span> margin
</span></span></code></pre></div><p><strong>Why this is FAST</strong></p><p>Alpha-beta pruning strength depends on window size.</p><p>Smaller window ⇒ way more cutoffs ⇒ exponential speedup</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span>function iterativeDeepening(position, maxTime):
</span></span><span style=display:flex><span>    previousScore <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> depth <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> to <span style=color:#960050;background-color:#1e0010>∞</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Use narrow window around previous score</span>
</span></span><span style=display:flex><span>        windowSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span>        alpha <span style=color:#f92672>=</span> previousScore <span style=color:#f92672>-</span> windowSize
</span></span><span style=display:flex><span>        beta <span style=color:#f92672>=</span> previousScore <span style=color:#f92672>+</span> windowSize
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        score <span style=color:#f92672>=</span> negamax(position, depth, alpha, beta, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Re-search if score falls outside window</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> score <span style=color:#f92672>&lt;=</span> alpha <span style=color:#f92672>or</span> score <span style=color:#f92672>&gt;=</span> beta:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Widen window and re-search</span>
</span></span><span style=display:flex><span>            score <span style=color:#f92672>=</span> negamax(position, depth, <span style=color:#f92672>-</span>INF, <span style=color:#f92672>+</span>INF, <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        previousScore <span style=color:#f92672>=</span> score
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> timeUp():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bestMove
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/minmax/>Minmax</a></li><li><a href=https://sankethbk.github.io/blog/tags/alpha-beta-pruning/>Alpha-Beta Pruning</a></li><li><a href=https://sankethbk.github.io/blog/tags/negamax/>Negamax</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>