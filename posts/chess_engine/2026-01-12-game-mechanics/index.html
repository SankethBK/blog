<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Game Mechanics | Sanketh's Blog</title><meta name=keywords content="game mechanics"><meta name=description content="We will go through some of the functions which are part of core game mechanics
Game Mechanics
1. Piece Movement
1. do_move
Purpose: Execute a move and update all position state incrementally.
Critical for performance: This function is called millions of times per second during search. Every optimization matters.
Preconditions:

Move m must be legal (pseudo-legal moves should be filtered first)
newSt must be a different StateInfo object than current state
Caller provides givesCheck flag (optional optimization to avoid recalculating)

Function Structure Overview

Setup and assertions
Copy old state → new state
Increment counters
Handle castling (special case)
Handle captures
Update position hash
Reset en passant
Update castling rights
Move the piece
Handle pawn moves (en passant, promotion)
Update incremental scores
Finalize state
Flip side to move
Compute check info

/// Position::do_move() makes a move, and saves all information necessary
/// to a StateInfo object. The move is assumed to be legal. Pseudo-legal
/// moves should be filtered out before this function is called.

void Position::do_move(Move m, StateInfo& newSt, bool givesCheck) {

  assert(is_ok(m));
  assert(&amp;newSt != st);

  ++nodes;
  Key k = st->key ^ Zobrist::side;

  // Copy some fields of the old state to our new StateInfo object except the
  // ones which are going to be recalculated from scratch anyway and then switch
  // our state pointer to point to the new (ready to be updated) state.
  std::memcpy(&amp;newSt, st, offsetof(StateInfo, key));
  newSt.previous = st;
  st = &amp;newSt;

  // Increment ply counters. In particular, rule50 will be reset to zero later on
  // in case of a capture or a pawn move.
  ++gamePly;
  ++st->rule50;
  ++st->pliesFromNull;

  Color us = sideToMove;
  Color them = ~us;
  Square from = from_sq(m);
  Square to = to_sq(m);
  Piece pc = piece_on(from);
  Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to);

  assert(color_of(pc) == us);
  assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us));
  assert(type_of(captured) != KING);

  if (type_of(m) == CASTLING)
  {
      assert(pc == make_piece(us, KING));
      assert(captured == make_piece(us, ROOK));

      Square rfrom, rto;
      do_castling<true>(us, from, to, rfrom, rto);

      st->psq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom];
      k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto];
      captured = NO_PIECE;
  }

  if (captured)
  {
      Square capsq = to;

      // If the captured piece is a pawn, update pawn hash key, otherwise
      // update non-pawn material.
      if (type_of(captured) == PAWN)
      {
          if (type_of(m) == ENPASSANT)
          {
              capsq -= pawn_push(us);

              assert(pc == make_piece(us, PAWN));
              assert(to == st->epSquare);
              assert(relative_rank(us, to) == RANK_6);
              assert(piece_on(to) == NO_PIECE);
              assert(piece_on(capsq) == make_piece(them, PAWN));

              board[capsq] = NO_PIECE; // Not done by remove_piece()
          }

          st->pawnKey ^= Zobrist::psq[captured][capsq];
      }
      else
          st->nonPawnMaterial[them] -= PieceValue[MG][captured];

      // Update board and piece lists
      remove_piece(captured, capsq);

      // Update material hash key and prefetch access to materialTable
      k ^= Zobrist::psq[captured][capsq];
      st->materialKey ^= Zobrist::psq[captured][pieceCount[captured]];
      prefetch(thisThread->materialTable[st->materialKey]);

      // Update incremental scores
      st->psq -= PSQT::psq[captured][capsq];

      // Reset rule 50 counter
      st->rule50 = 0;
  }

  // Update hash key
  k ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to];

  // Reset en passant square
  if (st->epSquare != SQ_NONE)
  {
      k ^= Zobrist::enpassant[file_of(st->epSquare)];
      st->epSquare = SQ_NONE;
  }

  // Update castling rights if needed
  if (st->castlingRights && (castlingRightsMask[from] | castlingRightsMask[to]))
  {
      int cr = castlingRightsMask[from] | castlingRightsMask[to];
      k ^= Zobrist::castling[st->castlingRights & cr];
      st->castlingRights &= ~cr;
  }

  // Move the piece. The tricky Chess960 castling is handled earlier
  if (type_of(m) != CASTLING)
      move_piece(pc, from, to);

  // If the moving piece is a pawn do some special extra work
  if (type_of(pc) == PAWN)
  {
      // Set en-passant square if the moved pawn can be captured
      if (   (int(to) ^ int(from)) == 16
          && (attacks_from<PAWN>(to - pawn_push(us), us) & pieces(them, PAWN)))
      {
          st->epSquare = (from + to) / 2;
          k ^= Zobrist::enpassant[file_of(st->epSquare)];
      }

      else if (type_of(m) == PROMOTION)
      {
          Piece promotion = make_piece(us, promotion_type(m));

          assert(relative_rank(us, to) == RANK_8);
          assert(type_of(promotion) >= KNIGHT && type_of(promotion) <= QUEEN);

          remove_piece(pc, to);
          put_piece(promotion, to);

          // Update hash keys
          k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to];
          st->pawnKey ^= Zobrist::psq[pc][to];
          st->materialKey ^=  Zobrist::psq[promotion][pieceCount[promotion]-1]
                            ^ Zobrist::psq[pc][pieceCount[pc]];

          // Update incremental score
          st->psq += PSQT::psq[promotion][to] - PSQT::psq[pc][to];

          // Update material
          st->nonPawnMaterial[us] += PieceValue[MG][promotion];
      }

      // Update pawn hash key and prefetch access to pawnsTable
      st->pawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to];
      prefetch(thisThread->pawnsTable[st->pawnKey]);

      // Reset rule 50 draw counter
      st->rule50 = 0;
  }

  // Update incremental scores
  st->psq += PSQT::psq[pc][to] - PSQT::psq[pc][from];

  // Set capture piece
  st->capturedPiece = captured;

  // Update the key with the final value
  st->key = k;

  // Calculate checkers bitboard (if move gives check)
  st->checkersBB = givesCheck ? attackers_to(square<KING>(them)) & pieces(us) : 0;

  sideToMove = ~sideToMove;

  // Update king attacks used for fast check detection
  set_check_info(st);

  assert(pos_is_ok());
}
Phase 1: Sanity checks and bookkeeping
assert(is_ok(m));
assert(&amp;newSt != st);

++nodes;
Key k = st->key ^ Zobrist::side;

Ensures the move encoding is valid
Ensures we don’t overwrite the current state
Increments node counter (used for search statistics)
Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally.

Phase 2: StateInfo chaining (undo mechanism)
std::memcpy(&amp;newSt, st, offsetof(StateInfo, key));
newSt.previous = st;
st = &amp;newSt;

Copies all fields up to key
Fields after key will be recomputed
Links the new state to the previous one (stack-style undo)
Advances the st pointer

Phase 3: Ply counters
++gamePly;
++st->rule50;
++st->pliesFromNull;

gamePly: depth from game start
rule50: increments unless reset later
pliesFromNull: prevents consecutive null moves

Phase 4: Decode move and involved pieces
Color us = sideToMove;
Color them = ~us;

Square from = from_sq(m);
Square to   = to_sq(m);

Piece pc = piece_on(from);
Piece captured =
    type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to);

assert(color_of(pc) == us);
assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us));
assert(type_of(captured) != KING);

Determines moving side
Determines source and destination squares
Determines captured piece (special handling for en passant)

Assertions ensure:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Game Mechanics"><meta property="og:description" content="We will go through some of the functions which are part of core game mechanics
Game Mechanics 1. Piece Movement 1. do_move Purpose: Execute a move and update all position state incrementally.
Critical for performance: This function is called millions of times per second during search. Every optimization matters.
Preconditions:
Move m must be legal (pseudo-legal moves should be filtered first) newSt must be a different StateInfo object than current state Caller provides givesCheck flag (optional optimization to avoid recalculating) Function Structure Overview Setup and assertions Copy old state → new state Increment counters Handle castling (special case) Handle captures Update position hash Reset en passant Update castling rights Move the piece Handle pawn moves (en passant, promotion) Update incremental scores Finalize state Flip side to move Compute check info /// Position::do_move() makes a move, and saves all information necessary /// to a StateInfo object. The move is assumed to be legal. Pseudo-legal /// moves should be filtered out before this function is called. void Position::do_move(Move m, StateInfo& newSt, bool givesCheck) { assert(is_ok(m)); assert(&amp;newSt != st); ++nodes; Key k = st->key ^ Zobrist::side; // Copy some fields of the old state to our new StateInfo object except the // ones which are going to be recalculated from scratch anyway and then switch // our state pointer to point to the new (ready to be updated) state. std::memcpy(&amp;newSt, st, offsetof(StateInfo, key)); newSt.previous = st; st = &amp;newSt; // Increment ply counters. In particular, rule50 will be reset to zero later on // in case of a capture or a pawn move. ++gamePly; ++st->rule50; ++st->pliesFromNull; Color us = sideToMove; Color them = ~us; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(from); Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to); assert(color_of(pc) == us); assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us)); assert(type_of(captured) != KING); if (type_of(m) == CASTLING) { assert(pc == make_piece(us, KING)); assert(captured == make_piece(us, ROOK)); Square rfrom, rto; do_castling<true>(us, from, to, rfrom, rto); st->psq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom]; k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto]; captured = NO_PIECE; } if (captured) { Square capsq = to; // If the captured piece is a pawn, update pawn hash key, otherwise // update non-pawn material. if (type_of(captured) == PAWN) { if (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); assert(pc == make_piece(us, PAWN)); assert(to == st->epSquare); assert(relative_rank(us, to) == RANK_6); assert(piece_on(to) == NO_PIECE); assert(piece_on(capsq) == make_piece(them, PAWN)); board[capsq] = NO_PIECE; // Not done by remove_piece() } st->pawnKey ^= Zobrist::psq[captured][capsq]; } else st->nonPawnMaterial[them] -= PieceValue[MG][captured]; // Update board and piece lists remove_piece(captured, capsq); // Update material hash key and prefetch access to materialTable k ^= Zobrist::psq[captured][capsq]; st->materialKey ^= Zobrist::psq[captured][pieceCount[captured]]; prefetch(thisThread->materialTable[st->materialKey]); // Update incremental scores st->psq -= PSQT::psq[captured][capsq]; // Reset rule 50 counter st->rule50 = 0; } // Update hash key k ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; // Reset en passant square if (st->epSquare != SQ_NONE) { k ^= Zobrist::enpassant[file_of(st->epSquare)]; st->epSquare = SQ_NONE; } // Update castling rights if needed if (st->castlingRights && (castlingRightsMask[from] | castlingRightsMask[to])) { int cr = castlingRightsMask[from] | castlingRightsMask[to]; k ^= Zobrist::castling[st->castlingRights & cr]; st->castlingRights &= ~cr; } // Move the piece. The tricky Chess960 castling is handled earlier if (type_of(m) != CASTLING) move_piece(pc, from, to); // If the moving piece is a pawn do some special extra work if (type_of(pc) == PAWN) { // Set en-passant square if the moved pawn can be captured if ( (int(to) ^ int(from)) == 16 && (attacks_from<PAWN>(to - pawn_push(us), us) & pieces(them, PAWN))) { st->epSquare = (from + to) / 2; k ^= Zobrist::enpassant[file_of(st->epSquare)]; } else if (type_of(m) == PROMOTION) { Piece promotion = make_piece(us, promotion_type(m)); assert(relative_rank(us, to) == RANK_8); assert(type_of(promotion) >= KNIGHT && type_of(promotion) <= QUEEN); remove_piece(pc, to); put_piece(promotion, to); // Update hash keys k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to]; st->pawnKey ^= Zobrist::psq[pc][to]; st->materialKey ^= Zobrist::psq[promotion][pieceCount[promotion]-1] ^ Zobrist::psq[pc][pieceCount[pc]]; // Update incremental score st->psq += PSQT::psq[promotion][to] - PSQT::psq[pc][to]; // Update material st->nonPawnMaterial[us] += PieceValue[MG][promotion]; } // Update pawn hash key and prefetch access to pawnsTable st->pawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; prefetch(thisThread->pawnsTable[st->pawnKey]); // Reset rule 50 draw counter st->rule50 = 0; } // Update incremental scores st->psq += PSQT::psq[pc][to] - PSQT::psq[pc][from]; // Set capture piece st->capturedPiece = captured; // Update the key with the final value st->key = k; // Calculate checkers bitboard (if move gives check) st->checkersBB = givesCheck ? attackers_to(square<KING>(them)) & pieces(us) : 0; sideToMove = ~sideToMove; // Update king attacks used for fast check detection set_check_info(st); assert(pos_is_ok()); } Phase 1: Sanity checks and bookkeeping assert(is_ok(m)); assert(&amp;newSt != st); ++nodes; Key k = st->key ^ Zobrist::side; Ensures the move encoding is valid Ensures we don’t overwrite the current state Increments node counter (used for search statistics) Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally. Phase 2: StateInfo chaining (undo mechanism) std::memcpy(&amp;newSt, st, offsetof(StateInfo, key)); newSt.previous = st; st = &amp;newSt; Copies all fields up to key Fields after key will be recomputed Links the new state to the previous one (stack-style undo) Advances the st pointer Phase 3: Ply counters ++gamePly; ++st->rule50; ++st->pliesFromNull; gamePly: depth from game start rule50: increments unless reset later pliesFromNull: prevents consecutive null moves Phase 4: Decode move and involved pieces Color us = sideToMove; Color them = ~us; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(from); Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to); assert(color_of(pc) == us); assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us)); assert(type_of(captured) != KING); Determines moving side Determines source and destination squares Determines captured piece (special handling for en passant) Assertions ensure:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-12T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-12T00:00:00+00:00"><meta property="article:tag" content="Game Mechanics"><meta name=twitter:card content="summary"><meta name=twitter:title content="Game Mechanics"><meta name=twitter:description content="We will go through some of the functions which are part of core game mechanics
Game Mechanics
1. Piece Movement
1. do_move
Purpose: Execute a move and update all position state incrementally.
Critical for performance: This function is called millions of times per second during search. Every optimization matters.
Preconditions:

Move m must be legal (pseudo-legal moves should be filtered first)
newSt must be a different StateInfo object than current state
Caller provides givesCheck flag (optional optimization to avoid recalculating)

Function Structure Overview

Setup and assertions
Copy old state → new state
Increment counters
Handle castling (special case)
Handle captures
Update position hash
Reset en passant
Update castling rights
Move the piece
Handle pawn moves (en passant, promotion)
Update incremental scores
Finalize state
Flip side to move
Compute check info

/// Position::do_move() makes a move, and saves all information necessary
/// to a StateInfo object. The move is assumed to be legal. Pseudo-legal
/// moves should be filtered out before this function is called.

void Position::do_move(Move m, StateInfo& newSt, bool givesCheck) {

  assert(is_ok(m));
  assert(&amp;newSt != st);

  ++nodes;
  Key k = st->key ^ Zobrist::side;

  // Copy some fields of the old state to our new StateInfo object except the
  // ones which are going to be recalculated from scratch anyway and then switch
  // our state pointer to point to the new (ready to be updated) state.
  std::memcpy(&amp;newSt, st, offsetof(StateInfo, key));
  newSt.previous = st;
  st = &amp;newSt;

  // Increment ply counters. In particular, rule50 will be reset to zero later on
  // in case of a capture or a pawn move.
  ++gamePly;
  ++st->rule50;
  ++st->pliesFromNull;

  Color us = sideToMove;
  Color them = ~us;
  Square from = from_sq(m);
  Square to = to_sq(m);
  Piece pc = piece_on(from);
  Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to);

  assert(color_of(pc) == us);
  assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us));
  assert(type_of(captured) != KING);

  if (type_of(m) == CASTLING)
  {
      assert(pc == make_piece(us, KING));
      assert(captured == make_piece(us, ROOK));

      Square rfrom, rto;
      do_castling<true>(us, from, to, rfrom, rto);

      st->psq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom];
      k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto];
      captured = NO_PIECE;
  }

  if (captured)
  {
      Square capsq = to;

      // If the captured piece is a pawn, update pawn hash key, otherwise
      // update non-pawn material.
      if (type_of(captured) == PAWN)
      {
          if (type_of(m) == ENPASSANT)
          {
              capsq -= pawn_push(us);

              assert(pc == make_piece(us, PAWN));
              assert(to == st->epSquare);
              assert(relative_rank(us, to) == RANK_6);
              assert(piece_on(to) == NO_PIECE);
              assert(piece_on(capsq) == make_piece(them, PAWN));

              board[capsq] = NO_PIECE; // Not done by remove_piece()
          }

          st->pawnKey ^= Zobrist::psq[captured][capsq];
      }
      else
          st->nonPawnMaterial[them] -= PieceValue[MG][captured];

      // Update board and piece lists
      remove_piece(captured, capsq);

      // Update material hash key and prefetch access to materialTable
      k ^= Zobrist::psq[captured][capsq];
      st->materialKey ^= Zobrist::psq[captured][pieceCount[captured]];
      prefetch(thisThread->materialTable[st->materialKey]);

      // Update incremental scores
      st->psq -= PSQT::psq[captured][capsq];

      // Reset rule 50 counter
      st->rule50 = 0;
  }

  // Update hash key
  k ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to];

  // Reset en passant square
  if (st->epSquare != SQ_NONE)
  {
      k ^= Zobrist::enpassant[file_of(st->epSquare)];
      st->epSquare = SQ_NONE;
  }

  // Update castling rights if needed
  if (st->castlingRights && (castlingRightsMask[from] | castlingRightsMask[to]))
  {
      int cr = castlingRightsMask[from] | castlingRightsMask[to];
      k ^= Zobrist::castling[st->castlingRights & cr];
      st->castlingRights &= ~cr;
  }

  // Move the piece. The tricky Chess960 castling is handled earlier
  if (type_of(m) != CASTLING)
      move_piece(pc, from, to);

  // If the moving piece is a pawn do some special extra work
  if (type_of(pc) == PAWN)
  {
      // Set en-passant square if the moved pawn can be captured
      if (   (int(to) ^ int(from)) == 16
          && (attacks_from<PAWN>(to - pawn_push(us), us) & pieces(them, PAWN)))
      {
          st->epSquare = (from + to) / 2;
          k ^= Zobrist::enpassant[file_of(st->epSquare)];
      }

      else if (type_of(m) == PROMOTION)
      {
          Piece promotion = make_piece(us, promotion_type(m));

          assert(relative_rank(us, to) == RANK_8);
          assert(type_of(promotion) >= KNIGHT && type_of(promotion) <= QUEEN);

          remove_piece(pc, to);
          put_piece(promotion, to);

          // Update hash keys
          k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to];
          st->pawnKey ^= Zobrist::psq[pc][to];
          st->materialKey ^=  Zobrist::psq[promotion][pieceCount[promotion]-1]
                            ^ Zobrist::psq[pc][pieceCount[pc]];

          // Update incremental score
          st->psq += PSQT::psq[promotion][to] - PSQT::psq[pc][to];

          // Update material
          st->nonPawnMaterial[us] += PieceValue[MG][promotion];
      }

      // Update pawn hash key and prefetch access to pawnsTable
      st->pawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to];
      prefetch(thisThread->pawnsTable[st->pawnKey]);

      // Reset rule 50 draw counter
      st->rule50 = 0;
  }

  // Update incremental scores
  st->psq += PSQT::psq[pc][to] - PSQT::psq[pc][from];

  // Set capture piece
  st->capturedPiece = captured;

  // Update the key with the final value
  st->key = k;

  // Calculate checkers bitboard (if move gives check)
  st->checkersBB = givesCheck ? attackers_to(square<KING>(them)) & pieces(us) : 0;

  sideToMove = ~sideToMove;

  // Update king attacks used for fast check detection
  set_check_info(st);

  assert(pos_is_ok());
}
Phase 1: Sanity checks and bookkeeping
assert(is_ok(m));
assert(&amp;newSt != st);

++nodes;
Key k = st->key ^ Zobrist::side;

Ensures the move encoding is valid
Ensures we don’t overwrite the current state
Increments node counter (used for search statistics)
Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally.

Phase 2: StateInfo chaining (undo mechanism)
std::memcpy(&amp;newSt, st, offsetof(StateInfo, key));
newSt.previous = st;
st = &amp;newSt;

Copies all fields up to key
Fields after key will be recomputed
Links the new state to the previous one (stack-style undo)
Advances the st pointer

Phase 3: Ply counters
++gamePly;
++st->rule50;
++st->pliesFromNull;

gamePly: depth from game start
rule50: increments unless reset later
pliesFromNull: prevents consecutive null moves

Phase 4: Decode move and involved pieces
Color us = sideToMove;
Color them = ~us;

Square from = from_sq(m);
Square to   = to_sq(m);

Piece pc = piece_on(from);
Piece captured =
    type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to);

assert(color_of(pc) == us);
assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us));
assert(type_of(captured) != KING);

Determines moving side
Determines source and destination squares
Determines captured piece (special handling for en passant)

Assertions ensure:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Game Mechanics","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Game Mechanics","name":"Game Mechanics","description":"We will go through some of the functions which are part of core game mechanics\nGame Mechanics 1. Piece Movement 1. do_move Purpose: Execute a move and update all position state incrementally.\nCritical for performance: This function is called millions of times per second during search. Every optimization matters.\nPreconditions:\nMove m must be legal (pseudo-legal moves should be filtered first) newSt must be a different StateInfo object than current state Caller provides givesCheck flag (optional optimization to avoid recalculating) Function Structure Overview Setup and assertions Copy old state → new state Increment counters Handle castling (special case) Handle captures Update position hash Reset en passant Update castling rights Move the piece Handle pawn moves (en passant, promotion) Update incremental scores Finalize state Flip side to move Compute check info /// Position::do_move() makes a move, and saves all information necessary /// to a StateInfo object. The move is assumed to be legal. Pseudo-legal /// moves should be filtered out before this function is called. void Position::do_move(Move m, StateInfo\u0026amp; newSt, bool givesCheck) { assert(is_ok(m)); assert(\u0026amp;newSt != st); ++nodes; Key k = st-\u0026gt;key ^ Zobrist::side; // Copy some fields of the old state to our new StateInfo object except the // ones which are going to be recalculated from scratch anyway and then switch // our state pointer to point to the new (ready to be updated) state. std::memcpy(\u0026amp;newSt, st, offsetof(StateInfo, key)); newSt.previous = st; st = \u0026amp;newSt; // Increment ply counters. In particular, rule50 will be reset to zero later on // in case of a capture or a pawn move. ++gamePly; ++st-\u0026gt;rule50; ++st-\u0026gt;pliesFromNull; Color us = sideToMove; Color them = ~us; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(from); Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to); assert(color_of(pc) == us); assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us)); assert(type_of(captured) != KING); if (type_of(m) == CASTLING) { assert(pc == make_piece(us, KING)); assert(captured == make_piece(us, ROOK)); Square rfrom, rto; do_castling\u0026lt;true\u0026gt;(us, from, to, rfrom, rto); st-\u0026gt;psq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom]; k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto]; captured = NO_PIECE; } if (captured) { Square capsq = to; // If the captured piece is a pawn, update pawn hash key, otherwise // update non-pawn material. if (type_of(captured) == PAWN) { if (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); assert(pc == make_piece(us, PAWN)); assert(to == st-\u0026gt;epSquare); assert(relative_rank(us, to) == RANK_6); assert(piece_on(to) == NO_PIECE); assert(piece_on(capsq) == make_piece(them, PAWN)); board[capsq] = NO_PIECE; // Not done by remove_piece() } st-\u0026gt;pawnKey ^= Zobrist::psq[captured][capsq]; } else st-\u0026gt;nonPawnMaterial[them] -= PieceValue[MG][captured]; // Update board and piece lists remove_piece(captured, capsq); // Update material hash key and prefetch access to materialTable k ^= Zobrist::psq[captured][capsq]; st-\u0026gt;materialKey ^= Zobrist::psq[captured][pieceCount[captured]]; prefetch(thisThread-\u0026gt;materialTable[st-\u0026gt;materialKey]); // Update incremental scores st-\u0026gt;psq -= PSQT::psq[captured][capsq]; // Reset rule 50 counter st-\u0026gt;rule50 = 0; } // Update hash key k ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; // Reset en passant square if (st-\u0026gt;epSquare != SQ_NONE) { k ^= Zobrist::enpassant[file_of(st-\u0026gt;epSquare)]; st-\u0026gt;epSquare = SQ_NONE; } // Update castling rights if needed if (st-\u0026gt;castlingRights \u0026amp;\u0026amp; (castlingRightsMask[from] | castlingRightsMask[to])) { int cr = castlingRightsMask[from] | castlingRightsMask[to]; k ^= Zobrist::castling[st-\u0026gt;castlingRights \u0026amp; cr]; st-\u0026gt;castlingRights \u0026amp;= ~cr; } // Move the piece. The tricky Chess960 castling is handled earlier if (type_of(m) != CASTLING) move_piece(pc, from, to); // If the moving piece is a pawn do some special extra work if (type_of(pc) == PAWN) { // Set en-passant square if the moved pawn can be captured if ( (int(to) ^ int(from)) == 16 \u0026amp;\u0026amp; (attacks_from\u0026lt;PAWN\u0026gt;(to - pawn_push(us), us) \u0026amp; pieces(them, PAWN))) { st-\u0026gt;epSquare = (from + to) / 2; k ^= Zobrist::enpassant[file_of(st-\u0026gt;epSquare)]; } else if (type_of(m) == PROMOTION) { Piece promotion = make_piece(us, promotion_type(m)); assert(relative_rank(us, to) == RANK_8); assert(type_of(promotion) \u0026gt;= KNIGHT \u0026amp;\u0026amp; type_of(promotion) \u0026lt;= QUEEN); remove_piece(pc, to); put_piece(promotion, to); // Update hash keys k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to]; st-\u0026gt;pawnKey ^= Zobrist::psq[pc][to]; st-\u0026gt;materialKey ^= Zobrist::psq[promotion][pieceCount[promotion]-1] ^ Zobrist::psq[pc][pieceCount[pc]]; // Update incremental score st-\u0026gt;psq += PSQT::psq[promotion][to] - PSQT::psq[pc][to]; // Update material st-\u0026gt;nonPawnMaterial[us] += PieceValue[MG][promotion]; } // Update pawn hash key and prefetch access to pawnsTable st-\u0026gt;pawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; prefetch(thisThread-\u0026gt;pawnsTable[st-\u0026gt;pawnKey]); // Reset rule 50 draw counter st-\u0026gt;rule50 = 0; } // Update incremental scores st-\u0026gt;psq += PSQT::psq[pc][to] - PSQT::psq[pc][from]; // Set capture piece st-\u0026gt;capturedPiece = captured; // Update the key with the final value st-\u0026gt;key = k; // Calculate checkers bitboard (if move gives check) st-\u0026gt;checkersBB = givesCheck ? attackers_to(square\u0026lt;KING\u0026gt;(them)) \u0026amp; pieces(us) : 0; sideToMove = ~sideToMove; // Update king attacks used for fast check detection set_check_info(st); assert(pos_is_ok()); } Phase 1: Sanity checks and bookkeeping assert(is_ok(m)); assert(\u0026amp;newSt != st); ++nodes; Key k = st-\u0026gt;key ^ Zobrist::side; Ensures the move encoding is valid Ensures we don’t overwrite the current state Increments node counter (used for search statistics) Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally. Phase 2: StateInfo chaining (undo mechanism) std::memcpy(\u0026amp;newSt, st, offsetof(StateInfo, key)); newSt.previous = st; st = \u0026amp;newSt; Copies all fields up to key Fields after key will be recomputed Links the new state to the previous one (stack-style undo) Advances the st pointer Phase 3: Ply counters ++gamePly; ++st-\u0026gt;rule50; ++st-\u0026gt;pliesFromNull; gamePly: depth from game start rule50: increments unless reset later pliesFromNull: prevents consecutive null moves Phase 4: Decode move and involved pieces Color us = sideToMove; Color them = ~us; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(from); Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to); assert(color_of(pc) == us); assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us)); assert(type_of(captured) != KING); Determines moving side Determines source and destination squares Determines captured piece (special handling for en passant) Assertions ensure:\n","keywords":["game mechanics"],"articleBody":"We will go through some of the functions which are part of core game mechanics\nGame Mechanics 1. Piece Movement 1. do_move Purpose: Execute a move and update all position state incrementally.\nCritical for performance: This function is called millions of times per second during search. Every optimization matters.\nPreconditions:\nMove m must be legal (pseudo-legal moves should be filtered first) newSt must be a different StateInfo object than current state Caller provides givesCheck flag (optional optimization to avoid recalculating) Function Structure Overview Setup and assertions Copy old state → new state Increment counters Handle castling (special case) Handle captures Update position hash Reset en passant Update castling rights Move the piece Handle pawn moves (en passant, promotion) Update incremental scores Finalize state Flip side to move Compute check info /// Position::do_move() makes a move, and saves all information necessary /// to a StateInfo object. The move is assumed to be legal. Pseudo-legal /// moves should be filtered out before this function is called. void Position::do_move(Move m, StateInfo\u0026 newSt, bool givesCheck) { assert(is_ok(m)); assert(\u0026newSt != st); ++nodes; Key k = st-\u003ekey ^ Zobrist::side; // Copy some fields of the old state to our new StateInfo object except the // ones which are going to be recalculated from scratch anyway and then switch // our state pointer to point to the new (ready to be updated) state. std::memcpy(\u0026newSt, st, offsetof(StateInfo, key)); newSt.previous = st; st = \u0026newSt; // Increment ply counters. In particular, rule50 will be reset to zero later on // in case of a capture or a pawn move. ++gamePly; ++st-\u003erule50; ++st-\u003epliesFromNull; Color us = sideToMove; Color them = ~us; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(from); Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to); assert(color_of(pc) == us); assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us)); assert(type_of(captured) != KING); if (type_of(m) == CASTLING) { assert(pc == make_piece(us, KING)); assert(captured == make_piece(us, ROOK)); Square rfrom, rto; do_castling\u003ctrue\u003e(us, from, to, rfrom, rto); st-\u003epsq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom]; k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto]; captured = NO_PIECE; } if (captured) { Square capsq = to; // If the captured piece is a pawn, update pawn hash key, otherwise // update non-pawn material. if (type_of(captured) == PAWN) { if (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); assert(pc == make_piece(us, PAWN)); assert(to == st-\u003eepSquare); assert(relative_rank(us, to) == RANK_6); assert(piece_on(to) == NO_PIECE); assert(piece_on(capsq) == make_piece(them, PAWN)); board[capsq] = NO_PIECE; // Not done by remove_piece() } st-\u003epawnKey ^= Zobrist::psq[captured][capsq]; } else st-\u003enonPawnMaterial[them] -= PieceValue[MG][captured]; // Update board and piece lists remove_piece(captured, capsq); // Update material hash key and prefetch access to materialTable k ^= Zobrist::psq[captured][capsq]; st-\u003ematerialKey ^= Zobrist::psq[captured][pieceCount[captured]]; prefetch(thisThread-\u003ematerialTable[st-\u003ematerialKey]); // Update incremental scores st-\u003epsq -= PSQT::psq[captured][capsq]; // Reset rule 50 counter st-\u003erule50 = 0; } // Update hash key k ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; // Reset en passant square if (st-\u003eepSquare != SQ_NONE) { k ^= Zobrist::enpassant[file_of(st-\u003eepSquare)]; st-\u003eepSquare = SQ_NONE; } // Update castling rights if needed if (st-\u003ecastlingRights \u0026\u0026 (castlingRightsMask[from] | castlingRightsMask[to])) { int cr = castlingRightsMask[from] | castlingRightsMask[to]; k ^= Zobrist::castling[st-\u003ecastlingRights \u0026 cr]; st-\u003ecastlingRights \u0026= ~cr; } // Move the piece. The tricky Chess960 castling is handled earlier if (type_of(m) != CASTLING) move_piece(pc, from, to); // If the moving piece is a pawn do some special extra work if (type_of(pc) == PAWN) { // Set en-passant square if the moved pawn can be captured if ( (int(to) ^ int(from)) == 16 \u0026\u0026 (attacks_from\u003cPAWN\u003e(to - pawn_push(us), us) \u0026 pieces(them, PAWN))) { st-\u003eepSquare = (from + to) / 2; k ^= Zobrist::enpassant[file_of(st-\u003eepSquare)]; } else if (type_of(m) == PROMOTION) { Piece promotion = make_piece(us, promotion_type(m)); assert(relative_rank(us, to) == RANK_8); assert(type_of(promotion) \u003e= KNIGHT \u0026\u0026 type_of(promotion) \u003c= QUEEN); remove_piece(pc, to); put_piece(promotion, to); // Update hash keys k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to]; st-\u003epawnKey ^= Zobrist::psq[pc][to]; st-\u003ematerialKey ^= Zobrist::psq[promotion][pieceCount[promotion]-1] ^ Zobrist::psq[pc][pieceCount[pc]]; // Update incremental score st-\u003epsq += PSQT::psq[promotion][to] - PSQT::psq[pc][to]; // Update material st-\u003enonPawnMaterial[us] += PieceValue[MG][promotion]; } // Update pawn hash key and prefetch access to pawnsTable st-\u003epawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; prefetch(thisThread-\u003epawnsTable[st-\u003epawnKey]); // Reset rule 50 draw counter st-\u003erule50 = 0; } // Update incremental scores st-\u003epsq += PSQT::psq[pc][to] - PSQT::psq[pc][from]; // Set capture piece st-\u003ecapturedPiece = captured; // Update the key with the final value st-\u003ekey = k; // Calculate checkers bitboard (if move gives check) st-\u003echeckersBB = givesCheck ? attackers_to(square\u003cKING\u003e(them)) \u0026 pieces(us) : 0; sideToMove = ~sideToMove; // Update king attacks used for fast check detection set_check_info(st); assert(pos_is_ok()); } Phase 1: Sanity checks and bookkeeping assert(is_ok(m)); assert(\u0026newSt != st); ++nodes; Key k = st-\u003ekey ^ Zobrist::side; Ensures the move encoding is valid Ensures we don’t overwrite the current state Increments node counter (used for search statistics) Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally. Phase 2: StateInfo chaining (undo mechanism) std::memcpy(\u0026newSt, st, offsetof(StateInfo, key)); newSt.previous = st; st = \u0026newSt; Copies all fields up to key Fields after key will be recomputed Links the new state to the previous one (stack-style undo) Advances the st pointer Phase 3: Ply counters ++gamePly; ++st-\u003erule50; ++st-\u003epliesFromNull; gamePly: depth from game start rule50: increments unless reset later pliesFromNull: prevents consecutive null moves Phase 4: Decode move and involved pieces Color us = sideToMove; Color them = ~us; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(from); Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to); assert(color_of(pc) == us); assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us)); assert(type_of(captured) != KING); Determines moving side Determines source and destination squares Determines captured piece (special handling for en passant) Assertions ensure:\nCorrect colors No king is ever captured Phase 5: Castling (special-case logic) if (type_of(m) == CASTLING) { assert(pc == make_piece(us, KING)); assert(captured == make_piece(us, ROOK)); Square rfrom, rto; do_castling\u003ctrue\u003e(us, from, to, rfrom, rto); st-\u003epsq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom]; k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto]; captured = NO_PIECE; } Castling is encoded as “king captures rook”:\nfrom = king square (e.g., e1) to = rook square (e.g., h1 for kingside) captured = our own rook do_castling() does:\nMoves king to final square (g1) Moves rook to final square (f1) Returns rfrom and rto (rook’s old and new squares) st-\u003epsq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom]; Remove rook’s old position score Add rook’s new position score (King’s score updated later in main move code) k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto]; XOR out rook from old square XOR in rook on new square captured = NO_PIECE; Special logic for castling is complete here, captured is set back to NO_PIECE (we don’t actually capture in castling) Prevents later code from treating this as a capture Phase 6: Capture handling If a capture occurs: (Castling doesn’t enter here)\nif (captured) { Square capsq = to; // If the captured piece is a pawn, update pawn hash key, otherwise // update non-pawn material. if (type_of(captured) == PAWN) { if (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); assert(pc == make_piece(us, PAWN)); assert(to == st-\u003eepSquare); assert(relative_rank(us, to) == RANK_6); assert(piece_on(to) == NO_PIECE); assert(piece_on(capsq) == make_piece(them, PAWN)); board[capsq] = NO_PIECE; // Not done by remove_piece() } st-\u003epawnKey ^= Zobrist::psq[captured][capsq]; } else st-\u003enonPawnMaterial[them] -= PieceValue[MG][captured]; // Update board and piece lists remove_piece(captured, capsq); // Update material hash key and prefetch access to materialTable k ^= Zobrist::psq[captured][capsq]; st-\u003ematerialKey ^= Zobrist::psq[captured][pieceCount[captured]]; prefetch(thisThread-\u003ematerialTable[st-\u003ematerialKey]); // Update incremental scores st-\u003epsq -= PSQT::psq[captured][capsq]; // Reset rule 50 counter st-\u003erule50 = 0; } Capture square:\nUsually to (normal capture) Exception: En passant (handled next) if (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); For Enpassant, captured piece is one square behind the captured square. Example: White pawn on e5, black pawn on d5 (just moved d7-d5) Move: exd6 (en passant) to = d6 (target square, EMPTY) capsq = d6 - pawn_push(WHITE) = d6 - 8 = d5 (where black pawn actually is) board[capsq] = NO_PIECE; // Not done by remove_piece() Special case for Enpassant, we need to clear the mailbox board manually, for other captures it will be handled by move_piece later. st-\u003epawnKey ^= Zobrist::psq[captured][capsq]; Remove captured pawn from pawn structure hash. else st-\u003enonPawnMaterial[them] -= PieceValue[MG][captured]; nonPawnMaterial excludes pawns (used for endgame detection) Pawn captures don’t change this value Remove Captured Piece\nremove_piece(captured, capsq); remove_piece() does:\nClear from byTypeBB[type] Clear from byColorBB[color] Remove from pieceList[captured] Update index[] array Decrement pieceCount[captured] At this point, captured piece is completely out of the board. Update Material Hash\nk ^= Zobrist::psq[captured][capsq]; st-\u003ematerialKey ^= Zobrist::psq[captured][pieceCount[captured]]; Captured piece is removed from Zobrist hash key k Same for materialKey. Remember: Material hash uses count, not square Prefetch Material Table\nprefetch(thisThread-\u003ematerialTable[st-\u003ematerialKey]); Prefetch explained:\nModern CPUs have cache hierarchy (L1/L2/L3). Prefetching hints the CPU to load data into cache before it’s needed.\nprefetch(address) // → CPU instruction: load this memory into cache Why prefetch?\nWe’ll need materialTable[st-\u003ematerialKey] soon (for evaluation) Loading from RAM is slow (~100+ cycles) Prefetching starts the load now (overlaps with other work) By the time we need it, it’s already in cache Update PSQ Score\nst-\u003epsq -= PSQT::psq[captured][capsq]; Remove captured piece’s positional bonus from total score. Reset 50-Move Rule\nst-\u003erule50 = 0; Captures reset the 50-move draw counter. Update Hash for Moving Piece\nk ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; We already removed only the captured piece from hash, this is just a piece moving from one swuare to another. Reset En Passant Square\nif (st-\u003eepSquare != SQ_NONE) { k ^= Zobrist::enpassant[file_of(st-\u003eepSquare)]; st-\u003eepSquare = SQ_NONE; } Clear old en passant:\nOld state might have had en passant opportunity Remove it from hash Reset to SQ_NONE (Will be set again later if this move creates new ep opportunity) Phase 7: Update Castling Rights if (st-\u003ecastlingRights \u0026\u0026 (castlingRightsMask[from] | castlingRightsMask[to])) { int cr = castlingRightsMask[from] | castlingRightsMask[to]; k ^= Zobrist::castling[st-\u003ecastlingRights \u0026 cr]; st-\u003ecastlingRights \u0026= ~cr; } If castlingRights is present and the current move touches any of the square that disturbs any castling rights int cr = castlingRightsMask[from] | castlingRightsMask[to]; These are the castling rights lost. Phase 8: Move the Piece if (type_of(m) != CASTLING) move_piece(pc, from, to); move_piece() does:\nUpdate board[from] and board[to] Update bitboards Update pieceList[] Update index[] Why skip for castling?\nCastling already moved both king and rook in do_castling() Would be redundant and incorrect to move again Phase 9: Pawn Specific handling // If the moving piece is a pawn do some special extra work if (type_of(pc) == PAWN) { // Set en-passant square if the moved pawn can be captured if ( (int(to) ^ int(from)) == 16 \u0026\u0026 (attacks_from\u003cPAWN\u003e(to - pawn_push(us), us) \u0026 pieces(them, PAWN))) { st-\u003eepSquare = (from + to) / 2; k ^= Zobrist::enpassant[file_of(st-\u003eepSquare)]; } else if (type_of(m) == PROMOTION) { Piece promotion = make_piece(us, promotion_type(m)); assert(relative_rank(us, to) == RANK_8); assert(type_of(promotion) \u003e= KNIGHT \u0026\u0026 type_of(promotion) \u003c= QUEEN); remove_piece(pc, to); put_piece(promotion, to); // Update hash keys k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to]; st-\u003epawnKey ^= Zobrist::psq[pc][to]; st-\u003ematerialKey ^= Zobrist::psq[promotion][pieceCount[promotion]-1] ^ Zobrist::psq[pc][pieceCount[pc]]; // Update incremental score st-\u003epsq += PSQT::psq[promotion][to] - PSQT::psq[pc][to]; // Update material st-\u003enonPawnMaterial[us] += PieceValue[MG][promotion]; } // Update pawn hash key and prefetch access to pawnsTable st-\u003epawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; prefetch(thisThread-\u003epawnsTable[st-\u003epawnKey]); // Reset rule 50 draw counter st-\u003erule50 = 0; } Pawns require extra handling because they have unique rules:\ndouble pushes create en-passant rights promotions replace the pawn with a new piece pawn structure is evaluated separately pawn moves reset the 50-move draw counter if ( (int(to) ^ int(from)) == 16 \u0026\u0026 (attacks_from\u003cPAWN\u003e(to - pawn_push(us), us) \u0026 pieces(them, PAWN))) A pawn double push always moves exactly 16 squares in index space:\nWhite: rank 2 → rank 4 Black: rank 7 → rank 5 Stockfish uses XOR instead of subtraction because it’s slightly faster and works reliably with square encoding.\nCan the pawn actually be captured?\nMeaning:\nlook at the square the pawn passed over generate pawn attacks from that square check if enemy pawns exist on those attack squares So en-passant is only enabled if it is a real tactical possibility.\nSetting the en-passant square\nst-\u003eepSquare = (from + to) / 2; The en-passant target is the square “in between”.\nExample:\ne2 → e4 epSquare = e3 Let’s take a scenario where blakc pawn is on d4 and white just moved pawn from e2 to e4.\nfrom = e2 = 12 to = e4 = 28 // Condition 1: Double push? (int(to) ^ int(from)) == 16 (28 ^ 12) == 16 16 == 16 ✓ // Condition 2: Can be captured? to - pawn_push(WHITE) = 28 - 8 = 20 (e3) attacks_from\u003cPAWN\u003e(e3, WHITE) = StepAttacksBB[W_PAWN][e3] = Bitboard{d4, f4} = 0x0000000014000000 pieces(BLACK, PAWN) = Bitboard{d4} d4_and_f4 \u0026 black_pawns = Bitboard{d4} \u0026 Bitboard{d4} = Bitboard{d4} ✓ Non-zero! // En passant IS set: st-\u003eepSquare = (e2 + e4) / 2 = (12 + 28) / 2 = 20 (e3) Updating the Zobrist hash\nk ^= Zobrist::enpassant[file_of(st-\u003eepSquare)]; En-passant affects legality and repetition detection, so it must be included in the position hash. Stockfish hashes only the file (not full square) because en-passant is file-dependent.\nHandling Pawn Promotion\nelse if (type_of(m) == PROMOTION) Promotions are special because the pawn is removed and replaced by a stronger piece.\nCreate the promoted piece Piece promotion = make_piece(us, promotion_type(m)); Example:\nWhite pawn promotes to queen → W_QUEEN Sanity checks\nassert(relative_rank(us, to) == RANK_8); assert(type_of(promotion) \u003e= KNIGHT \u0026\u0026 type_of(promotion) \u003c= QUEEN); Promotion must occur on the last rank, and only to:\nKnight Bishop Rook Queen Replace pawn with promoted piece remove_piece(pc, to); put_piece(promotion, to); So the board now contains the new piece instead of the pawn.\nUpdating Hash Keys During Promotion k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to]; Meaning:\nremove pawn from hash add promoted piece to hash Pawn structure hash\nst-\u003epawnKey ^= Zobrist::psq[pc][to]; Pawn hash only tracks pawns, so the pawn disappears from it.\nMaterial hash\nst-\u003ematerialKey ^= Zobrist::psq[promotion][pieceCount[promotion]-1] ^ Zobrist::psq[pc][pieceCount[pc]]; MaterialKey tracks piece counts, so promotion changes:\npawn count decreases promoted piece count increases This hash is used for caching evaluation terms like bishop pair bonuses.\nUpdating Incremental Evaluation (PSQT) st-\u003epsq += PSQT::psq[promotion][to] - PSQT::psq[pc][to]; This is an incremental update:\nsubtract pawn-square contribution add promoted piece-square contribution Updating Material Balance st-\u003enonPawnMaterial[us] += PieceValue[MG][promotion]; Promotion increases non-pawn material:\npawn is removed queen/rook/etc is added Updating Pawn Hash After Any Pawn Move Regardless of promotion:\nst-\u003epawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to]; Pawn structure is extremely important, so Stockfish maintains a separate pawn hash key.\nThis enables a pawn evaluation cache:\nprefetch(thisThread-\u003epawnsTable[st-\u003epawnKey]); Meaning:\npawn evaluation will be needed soon prefetch it into CPU cache early Phase 10: Wrap up // Update incremental scores st-\u003epsq += PSQT::psq[pc][to] - PSQT::psq[pc][from]; // Set capture piece st-\u003ecapturedPiece = captured; // Update the key with the final value st-\u003ekey = k; // Calculate checkers bitboard (if move gives check) st-\u003echeckersBB = givesCheck ? attackers_to(square\u003cKING\u003e(them)) \u0026 pieces(us) : 0; sideToMove = ~sideToMove; // Update king attacks used for fast check detection set_check_info(st); assert(pos_is_ok()); This section completes the move by updating:\nevaluation bookkeeping (PSQT) captured piece info (for undo) final Zobrist key check detection bitboards side-to-move switch king safety helper data 1. Incremental PSQT Update\n// Update incremental scores st-\u003epsq += PSQT::psq[pc][to] - PSQT::psq[pc][from]; st-\u003epsq is the piece-square evaluation score of the current position.\nInstead of recomputing evaluation from scratch every move, Stockfish maintains it incrementally:\nRemove the piece’s contribution from the old square Add the contribution from the new square 2. Store Captured Piece for Undo\n// Set capture piece st-\u003ecapturedPiece = captured; Why store this?\nWhen search backtracks, Stockfish calls:\nundo_move(m); To undo correctly, it must know:\nWas something captured? What piece was it? Where should it be restored? So capturedPiece is saved inside StateInfo.\n3. Finalize the Zobrist Key\n// Update the key with the final value st-\u003ekey = k; What is k?\nThroughout do_move(), Stockfish incrementally updated:\npiece-square hash changes castling rights changes en-passant changes side-to-move flip Now the hash is complete.\n4. Compute Checkers Bitboard\n// Calculate checkers bitboard (if move gives check) st-\u003echeckersBB = givesCheck ? attackers_to(square\u003cKING\u003e(them)) \u0026 pieces(us) : 0; What is checkersBB?\nA bitboard containing all pieces currently giving check to the opponent king.\nWhy only if givesCheck?\nStockfish already computed earlier whether this move gives check.\nSo instead of recomputing always, it does:\nIf check → compute attackers Else → set to 0 How does it work?\nattackers_to(enemyKingSquare) returns all pieces attacking that square.\nIntersect with:\npieces(us) to keep only the current side’s attackers.\nWhy store it?\nLater, move generation and legality checks depend heavily on:\n“Are we in check?” “Who is checking us?” 5. Switch Side to Move\nsideToMove = ~sideToMove; After making a move, it becomes the opponent’s turn.\n2. undo_move /// Position::undo_move() unmakes a move. When it returns, the position should /// be restored to exactly the same state as before the move was made. void Position::undo_move(Move m) { assert(is_ok(m)); sideToMove = ~sideToMove; Color us = sideToMove; Square from = from_sq(m); Square to = to_sq(m); Piece pc = piece_on(to); assert(empty(from) || type_of(m) == CASTLING); assert(type_of(st-\u003ecapturedPiece) != KING); if (type_of(m) == PROMOTION) { assert(relative_rank(us, to) == RANK_8); assert(type_of(pc) == promotion_type(m)); assert(type_of(pc) \u003e= KNIGHT \u0026\u0026 type_of(pc) \u003c= QUEEN); remove_piece(pc, to); pc = make_piece(us, PAWN); put_piece(pc, to); } if (type_of(m) == CASTLING) { Square rfrom, rto; do_castling\u003cfalse\u003e(us, from, to, rfrom, rto); } else { move_piece(pc, to, from); // Put the piece back at the source square if (st-\u003ecapturedPiece) { Square capsq = to; if (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); assert(type_of(pc) == PAWN); assert(to == st-\u003eprevious-\u003eepSquare); assert(relative_rank(us, to) == RANK_6); assert(piece_on(capsq) == NO_PIECE); assert(st-\u003ecapturedPiece == make_piece(~us, PAWN)); } put_piece(st-\u003ecapturedPiece, capsq); // Restore the captured piece } } // Finally point our state pointer back to the previous state st = st-\u003eprevious; --gamePly; assert(pos_is_ok()); } undo_move() reverses the effects of do_move().\nAfter this function finishes:\nboard[] must match exactly bitboards must match exactly piece lists must match exactly hash keys, castling rights, ep square must match exactly evaluation state must match exactly This is what allows Stockfish to explore:\nPosition → move → deeper search → undo → next move undo_move() reverses a move by:\nflipping side-to-move back undoing promotions (piece → pawn) undoing castling (king + rook) moving the piece back restoring captured pieces (including en passant) restoring the previous StateInfo snapshot Step-by-step Breakdown 1. Flip Side to Move Back sideToMove = ~sideToMove; 2. Special Move Reversal Undo must handle tricky move types first:\nPromotion Castling En passant Captures 3. Undo Promotion if (type_of(m) == PROMOTION) { remove_piece(pc, to); pc = make_piece(us, PAWN); put_piece(pc, to); } Promotion replaced a pawn with a new piece:\nPawn disappears → Queen appears Undo must reverse:\nQueen disappears → Pawn comes back Why is pc reassigned?\nBecause later we still need to move the pawn back to from.\nSo we convert:\npc = Pawn 4. Undo Castling if (type_of(m) == CASTLING) { Square rfrom, rto; do_castling\u003cfalse\u003e(us, from, to, rfrom, rto); } Castling is special\nCastling moves two pieces:\nKing Rook So Stockfish uses a helper:\ndo_castling\u003cfalse\u003e() Where means:\nundo mode\nThis restores:\nking back to from rook back to its original square 5. Undo Normal Moves else { move_piece(pc, to, from); } For all regular moves:\nMove piece back from destination → origin This restores the moved piece.\n6. Restoring Captures if (st-\u003ecapturedPiece) { Square capsq = to; If something was captured, Stockfish stored it earlier in:\nst-\u003ecapturedPiece So undo checks:\nWas this move a capture? If yes → restore the captured piece.\nSpecial Case: En Passant Capture\nif (type_of(m) == ENPASSANT) { capsq -= pawn_push(us); } Why?\nIn en passant:\ncaptured pawn is not on to it is behind it 7. Restore the Captured Piece put_piece(st-\u003ecapturedPiece, capsq); This places the captured piece back on the board and updates:\nboard[] bitboards pieceList[] pieceCount[] Undo is complete now.\n8. Roll Back State Pointer st = st-\u003eprevious; --gamePly; It automatically restores:\nzobrist key pawnKey materialKey castling rights ep square rule50 psq score check info Without recomputation.\n2. Move Generation 1. legal /// Position::legal() tests whether a pseudo-legal move is legal bool Position::legal(Move m) const { assert(is_ok(m)); Color us = sideToMove; Square from = from_sq(m); assert(color_of(moved_piece(m)) == us); assert(piece_on(square\u003cKING\u003e(us)) == make_piece(us, KING)); // En passant captures are a tricky special case. Because they are rather // uncommon, we do it simply by testing whether the king is attacked after // the move is made. if (type_of(m) == ENPASSANT) { Square ksq = square\u003cKING\u003e(us); Square to = to_sq(m); Square capsq = to - pawn_push(us); Bitboard occupied = (pieces() ^ from ^ capsq) | to; assert(to == ep_square()); assert(moved_piece(m) == make_piece(us, PAWN)); assert(piece_on(capsq) == make_piece(~us, PAWN)); assert(piece_on(to) == NO_PIECE); return !(attacks_bb\u003c ROOK\u003e(ksq, occupied) \u0026 pieces(~us, QUEEN, ROOK)) \u0026\u0026 !(attacks_bb\u003cBISHOP\u003e(ksq, occupied) \u0026 pieces(~us, QUEEN, BISHOP)); } Purpose\n/// Position::legal() tests whether a pseudo-legal move is legal Stockfish generates pseudo-legal moves first:\npiece moves correctly ignores king safety Then legal() filters out moves that are illegal because:\nking is left in check pinned piece moved wrongly en passant reveals discovered attack 1. Basic Setup Color us = sideToMove; Square from = from_sq(m); us = side making the move from = origin square of the move assert(color_of(moved_piece(m)) == us); assert(piece_on(square\u003cKING\u003e(us)) == make_piece(us, KING)); These ensure:\nthe moving piece belongs to the side to move the king exists where expected These are debugging correctness checks.\n2. Special Case 1: En Passant if (type_of(m) == ENPASSANT) En passant is special because the captured pawn is not on the destination square.\nExample:\nWhite pawn e5 captures d6 en passant Captured pawn was actually on d5 So removing that pawn can suddenly open a file/diagonal and expose the king.\nThat means:\nAn en passant move may be pseudo-legal but illegal because it reveals check.\nStockfish’s solution: simulate occupancy Square ksq = square(us); Square to = to_sq(m); Square capsq = to - pawn_push(us); Bitboard occupied = (pieces() ^ from ^ capsq) | to; This creates a simulated occupancy bitboard showing what the board would look like after the en passant.\nBreaking it down:\npieces() // All pieces currently on the board ^ from // XOR with 'from' → removes our pawn from e4 ^ capsq // XOR with 'capsq' → removes their pawn from d5 | to // OR with 'to' → adds our pawn to d6 So occupied is:\nwhat the board would look like after en passant\nCheck if king becomes attacked return !(attacks_bb\u003cROOK\u003e(ksq, occupied) \u0026 pieces(~us, QUEEN, ROOK)) \u0026\u0026 !(attacks_bb\u003cBISHOP\u003e(ksq, occupied) \u0026 pieces(~us, QUEEN, BISHOP)); This checks TWO conditions (both must be true):\nKing not attacked by enemy rooks/queens (along ranks/files) King not attacked by enemy bishops/queens (along diagonals) Check 1: Rook/Queen Attacks\n!(attacks_bb\u003cROOK\u003e(ksq, occupied) \u0026 pieces(~us, QUEEN, ROOK)) attacks_bb\u003cROOK\u003e(ksq, occupied) What it does: Computes rook attacks from the king’s square using the simulated occupancy.\nInterpretation: “If there were a rook on the king’s square, what squares could it attack?”\nReverse logic: “What squares have line-of-sight to the king along ranks/files?”\npieces(~us, QUEEN, ROOK) All enemy queens and rooks.\nattacks_bb\u003cROOK\u003e(ksq, occupied) \u0026 pieces(~us, QUEEN, ROOK) Intersection: Are any enemy rooks/queens on squares that have rook-line-of-sight to our king?\nIf there was any bishop or rook in place of our king, will it see any enemy rook, bishop or queen? If so it means our king will end up in check after this move.\nIf intersection is non-empty → function returns false (illegal move).\n3. Special Case 2: King Moves // If the moving piece is a king, check whether the destination // square is attacked by the opponent. Castling moves are checked // for legality during move generation. if (type_of(piece_on(from)) == KING) return type_of(m) == CASTLING || !(attackers_to(to_sq(m)) \u0026 pieces(~us)); If the moving piece is the king:\nking cannot move into check Castling rules are checked during move generation itself.\n4. Non-King Move Legality Check // A non-king move is legal if and only if it is not pinned or it // is moving along the ray towards or away from the king. return !(pinned_pieces(us) \u0026 from) || aligned(from, to_sq(m), square\u003cKING\u003e(us)); This handles legality for all non-king, non-en-passant moves by checking if the move would expose the king to check.\nCase 1: !(pinned_pieces(us) \u0026 from) // Piece is NOT pinned OR Case 2: aligned(from, to_sq(m), square\u003cKING\u003e(us)) // Move is along pin line Case 1: Piece is NOT Pinned\nBitboard pinned_pieces(Color c) const; Returns: Bitboard of all our pieces that are pinned to our king.\nBitwise and with from gives the intersection, it tells if the moving piece is pinned.\nCase 2: Move Along Pin Line\naligned(from, to_sq(m), square\u003cKING\u003e(us)) Only checked if Case 1 fails (piece IS pinned).\n2. pseudo_legal /// Position::pseudo_legal() takes a random move and tests whether the move is /// pseudo legal. It is used to validate moves from TT that can be corrupted /// due to SMP concurrent access or hash position key aliasing. bool Position::pseudo_legal(const Move m) const { Color us = sideToMove; Square from = from_sq(m); Square to = to_sq(m); Piece pc = moved_piece(m); // Use a slower but simpler function for uncommon cases if (type_of(m) != NORMAL) return MoveList\u003cLEGAL\u003e(*this).contains(m); // Is not a promotion, so promotion piece must be empty if (promotion_type(m) - KNIGHT != NO_PIECE_TYPE) return false; // If the 'from' square is not occupied by a piece belonging to the side to // move, the move is obviously not legal. if (pc == NO_PIECE || color_of(pc) != us) return false; // The destination square cannot be occupied by a friendly piece if (pieces(us) \u0026 to) return false; // Handle the special case of a pawn move if (type_of(pc) == PAWN) { // We have already handled promotion moves, so destination // cannot be on the 8th/1st rank. if (rank_of(to) == relative_rank(us, RANK_8)) return false; if ( !(attacks_from\u003cPAWN\u003e(from, us) \u0026 pieces(~us) \u0026 to) // Not a capture \u0026\u0026 !((from + pawn_push(us) == to) \u0026\u0026 empty(to)) // Not a single push \u0026\u0026 !( (from + 2 * pawn_push(us) == to) // Not a double push \u0026\u0026 (rank_of(from) == relative_rank(us, RANK_2)) \u0026\u0026 empty(to) \u0026\u0026 empty(to - pawn_push(us)))) return false; } else if (!(attacks_from(pc, from) \u0026 to)) return false; // Evasions generator already takes care to avoid some kind of illegal moves // and legal() relies on this. We therefore have to take care that the same // kind of moves are filtered out here. if (checkers()) { if (type_of(pc) != KING) { // Double check? In this case a king move is required if (more_than_one(checkers())) return false; // Our move must be a blocking evasion or a capture of the checking piece if (!((between_bb(lsb(checkers()), square\u003cKING\u003e(us)) | checkers()) \u0026 to)) return false; } // In case of king moves under check we have to remove king so as to catch // invalid moves like b1a1 when opposite queen is on c1. else if (attackers_to(to, pieces() ^ from) \u0026 pieces(~us)) return false; } return true; } Purpose: Validate that a move is pseudo-legal (follows piece movement rules, but may leave king in check).\nUse case: Validate moves from transposition table that might be corrupted due to:\nHash collisions (different positions with same key) SMP concurrent access (race conditions) Memory corruption Pseudo-legal vs Legal:\nPseudo-legal: Piece can physically make the move (ignoring king safety) Legal: Pseudo-legal AND doesn’t leave own king in check Function Structure Extract move information Handle special moves (promotion, castling, en passant) via slow path Basic validation (piece exists, colors match) Validate destination square Validate piece-specific movement rules Handle check evasions Return result 1. Extract Move Information Color us = sideToMove; Square from = from_sq(m); Square to = to_sq(m); Piece pc = moved_piece(m); Standard setup:\nus: Whose turn it is from: Source square to: Destination square pc: What piece is moving (from the move encoding or board) 2. Special Move Types (Slow Path) // Use a slower but simpler function for uncommon cases if (type_of(m) != NORMAL) return MoveList\u003cLEGAL\u003e(*this).contains(m); Handle special cases by generating all legal moves:\nPROMOTION: Pawn reaching 8th rank ENPASSANT: En passant capture CASTLING: Castling Why slow path?\nMoveList\u003cLEGAL\u003e(*this) // Generates ALL legal moves for position .contains(m) // Checks if m is in the list This generates every legal move (expensive!) just to validate one move.\nWhy do this?\nSpecial moves have complex validation rules They’re rare (~5% of moves) Simpler to reuse existing move generation than duplicate logic Example:\nMove m = make_move(e7, e8, PROMOTION, QUEEN); type_of(m) = PROMOTION ✓ Not NORMAL // Generate all legal moves: MoveList\u003cLEGAL\u003e moves(*this); // {e7e8q, e7e8r, e7e8b, e7e8n, Nf6, ...} // Check if our move is in the list: return moves.contains(e7e8q); ✓ true Performance: This is acceptable because:\nTT validation is infrequent (only when probe succeeds) Special moves are rare Correctness \u003e speed for this function 3. Promotion Validation // Is not a promotion, so promotion piece must be empty if (promotion_type(m) - KNIGHT != NO_PIECE_TYPE) return false; What this checks: If move type is NORMAL, there should be no promotion piece encoded. Its subtracting KNIGHT, because promotion pieces are encoded as KNIGHT - 2.\n4. Basic Piece Validation // If the 'from' square is not occupied by a piece belonging to the side to // move, the move is obviously not legal. if (pc == NO_PIECE || color_of(pc) != us) return false; Check 1: Piece exists pc == NO_PIECE Example of failure:\nBoard: 4 . . . . . . . . ← e4 is empty Move: e4-e5 pc = piece_on(e4) = NO_PIECE ✗ return false // Can't move nothing! Check 2: Correct color color_of(pc) != us Example of failure:\nBoard: 4 . . . . ● . . . ← e4 has black pawn Side to move: WHITE Move: e4-e5 pc = B_PAWN color_of(B_PAWN) = BLACK BLACK != WHITE ✗ return false // Can't move opponent's piece! Why these can fail:\nHash collision: Different position mapped to same TT entry Concurrent access: Position changed while reading TT entry Move encoding corruption 5. Destination Square Validation // The destination square cannot be occupied by a friendly piece if (pieces(us) \u0026 to) return false; Can’t capture our own pieces:\n6. Pawn Movement Validation if (type_of(pc) == PAWN) { // We have already handled promotion moves, so destination // cannot be on the 8th/1st rank. if (rank_of(to) == relative_rank(us, RANK_8)) return false; Check 1: Not on promotion rank Since promotions were handled earlier (slow path), a NORMAL pawn move can’t end on the 8th rank.\nrelative_rank(WHITE, RANK_8) = RANK_8 (8th rank for white) relative_rank(BLACK, RANK_8) = RANK_1 (1st rank for black, which is black's 8th) // Example: us = WHITE to = e8 rank_of(e8) = RANK_8 RANK_8 == RANK_8 ✗ return false // Pawn to 8th rank must be promotion! Pawn Movement Rules if ( !(attacks_from\u003cPAWN\u003e(from, us) \u0026 pieces(~us) \u0026 to) // Not a capture \u0026\u0026 !((from + pawn_push(us) == to) \u0026\u0026 empty(to)) // Not a single push \u0026\u0026 !( (from + 2 * pawn_push(us) == to) // Not a double push \u0026\u0026 (rank_of(from) == relative_rank(us, RANK_2)) \u0026\u0026 empty(to) \u0026\u0026 empty(to - pawn_push(us)))) return false; This is a complex condition: Move is valid if ANY of these is true:\nPawn capture Single push Double push If NONE are true → invalid.\nPart 1: Pawn Capture\n!(attacks_from\u003cPAWN\u003e(from, us) \u0026 pieces(~us) \u0026 to) Check: Is this a valid pawn capture?\nattacks_from\u003cPAWN\u003e(from, us) // Diagonal attacks from source \u0026 pieces(~us) // Enemy pieces \u0026 to // Destination square Example - Valid capture:\n5 . . . ○ . . . . ← d5: black pawn 4 . . . . ● . . . ← e4: white pawn Move: e4xd5 attacks_from\u003cPAWN\u003e(e4, WHITE) = {d5, f5} pieces(BLACK) = {d5, ...} to = d5 {d5, f5} \u0026 {d5, ...} \u0026 d5 = {d5} ✓ Non-empty (valid capture) !{d5} = false // This part fails, but that's OK - we check other parts Part 2: Single Push\n!((from + pawn_push(us) == to) \u0026\u0026 empty(to)) Check: Is this a valid single square forward move?\npawn_push(WHITE) = 8 (NORTH) pawn_push(BLACK) = -8 (SOUTH) from + pawn_push(us) == to // Is destination one square forward? \u0026\u0026 empty(to) // Is destination empty? Example - Valid single push:\n5 . . . . . . . . ← e5: empty 4 . . . . ● . . . ← e4: white pawn Move: e4-e5 from + pawn_push(WHITE) = e4 + 8 = e5 e5 == e5 ✓ empty(e5) = true ✓ (true \u0026\u0026 true) = true !(true) = false // This part fails, but that's OK (valid move) Part 3: Double Push\n!( (from + 2 * pawn_push(us) == to) // Two squares forward \u0026\u0026 (rank_of(from) == relative_rank(us, RANK_2)) // From starting rank \u0026\u0026 empty(to) // Destination empty \u0026\u0026 empty(to - pawn_push(us))) // Square in between empty 7. Non-Pawn Movement Validation else if (!(attacks_from(pc, from) \u0026 to)) return false; For knights, bishops, rooks, queens, kings:\nexample - Valid knight move:\nMove: Nd3-e4\nattacks_from(pc, from) // Bitboard of squares piece can attack \u0026 to // Is destination in attack set? attacks_from(W_KNIGHT, d3) \u0026 e4 = {e4} ✓ Non-empty !{e5} = false // Don't return false, continue checking... 8. Check Evasion Validation if (checkers()) { If we’re in check, additional restrictions apply:\nif (type_of(pc) != KING) { It means the piece we moved is not king, even though we were in check.\n1. Double Check → Must Move King // Double check? In this case a king move is required if (more_than_one(checkers())) return false; checkers() // Bitboard of pieces giving check more_than_one(checkers()) // Are there 2+ checkers? If its double check and king hasn’t moved, we can return false.\n2. Single Check → Block or Capture // Our move must be a blocking evasion or a capture of the checking piece if (!((between_bb(lsb(checkers()), square\u003cKING\u003e(us)) | checkers()) \u0026 to)) return false; } In single check, move must EITHER:\nBlock the check (move to a square between attacker and king) Capture the checking piece (between_bb(lsb(checkers()), square\u003cKING\u003e(us)) // Squares between checker and king | checkers()) // OR the checker's square itself \u0026 to // Is destination one of these? It means we should move to a square in-between king and checker or capture the checker.\nSince we know it can’t be double check, we can safely extract checker by lsb(checkers())\n3. King Moves Under Check // In case of king moves under check we have to remove king so as to catch // invalid moves like b1a1 when opposite queen is on c1. else if (attackers_to(to, pieces() ^ from) \u0026 pieces(~us)) return false; Special handling for king moves when in check:\npieces() ^ from // Occupancy with king removed from current square Why remove king? To detect attacks “through” the king’s current square.\nExample - Invalid king move:\n2 . . . . . . . . 1 . K . q . . . . ← b1: king, d1: black queen a b c d e f g h ╰───╯ King trying to move along queen's attack ray Move: Kb1-a1 Without removing king: attackers_to(a1, pieces()) queen on d1 doesn't attack b1 and a1, since its blocked by our king. 9. All Tests passed return true; 3. attackers_to attackers_to(sq) answers the question:\n“Which pieces (of either side) are currently attacking square sq?”\nIt returns a bitboard containing all attackers.\nFunction Signatures\nBitboard attackers_to(Square s) const; Bitboard attackers_to(Square s, Bitboard occupied) const; attackers_to(s): attackers using current board occupancy attackers_to(s, occupied): attackers assuming a custom occupancy mask The second one is used in tricky cases like:\nen passant legality discovered attacks move simulation without actually making the move inline Bitboard Position::attackers_to(Square s) const { return attackers_to(s, byTypeBB[ALL_PIECES]); } /// Position::attackers_to() computes a bitboard of all pieces which attack a /// given square. Slider attacks use the occupied bitboard to indicate occupancy. Bitboard Position::attackers_to(Square s, Bitboard occupied) const { return (attacks_from\u003cPAWN\u003e(s, BLACK) \u0026 pieces(WHITE, PAWN)) | (attacks_from\u003cPAWN\u003e(s, WHITE) \u0026 pieces(BLACK, PAWN)) | (attacks_from\u003cKNIGHT\u003e(s) \u0026 pieces(KNIGHT)) | (attacks_bb\u003cROOK \u003e(s, occupied) \u0026 pieces(ROOK, QUEEN)) | (attacks_bb\u003cBISHOP\u003e(s, occupied) \u0026 pieces(BISHOP, QUEEN)) | (attacks_from\u003cKING\u003e(s) \u0026 pieces(KING)); } Attackers come from 6 piece types:\npawns knights bishops rooks queens king So conceptually:\nattackers = pawn_attackers + knight_attackers + bishop_attackers + rook_attackers + queen_attackers + king_attackers; 1. Pawn Attackers Pawns are asymmetric: white pawns attack upward, black pawns downward.\nSo Stockfish reverses the logic:\n(attacks_from\u003cPAWN\u003e(s, BLACK) \u0026 pieces(WHITE, PAWN)) To answer which white pawns attack the square s, stockfish asks the reverse questions:\nattacks_from\u003cPAWN\u003e(s, BLACK) If a black pawn was present in square s, which squares would it attack?\npieces(WHITE, PAWN) This returns a bitboard with only squares containing white pawns, so the final result contains only those squares which are under attack by a hypothetical black pawn in square s, bitwise and white pawns. So final bitboard will give us all white pawns which can attack this square s.\nattacks_from uses StepAttacksBB which is a map of precomputed attack squares.\ntemplate\u003c\u003e inline Bitboard Position::attacks_from\u003cPAWN\u003e(Square s, Color c) const { return StepAttacksBB[make_piece(c, PAWN)][s]; } Examples:\nStepAttacksBB[W_PAWN][e4] → Bitboard with d5, f5 set (white pawn attacks) StepAttacksBB[B_PAWN][e5] → Bitboard with d4, f4 set (black pawn attacks) StepAttacksBB[W_KNIGHT][e4] → Bitboard with d2, f2, c3, g3, c5, g5, d6, f6 StepAttacksBB[W_KING][e1] → Bitboard with d1, f1, d2, e2, f2 Similar logic is used to find all black pawns attacking the square s\n(attacks_from\u003cPAWN\u003e(s, WHITE) \u0026 pieces(BLACK, PAWN)) 2. Knight Attacks (attacks_from\u003cKNIGHT\u003e(s) \u0026 pieces(KNIGHT)) Knights are color-independent (same attack pattern for white/black).\nattacks_from\u003cKNIGHT\u003e(s) // All squares a knight on `s` could attack pieces(KNIGHT) // All knights (both colors) This is again a reverse lookup with same logic.\nIn this case, the implementation of attacks_from is\ntemplate\u003cPieceType Pt\u003e inline Bitboard Position::attacks_from(Square s) const { return Pt == BISHOP || Pt == ROOK ? attacks_bb\u003cPt\u003e(s, byTypeBB[ALL_PIECES]) : Pt == QUEEN ? attacks_from\u003cROOK\u003e(s) | attacks_from\u003cBISHOP\u003e(s) : StepAttacksBB[Pt][s]; } For knight also its just StepAttacksBB[Pt][s] after stripping all the polymorphic code\n3. Sliding Attacks (Rook/Bishop/Queen, Occupancy-Dependent) template\u003cPieceType Pt\u003e inline Bitboard attacks_bb(Square s, Bitboard occupied) { extern Bitboard* RookAttacks[SQUARE_NB]; extern Bitboard* BishopAttacks[SQUARE_NB]; return (Pt == ROOK ? RookAttacks : BishopAttacks)[s][magic_index\u003cPt\u003e(s, occupied)]; } It uses the precomputed magic bitboards to get the attack bitboard, logic is similar for rook and bishop, but they have different precomputed tables.\nFor queen, the attack bitboard is just bitwise OR of rook and bishop\nPt == QUEEN ? attacks_from\u003cROOK\u003e(s) | attacks_from\u003cBISHOP\u003e(s) ","wordCount":"6267","inLanguage":"en","datePublished":"2026-01-12T00:00:00Z","dateModified":"2026-01-12T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-12-game-mechanics/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Game Mechanics</h1><div class=post-meta><span title='2026-01-12 00:00:00 +0000 UTC'>January 12, 2026</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-12-game-mechanics.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#game-mechanics aria-label="Game Mechanics">Game Mechanics</a><ul><li><a href=#1-piece-movement aria-label="1. Piece Movement">1. Piece Movement</a><ul><li><a href=#1-do_move aria-label="1. do_move">1. do_move</a><ul><li><a href=#function-structure-overview aria-label="Function Structure Overview">Function Structure Overview</a></li><li><a href=#phase-1-sanity-checks-and-bookkeeping aria-label="Phase 1: Sanity checks and bookkeeping">Phase 1: Sanity checks and bookkeeping</a></li><li><a href=#phase-2-stateinfo-chaining-undo-mechanism aria-label="Phase 2: StateInfo chaining (undo mechanism)">Phase 2: StateInfo chaining (undo mechanism)</a></li><li><a href=#phase-3-ply-counters aria-label="Phase 3: Ply counters">Phase 3: Ply counters</a></li><li><a href=#phase-4-decode-move-and-involved-pieces aria-label="Phase 4: Decode move and involved pieces">Phase 4: Decode move and involved pieces</a></li><li><a href=#phase-5-castling-special-case-logic aria-label="Phase 5: Castling (special-case logic)">Phase 5: Castling (special-case logic)</a></li><li><a href=#phase-6-capture-handling aria-label="Phase 6: Capture handling">Phase 6: Capture handling</a></li><li><a href=#phase-7-update-castling-rights aria-label="Phase 7: Update Castling Rights">Phase 7: Update Castling Rights</a></li><li><a href=#phase-8-move-the-piece aria-label="Phase 8: Move the Piece">Phase 8: Move the Piece</a></li><li><a href=#phase-9-pawn-specific-handling aria-label="Phase 9: Pawn Specific handling">Phase 9: Pawn Specific handling</a></li><li><a href=#phase-10-wrap-up aria-label="Phase 10: Wrap up">Phase 10: Wrap up</a></li></ul></li><li><a href=#2-undo_move aria-label="2. undo_move">2. undo_move</a><ul><li><a href=#step-by-step-breakdown aria-label="Step-by-step Breakdown">Step-by-step Breakdown</a></li><li><a href=#1-flip-side-to-move-back aria-label="1. Flip Side to Move Back">1. Flip Side to Move Back</a></li><li><a href=#2-special-move-reversal aria-label="2. Special Move Reversal">2. Special Move Reversal</a></li><li><a href=#3-undo-promotion aria-label="3. Undo Promotion">3. Undo Promotion</a></li><li><a href=#4-undo-castling aria-label="4. Undo Castling">4. Undo Castling</a></li><li><a href=#5-undo-normal-moves aria-label="5. Undo Normal Moves">5. Undo Normal Moves</a></li><li><a href=#6-restoring-captures aria-label="6. Restoring Captures">6. Restoring Captures</a></li><li><a href=#7-restore-the-captured-piece aria-label="7. Restore the Captured Piece">7. Restore the Captured Piece</a></li><li><a href=#8-roll-back-state-pointer aria-label="8. Roll Back State Pointer">8. Roll Back State Pointer</a></li></ul></li></ul></li><li><a href=#2-move-generation aria-label="2. Move Generation">2. Move Generation</a><ul><li><a href=#1-legal aria-label="1. legal">1. legal</a><ul><li><a href=#1-basic-setup aria-label="1. Basic Setup">1. Basic Setup</a></li><li><a href=#2-special-case-1-en-passant aria-label="2. Special Case 1: En Passant">2. Special Case 1: En Passant</a><ul><li><a href=#stockfishs-solution-simulate-occupancy aria-label="Stockfish’s solution: simulate occupancy">Stockfish’s solution: simulate occupancy</a></li><li><a href=#check-if-king-becomes-attacked aria-label="Check if king becomes attacked">Check if king becomes attacked</a></li></ul></li><li><a href=#3-special-case-2-king-moves aria-label="3. Special Case 2: King Moves">3. Special Case 2: King Moves</a></li><li><a href=#4-non-king-move-legality-check aria-label="4. Non-King Move Legality Check">4. Non-King Move Legality Check</a></li></ul></li><li><a href=#2-pseudo_legal aria-label="2. pseudo_legal">2. pseudo_legal</a><ul><li><a href=#function-structure aria-label="Function Structure">Function Structure</a></li><li><a href=#1-extract-move-information aria-label="1. Extract Move Information">1. Extract Move Information</a></li><li><a href=#2-special-move-types-slow-path aria-label="2. Special Move Types (Slow Path)">2. Special Move Types (Slow Path)</a></li><li><a href=#3-promotion-validation aria-label="3. Promotion Validation">3. Promotion Validation</a></li><li><a href=#4-basic-piece-validation aria-label="4. Basic Piece Validation">4. Basic Piece Validation</a><ul><li><a href=#check-1-piece-exists aria-label="Check 1: Piece exists">Check 1: Piece exists</a></li><li><a href=#check-2-correct-color aria-label="Check 2: Correct color">Check 2: Correct color</a></li></ul></li><li><a href=#5-destination-square-validation aria-label="5. Destination Square Validation">5. Destination Square Validation</a></li><li><a href=#6-pawn-movement-validation aria-label="6. Pawn Movement Validation">6. Pawn Movement Validation</a><ul><li><a href=#check-1-not-on-promotion-rank aria-label="Check 1: Not on promotion rank">Check 1: Not on promotion rank</a></li><li><a href=#pawn-movement-rules aria-label="Pawn Movement Rules">Pawn Movement Rules</a></li></ul></li><li><a href=#7-non-pawn-movement-validation aria-label="7. Non-Pawn Movement Validation">7. Non-Pawn Movement Validation</a></li><li><a href=#8-check-evasion-validation aria-label="8. Check Evasion Validation">8. Check Evasion Validation</a><ul><li><a href=#1-double-check--must-move-king aria-label="1. Double Check → Must Move King">1. Double Check → Must Move King</a></li><li><a href=#2-single-check--block-or-capture aria-label="2. Single Check → Block or Capture">2. Single Check → Block or Capture</a></li><li><a href=#3-king-moves-under-check aria-label="3. King Moves Under Check">3. King Moves Under Check</a></li></ul></li><li><a href=#9-all-tests-passed aria-label="9. All Tests passed">9. All Tests passed</a></li></ul></li><li><a href=#3-attackers_to aria-label="3. attackers_to">3. attackers_to</a><ul><li><a href=#1-pawn-attackers aria-label="1. Pawn Attackers">1. Pawn Attackers</a></li><li><a href=#2-knight-attacks aria-label="2. Knight Attacks">2. Knight Attacks</a></li><li><a href=#3-sliding-attacks-rookbishopqueen-occupancy-dependent aria-label="3. Sliding Attacks (Rook/Bishop/Queen, Occupancy-Dependent)">3. Sliding Attacks (Rook/Bishop/Queen, Occupancy-Dependent)</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>We will go through some of the functions which are part of core game mechanics</p><h1 id=game-mechanics>Game Mechanics<a hidden class=anchor aria-hidden=true href=#game-mechanics>#</a></h1><h2 id=1-piece-movement>1. Piece Movement<a hidden class=anchor aria-hidden=true href=#1-piece-movement>#</a></h2><h3 id=1-do_move>1. do_move<a hidden class=anchor aria-hidden=true href=#1-do_move>#</a></h3><p><strong>Purpose</strong>: Execute a move and update all position state incrementally.</p><p><strong>Critical for performance</strong>: This function is called <strong>millions of times per second</strong> during search. Every optimization matters.</p><p><strong>Preconditions</strong>:</p><ul><li>Move <code>m</code> must be <strong>legal</strong> (pseudo-legal moves should be filtered first)</li><li><code>newSt</code> must be a <strong>different</strong> StateInfo object than current state</li><li>Caller provides <code>givesCheck</code> flag (optional optimization to avoid recalculating)</li></ul><h4 id=function-structure-overview>Function Structure Overview<a hidden class=anchor aria-hidden=true href=#function-structure-overview>#</a></h4><ol><li>Setup and assertions</li><li>Copy old state → new state</li><li>Increment counters</li><li>Handle castling (special case)</li><li>Handle captures</li><li>Update position hash</li><li>Reset en passant</li><li>Update castling rights</li><li>Move the piece</li><li>Handle pawn moves (en passant, promotion)</li><li>Update incremental scores</li><li>Finalize state</li><li>Flip side to move</li><li>Compute check info</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Position::do_move() makes a move, and saves all information necessary
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// to a StateInfo object. The move is assumed to be legal. Pseudo-legal
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// moves should be filtered out before this function is called.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Position<span style=color:#f92672>::</span>do_move(Move m, StateInfo<span style=color:#f92672>&amp;</span> newSt, <span style=color:#66d9ef>bool</span> givesCheck) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(is_ok(m));
</span></span><span style=display:flex><span>  assert(<span style=color:#f92672>&amp;</span>newSt <span style=color:#f92672>!=</span> st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>++</span>nodes;
</span></span><span style=display:flex><span>  Key k <span style=color:#f92672>=</span> st<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>side;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Copy some fields of the old state to our new StateInfo object except the
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// ones which are going to be recalculated from scratch anyway and then switch
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// our state pointer to point to the new (ready to be updated) state.
</span></span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>memcpy(<span style=color:#f92672>&amp;</span>newSt, st, offsetof(StateInfo, key));
</span></span><span style=display:flex><span>  newSt.previous <span style=color:#f92672>=</span> st;
</span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>newSt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Increment ply counters. In particular, rule50 will be reset to zero later on
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// in case of a capture or a pawn move.
</span></span></span><span style=display:flex><span>  <span style=color:#f92672>++</span>gamePly;
</span></span><span style=display:flex><span>  <span style=color:#f92672>++</span>st<span style=color:#f92672>-&gt;</span>rule50;
</span></span><span style=display:flex><span>  <span style=color:#f92672>++</span>st<span style=color:#f92672>-&gt;</span>pliesFromNull;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>  Color them <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>us;
</span></span><span style=display:flex><span>  Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span><span style=display:flex><span>  Square to <span style=color:#f92672>=</span> to_sq(m);
</span></span><span style=display:flex><span>  Piece pc <span style=color:#f92672>=</span> piece_on(from);
</span></span><span style=display:flex><span>  Piece captured <span style=color:#f92672>=</span> type_of(m) <span style=color:#f92672>==</span> ENPASSANT <span style=color:#f92672>?</span> make_piece(them, PAWN) <span style=color:#f92672>:</span> piece_on(to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(color_of(pc) <span style=color:#f92672>==</span> us);
</span></span><span style=display:flex><span>  assert(captured <span style=color:#f92672>==</span> NO_PIECE <span style=color:#f92672>||</span> color_of(captured) <span style=color:#f92672>==</span> (type_of(m) <span style=color:#f92672>!=</span> CASTLING <span style=color:#f92672>?</span> them : us));
</span></span><span style=display:flex><span>  assert(type_of(captured) <span style=color:#f92672>!=</span> KING);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> CASTLING)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      assert(pc <span style=color:#f92672>==</span> make_piece(us, KING));
</span></span><span style=display:flex><span>      assert(captured <span style=color:#f92672>==</span> make_piece(us, ROOK));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      Square rfrom, rto;
</span></span><span style=display:flex><span>      do_castling<span style=color:#f92672>&lt;</span>true<span style=color:#f92672>&gt;</span>(us, from, to, rfrom, rto);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[captured][rto] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[captured][rfrom];
</span></span><span style=display:flex><span>      k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][rfrom] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[captured][rto];
</span></span><span style=display:flex><span>      captured <span style=color:#f92672>=</span> NO_PIECE;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (captured)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square capsq <span style=color:#f92672>=</span> to;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// If the captured piece is a pawn, update pawn hash key, otherwise
</span></span></span><span style=display:flex><span>      <span style=color:#75715e>// update non-pawn material.
</span></span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (type_of(captured) <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>              capsq <span style=color:#f92672>-=</span> pawn_push(us);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              assert(pc <span style=color:#f92672>==</span> make_piece(us, PAWN));
</span></span><span style=display:flex><span>              assert(to <span style=color:#f92672>==</span> st<span style=color:#f92672>-&gt;</span>epSquare);
</span></span><span style=display:flex><span>              assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_6);
</span></span><span style=display:flex><span>              assert(piece_on(to) <span style=color:#f92672>==</span> NO_PIECE);
</span></span><span style=display:flex><span>              assert(piece_on(capsq) <span style=color:#f92672>==</span> make_piece(them, PAWN));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              board[capsq] <span style=color:#f92672>=</span> NO_PIECE; <span style=color:#75715e>// Not done by remove_piece()
</span></span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>nonPawnMaterial[them] <span style=color:#f92672>-=</span> PieceValue[MG][captured];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update board and piece lists
</span></span></span><span style=display:flex><span>      remove_piece(captured, capsq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update material hash key and prefetch access to materialTable
</span></span></span><span style=display:flex><span>      k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][pieceCount[captured]];
</span></span><span style=display:flex><span>      prefetch(thisThread<span style=color:#f92672>-&gt;</span>materialTable[st<span style=color:#f92672>-&gt;</span>materialKey]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update incremental scores
</span></span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>-=</span> PSQT<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Reset rule 50 counter
</span></span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>rule50 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update hash key
</span></span></span><span style=display:flex><span>  k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][from] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Reset en passant square
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>!=</span> SQ_NONE)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(st<span style=color:#f92672>-&gt;</span>epSquare)];
</span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>=</span> SQ_NONE;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update castling rights if needed
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (st<span style=color:#f92672>-&gt;</span>castlingRights <span style=color:#f92672>&amp;&amp;</span> (castlingRightsMask[from] <span style=color:#f92672>|</span> castlingRightsMask[to]))
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> cr <span style=color:#f92672>=</span> castlingRightsMask[from] <span style=color:#f92672>|</span> castlingRightsMask[to];
</span></span><span style=display:flex><span>      k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>castling[st<span style=color:#f92672>-&gt;</span>castlingRights <span style=color:#f92672>&amp;</span> cr];
</span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>castlingRights <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>cr;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Move the piece. The tricky Chess960 castling is handled earlier
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>!=</span> CASTLING)
</span></span><span style=display:flex><span>      move_piece(pc, from, to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If the moving piece is a pawn do some special extra work
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Set en-passant square if the moved pawn can be captured
</span></span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (   (<span style=color:#66d9ef>int</span>(to) <span style=color:#f92672>^</span> <span style=color:#66d9ef>int</span>(from)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> (attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> pawn_push(us), us) <span style=color:#f92672>&amp;</span> pieces(them, PAWN)))
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>=</span> (from <span style=color:#f92672>+</span> to) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>          k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(st<span style=color:#f92672>-&gt;</span>epSquare)];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (type_of(m) <span style=color:#f92672>==</span> PROMOTION)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          Piece promotion <span style=color:#f92672>=</span> make_piece(us, promotion_type(m));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_8);
</span></span><span style=display:flex><span>          assert(type_of(promotion) <span style=color:#f92672>&gt;=</span> KNIGHT <span style=color:#f92672>&amp;&amp;</span> type_of(promotion) <span style=color:#f92672>&lt;=</span> QUEEN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          remove_piece(pc, to);
</span></span><span style=display:flex><span>          put_piece(promotion, to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Update hash keys
</span></span></span><span style=display:flex><span>          k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[promotion][to];
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span>  Zobrist<span style=color:#f92672>::</span>psq[promotion][pieceCount[promotion]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                            <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][pieceCount[pc]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Update incremental score
</span></span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[promotion][to] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Update material
</span></span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>nonPawnMaterial[us] <span style=color:#f92672>+=</span> PieceValue[MG][promotion];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update pawn hash key and prefetch access to pawnsTable
</span></span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][from] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>      prefetch(thisThread<span style=color:#f92672>-&gt;</span>pawnsTable[st<span style=color:#f92672>-&gt;</span>pawnKey]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Reset rule 50 draw counter
</span></span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>rule50 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update incremental scores
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[pc][to] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[pc][from];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Set capture piece
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>capturedPiece <span style=color:#f92672>=</span> captured;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update the key with the final value
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Calculate checkers bitboard (if move gives check)
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>checkersBB <span style=color:#f92672>=</span> givesCheck <span style=color:#f92672>?</span> attackers_to(square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(them)) <span style=color:#f92672>&amp;</span> pieces(us) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sideToMove <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>sideToMove;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update king attacks used for fast check detection
</span></span></span><span style=display:flex><span>  set_check_info(st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(pos_is_ok());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=phase-1-sanity-checks-and-bookkeeping>Phase 1: Sanity checks and bookkeeping<a hidden class=anchor aria-hidden=true href=#phase-1-sanity-checks-and-bookkeeping>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(is_ok(m));
</span></span><span style=display:flex><span>assert(<span style=color:#f92672>&amp;</span>newSt <span style=color:#f92672>!=</span> st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>++</span>nodes;
</span></span><span style=display:flex><span>Key k <span style=color:#f92672>=</span> st<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>side;
</span></span></code></pre></div><ul><li>Ensures the move encoding is valid</li><li>Ensures we don’t overwrite the current state</li><li>Increments node counter (used for search statistics)</li><li>Flips side-to-move bit in the Zobrist key, k is a working copy of the hash key, updated incrementally.</li></ul><h4 id=phase-2-stateinfo-chaining-undo-mechanism>Phase 2: StateInfo chaining (undo mechanism)<a hidden class=anchor aria-hidden=true href=#phase-2-stateinfo-chaining-undo-mechanism>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>memcpy(<span style=color:#f92672>&amp;</span>newSt, st, offsetof(StateInfo, key));
</span></span><span style=display:flex><span>newSt.previous <span style=color:#f92672>=</span> st;
</span></span><span style=display:flex><span>st <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>newSt;
</span></span></code></pre></div><ul><li>Copies all fields up to key</li><li>Fields after key will be recomputed</li><li>Links the new state to the previous one (stack-style undo)</li><li>Advances the st pointer</li></ul><h4 id=phase-3-ply-counters>Phase 3: Ply counters<a hidden class=anchor aria-hidden=true href=#phase-3-ply-counters>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>++</span>gamePly;
</span></span><span style=display:flex><span><span style=color:#f92672>++</span>st<span style=color:#f92672>-&gt;</span>rule50;
</span></span><span style=display:flex><span><span style=color:#f92672>++</span>st<span style=color:#f92672>-&gt;</span>pliesFromNull;
</span></span></code></pre></div><ul><li>gamePly: depth from game start</li><li>rule50: increments unless reset later</li><li>pliesFromNull: prevents consecutive null moves</li></ul><h4 id=phase-4-decode-move-and-involved-pieces>Phase 4: Decode move and involved pieces<a hidden class=anchor aria-hidden=true href=#phase-4-decode-move-and-involved-pieces>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>Color them <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>us;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span><span style=display:flex><span>Square to   <span style=color:#f92672>=</span> to_sq(m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Piece pc <span style=color:#f92672>=</span> piece_on(from);
</span></span><span style=display:flex><span>Piece captured <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    type_of(m) <span style=color:#f92672>==</span> ENPASSANT <span style=color:#f92672>?</span> make_piece(them, PAWN) <span style=color:#f92672>:</span> piece_on(to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert(color_of(pc) <span style=color:#f92672>==</span> us);
</span></span><span style=display:flex><span>assert(captured <span style=color:#f92672>==</span> NO_PIECE <span style=color:#f92672>||</span> color_of(captured) <span style=color:#f92672>==</span> (type_of(m) <span style=color:#f92672>!=</span> CASTLING <span style=color:#f92672>?</span> them : us));
</span></span><span style=display:flex><span>assert(type_of(captured) <span style=color:#f92672>!=</span> KING);
</span></span></code></pre></div><ul><li>Determines moving side</li><li>Determines source and destination squares</li><li>Determines captured piece (special handling for en passant)</li></ul><p>Assertions ensure:</p><ul><li>Correct colors</li><li>No king is ever captured</li></ul><h4 id=phase-5-castling-special-case-logic>Phase 5: Castling (special-case logic)<a hidden class=anchor aria-hidden=true href=#phase-5-castling-special-case-logic>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> CASTLING)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(pc <span style=color:#f92672>==</span> make_piece(us, KING));
</span></span><span style=display:flex><span>    assert(captured <span style=color:#f92672>==</span> make_piece(us, ROOK));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Square rfrom, rto;
</span></span><span style=display:flex><span>    do_castling<span style=color:#f92672>&lt;</span>true<span style=color:#f92672>&gt;</span>(us, from, to, rfrom, rto);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[captured][rto] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[captured][rfrom];
</span></span><span style=display:flex><span>    k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][rfrom] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[captured][rto];
</span></span><span style=display:flex><span>    captured <span style=color:#f92672>=</span> NO_PIECE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Castling is encoded as &ldquo;king captures rook&rdquo;:</p><ul><li><code>from</code> = king square (e.g., e1)</li><li><code>to</code> = rook square (e.g., h1 for kingside)</li><li><code>captured</code> = our own rook</li></ul><p><code>do_castling&lt;true>()</code> does:</p><ul><li>Moves king to final square (g1)</li><li>Moves rook to final square (f1)</li><li>Returns <code>rfrom</code> and <code>rto</code> (rook&rsquo;s old and new squares)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[captured][rto] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[captured][rfrom];
</span></span></code></pre></div><ul><li>Remove rook&rsquo;s old position score</li><li>Add rook&rsquo;s new position score</li><li>(King&rsquo;s score updated later in main move code)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][rfrom] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[captured][rto];
</span></span></code></pre></div><ul><li>XOR out rook from old square</li><li>XOR in rook on new square</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>captured <span style=color:#f92672>=</span> NO_PIECE;
</span></span></code></pre></div><ul><li>Special logic for castling is complete here, <code>captured</code> is set back to <code>NO_PIECE</code> (we don&rsquo;t actually capture in castling)</li><li>Prevents later code from treating this as a capture</li></ul><h4 id=phase-6-capture-handling>Phase 6: Capture handling<a hidden class=anchor aria-hidden=true href=#phase-6-capture-handling>#</a></h4><p>If a capture occurs: (Castling doesn&rsquo;t enter here)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (captured)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Square capsq <span style=color:#f92672>=</span> to;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the captured piece is a pawn, update pawn hash key, otherwise
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// update non-pawn material.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (type_of(captured) <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            capsq <span style=color:#f92672>-=</span> pawn_push(us);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            assert(pc <span style=color:#f92672>==</span> make_piece(us, PAWN));
</span></span><span style=display:flex><span>            assert(to <span style=color:#f92672>==</span> st<span style=color:#f92672>-&gt;</span>epSquare);
</span></span><span style=display:flex><span>            assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_6);
</span></span><span style=display:flex><span>            assert(piece_on(to) <span style=color:#f92672>==</span> NO_PIECE);
</span></span><span style=display:flex><span>            assert(piece_on(capsq) <span style=color:#f92672>==</span> make_piece(them, PAWN));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            board[capsq] <span style=color:#f92672>=</span> NO_PIECE; <span style=color:#75715e>// Not done by remove_piece()
</span></span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        st<span style=color:#f92672>-&gt;</span>nonPawnMaterial[them] <span style=color:#f92672>-=</span> PieceValue[MG][captured];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Update board and piece lists
</span></span></span><span style=display:flex><span>    remove_piece(captured, capsq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Update material hash key and prefetch access to materialTable
</span></span></span><span style=display:flex><span>    k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][pieceCount[captured]];
</span></span><span style=display:flex><span>    prefetch(thisThread<span style=color:#f92672>-&gt;</span>materialTable[st<span style=color:#f92672>-&gt;</span>materialKey]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Update incremental scores
</span></span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>-=</span> PSQT<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reset rule 50 counter
</span></span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>rule50 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Capture square:</p><ul><li>Usually <code>to</code> (normal capture)</li><li>Exception: En passant (handled next)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        capsq <span style=color:#f92672>-=</span> pawn_push(us);
</span></span></code></pre></div><ul><li>For Enpassant, captured piece is one square behind the captured square.</li></ul><pre tabindex=0><code>Example: White pawn on e5, black pawn on d5 (just moved d7-d5)
Move: exd6 (en passant)

to = d6 (target square, EMPTY)
capsq = d6 - pawn_push(WHITE)
      = d6 - 8
      = d5 (where black pawn actually is)
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        board[capsq] <span style=color:#f92672>=</span> NO_PIECE; <span style=color:#75715e>// Not done by remove_piece()
</span></span></span></code></pre></div><ul><li>Special case for Enpassant, we need to clear the mailbox board manually, for other captures it will be handled by <code>move_piece</code> later.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span></code></pre></div><ul><li>Remove captured pawn from pawn structure hash.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>nonPawnMaterial[them] <span style=color:#f92672>-=</span> PieceValue[MG][captured];
</span></span></code></pre></div><ul><li><code>nonPawnMaterial</code> excludes pawns (used for endgame detection)</li><li>Pawn captures don&rsquo;t change this value</li></ul><p><strong>Remove Captured Piece</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>remove_piece(captured, capsq);
</span></span></code></pre></div><p><code>remove_piece()</code> does:</p><ul><li>Clear from <code>byTypeBB[type]</code></li><li>Clear from <code>byColorBB[color]</code></li><li>Remove from <code>pieceList[captured]</code></li><li>Update <code>index[]</code> array</li><li>Decrement <code>pieceCount[captured]</code></li><li>At this point, captured piece is completely out of the board.</li></ul><p><strong>Update Material Hash</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[captured][pieceCount[captured]];
</span></span></code></pre></div><ul><li>Captured piece is removed from Zobrist hash key <code>k</code></li><li>Same for <code>materialKey</code>. Remember: Material hash uses count, not square</li></ul><p><strong>Prefetch Material Table</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>prefetch(thisThread<span style=color:#f92672>-&gt;</span>materialTable[st<span style=color:#f92672>-&gt;</span>materialKey]);
</span></span></code></pre></div><p>Prefetch explained:</p><p>Modern CPUs have cache hierarchy (L1/L2/L3). Prefetching hints the CPU to load data into cache before it&rsquo;s needed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>prefetch(address)  <span style=color:#75715e>// → CPU instruction: load this memory into cache
</span></span></span></code></pre></div><p>Why prefetch?</p><ul><li>We&rsquo;ll need <code>materialTable[st->materialKey]</code> soon (for evaluation)</li><li>Loading from RAM is slow (~100+ cycles)</li><li>Prefetching starts the load now (overlaps with other work)</li><li>By the time we need it, it&rsquo;s already in cache</li></ul><p><strong>Update PSQ Score</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>-=</span> PSQT<span style=color:#f92672>::</span>psq[captured][capsq];
</span></span></code></pre></div><ul><li>Remove captured piece&rsquo;s positional bonus from total score.</li></ul><p><strong>Reset 50-Move Rule</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>rule50 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><ul><li>Captures reset the 50-move draw counter.</li></ul><p><strong>Update Hash for Moving Piece</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][from] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span></code></pre></div><ul><li>We already removed only the captured piece from hash, this is just a piece moving from one swuare to another.</li></ul><p><strong>Reset En Passant Square</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>!=</span> SQ_NONE)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(st<span style=color:#f92672>-&gt;</span>epSquare)];
</span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>=</span> SQ_NONE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Clear old en passant:</p><ul><li>Old state might have had en passant opportunity</li><li>Remove it from hash</li><li>Reset to <code>SQ_NONE</code></li><li>(Will be set again later if this move creates new ep opportunity)</li></ul><h4 id=phase-7-update-castling-rights>Phase 7: Update Castling Rights<a hidden class=anchor aria-hidden=true href=#phase-7-update-castling-rights>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (st<span style=color:#f92672>-&gt;</span>castlingRights <span style=color:#f92672>&amp;&amp;</span> (castlingRightsMask[from] <span style=color:#f92672>|</span> castlingRightsMask[to]))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cr <span style=color:#f92672>=</span> castlingRightsMask[from] <span style=color:#f92672>|</span> castlingRightsMask[to];
</span></span><span style=display:flex><span>    k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>castling[st<span style=color:#f92672>-&gt;</span>castlingRights <span style=color:#f92672>&amp;</span> cr];
</span></span><span style=display:flex><span>    st<span style=color:#f92672>-&gt;</span>castlingRights <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>cr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>If <code>castlingRights</code> is present and the current move touches any of the square that disturbs any castling rights</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> cr <span style=color:#f92672>=</span> castlingRightsMask[from] <span style=color:#f92672>|</span> castlingRightsMask[to];
</span></span></code></pre></div><ul><li>These are the castling rights lost.</li></ul><h4 id=phase-8-move-the-piece>Phase 8: Move the Piece<a hidden class=anchor aria-hidden=true href=#phase-8-move-the-piece>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>!=</span> CASTLING)
</span></span><span style=display:flex><span>    move_piece(pc, from, to);
</span></span></code></pre></div><p><code>move_piece()</code> does:</p><ul><li>Update <code>board[from]</code> and <code>board[to]</code></li><li>Update bitboards</li><li>Update <code>pieceList[]</code></li><li>Update <code>index[]</code></li></ul><p><strong>Why skip for castling?</strong></p><ul><li>Castling already moved both king and rook in <code>do_castling()</code></li><li>Would be redundant and incorrect to move again</li></ul><h4 id=phase-9-pawn-specific-handling>Phase 9: Pawn Specific handling<a hidden class=anchor aria-hidden=true href=#phase-9-pawn-specific-handling>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#75715e>// If the moving piece is a pawn do some special extra work
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Set en-passant square if the moved pawn can be captured
</span></span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (   (<span style=color:#66d9ef>int</span>(to) <span style=color:#f92672>^</span> <span style=color:#66d9ef>int</span>(from)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> (attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> pawn_push(us), us) <span style=color:#f92672>&amp;</span> pieces(them, PAWN)))
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>=</span> (from <span style=color:#f92672>+</span> to) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>          k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(st<span style=color:#f92672>-&gt;</span>epSquare)];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (type_of(m) <span style=color:#f92672>==</span> PROMOTION)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          Piece promotion <span style=color:#f92672>=</span> make_piece(us, promotion_type(m));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_8);
</span></span><span style=display:flex><span>          assert(type_of(promotion) <span style=color:#f92672>&gt;=</span> KNIGHT <span style=color:#f92672>&amp;&amp;</span> type_of(promotion) <span style=color:#f92672>&lt;=</span> QUEEN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          remove_piece(pc, to);
</span></span><span style=display:flex><span>          put_piece(promotion, to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Update hash keys
</span></span></span><span style=display:flex><span>          k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[promotion][to];
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span>  Zobrist<span style=color:#f92672>::</span>psq[promotion][pieceCount[promotion]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                            <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][pieceCount[pc]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Update incremental score
</span></span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[promotion][to] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Update material
</span></span></span><span style=display:flex><span>          st<span style=color:#f92672>-&gt;</span>nonPawnMaterial[us] <span style=color:#f92672>+=</span> PieceValue[MG][promotion];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Update pawn hash key and prefetch access to pawnsTable
</span></span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][from] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span><span style=display:flex><span>      prefetch(thisThread<span style=color:#f92672>-&gt;</span>pawnsTable[st<span style=color:#f92672>-&gt;</span>pawnKey]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Reset rule 50 draw counter
</span></span></span><span style=display:flex><span>      st<span style=color:#f92672>-&gt;</span>rule50 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>Pawns require extra handling because they have unique rules:</p><ul><li>double pushes create en-passant rights</li><li>promotions replace the pawn with a new piece</li><li>pawn structure is evaluated separately</li><li>pawn moves reset the 50-move draw counter</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (   (<span style=color:#66d9ef>int</span>(to) <span style=color:#f92672>^</span> <span style=color:#66d9ef>int</span>(from)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> (attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> pawn_push(us), us) <span style=color:#f92672>&amp;</span> pieces(them, PAWN)))
</span></span></code></pre></div><p>A pawn double push always moves exactly 16 squares in index space:</p><ul><li>White: rank 2 → rank 4</li><li>Black: rank 7 → rank 5</li></ul><p>Stockfish uses XOR instead of subtraction because it’s slightly faster and works reliably with square encoding.</p><p><strong>Can the pawn actually be captured?</strong></p><p>Meaning:</p><ul><li>look at the square the pawn passed over</li><li>generate pawn attacks from that square</li><li>check if enemy pawns exist on those attack squares</li></ul><p>So en-passant is only enabled if it is a real tactical possibility.</p><p><strong>Setting the en-passant square</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>=</span> (from <span style=color:#f92672>+</span> to) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>The en-passant target is the square “in between”.</p><p>Example:</p><ul><li>e2 → e4</li><li>epSquare = e3</li></ul><p>Let&rsquo;s take a scenario where blakc pawn is on d4 and white just moved pawn from e2 to e4.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>from <span style=color:#f92672>=</span> e2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>to <span style=color:#f92672>=</span> e4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Condition 1: Double push?
</span></span></span><span style=display:flex><span>(<span style=color:#66d9ef>int</span>(to) <span style=color:#f92672>^</span> <span style=color:#66d9ef>int</span>(from)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>28</span> <span style=color:#f92672>^</span> <span style=color:#ae81ff>12</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>16</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>16</span>  <span style=color:#960050;background-color:#1e0010>✓</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Condition 2: Can be captured?
</span></span></span><span style=display:flex><span>to <span style=color:#f92672>-</span> pawn_push(WHITE) <span style=color:#f92672>=</span> <span style=color:#ae81ff>28</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span> (e3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(e3, WHITE) <span style=color:#f92672>=</span> StepAttacksBB[W_PAWN][e3]
</span></span><span style=display:flex><span>                               <span style=color:#f92672>=</span> Bitboard{d4, f4}
</span></span><span style=display:flex><span>                               <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0000000014000000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pieces(BLACK, PAWN) <span style=color:#f92672>=</span> Bitboard{d4}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>d4_and_f4 <span style=color:#f92672>&amp;</span> black_pawns <span style=color:#f92672>=</span> Bitboard{d4} <span style=color:#f92672>&amp;</span> Bitboard{d4}
</span></span><span style=display:flex><span>                        <span style=color:#f92672>=</span> Bitboard{d4}  <span style=color:#960050;background-color:#1e0010>✓</span> Non<span style=color:#f92672>-</span>zero<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// En passant IS set:
</span></span></span><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>=</span> (e2 <span style=color:#f92672>+</span> e4) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>12</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>28</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span> (e3)
</span></span></code></pre></div><p><strong>Updating the Zobrist hash</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(st<span style=color:#f92672>-&gt;</span>epSquare)];
</span></span></code></pre></div><p>En-passant affects legality and repetition detection, so it must be included in the position hash. Stockfish hashes only the file (not full square) because en-passant is file-dependent.</p><p><strong>Handling Pawn Promotion</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> PROMOTION)
</span></span></code></pre></div><p>Promotions are special because the pawn is removed and replaced by a stronger piece.</p><ol><li>Create the promoted piece</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Piece promotion <span style=color:#f92672>=</span> make_piece(us, promotion_type(m));
</span></span></code></pre></div><p>Example:</p><ul><li>White pawn promotes to queen → W_QUEEN</li></ul><p>Sanity checks</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_8);
</span></span><span style=display:flex><span>assert(type_of(promotion) <span style=color:#f92672>&gt;=</span> KNIGHT <span style=color:#f92672>&amp;&amp;</span> type_of(promotion) <span style=color:#f92672>&lt;=</span> QUEEN);
</span></span></code></pre></div><p>Promotion must occur on the last rank, and only to:</p><ul><li>Knight</li><li>Bishop</li><li>Rook</li><li>Queen</li></ul><ol start=2><li>Replace pawn with promoted piece</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>remove_piece(pc, to);
</span></span><span style=display:flex><span>put_piece(promotion, to);
</span></span></code></pre></div><p>So the board now contains the new piece instead of the pawn.</p><ol start=3><li>Updating Hash Keys During Promotion</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>k <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[promotion][to];
</span></span></code></pre></div><p>Meaning:</p><ul><li>remove pawn from hash</li><li>add promoted piece to hash</li></ul><p>Pawn structure hash</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span></code></pre></div><p>Pawn hash only tracks pawns, so the pawn disappears from it.</p><p>Material hash</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span>  Zobrist<span style=color:#f92672>::</span>psq[promotion][pieceCount[promotion]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                  <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][pieceCount[pc]];
</span></span></code></pre></div><p>MaterialKey tracks piece counts, so promotion changes:</p><ul><li>pawn count decreases</li><li>promoted piece count increases</li></ul><p>This hash is used for caching evaluation terms like bishop pair bonuses.</p><ol start=4><li>Updating Incremental Evaluation (PSQT)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[promotion][to] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[pc][to];
</span></span></code></pre></div><p>This is an incremental update:</p><ul><li>subtract pawn-square contribution</li><li>add promoted piece-square contribution</li></ul><ol start=5><li>Updating Material Balance</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>nonPawnMaterial[us] <span style=color:#f92672>+=</span> PieceValue[MG][promotion];
</span></span></code></pre></div><p>Promotion increases non-pawn material:</p><ul><li>pawn is removed</li><li>queen/rook/etc is added</li></ul><ol start=6><li>Updating Pawn Hash After Any Pawn Move</li></ol><p>Regardless of promotion:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][from] <span style=color:#f92672>^</span> Zobrist<span style=color:#f92672>::</span>psq[pc][to];
</span></span></code></pre></div><p>Pawn structure is extremely important, so Stockfish maintains a separate pawn hash key.</p><p>This enables a pawn evaluation cache:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>prefetch(thisThread<span style=color:#f92672>-&gt;</span>pawnsTable[st<span style=color:#f92672>-&gt;</span>pawnKey]);
</span></span></code></pre></div><p>Meaning:</p><ul><li>pawn evaluation will be needed soon</li><li>prefetch it into CPU cache early</li></ul><h4 id=phase-10-wrap-up>Phase 10: Wrap up<a hidden class=anchor aria-hidden=true href=#phase-10-wrap-up>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#75715e>// Update incremental scores
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[pc][to] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[pc][from];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Set capture piece
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>capturedPiece <span style=color:#f92672>=</span> captured;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update the key with the final value
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Calculate checkers bitboard (if move gives check)
</span></span></span><span style=display:flex><span>  st<span style=color:#f92672>-&gt;</span>checkersBB <span style=color:#f92672>=</span> givesCheck <span style=color:#f92672>?</span> attackers_to(square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(them)) <span style=color:#f92672>&amp;</span> pieces(us) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sideToMove <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>sideToMove;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update king attacks used for fast check detection
</span></span></span><span style=display:flex><span>  set_check_info(st);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(pos_is_ok());
</span></span></code></pre></div><p>This section completes the move by updating:</p><ul><li>evaluation bookkeeping (PSQT)</li><li>captured piece info (for undo)</li><li>final Zobrist key</li><li>check detection bitboards</li><li>side-to-move switch</li><li>king safety helper data</li></ul><p><strong>1. Incremental PSQT Update</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Update incremental scores
</span></span></span><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[pc][to] <span style=color:#f92672>-</span> PSQT<span style=color:#f92672>::</span>psq[pc][from];
</span></span></code></pre></div><p>st->psq is the piece-square evaluation score of the current position.</p><p>Instead of recomputing evaluation from scratch every move, Stockfish maintains it incrementally:</p><ul><li>Remove the piece’s contribution from the old square</li><li>Add the contribution from the new square</li></ul><p><strong>2. Store Captured Piece for Undo</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Set capture piece
</span></span></span><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>capturedPiece <span style=color:#f92672>=</span> captured;
</span></span></code></pre></div><p>Why store this?</p><p>When search backtracks, Stockfish calls:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>undo_move(m);
</span></span></code></pre></div><p>To undo correctly, it must know:</p><ul><li>Was something captured?</li><li>What piece was it?</li><li>Where should it be restored?</li></ul><p>So <code>capturedPiece</code> is saved inside <code>StateInfo</code>.</p><p><strong>3. Finalize the Zobrist Key</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Update the key with the final value
</span></span></span><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>=</span> k;
</span></span></code></pre></div><p>What is k?</p><p>Throughout do_move(), Stockfish incrementally updated:</p><ul><li>piece-square hash changes</li><li>castling rights changes</li><li>en-passant changes</li><li>side-to-move flip</li></ul><p>Now the hash is complete.</p><p><strong>4. Compute Checkers Bitboard</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Calculate checkers bitboard (if move gives check)
</span></span></span><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>checkersBB <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    givesCheck <span style=color:#f92672>?</span> attackers_to(square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(them)) <span style=color:#f92672>&amp;</span> pieces(us) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p>What is checkersBB?</p><p>A bitboard containing all pieces currently giving check to the opponent king.</p><p>Why only if givesCheck?</p><p>Stockfish already computed earlier whether this move gives check.</p><p>So instead of recomputing always, it does:</p><ul><li>If check → compute attackers</li><li>Else → set to 0</li></ul><p>How does it work?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attackers_to(enemyKingSquare)
</span></span></code></pre></div><p>returns all pieces attacking that square.</p><p>Intersect with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pieces(us)
</span></span></code></pre></div><p>to keep only the current side’s attackers.</p><p>Why store it?</p><p>Later, move generation and legality checks depend heavily on:</p><ul><li>“Are we in check?”</li><li>“Who is checking us?”</li></ul><p><strong>5. Switch Side to Move</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>sideToMove <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>sideToMove;
</span></span></code></pre></div><p>After making a move, it becomes the opponent’s turn.</p><h3 id=2-undo_move>2. undo_move<a hidden class=anchor aria-hidden=true href=#2-undo_move>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Position::undo_move() unmakes a move. When it returns, the position should
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// be restored to exactly the same state as before the move was made.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Position<span style=color:#f92672>::</span>undo_move(Move m) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(is_ok(m));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  sideToMove <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>sideToMove;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>  Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span><span style=display:flex><span>  Square to <span style=color:#f92672>=</span> to_sq(m);
</span></span><span style=display:flex><span>  Piece pc <span style=color:#f92672>=</span> piece_on(to);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(empty(from) <span style=color:#f92672>||</span> type_of(m) <span style=color:#f92672>==</span> CASTLING);
</span></span><span style=display:flex><span>  assert(type_of(st<span style=color:#f92672>-&gt;</span>capturedPiece) <span style=color:#f92672>!=</span> KING);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> PROMOTION)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_8);
</span></span><span style=display:flex><span>      assert(type_of(pc) <span style=color:#f92672>==</span> promotion_type(m));
</span></span><span style=display:flex><span>      assert(type_of(pc) <span style=color:#f92672>&gt;=</span> KNIGHT <span style=color:#f92672>&amp;&amp;</span> type_of(pc) <span style=color:#f92672>&lt;=</span> QUEEN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      remove_piece(pc, to);
</span></span><span style=display:flex><span>      pc <span style=color:#f92672>=</span> make_piece(us, PAWN);
</span></span><span style=display:flex><span>      put_piece(pc, to);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> CASTLING)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square rfrom, rto;
</span></span><span style=display:flex><span>      do_castling<span style=color:#f92672>&lt;</span>false<span style=color:#f92672>&gt;</span>(us, from, to, rfrom, rto);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      move_piece(pc, to, from); <span style=color:#75715e>// Put the piece back at the source square
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (st<span style=color:#f92672>-&gt;</span>capturedPiece)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          Square capsq <span style=color:#f92672>=</span> to;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>              capsq <span style=color:#f92672>-=</span> pawn_push(us);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              assert(type_of(pc) <span style=color:#f92672>==</span> PAWN);
</span></span><span style=display:flex><span>              assert(to <span style=color:#f92672>==</span> st<span style=color:#f92672>-&gt;</span>previous<span style=color:#f92672>-&gt;</span>epSquare);
</span></span><span style=display:flex><span>              assert(relative_rank(us, to) <span style=color:#f92672>==</span> RANK_6);
</span></span><span style=display:flex><span>              assert(piece_on(capsq) <span style=color:#f92672>==</span> NO_PIECE);
</span></span><span style=display:flex><span>              assert(st<span style=color:#f92672>-&gt;</span>capturedPiece <span style=color:#f92672>==</span> make_piece(<span style=color:#f92672>~</span>us, PAWN));
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          put_piece(st<span style=color:#f92672>-&gt;</span>capturedPiece, capsq); <span style=color:#75715e>// Restore the captured piece
</span></span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Finally point our state pointer back to the previous state
</span></span></span><span style=display:flex><span>  st <span style=color:#f92672>=</span> st<span style=color:#f92672>-&gt;</span>previous;
</span></span><span style=display:flex><span>  <span style=color:#f92672>--</span>gamePly;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(pos_is_ok());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>undo_move() reverses the effects of do_move().</p><p>After this function finishes:</p><ul><li>board[] must match exactly</li><li>bitboards must match exactly</li><li>piece lists must match exactly</li><li>hash keys, castling rights, ep square must match exactly</li><li>evaluation state must match exactly</li></ul><p>This is what allows Stockfish to explore:</p><pre tabindex=0><code>Position → move → deeper search → undo → next move
</code></pre><p>undo_move() reverses a move by:</p><ul><li>flipping side-to-move back</li><li>undoing promotions (piece → pawn)</li><li>undoing castling (king + rook)</li><li>moving the piece back</li><li>restoring captured pieces (including en passant)</li><li>restoring the previous StateInfo snapshot</li></ul><h4 id=step-by-step-breakdown>Step-by-step Breakdown<a hidden class=anchor aria-hidden=true href=#step-by-step-breakdown>#</a></h4><h4 id=1-flip-side-to-move-back>1. Flip Side to Move Back<a hidden class=anchor aria-hidden=true href=#1-flip-side-to-move-back>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>sideToMove <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>sideToMove;
</span></span></code></pre></div><h4 id=2-special-move-reversal>2. Special Move Reversal<a hidden class=anchor aria-hidden=true href=#2-special-move-reversal>#</a></h4><p>Undo must handle tricky move types first:</p><ul><li>Promotion</li><li>Castling</li><li>En passant</li><li>Captures</li></ul><h4 id=3-undo-promotion>3. Undo Promotion<a hidden class=anchor aria-hidden=true href=#3-undo-promotion>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> PROMOTION)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    remove_piece(pc, to);
</span></span><span style=display:flex><span>    pc <span style=color:#f92672>=</span> make_piece(us, PAWN);
</span></span><span style=display:flex><span>    put_piece(pc, to);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Promotion replaced a pawn with a new piece:</p><pre tabindex=0><code>Pawn disappears → Queen appears
</code></pre><p>Undo must reverse:</p><pre tabindex=0><code>Queen disappears → Pawn comes back
</code></pre><p><strong>Why is pc reassigned?</strong></p><p>Because later we still need to move the pawn back to from.</p><p>So we convert:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pc <span style=color:#f92672>=</span> Pawn
</span></span></code></pre></div><h4 id=4-undo-castling>4. Undo Castling<a hidden class=anchor aria-hidden=true href=#4-undo-castling>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> CASTLING)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Square rfrom, rto;
</span></span><span style=display:flex><span>    do_castling<span style=color:#f92672>&lt;</span>false<span style=color:#f92672>&gt;</span>(us, from, to, rfrom, rto);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Castling is special</strong></p><p>Castling moves two pieces:</p><ul><li>King</li><li>Rook</li></ul><p>So Stockfish uses a helper:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>do_castling<span style=color:#f92672>&lt;</span>false<span style=color:#f92672>&gt;</span>()
</span></span></code></pre></div><p>Where <code>&lt;false></code> means:</p><blockquote><p>undo mode</p></blockquote><p>This restores:</p><ul><li>king back to from</li><li>rook back to its original square</li></ul><h4 id=5-undo-normal-moves>5. Undo Normal Moves<a hidden class=anchor aria-hidden=true href=#5-undo-normal-moves>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    move_piece(pc, to, from);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For all regular moves:</p><ul><li>Move piece back from destination → origin</li></ul><p>This restores the moved piece.</p><h4 id=6-restoring-captures>6. Restoring Captures<a hidden class=anchor aria-hidden=true href=#6-restoring-captures>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (st<span style=color:#f92672>-&gt;</span>capturedPiece)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Square capsq <span style=color:#f92672>=</span> to;
</span></span></code></pre></div><p>If something was captured, Stockfish stored it earlier in:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>capturedPiece
</span></span></code></pre></div><p>So undo checks:</p><ul><li>Was this move a capture?</li></ul><p>If yes → restore the captured piece.</p><p><strong>Special Case: En Passant Capture</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    capsq <span style=color:#f92672>-=</span> pawn_push(us);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Why?</p><p>In en passant:</p><ul><li>captured pawn is not on to</li><li>it is behind it</li></ul><h4 id=7-restore-the-captured-piece>7. Restore the Captured Piece<a hidden class=anchor aria-hidden=true href=#7-restore-the-captured-piece>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>put_piece(st<span style=color:#f92672>-&gt;</span>capturedPiece, capsq);
</span></span></code></pre></div><p>This places the captured piece back on the board and updates:</p><ul><li>board[]</li><li>bitboards</li><li>pieceList[]</li><li>pieceCount[]</li></ul><p>Undo is complete now.</p><h4 id=8-roll-back-state-pointer>8. Roll Back State Pointer<a hidden class=anchor aria-hidden=true href=#8-roll-back-state-pointer>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>st <span style=color:#f92672>=</span> st<span style=color:#f92672>-&gt;</span>previous;
</span></span><span style=display:flex><span><span style=color:#f92672>--</span>gamePly;
</span></span></code></pre></div><p>It automatically restores:</p><ul><li>zobrist key</li><li>pawnKey</li><li>materialKey</li><li>castling rights</li><li>ep square</li><li>rule50</li><li>psq score</li><li>check info</li></ul><p>Without recomputation.</p><h2 id=2-move-generation>2. Move Generation<a hidden class=anchor aria-hidden=true href=#2-move-generation>#</a></h2><h3 id=1-legal>1. legal<a hidden class=anchor aria-hidden=true href=#1-legal>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Position::legal() tests whether a pseudo-legal move is legal
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> Position<span style=color:#f92672>::</span>legal(Move m) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(is_ok(m));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>  Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(color_of(moved_piece(m)) <span style=color:#f92672>==</span> us);
</span></span><span style=display:flex><span>  assert(piece_on(square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us)) <span style=color:#f92672>==</span> make_piece(us, KING));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// En passant captures are a tricky special case. Because they are rather
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// uncommon, we do it simply by testing whether the king is attacked after
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// the move is made.
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square ksq <span style=color:#f92672>=</span> square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us);
</span></span><span style=display:flex><span>      Square to <span style=color:#f92672>=</span> to_sq(m);
</span></span><span style=display:flex><span>      Square capsq <span style=color:#f92672>=</span> to <span style=color:#f92672>-</span> pawn_push(us);
</span></span><span style=display:flex><span>      Bitboard occupied <span style=color:#f92672>=</span> (pieces() <span style=color:#f92672>^</span> from <span style=color:#f92672>^</span> capsq) <span style=color:#f92672>|</span> to;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      assert(to <span style=color:#f92672>==</span> ep_square());
</span></span><span style=display:flex><span>      assert(moved_piece(m) <span style=color:#f92672>==</span> make_piece(us, PAWN));
</span></span><span style=display:flex><span>      assert(piece_on(capsq) <span style=color:#f92672>==</span> make_piece(<span style=color:#f92672>~</span>us, PAWN));
</span></span><span style=display:flex><span>      assert(piece_on(to) <span style=color:#f92672>==</span> NO_PIECE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>   <span style=color:#f92672>!</span>(attacks_bb<span style=color:#f92672>&lt;</span>  ROOK<span style=color:#f92672>&gt;</span>(ksq, occupied) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us, QUEEN, ROOK))
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(ksq, occupied) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us, QUEEN, BISHOP));
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>Purpose</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Position::legal() tests whether a pseudo-legal move is legal
</span></span></span></code></pre></div><p>Stockfish generates pseudo-legal moves first:</p><ul><li>piece moves correctly</li><li>ignores king safety</li></ul><p>Then legal() filters out moves that are illegal because:</p><ul><li>king is left in check</li><li>pinned piece moved wrongly</li><li>en passant reveals discovered attack</li></ul><h4 id=1-basic-setup>1. Basic Setup<a hidden class=anchor aria-hidden=true href=#1-basic-setup>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span></code></pre></div><ul><li>us = side making the move</li><li>from = origin square of the move</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(color_of(moved_piece(m)) <span style=color:#f92672>==</span> us);
</span></span><span style=display:flex><span>assert(piece_on(square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us)) <span style=color:#f92672>==</span> make_piece(us, KING));
</span></span></code></pre></div><p>These ensure:</p><ul><li>the moving piece belongs to the side to move</li><li>the king exists where expected</li></ul><p>These are debugging correctness checks.</p><h4 id=2-special-case-1-en-passant>2. Special Case 1: En Passant<a hidden class=anchor aria-hidden=true href=#2-special-case-1-en-passant>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>==</span> ENPASSANT)
</span></span></code></pre></div><p>En passant is special because the captured pawn is not on the destination square.</p><p>Example:</p><pre tabindex=0><code>White pawn e5 captures d6 en passant
Captured pawn was actually on d5
</code></pre><p>So removing that pawn can suddenly open a file/diagonal and expose the king.</p><p>That means:</p><blockquote><p>An en passant move may be pseudo-legal but illegal because it reveals check.</p></blockquote><h5 id=stockfishs-solution-simulate-occupancy>Stockfish’s solution: simulate occupancy<a hidden class=anchor aria-hidden=true href=#stockfishs-solution-simulate-occupancy>#</a></h5><pre tabindex=0><code>Square ksq = square&lt;KING&gt;(us);
Square to = to_sq(m);
Square capsq = to - pawn_push(us);
Bitboard occupied = (pieces() ^ from ^ capsq) | to;
</code></pre><p>This creates a simulated occupancy bitboard showing what the board would look like after the en passant.</p><p>Breaking it down:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pieces()        <span style=color:#75715e>// All pieces currently on the board
</span></span></span><span style=display:flex><span><span style=color:#f92672>^</span> from          <span style=color:#75715e>// XOR with &#39;from&#39; → removes our pawn from e4
</span></span></span><span style=display:flex><span><span style=color:#f92672>^</span> capsq         <span style=color:#75715e>// XOR with &#39;capsq&#39; → removes their pawn from d5
</span></span></span><span style=display:flex><span><span style=color:#f92672>|</span> to            <span style=color:#75715e>// OR with &#39;to&#39; → adds our pawn to d6
</span></span></span></code></pre></div><p>So occupied is:</p><blockquote><p>what the board would look like after en passant</p></blockquote><h5 id=check-if-king-becomes-attacked>Check if king becomes attacked<a hidden class=anchor aria-hidden=true href=#check-if-king-becomes-attacked>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>return</span>   <span style=color:#f92672>!</span>(attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(ksq, occupied) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us, QUEEN, ROOK))
</span></span><span style=display:flex><span>      <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(ksq, occupied) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us, QUEEN, BISHOP));
</span></span></code></pre></div><p>This checks TWO conditions (both must be true):</p><ul><li>King not attacked by enemy rooks/queens (along ranks/files)</li><li>King not attacked by enemy bishops/queens (along diagonals)</li></ul><p><strong>Check 1: Rook/Queen Attacks</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>!</span>(attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(ksq, occupied) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us, QUEEN, ROOK))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(ksq, occupied)
</span></span></code></pre></div><p><strong>What it does:</strong> Computes <strong>rook attacks from the king&rsquo;s square</strong> using the simulated occupancy.</p><p><strong>Interpretation:</strong> &ldquo;If there were a rook on the king&rsquo;s square, what squares could it attack?&rdquo;</p><p><strong>Reverse logic:</strong> &ldquo;What squares have line-of-sight to the king along ranks/files?&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pieces(<span style=color:#f92672>~</span>us, QUEEN, ROOK)
</span></span></code></pre></div><p>All enemy queens and rooks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(ksq, occupied) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us, QUEEN, ROOK)
</span></span></code></pre></div><p><strong>Intersection:</strong> Are any enemy rooks/queens on squares that have rook-line-of-sight to our king?</p><p>If there was any bishop or rook in place of our king, will it see any enemy rook, bishop or queen? If so it means our king will end up in check after this move.</p><p>If intersection is non-empty → function returns false (illegal move).</p><h4 id=3-special-case-2-king-moves>3. Special Case 2: King Moves<a hidden class=anchor aria-hidden=true href=#3-special-case-2-king-moves>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// If the moving piece is a king, check whether the destination
</span></span></span><span style=display:flex><span><span style=color:#75715e>// square is attacked by the opponent. Castling moves are checked
</span></span></span><span style=display:flex><span><span style=color:#75715e>// for legality during move generation.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(piece_on(from)) <span style=color:#f92672>==</span> KING)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> type_of(m) <span style=color:#f92672>==</span> CASTLING <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>(attackers_to(to_sq(m)) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us));
</span></span></code></pre></div><p>If the moving piece is the king:</p><ul><li>king cannot move into check</li></ul><p>Castling rules are checked during move generation itself.</p><h4 id=4-non-king-move-legality-check>4. Non-King Move Legality Check<a hidden class=anchor aria-hidden=true href=#4-non-king-move-legality-check>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#75715e>// A non-king move is legal if and only if it is not pinned or it
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// is moving along the ray towards or away from the king.
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>   <span style=color:#f92672>!</span>(pinned_pieces(us) <span style=color:#f92672>&amp;</span> from)
</span></span><span style=display:flex><span>        <span style=color:#f92672>||</span>  aligned(from, to_sq(m), square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us));
</span></span></code></pre></div><p>This handles legality for all non-king, non-en-passant moves by checking if the move would expose the king to check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Case <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> <span style=color:#f92672>!</span>(pinned_pieces(us) <span style=color:#f92672>&amp;</span> from)     <span style=color:#75715e>// Piece is NOT pinned
</span></span></span><span style=display:flex><span>   OR
</span></span><span style=display:flex><span>Case <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> aligned(from, to_sq(m), square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us))  <span style=color:#75715e>// Move is along pin line
</span></span></span></code></pre></div><p><strong>Case 1: Piece is NOT Pinned</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard <span style=color:#a6e22e>pinned_pieces</span>(Color c) <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>Returns: Bitboard of all our pieces that are pinned to our king.</p><p>Bitwise and with <code>from</code> gives the intersection, it tells if the moving piece is pinned.</p><p><strong>Case 2: Move Along Pin Line</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>aligned(from, to_sq(m), square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us))
</span></span></code></pre></div><p>Only checked if Case 1 fails (piece IS pinned).</p><h3 id=2-pseudo_legal>2. pseudo_legal<a hidden class=anchor aria-hidden=true href=#2-pseudo_legal>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Position::pseudo_legal() takes a random move and tests whether the move is
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// pseudo legal. It is used to validate moves from TT that can be corrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// due to SMP concurrent access or hash position key aliasing.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> Position<span style=color:#f92672>::</span>pseudo_legal(<span style=color:#66d9ef>const</span> Move m) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>  Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span><span style=display:flex><span>  Square to <span style=color:#f92672>=</span> to_sq(m);
</span></span><span style=display:flex><span>  Piece pc <span style=color:#f92672>=</span> moved_piece(m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Use a slower but simpler function for uncommon cases
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>!=</span> NORMAL)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> MoveList<span style=color:#f92672>&lt;</span>LEGAL<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>).contains(m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Is not a promotion, so promotion piece must be empty
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (promotion_type(m) <span style=color:#f92672>-</span> KNIGHT <span style=color:#f92672>!=</span> NO_PIECE_TYPE)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// If the &#39;from&#39; square is not occupied by a piece belonging to the side to
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// move, the move is obviously not legal.
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>==</span> NO_PIECE <span style=color:#f92672>||</span> color_of(pc) <span style=color:#f92672>!=</span> us)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The destination square cannot be occupied by a friendly piece
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pieces(us) <span style=color:#f92672>&amp;</span> to)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Handle the special case of a pawn move
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We have already handled promotion moves, so destination
</span></span></span><span style=display:flex><span>      <span style=color:#75715e>// cannot be on the 8th/1st rank.
</span></span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (rank_of(to) <span style=color:#f92672>==</span> relative_rank(us, RANK_8))
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (   <span style=color:#f92672>!</span>(attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(from, us) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us) <span style=color:#f92672>&amp;</span> to) <span style=color:#75715e>// Not a capture
</span></span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>((from <span style=color:#f92672>+</span> pawn_push(us) <span style=color:#f92672>==</span> to) <span style=color:#f92672>&amp;&amp;</span> empty(to))       <span style=color:#75715e>// Not a single push
</span></span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(   (from <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> pawn_push(us) <span style=color:#f92672>==</span> to)              <span style=color:#75715e>// Not a double push
</span></span></span><span style=display:flex><span>               <span style=color:#f92672>&amp;&amp;</span> (rank_of(from) <span style=color:#f92672>==</span> relative_rank(us, RANK_2))
</span></span><span style=display:flex><span>               <span style=color:#f92672>&amp;&amp;</span> empty(to)
</span></span><span style=display:flex><span>               <span style=color:#f92672>&amp;&amp;</span> empty(to <span style=color:#f92672>-</span> pawn_push(us))))
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (<span style=color:#f92672>!</span>(attacks_from(pc, from) <span style=color:#f92672>&amp;</span> to))
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Evasions generator already takes care to avoid some kind of illegal moves
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// and legal() relies on this. We therefore have to take care that the same
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// kind of moves are filtered out here.
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (checkers())
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>!=</span> KING)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Double check? In this case a king move is required
</span></span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (more_than_one(checkers()))
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// Our move must be a blocking evasion or a capture of the checking piece
</span></span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>((between_bb(lsb(checkers()), square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us)) <span style=color:#f92672>|</span> checkers()) <span style=color:#f92672>&amp;</span> to))
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// In case of king moves under check we have to remove king so as to catch
</span></span></span><span style=display:flex><span>      <span style=color:#75715e>// invalid moves like b1a1 when opposite queen is on c1.
</span></span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (attackers_to(to, pieces() <span style=color:#f92672>^</span> from) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us))
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Purpose:</strong> Validate that a move is <strong>pseudo-legal</strong> (follows piece movement rules, but may leave king in check).</p><p><strong>Use case:</strong> Validate moves from <strong>transposition table</strong> that might be corrupted due to:</p><ul><li>Hash collisions (different positions with same key)</li><li>SMP concurrent access (race conditions)</li><li>Memory corruption</li></ul><p><strong>Pseudo-legal vs Legal:</strong></p><ul><li><strong>Pseudo-legal:</strong> Piece can physically make the move (ignoring king safety)</li><li><strong>Legal:</strong> Pseudo-legal AND doesn&rsquo;t leave own king in check</li></ul><h4 id=function-structure>Function Structure<a hidden class=anchor aria-hidden=true href=#function-structure>#</a></h4><ol><li>Extract move information</li><li>Handle special moves (promotion, castling, en passant) via slow path</li><li>Basic validation (piece exists, colors match)</li><li>Validate destination square</li><li>Validate piece-specific movement rules</li><li>Handle check evasions</li><li>Return result</li></ol><h4 id=1-extract-move-information>1. Extract Move Information<a hidden class=anchor aria-hidden=true href=#1-extract-move-information>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Color us <span style=color:#f92672>=</span> sideToMove;
</span></span><span style=display:flex><span>Square from <span style=color:#f92672>=</span> from_sq(m);
</span></span><span style=display:flex><span>Square to <span style=color:#f92672>=</span> to_sq(m);
</span></span><span style=display:flex><span>Piece pc <span style=color:#f92672>=</span> moved_piece(m);
</span></span></code></pre></div><p>Standard setup:</p><ul><li><code>us</code>: Whose turn it is</li><li><code>from</code>: Source square</li><li><code>to</code>: Destination square</li><li><code>pc</code>: What piece is moving (from the move encoding or board)</li></ul><h4 id=2-special-move-types-slow-path>2. Special Move Types (Slow Path)<a hidden class=anchor aria-hidden=true href=#2-special-move-types-slow-path>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Use a slower but simpler function for uncommon cases
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(m) <span style=color:#f92672>!=</span> NORMAL)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> MoveList<span style=color:#f92672>&lt;</span>LEGAL<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>).contains(m);
</span></span></code></pre></div><p>Handle special cases by generating all legal moves:</p><ul><li><code>PROMOTION</code>: Pawn reaching 8th rank</li><li><code>ENPASSANT</code>: En passant capture</li><li><code>CASTLING</code>: Castling</li></ul><p>Why slow path?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MoveList<span style=color:#f92672>&lt;</span>LEGAL<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>)  <span style=color:#75715e>// Generates ALL legal moves for position
</span></span></span><span style=display:flex><span>.contains(m)            <span style=color:#75715e>// Checks if m is in the list
</span></span></span></code></pre></div><p>This generates every legal move (expensive!) just to validate one move.</p><p><strong>Why do this?</strong></p><ul><li>Special moves have complex validation rules</li><li>They&rsquo;re rare (~5% of moves)</li><li>Simpler to reuse existing move generation than duplicate logic</li></ul><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Move m <span style=color:#f92672>=</span> make_move(e7, e8, PROMOTION, QUEEN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type_of(m) <span style=color:#f92672>=</span> PROMOTION  <span style=color:#960050;background-color:#1e0010>✓</span> Not NORMAL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Generate all legal moves:
</span></span></span><span style=display:flex><span>MoveList<span style=color:#f92672>&lt;</span>LEGAL<span style=color:#f92672>&gt;</span> moves(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);  <span style=color:#75715e>// {e7e8q, e7e8r, e7e8b, e7e8n, Nf6, ...}
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Check if our move is in the list:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> moves.contains(e7e8q);  <span style=color:#960050;background-color:#1e0010>✓</span> true
</span></span></code></pre></div><p><strong>Performance:</strong> This is acceptable because:</p><ul><li>TT validation is infrequent (only when probe succeeds)</li><li>Special moves are rare</li><li>Correctness > speed for this function</li></ul><h4 id=3-promotion-validation>3. Promotion Validation<a hidden class=anchor aria-hidden=true href=#3-promotion-validation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Is not a promotion, so promotion piece must be empty
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (promotion_type(m) <span style=color:#f92672>-</span> KNIGHT <span style=color:#f92672>!=</span> NO_PIECE_TYPE)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><p>What this checks: If move type is NORMAL, there should be no promotion piece encoded. Its subtracting KNIGHT, because promotion pieces are encoded as KNIGHT - 2.</p><h4 id=4-basic-piece-validation>4. Basic Piece Validation<a hidden class=anchor aria-hidden=true href=#4-basic-piece-validation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// If the &#39;from&#39; square is not occupied by a piece belonging to the side to
</span></span></span><span style=display:flex><span><span style=color:#75715e>// move, the move is obviously not legal.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>==</span> NO_PIECE <span style=color:#f92672>||</span> color_of(pc) <span style=color:#f92672>!=</span> us)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><h5 id=check-1-piece-exists>Check 1: Piece exists<a hidden class=anchor aria-hidden=true href=#check-1-piece-exists>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pc <span style=color:#f92672>==</span> NO_PIECE
</span></span></code></pre></div><p><strong>Example of failure:</strong></p><pre tabindex=0><code>Board:
  4  . . . . . . . .  ← e4 is empty
  
Move: e4-e5

pc = piece_on(e4) = NO_PIECE  ✗

return false  // Can&#39;t move nothing!
</code></pre><h5 id=check-2-correct-color>Check 2: Correct color<a hidden class=anchor aria-hidden=true href=#check-2-correct-color>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>color_of(pc) <span style=color:#f92672>!=</span> us
</span></span></code></pre></div><p><strong>Example of failure:</strong></p><pre tabindex=0><code>Board:
  4  . . . . ● . . .  ← e4 has black pawn
  
Side to move: WHITE
Move: e4-e5

pc = B_PAWN
color_of(B_PAWN) = BLACK
BLACK != WHITE  ✗

return false  // Can&#39;t move opponent&#39;s piece!
</code></pre><p><strong>Why these can fail:</strong></p><ul><li>Hash collision: Different position mapped to same TT entry</li><li>Concurrent access: Position changed while reading TT entry</li><li>Move encoding corruption</li></ul><h4 id=5-destination-square-validation>5. Destination Square Validation<a hidden class=anchor aria-hidden=true href=#5-destination-square-validation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// The destination square cannot be occupied by a friendly piece
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (pieces(us) <span style=color:#f92672>&amp;</span> to)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><p>Can&rsquo;t capture our own pieces:</p><h4 id=6-pawn-movement-validation>6. Pawn Movement Validation<a hidden class=anchor aria-hidden=true href=#6-pawn-movement-validation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We have already handled promotion moves, so destination
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// cannot be on the 8th/1st rank.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (rank_of(to) <span style=color:#f92672>==</span> relative_rank(us, RANK_8))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><h5 id=check-1-not-on-promotion-rank>Check 1: Not on promotion rank<a hidden class=anchor aria-hidden=true href=#check-1-not-on-promotion-rank>#</a></h5><p>Since promotions were handled earlier (slow path), a NORMAL pawn move can&rsquo;t end on the 8th rank.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>relative_rank(WHITE, RANK_8) <span style=color:#f92672>=</span> RANK_8 (<span style=color:#ae81ff>8</span>th rank <span style=color:#66d9ef>for</span> white)
</span></span><span style=display:flex><span>relative_rank(BLACK, RANK_8) <span style=color:#f92672>=</span> RANK_1 (<span style=color:#ae81ff>1</span>st rank <span style=color:#66d9ef>for</span> black, which is black<span style=color:#960050;background-color:#1e0010>&#39;</span>s <span style=color:#ae81ff>8</span>th)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example:
</span></span></span><span style=display:flex><span>us <span style=color:#f92672>=</span> WHITE
</span></span><span style=display:flex><span>to <span style=color:#f92672>=</span> e8
</span></span><span style=display:flex><span>rank_of(e8) <span style=color:#f92672>=</span> RANK_8
</span></span><span style=display:flex><span>RANK_8 <span style=color:#f92672>==</span> RANK_8  <span style=color:#960050;background-color:#1e0010>✗</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> false  <span style=color:#75715e>// Pawn to 8th rank must be promotion!
</span></span></span></code></pre></div><h5 id=pawn-movement-rules>Pawn Movement Rules<a hidden class=anchor aria-hidden=true href=#pawn-movement-rules>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (   <span style=color:#f92672>!</span>(attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(from, us) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us) <span style=color:#f92672>&amp;</span> to) <span style=color:#75715e>// Not a capture
</span></span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>((from <span style=color:#f92672>+</span> pawn_push(us) <span style=color:#f92672>==</span> to) <span style=color:#f92672>&amp;&amp;</span> empty(to))       <span style=color:#75715e>// Not a single push
</span></span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(   (from <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> pawn_push(us) <span style=color:#f92672>==</span> to)              <span style=color:#75715e>// Not a double push
</span></span></span><span style=display:flex><span>         <span style=color:#f92672>&amp;&amp;</span> (rank_of(from) <span style=color:#f92672>==</span> relative_rank(us, RANK_2))
</span></span><span style=display:flex><span>         <span style=color:#f92672>&amp;&amp;</span> empty(to)
</span></span><span style=display:flex><span>         <span style=color:#f92672>&amp;&amp;</span> empty(to <span style=color:#f92672>-</span> pawn_push(us))))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><p>This is a complex condition: Move is valid if ANY of these is true:</p><ul><li>Pawn capture</li><li>Single push</li><li>Double push</li></ul><p>If NONE are true → invalid.</p><p><strong>Part 1: Pawn Capture</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>!</span>(attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(from, us) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us) <span style=color:#f92672>&amp;</span> to)
</span></span></code></pre></div><p>Check: Is this a valid pawn capture?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(from, us)  <span style=color:#75715e>// Diagonal attacks from source
</span></span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us)                 <span style=color:#75715e>// Enemy pieces
</span></span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span> to                          <span style=color:#75715e>// Destination square
</span></span></span></code></pre></div><p>Example - Valid capture:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#ae81ff>5</span>  . . . <span style=color:#960050;background-color:#1e0010>○</span> . . . .  <span style=color:#960050;background-color:#1e0010>←</span> d5: black pawn
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>4</span>  . . . . <span style=color:#960050;background-color:#1e0010>●</span> . . .  <span style=color:#960050;background-color:#1e0010>←</span> e4: white pawn
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>Move: e4xd5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(e4, WHITE) <span style=color:#f92672>=</span> {d5, f5}
</span></span><span style=display:flex><span>pieces(BLACK) <span style=color:#f92672>=</span> {d5, ...}
</span></span><span style=display:flex><span>to <span style=color:#f92672>=</span> d5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{d5, f5} <span style=color:#f92672>&amp;</span> {d5, ...} <span style=color:#f92672>&amp;</span> d5 <span style=color:#f92672>=</span> {d5}  <span style=color:#960050;background-color:#1e0010>✓</span> Non<span style=color:#f92672>-</span>empty (valid capture)
</span></span><span style=display:flex><span><span style=color:#f92672>!</span>{d5} <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This part fails, but that&#39;s OK - we check other parts
</span></span></span></code></pre></div><p><strong>Part 2: Single Push</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>!</span>((from <span style=color:#f92672>+</span> pawn_push(us) <span style=color:#f92672>==</span> to) <span style=color:#f92672>&amp;&amp;</span> empty(to))
</span></span></code></pre></div><p>Check: Is this a valid single square forward move?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pawn_push(WHITE) <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>  (NORTH)
</span></span><span style=display:flex><span>pawn_push(BLACK) <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span> (SOUTH)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>from <span style=color:#f92672>+</span> pawn_push(us) <span style=color:#f92672>==</span> to  <span style=color:#75715e>// Is destination one square forward?
</span></span></span><span style=display:flex><span><span style=color:#f92672>&amp;&amp;</span> empty(to)                <span style=color:#75715e>// Is destination empty?
</span></span></span></code></pre></div><p>Example - Valid single push:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#ae81ff>5</span>  . . . . . . . .  <span style=color:#960050;background-color:#1e0010>←</span> e5: empty
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>4</span>  . . . . <span style=color:#960050;background-color:#1e0010>●</span> . . .  <span style=color:#960050;background-color:#1e0010>←</span> e4: white pawn
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>Move: e4<span style=color:#f92672>-</span>e5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>from <span style=color:#f92672>+</span> pawn_push(WHITE) <span style=color:#f92672>=</span> e4 <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>=</span> e5
</span></span><span style=display:flex><span>e5 <span style=color:#f92672>==</span> e5  <span style=color:#960050;background-color:#1e0010>✓</span>
</span></span><span style=display:flex><span>empty(e5) <span style=color:#f92672>=</span> true  <span style=color:#960050;background-color:#1e0010>✓</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(true <span style=color:#f92672>&amp;&amp;</span> true) <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span><span style=color:#f92672>!</span>(true) <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This part fails, but that&#39;s OK (valid move)
</span></span></span></code></pre></div><p><strong>Part 3: Double Push</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>!</span>(   (from <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> pawn_push(us) <span style=color:#f92672>==</span> to)              <span style=color:#75715e>// Two squares forward
</span></span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> (rank_of(from) <span style=color:#f92672>==</span> relative_rank(us, RANK_2))  <span style=color:#75715e>// From starting rank
</span></span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> empty(to)                                      <span style=color:#75715e>// Destination empty
</span></span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> empty(to <span style=color:#f92672>-</span> pawn_push(us)))                    <span style=color:#75715e>// Square in between empty
</span></span></span></code></pre></div><h4 id=7-non-pawn-movement-validation>7. Non-Pawn Movement Validation<a hidden class=anchor aria-hidden=true href=#7-non-pawn-movement-validation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (<span style=color:#f92672>!</span>(attacks_from(pc, from) <span style=color:#f92672>&amp;</span> to))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><p>For knights, bishops, rooks, queens, kings:</p><p>example - Valid knight move:</p><p>Move: Nd3-e4</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>attacks_from(pc, from)  <span style=color:#75715e>// Bitboard of squares piece can attack
</span></span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span> to                    <span style=color:#75715e>// Is destination in attack set?
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>attacks_from(W_KNIGHT, d3) <span style=color:#f92672>&amp;</span> e4 <span style=color:#f92672>=</span> {e4}  <span style=color:#960050;background-color:#1e0010>✓</span> Non<span style=color:#f92672>-</span>empty
</span></span><span style=display:flex><span><span style=color:#f92672>!</span>{e5} <span style=color:#f92672>=</span> false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Don&#39;t return false, continue checking...
</span></span></span></code></pre></div><h4 id=8-check-evasion-validation>8. Check Evasion Validation<a hidden class=anchor aria-hidden=true href=#8-check-evasion-validation>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (checkers())
</span></span><span style=display:flex><span>{
</span></span></code></pre></div><p>If we&rsquo;re in check, additional restrictions apply:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>!=</span> KING)
</span></span><span style=display:flex><span>{
</span></span></code></pre></div><p>It means the piece we moved is not king, even though we were in check.</p><h5 id=1-double-check--must-move-king>1. Double Check → Must Move King<a hidden class=anchor aria-hidden=true href=#1-double-check--must-move-king>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Double check? In this case a king move is required
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (more_than_one(checkers()))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>checkers()  <span style=color:#75715e>// Bitboard of pieces giving check
</span></span></span><span style=display:flex><span>more_than_one(checkers())  <span style=color:#75715e>// Are there 2+ checkers?
</span></span></span></code></pre></div><p>If its double check and king hasn&rsquo;t moved, we can return false.</p><h5 id=2-single-check--block-or-capture>2. Single Check → Block or Capture<a hidden class=anchor aria-hidden=true href=#2-single-check--block-or-capture>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Our move must be a blocking evasion or a capture of the checking piece
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>((between_bb(lsb(checkers()), square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us)) <span style=color:#f92672>|</span> checkers()) <span style=color:#f92672>&amp;</span> to))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In single check, move must EITHER:</p><ul><li>Block the check (move to a square between attacker and king)</li><li>Capture the checking piece</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>(between_bb(lsb(checkers()), square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(us))  <span style=color:#75715e>// Squares between checker and king
</span></span></span><span style=display:flex><span><span style=color:#f92672>|</span> checkers())                                   <span style=color:#75715e>// OR the checker&#39;s square itself
</span></span></span><span style=display:flex><span><span style=color:#f92672>&amp;</span> to                                           <span style=color:#75715e>// Is destination one of these?
</span></span></span></code></pre></div><p>It means we should move to a square in-between king and checker or capture the checker.</p><p>Since we know it can&rsquo;t be double check, we can safely extract checker by <code>lsb(checkers())</code></p><h5 id=3-king-moves-under-check>3. King Moves Under Check<a hidden class=anchor aria-hidden=true href=#3-king-moves-under-check>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// In case of king moves under check we have to remove king so as to catch
</span></span></span><span style=display:flex><span><span style=color:#75715e>// invalid moves like b1a1 when opposite queen is on c1.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (attackers_to(to, pieces() <span style=color:#f92672>^</span> from) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>us))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><p><strong>Special handling for king moves when in check:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pieces() <span style=color:#f92672>^</span> from  <span style=color:#75715e>// Occupancy with king removed from current square
</span></span></span></code></pre></div><p><strong>Why remove king?</strong> To detect attacks &ldquo;through&rdquo; the king&rsquo;s current square.</p><p><strong>Example - Invalid king move:</strong></p><pre tabindex=0><code>  2  . . . . . . . .
  1  . K . q . . . .  ← b1: king, d1: black queen
     a b c d e f g h
     ╰───╯
     King trying to move along queen&#39;s attack ray

Move: Kb1-a1


Without removing king:
attackers_to(a1, pieces()) queen on d1 doesn&#39;t attack b1 and a1, since its blocked by our king.
</code></pre><h4 id=9-all-tests-passed>9. All Tests passed<a hidden class=anchor aria-hidden=true href=#9-all-tests-passed>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>return</span> true;
</span></span></code></pre></div><h3 id=3-attackers_to>3. attackers_to<a hidden class=anchor aria-hidden=true href=#3-attackers_to>#</a></h3><p><code>attackers_to(sq)</code> answers the question:</p><blockquote><p>“Which pieces (of either side) are currently attacking square sq?”</p></blockquote><p>It returns a bitboard containing all attackers.</p><p><strong>Function Signatures</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard <span style=color:#a6e22e>attackers_to</span>(Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>Bitboard <span style=color:#a6e22e>attackers_to</span>(Square s, Bitboard occupied) <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><ul><li><code>attackers_to(s)</code>: attackers using current board occupancy</li><li><code>attackers_to(s, occupied)</code>: attackers assuming a custom occupancy mask</li></ul><p>The second one is used in tricky cases like:</p><ul><li>en passant legality</li><li>discovered attacks</li><li>move simulation without actually making the move</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard Position<span style=color:#f92672>::</span>attackers_to(Square s) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>attackers_to</span>(s, byTypeBB[ALL_PIECES]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Position::attackers_to() computes a bitboard of all pieces which attack a
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// given square. Slider attacks use the occupied bitboard to indicate occupancy.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bitboard Position<span style=color:#f92672>::</span>attackers_to(Square s, Bitboard occupied) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>  (attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(s, BLACK)    <span style=color:#f92672>&amp;</span> pieces(WHITE, PAWN))
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> (attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(s, WHITE)    <span style=color:#f92672>&amp;</span> pieces(BLACK, PAWN))
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> (attacks_from<span style=color:#f92672>&lt;</span>KNIGHT<span style=color:#f92672>&gt;</span>(s)         <span style=color:#f92672>&amp;</span> pieces(KNIGHT))
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> (attacks_bb<span style=color:#f92672>&lt;</span>ROOK  <span style=color:#f92672>&gt;</span>(s, occupied) <span style=color:#f92672>&amp;</span> pieces(ROOK,   QUEEN))
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> (attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s, occupied) <span style=color:#f92672>&amp;</span> pieces(BISHOP, QUEEN))
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span> (attacks_from<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(s)           <span style=color:#f92672>&amp;</span> pieces(KING));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Attackers come from 6 piece types:</p><ul><li>pawns</li><li>knights</li><li>bishops</li><li>rooks</li><li>queens</li><li>king</li></ul><p>So conceptually:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attackers <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    pawn_attackers <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    knight_attackers <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    bishop_attackers <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    rook_attackers <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    queen_attackers <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    king_attackers;
</span></span></code></pre></div><h4 id=1-pawn-attackers>1. Pawn Attackers<a hidden class=anchor aria-hidden=true href=#1-pawn-attackers>#</a></h4><p>Pawns are asymmetric:
white pawns attack upward, black pawns downward.</p><p>So Stockfish reverses the logic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>(attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(s, BLACK) <span style=color:#f92672>&amp;</span> pieces(WHITE, PAWN))
</span></span></code></pre></div><p>To answer which white pawns attack the square s, stockfish asks the reverse questions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(s, BLACK)
</span></span></code></pre></div><p>If a black pawn was present in square s, which squares would it attack?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pieces(WHITE, PAWN)
</span></span></code></pre></div><p>This returns a bitboard with only squares containing white pawns, so the final result contains only those squares which are under attack by a hypothetical black pawn in square s, bitwise and white pawns. So final bitboard will give us all white pawns which can attack this square s.</p><p><code>attacks_from&lt;PAWN></code> uses <code>StepAttacksBB</code> which is a map of precomputed attack squares.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard Position<span style=color:#f92672>::</span>attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(Square s, Color c) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> StepAttacksBB[make_piece(c, PAWN)][s];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Examples:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>StepAttacksBB[W_PAWN][e4]  <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d5, f5 set (white pawn attacks)
</span></span><span style=display:flex><span>StepAttacksBB[B_PAWN][e5]  <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d4, f4 set (black pawn attacks)
</span></span><span style=display:flex><span>StepAttacksBB[W_KNIGHT][e4] <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d2, f2, c3, g3, c5, g5, d6, f6
</span></span><span style=display:flex><span>StepAttacksBB[W_KING][e1]  <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d1, f1, d2, e2, f2
</span></span></code></pre></div><p>Similar logic is used to find all black pawns attacking the square s</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>(attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(s, WHITE) <span style=color:#f92672>&amp;</span> pieces(BLACK, PAWN))
</span></span></code></pre></div><h4 id=2-knight-attacks>2. Knight Attacks<a hidden class=anchor aria-hidden=true href=#2-knight-attacks>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>(attacks_from<span style=color:#f92672>&lt;</span>KNIGHT<span style=color:#f92672>&gt;</span>(s)         <span style=color:#f92672>&amp;</span> pieces(KNIGHT))
</span></span></code></pre></div><p>Knights are color-independent (same attack pattern for white/black).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks_from<span style=color:#f92672>&lt;</span>KNIGHT<span style=color:#f92672>&gt;</span>(s)  <span style=color:#75715e>// All squares a knight on `s` could attack
</span></span></span><span style=display:flex><span>pieces(KNIGHT)           <span style=color:#75715e>// All knights (both colors)
</span></span></span></code></pre></div><p>This is again a reverse lookup with same logic.</p><p>In this case, the implementation of <code>attacks_from</code> is</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard Position<span style=color:#f92672>::</span>attacks_from(Square s) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>  Pt <span style=color:#f92672>==</span> BISHOP <span style=color:#f92672>||</span> Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>?</span> attacks_bb<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(s, byTypeBB[ALL_PIECES])
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> Pt <span style=color:#f92672>==</span> QUEEN  <span style=color:#f92672>?</span> attacks_from<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(s) <span style=color:#f92672>|</span> attacks_from<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> StepAttacksBB[Pt][s];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For knight also its just <code>StepAttacksBB[Pt][s]</code> after stripping all the polymorphic code</p><h4 id=3-sliding-attacks-rookbishopqueen-occupancy-dependent>3. Sliding Attacks (Rook/Bishop/Queen, Occupancy-Dependent)<a hidden class=anchor aria-hidden=true href=#3-sliding-attacks-rookbishopqueen-occupancy-dependent>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard attacks_bb(Square s, Bitboard occupied) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> Bitboard<span style=color:#f92672>*</span> RookAttacks[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> Bitboard<span style=color:#f92672>*</span> BishopAttacks[SQUARE_NB];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>?</span> RookAttacks : BishopAttacks)[s][magic_index<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(s, occupied)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It uses the precomputed magic bitboards to get the attack bitboard, logic is similar for rook and bishop, but they have different precomputed tables.</p><p>For queen, the attack bitboard is just bitwise OR of rook and bishop</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Pt <span style=color:#f92672>==</span> QUEEN  <span style=color:#f92672>?</span> attacks_from<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(s) <span style=color:#f92672>|</span> attacks_from<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s)
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/game-mechanics/>Game Mechanics</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>