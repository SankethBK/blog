<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Representation of The Game State | Sanketh's Blog</title><meta name=keywords content="board representation,Position,StateInfo"><meta name=description content="Representation of The Game State
The Position Class
The Position class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.
class Position {
public:
  static void init();

  Position() = default;
  Position(const Position&) = delete;
  Position& operator=(const Position&) = delete;

  // FEN string input/output
  Position& set(const std::string& fenStr, bool isChess960, StateInfo* si, Thread* th);
  const std::string fen() const;

  // Position representation
  Bitboard pieces() const;
  Bitboard pieces(PieceType pt) const;
  Bitboard pieces(PieceType pt1, PieceType pt2) const;
  Bitboard pieces(Color c) const;
  Bitboard pieces(Color c, PieceType pt) const;
  Bitboard pieces(Color c, PieceType pt1, PieceType pt2) const;
  Piece piece_on(Square s) const;
  Square ep_square() const;
  bool empty(Square s) const;
  template<PieceType Pt> int count(Color c) const;
  template<PieceType Pt> const Square* squares(Color c) const;
  template<PieceType Pt> Square square(Color c) const;

  // Castling
  int can_castle(Color c) const;
  int can_castle(CastlingRight cr) const;
  bool castling_impeded(CastlingRight cr) const;
  Square castling_rook_square(CastlingRight cr) const;

  // Checking
  Bitboard checkers() const;
  Bitboard discovered_check_candidates() const;
  Bitboard pinned_pieces(Color c) const;
  Bitboard check_squares(PieceType pt) const;

  // Attacks to/from a given square
  Bitboard attackers_to(Square s) const;
  Bitboard attackers_to(Square s, Bitboard occupied) const;
  Bitboard attacks_from(Piece pc, Square s) const;
  template<PieceType> Bitboard attacks_from(Square s) const;
  template<PieceType> Bitboard attacks_from(Square s, Color c) const;
  Bitboard slider_blockers(Bitboard sliders, Square s, Bitboard& pinners) const;

  // Properties of moves
  bool legal(Move m) const;
  bool pseudo_legal(const Move m) const;
  bool capture(Move m) const;
  bool capture_or_promotion(Move m) const;
  bool gives_check(Move m) const;
  bool advanced_pawn_push(Move m) const;
  Piece moved_piece(Move m) const;
  Piece captured_piece() const;

  // Piece specific
  bool pawn_passed(Color c, Square s) const;
  bool opposite_bishops() const;

  // Doing and undoing moves
  void do_move(Move m, StateInfo& st, bool givesCheck);
  void undo_move(Move m);
  void do_null_move(StateInfo& st);
  void undo_null_move();

  // Static Exchange Evaluation
  bool see_ge(Move m, Value value) const;

  // Accessing hash keys
  Key key() const;
  Key key_after(Move m) const;
  Key material_key() const;
  Key pawn_key() const;

  // Other properties of the position
  Color side_to_move() const;
  Phase game_phase() const;
  int game_ply() const;
  bool is_chess960() const;
  Thread* this_thread() const;
  uint64_t nodes_searched() const;
  bool is_draw() const;
  int rule50_count() const;
  Score psq_score() const;
  Value non_pawn_material(Color c) const;

  // Position consistency check, for debugging
  bool pos_is_ok(int* failedStep = nullptr) const;
  void flip();

private:
  // Initialization helpers (used while setting up a position)
  void set_castling_right(Color c, Square rfrom);
  void set_state(StateInfo* si) const;
  void set_check_info(StateInfo* si) const;

  // Other helpers
  void put_piece(Piece pc, Square s);
  void remove_piece(Piece pc, Square s);
  void move_piece(Piece pc, Square from, Square to);
  template<bool Do>
  void do_castling(Color us, Square from, Square& to, Square& rfrom, Square& rto);

  // Data members
  Piece board[SQUARE_NB];
  Bitboard byTypeBB[PIECE_TYPE_NB];
  Bitboard byColorBB[COLOR_NB];
  int pieceCount[PIECE_NB];
  Square pieceList[PIECE_NB][16];
  int index[SQUARE_NB];
  int castlingRightsMask[SQUARE_NB];
  Square castlingRookSquare[CASTLING_RIGHT_NB];
  Bitboard castlingPath[CASTLING_RIGHT_NB];
  uint64_t nodes;
  int gamePly;
  Color sideToMove;
  Thread* thisThread;
  StateInfo* st;
  bool chess960;
};
Class Design Decisions
1. Non-Copyable
Position(const Position&) = delete;
Position& operator=(const Position&) = delete;

Cannot be copied (copy constructor and assignment deleted)
Why? Positions are heavy objects with complex state
Must be moved or passed by reference/pointer
Prevents accidental expensive copies

2. Default Constructor
Position() = default;

Creates uninitialized position
Must call set() to initialize with FEN string

Core Data Members
1. Board Representation - MailBox
Piece board[SQUARE_NB];  // SQUARE_NB = 64

Mailbox representation: Direct lookup &ldquo;what piece is on square X?&rdquo;
board[e4] → returns W_KNIGHT or NO_PIECE
Fast for: &ldquo;piece_on(Square s)&rdquo;

2. Bitboard Representation
Technically we need 12 bitboards to represent the all the pieces on chessboard."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Representation of The Game State"><meta property="og:description" content="Representation of The Game State The Position Class The Position class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.
class Position { public: static void init(); Position() = default; Position(const Position&) = delete; Position& operator=(const Position&) = delete; // FEN string input/output Position& set(const std::string& fenStr, bool isChess960, StateInfo* si, Thread* th); const std::string fen() const; // Position representation Bitboard pieces() const; Bitboard pieces(PieceType pt) const; Bitboard pieces(PieceType pt1, PieceType pt2) const; Bitboard pieces(Color c) const; Bitboard pieces(Color c, PieceType pt) const; Bitboard pieces(Color c, PieceType pt1, PieceType pt2) const; Piece piece_on(Square s) const; Square ep_square() const; bool empty(Square s) const; template<PieceType Pt> int count(Color c) const; template<PieceType Pt> const Square* squares(Color c) const; template<PieceType Pt> Square square(Color c) const; // Castling int can_castle(Color c) const; int can_castle(CastlingRight cr) const; bool castling_impeded(CastlingRight cr) const; Square castling_rook_square(CastlingRight cr) const; // Checking Bitboard checkers() const; Bitboard discovered_check_candidates() const; Bitboard pinned_pieces(Color c) const; Bitboard check_squares(PieceType pt) const; // Attacks to/from a given square Bitboard attackers_to(Square s) const; Bitboard attackers_to(Square s, Bitboard occupied) const; Bitboard attacks_from(Piece pc, Square s) const; template<PieceType> Bitboard attacks_from(Square s) const; template<PieceType> Bitboard attacks_from(Square s, Color c) const; Bitboard slider_blockers(Bitboard sliders, Square s, Bitboard& pinners) const; // Properties of moves bool legal(Move m) const; bool pseudo_legal(const Move m) const; bool capture(Move m) const; bool capture_or_promotion(Move m) const; bool gives_check(Move m) const; bool advanced_pawn_push(Move m) const; Piece moved_piece(Move m) const; Piece captured_piece() const; // Piece specific bool pawn_passed(Color c, Square s) const; bool opposite_bishops() const; // Doing and undoing moves void do_move(Move m, StateInfo& st, bool givesCheck); void undo_move(Move m); void do_null_move(StateInfo& st); void undo_null_move(); // Static Exchange Evaluation bool see_ge(Move m, Value value) const; // Accessing hash keys Key key() const; Key key_after(Move m) const; Key material_key() const; Key pawn_key() const; // Other properties of the position Color side_to_move() const; Phase game_phase() const; int game_ply() const; bool is_chess960() const; Thread* this_thread() const; uint64_t nodes_searched() const; bool is_draw() const; int rule50_count() const; Score psq_score() const; Value non_pawn_material(Color c) const; // Position consistency check, for debugging bool pos_is_ok(int* failedStep = nullptr) const; void flip(); private: // Initialization helpers (used while setting up a position) void set_castling_right(Color c, Square rfrom); void set_state(StateInfo* si) const; void set_check_info(StateInfo* si) const; // Other helpers void put_piece(Piece pc, Square s); void remove_piece(Piece pc, Square s); void move_piece(Piece pc, Square from, Square to); template<bool Do> void do_castling(Color us, Square from, Square& to, Square& rfrom, Square& rto); // Data members Piece board[SQUARE_NB]; Bitboard byTypeBB[PIECE_TYPE_NB]; Bitboard byColorBB[COLOR_NB]; int pieceCount[PIECE_NB]; Square pieceList[PIECE_NB][16]; int index[SQUARE_NB]; int castlingRightsMask[SQUARE_NB]; Square castlingRookSquare[CASTLING_RIGHT_NB]; Bitboard castlingPath[CASTLING_RIGHT_NB]; uint64_t nodes; int gamePly; Color sideToMove; Thread* thisThread; StateInfo* st; bool chess960; }; Class Design Decisions 1. Non-Copyable Position(const Position&) = delete; Position& operator=(const Position&) = delete; Cannot be copied (copy constructor and assignment deleted) Why? Positions are heavy objects with complex state Must be moved or passed by reference/pointer Prevents accidental expensive copies 2. Default Constructor Position() = default; Creates uninitialized position Must call set() to initialize with FEN string Core Data Members 1. Board Representation - MailBox Piece board[SQUARE_NB]; // SQUARE_NB = 64 Mailbox representation: Direct lookup “what piece is on square X?” board[e4] → returns W_KNIGHT or NO_PIECE Fast for: “piece_on(Square s)” 2. Bitboard Representation Technically we need 12 bitboards to represent the all the pieces on chessboard."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-07T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-07T00:00:00+00:00"><meta property="article:tag" content="Board Representation"><meta property="article:tag" content="Position"><meta property="article:tag" content="StateInfo"><meta name=twitter:card content="summary"><meta name=twitter:title content="Representation of The Game State"><meta name=twitter:description content="Representation of The Game State
The Position Class
The Position class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.
class Position {
public:
  static void init();

  Position() = default;
  Position(const Position&) = delete;
  Position& operator=(const Position&) = delete;

  // FEN string input/output
  Position& set(const std::string& fenStr, bool isChess960, StateInfo* si, Thread* th);
  const std::string fen() const;

  // Position representation
  Bitboard pieces() const;
  Bitboard pieces(PieceType pt) const;
  Bitboard pieces(PieceType pt1, PieceType pt2) const;
  Bitboard pieces(Color c) const;
  Bitboard pieces(Color c, PieceType pt) const;
  Bitboard pieces(Color c, PieceType pt1, PieceType pt2) const;
  Piece piece_on(Square s) const;
  Square ep_square() const;
  bool empty(Square s) const;
  template<PieceType Pt> int count(Color c) const;
  template<PieceType Pt> const Square* squares(Color c) const;
  template<PieceType Pt> Square square(Color c) const;

  // Castling
  int can_castle(Color c) const;
  int can_castle(CastlingRight cr) const;
  bool castling_impeded(CastlingRight cr) const;
  Square castling_rook_square(CastlingRight cr) const;

  // Checking
  Bitboard checkers() const;
  Bitboard discovered_check_candidates() const;
  Bitboard pinned_pieces(Color c) const;
  Bitboard check_squares(PieceType pt) const;

  // Attacks to/from a given square
  Bitboard attackers_to(Square s) const;
  Bitboard attackers_to(Square s, Bitboard occupied) const;
  Bitboard attacks_from(Piece pc, Square s) const;
  template<PieceType> Bitboard attacks_from(Square s) const;
  template<PieceType> Bitboard attacks_from(Square s, Color c) const;
  Bitboard slider_blockers(Bitboard sliders, Square s, Bitboard& pinners) const;

  // Properties of moves
  bool legal(Move m) const;
  bool pseudo_legal(const Move m) const;
  bool capture(Move m) const;
  bool capture_or_promotion(Move m) const;
  bool gives_check(Move m) const;
  bool advanced_pawn_push(Move m) const;
  Piece moved_piece(Move m) const;
  Piece captured_piece() const;

  // Piece specific
  bool pawn_passed(Color c, Square s) const;
  bool opposite_bishops() const;

  // Doing and undoing moves
  void do_move(Move m, StateInfo& st, bool givesCheck);
  void undo_move(Move m);
  void do_null_move(StateInfo& st);
  void undo_null_move();

  // Static Exchange Evaluation
  bool see_ge(Move m, Value value) const;

  // Accessing hash keys
  Key key() const;
  Key key_after(Move m) const;
  Key material_key() const;
  Key pawn_key() const;

  // Other properties of the position
  Color side_to_move() const;
  Phase game_phase() const;
  int game_ply() const;
  bool is_chess960() const;
  Thread* this_thread() const;
  uint64_t nodes_searched() const;
  bool is_draw() const;
  int rule50_count() const;
  Score psq_score() const;
  Value non_pawn_material(Color c) const;

  // Position consistency check, for debugging
  bool pos_is_ok(int* failedStep = nullptr) const;
  void flip();

private:
  // Initialization helpers (used while setting up a position)
  void set_castling_right(Color c, Square rfrom);
  void set_state(StateInfo* si) const;
  void set_check_info(StateInfo* si) const;

  // Other helpers
  void put_piece(Piece pc, Square s);
  void remove_piece(Piece pc, Square s);
  void move_piece(Piece pc, Square from, Square to);
  template<bool Do>
  void do_castling(Color us, Square from, Square& to, Square& rfrom, Square& rto);

  // Data members
  Piece board[SQUARE_NB];
  Bitboard byTypeBB[PIECE_TYPE_NB];
  Bitboard byColorBB[COLOR_NB];
  int pieceCount[PIECE_NB];
  Square pieceList[PIECE_NB][16];
  int index[SQUARE_NB];
  int castlingRightsMask[SQUARE_NB];
  Square castlingRookSquare[CASTLING_RIGHT_NB];
  Bitboard castlingPath[CASTLING_RIGHT_NB];
  uint64_t nodes;
  int gamePly;
  Color sideToMove;
  Thread* thisThread;
  StateInfo* st;
  bool chess960;
};
Class Design Decisions
1. Non-Copyable
Position(const Position&) = delete;
Position& operator=(const Position&) = delete;

Cannot be copied (copy constructor and assignment deleted)
Why? Positions are heavy objects with complex state
Must be moved or passed by reference/pointer
Prevents accidental expensive copies

2. Default Constructor
Position() = default;

Creates uninitialized position
Must call set() to initialize with FEN string

Core Data Members
1. Board Representation - MailBox
Piece board[SQUARE_NB];  // SQUARE_NB = 64

Mailbox representation: Direct lookup &ldquo;what piece is on square X?&rdquo;
board[e4] → returns W_KNIGHT or NO_PIECE
Fast for: &ldquo;piece_on(Square s)&rdquo;

2. Bitboard Representation
Technically we need 12 bitboards to represent the all the pieces on chessboard."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Representation of The Game State","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Representation of The Game State","name":"Representation of The Game State","description":"Representation of The Game State The Position Class The Position class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.\nclass Position { public: static void init(); Position() = default; Position(const Position\u0026amp;) = delete; Position\u0026amp; operator=(const Position\u0026amp;) = delete; // FEN string input/output Position\u0026amp; set(const std::string\u0026amp; fenStr, bool isChess960, StateInfo* si, Thread* th); const std::string fen() const; // Position representation Bitboard pieces() const; Bitboard pieces(PieceType pt) const; Bitboard pieces(PieceType pt1, PieceType pt2) const; Bitboard pieces(Color c) const; Bitboard pieces(Color c, PieceType pt) const; Bitboard pieces(Color c, PieceType pt1, PieceType pt2) const; Piece piece_on(Square s) const; Square ep_square() const; bool empty(Square s) const; template\u0026lt;PieceType Pt\u0026gt; int count(Color c) const; template\u0026lt;PieceType Pt\u0026gt; const Square* squares(Color c) const; template\u0026lt;PieceType Pt\u0026gt; Square square(Color c) const; // Castling int can_castle(Color c) const; int can_castle(CastlingRight cr) const; bool castling_impeded(CastlingRight cr) const; Square castling_rook_square(CastlingRight cr) const; // Checking Bitboard checkers() const; Bitboard discovered_check_candidates() const; Bitboard pinned_pieces(Color c) const; Bitboard check_squares(PieceType pt) const; // Attacks to/from a given square Bitboard attackers_to(Square s) const; Bitboard attackers_to(Square s, Bitboard occupied) const; Bitboard attacks_from(Piece pc, Square s) const; template\u0026lt;PieceType\u0026gt; Bitboard attacks_from(Square s) const; template\u0026lt;PieceType\u0026gt; Bitboard attacks_from(Square s, Color c) const; Bitboard slider_blockers(Bitboard sliders, Square s, Bitboard\u0026amp; pinners) const; // Properties of moves bool legal(Move m) const; bool pseudo_legal(const Move m) const; bool capture(Move m) const; bool capture_or_promotion(Move m) const; bool gives_check(Move m) const; bool advanced_pawn_push(Move m) const; Piece moved_piece(Move m) const; Piece captured_piece() const; // Piece specific bool pawn_passed(Color c, Square s) const; bool opposite_bishops() const; // Doing and undoing moves void do_move(Move m, StateInfo\u0026amp; st, bool givesCheck); void undo_move(Move m); void do_null_move(StateInfo\u0026amp; st); void undo_null_move(); // Static Exchange Evaluation bool see_ge(Move m, Value value) const; // Accessing hash keys Key key() const; Key key_after(Move m) const; Key material_key() const; Key pawn_key() const; // Other properties of the position Color side_to_move() const; Phase game_phase() const; int game_ply() const; bool is_chess960() const; Thread* this_thread() const; uint64_t nodes_searched() const; bool is_draw() const; int rule50_count() const; Score psq_score() const; Value non_pawn_material(Color c) const; // Position consistency check, for debugging bool pos_is_ok(int* failedStep = nullptr) const; void flip(); private: // Initialization helpers (used while setting up a position) void set_castling_right(Color c, Square rfrom); void set_state(StateInfo* si) const; void set_check_info(StateInfo* si) const; // Other helpers void put_piece(Piece pc, Square s); void remove_piece(Piece pc, Square s); void move_piece(Piece pc, Square from, Square to); template\u0026lt;bool Do\u0026gt; void do_castling(Color us, Square from, Square\u0026amp; to, Square\u0026amp; rfrom, Square\u0026amp; rto); // Data members Piece board[SQUARE_NB]; Bitboard byTypeBB[PIECE_TYPE_NB]; Bitboard byColorBB[COLOR_NB]; int pieceCount[PIECE_NB]; Square pieceList[PIECE_NB][16]; int index[SQUARE_NB]; int castlingRightsMask[SQUARE_NB]; Square castlingRookSquare[CASTLING_RIGHT_NB]; Bitboard castlingPath[CASTLING_RIGHT_NB]; uint64_t nodes; int gamePly; Color sideToMove; Thread* thisThread; StateInfo* st; bool chess960; }; Class Design Decisions 1. Non-Copyable Position(const Position\u0026amp;) = delete; Position\u0026amp; operator=(const Position\u0026amp;) = delete; Cannot be copied (copy constructor and assignment deleted) Why? Positions are heavy objects with complex state Must be moved or passed by reference/pointer Prevents accidental expensive copies 2. Default Constructor Position() = default; Creates uninitialized position Must call set() to initialize with FEN string Core Data Members 1. Board Representation - MailBox Piece board[SQUARE_NB]; // SQUARE_NB = 64 Mailbox representation: Direct lookup \u0026ldquo;what piece is on square X?\u0026rdquo; board[e4] → returns W_KNIGHT or NO_PIECE Fast for: \u0026ldquo;piece_on(Square s)\u0026rdquo; 2. Bitboard Representation Technically we need 12 bitboards to represent the all the pieces on chessboard.\n","keywords":["board representation","Position","StateInfo"],"articleBody":"Representation of The Game State The Position Class The Position class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.\nclass Position { public: static void init(); Position() = default; Position(const Position\u0026) = delete; Position\u0026 operator=(const Position\u0026) = delete; // FEN string input/output Position\u0026 set(const std::string\u0026 fenStr, bool isChess960, StateInfo* si, Thread* th); const std::string fen() const; // Position representation Bitboard pieces() const; Bitboard pieces(PieceType pt) const; Bitboard pieces(PieceType pt1, PieceType pt2) const; Bitboard pieces(Color c) const; Bitboard pieces(Color c, PieceType pt) const; Bitboard pieces(Color c, PieceType pt1, PieceType pt2) const; Piece piece_on(Square s) const; Square ep_square() const; bool empty(Square s) const; template\u003cPieceType Pt\u003e int count(Color c) const; template\u003cPieceType Pt\u003e const Square* squares(Color c) const; template\u003cPieceType Pt\u003e Square square(Color c) const; // Castling int can_castle(Color c) const; int can_castle(CastlingRight cr) const; bool castling_impeded(CastlingRight cr) const; Square castling_rook_square(CastlingRight cr) const; // Checking Bitboard checkers() const; Bitboard discovered_check_candidates() const; Bitboard pinned_pieces(Color c) const; Bitboard check_squares(PieceType pt) const; // Attacks to/from a given square Bitboard attackers_to(Square s) const; Bitboard attackers_to(Square s, Bitboard occupied) const; Bitboard attacks_from(Piece pc, Square s) const; template\u003cPieceType\u003e Bitboard attacks_from(Square s) const; template\u003cPieceType\u003e Bitboard attacks_from(Square s, Color c) const; Bitboard slider_blockers(Bitboard sliders, Square s, Bitboard\u0026 pinners) const; // Properties of moves bool legal(Move m) const; bool pseudo_legal(const Move m) const; bool capture(Move m) const; bool capture_or_promotion(Move m) const; bool gives_check(Move m) const; bool advanced_pawn_push(Move m) const; Piece moved_piece(Move m) const; Piece captured_piece() const; // Piece specific bool pawn_passed(Color c, Square s) const; bool opposite_bishops() const; // Doing and undoing moves void do_move(Move m, StateInfo\u0026 st, bool givesCheck); void undo_move(Move m); void do_null_move(StateInfo\u0026 st); void undo_null_move(); // Static Exchange Evaluation bool see_ge(Move m, Value value) const; // Accessing hash keys Key key() const; Key key_after(Move m) const; Key material_key() const; Key pawn_key() const; // Other properties of the position Color side_to_move() const; Phase game_phase() const; int game_ply() const; bool is_chess960() const; Thread* this_thread() const; uint64_t nodes_searched() const; bool is_draw() const; int rule50_count() const; Score psq_score() const; Value non_pawn_material(Color c) const; // Position consistency check, for debugging bool pos_is_ok(int* failedStep = nullptr) const; void flip(); private: // Initialization helpers (used while setting up a position) void set_castling_right(Color c, Square rfrom); void set_state(StateInfo* si) const; void set_check_info(StateInfo* si) const; // Other helpers void put_piece(Piece pc, Square s); void remove_piece(Piece pc, Square s); void move_piece(Piece pc, Square from, Square to); template\u003cbool Do\u003e void do_castling(Color us, Square from, Square\u0026 to, Square\u0026 rfrom, Square\u0026 rto); // Data members Piece board[SQUARE_NB]; Bitboard byTypeBB[PIECE_TYPE_NB]; Bitboard byColorBB[COLOR_NB]; int pieceCount[PIECE_NB]; Square pieceList[PIECE_NB][16]; int index[SQUARE_NB]; int castlingRightsMask[SQUARE_NB]; Square castlingRookSquare[CASTLING_RIGHT_NB]; Bitboard castlingPath[CASTLING_RIGHT_NB]; uint64_t nodes; int gamePly; Color sideToMove; Thread* thisThread; StateInfo* st; bool chess960; }; Class Design Decisions 1. Non-Copyable Position(const Position\u0026) = delete; Position\u0026 operator=(const Position\u0026) = delete; Cannot be copied (copy constructor and assignment deleted) Why? Positions are heavy objects with complex state Must be moved or passed by reference/pointer Prevents accidental expensive copies 2. Default Constructor Position() = default; Creates uninitialized position Must call set() to initialize with FEN string Core Data Members 1. Board Representation - MailBox Piece board[SQUARE_NB]; // SQUARE_NB = 64 Mailbox representation: Direct lookup “what piece is on square X?” board[e4] → returns W_KNIGHT or NO_PIECE Fast for: “piece_on(Square s)” 2. Bitboard Representation Technically we need 12 bitboards to represent the all the pieces on chessboard.\nwhite pawns white knights white bishops white rooks white queens white king black pawns black knights black bishops black rooks black queens black king Stockfish’s representation (factorized)\n1. byTypeBB Bitboard byTypeBB[PIECE_TYPE_NB]; // PIECE_TYPE_NB = 8 byTypeBB is an array of 8 bitboards. This stores piece-type bitboards regardless of color:\nenum PieceType { NO_PIECE_TYPE, // = 0 PAWN, // = 1 KNIGHT, // = 2 BISHOP, // = 3 ROOK, // = 4 QUEEN, // = 5 KING, // = 6 ALL_PIECES = 0, // = 0 (EXPLICIT assignment, alias for NO_PIECE_TYPE) PIECE_TYPE_NB = 8 // = 8 (total count for array sizing) }; Index mapping\nbyTypeBB[0] = byTypeBB[NO_PIECE_TYPE] = byTypeBB[ALL_PIECES] = all pieces (both colors) byTypeBB[1] = byTypeBB[PAWN] = all pawns byTypeBB[2] = byTypeBB[KNIGHT] = all knights byTypeBB[3] = byTypeBB[BISHOP] = all bishops byTypeBB[4] = byTypeBB[ROOK] = all rooks byTypeBB[5] = byTypeBB[QUEEN] = all queens byTypeBB[6] = byTypeBB[KING] = all kings byTypeBB[7] = ??? // (UNUSED, for padding) 2. byColorBB Bitboard byColorBB[COLOR_NB]; // COLOR_NB = 2 Bitboards by color: All pieces of a color byColorBB[WHITE] → all white pieces byColorBB[BLACK] → all black pieces Fast for: “where are all black pieces?” 3. castlingPath Bitboard castlingPath[CASTLING_RIGHT_NB]; // CASTLING_RIGHT_NB = 16 THis seems like the biggest bitboard array with eleemnts 16 × 8 bytes = 128 bytes.\nLet’s understand why its like this\nenum CastlingRight { NO_CASTLING, WHITE_OO, WHITE_OOO = WHITE_OO \u003c\u003c 1, BLACK_OO = WHITE_OO \u003c\u003c 2, BLACK_OOO = WHITE_OO \u003c\u003c 3, ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO, CASTLING_RIGHT_NB = 16 }; So the values range from:\n0000 (0) → no castling 0001 (1) → white O-O 0010 (2) → white O-O-O ... 1111 (15) → all castling rights 16 possible states, hence CASTLING_RIGHT_NB = 16\nWhat castlingPath Actually Stores?\ncastlingPath stores the squares that must be empty for each individual castling move, not for each combination of rights. It has 16 bitboards but only 4 of them are used.\ncastlingPath[NO_CASTLING] // Index 0 - unused castlingPath[WHITE_OO] // Index 1 - squares between white king and h1 rook castlingPath[WHITE_OOO] // Index 2 - squares between white king and a1 rook castlingPath[BLACK_OO] // Index 4 - squares between black king and h8 rook castlingPath[BLACK_OOO] // Index 8 - squares between black king and a8 rook Why? Because they’re bit flags designed to be combined with bitwise OR:\nint rights = WHITE_OO | BLACK_OOO; // = 1 | 8 = 9 (0b1001) We can see most of the squares of bitboards will be empty. This is a deliberate design choice, so that we can quickly compute operations like this:\nbool Position::castling_impeded(CastlingRight cr) const { return byTypeBB[ALL_PIECES] \u0026 castlingPath[cr]; } If any overlap exists, the AND is non-zero → castling blocked.\nThis is:\n1 CPU instruction (AND) 1 branchless boolean check 3. PieceCount int pieceCount[PIECE_NB]; // PIECE_NB = 16 Count of each piece type per color pieceCount[W_KNIGHT] → number of white knights (0-10) Fast for: “how many white rooks exist?” Square pieceList[PIECE_NB][16]; List of squares for each piece type pieceList[W_KNIGHT] = {SQ_B1, SQ_G1, SQ_NONE, ...} Max 16 of any piece (all pawns could promote) Fast for: iterating over pieces (no need to scan entire board) Terminated by SQ_NONE 4. Index int index[SQUARE_NB]; Reverse lookup: Which index in pieceList? index[b1] → 0 (first white knight in pieceList) Used when moving/removing pieces to update pieceList efficiently For each square on the board, index[s] stores:\nThe index of the piece on square s inside that piece’s pieceList[] array (index[square] → position inside pieceList[piece][…])\nWhy this exists\nStockfish maintains two parallel representations of pieces: 1.\tBitboards → fast attacks \u0026 occupancy 2.\tPiece lists → fast iteration over pieces of a given type\nTo make removals and moves O(1), Stockfish needs a way to jump directly to the piece’s position inside the list.\n5. castlingRightsMask int castlingRightsMask[SQUARE_NB]; For each square, tells you which castling rights are lost if a piece moves from or to that square.\nThis allows Stockfish to update castling rights in O(1) with no conditionals.\nWhy this exists\nCastling rights are affected when:\nThe king moves The rook moves The rook is captured castlingRightsMask[sq] = which castling rights are invalidated if a move touches this square Square Mask E1 WHITE_OO A1 WHITE_OOO H1 WHITE_OO E8 BLACK_OO A8 BLACK_OOO H8 BLACK_OO All others 0 Why Multiple Representations? Redundancy for speed! Different operations need different views:\nOperation Best Representation “What piece is on e4?” board[e4] (O(1)) “Where are all white pieces?” byColorBB[WHITE] (O(1)) “Are there any black rooks on the 7th rank?” byTypeBB[ROOK] \u0026 byColorBB[BLACK] \u0026 Rank7BB “Loop through all white knights” pieceList[W_KNIGHT] (no empty squares) Game State Members 1. sideToMove Color sideToMove; Whose turn: WHITE or BLACK 2. gamePly int gamePly; Full move counter (increments every move, not just every full turn) Move 1 White = ply 0, Move 1 Black = ply 1, Move 2 White = ply 2… 3. StateInfo StateInfo* st; Pointer to current state (zobrist key, castling rights, en passant, etc.) Points to external StateInfo object Why pointer? State is stored in a stack during search (for undo) Position stores the current board. StateInfo stores the history-dependent metadata needed to undo moves efficiently.\nEvery time Stockfish makes a move during search, it:\nMutates the Position Pushes a new StateInfo onto a stack On undo, it restores the previous StateInfo pointer This gives O(1) undo with no recomputation.\nWhy StateInfo st is a pointer*\nStateInfo* st; Because StateInfo objects live in a stack, not inside Position.\nStateInfo states[MAX_PLY]; Position.st ──► states[current_ply] On do_move():\nnew StateInfo is written into states[ply+1] Position.st is updated to point to it On undo_move():\nPosition.st simply points back to the previous one 4. thisThread Thread* thisThread; Identifies which search thread owns and is allowed to modify this Position.\nStockfish uses shared-memory parallel search (Lazy SMP).\nThat means:\nMultiple threads run searches in parallel Threads share global structures (TT, history, eval cache) But each thread must have its own Position and state stack Conceptually:\nThread ├─ Position pos ├─ StateInfo states[MAX_PLY] ├─ SearchStack ss[MAX_PLY] └─ counters / limits Each thread searches independently, occasionally syncing via shared tables.\nThe StateInfo StateInfo stores all non-deducible state of a chess position - information that cannot be reconstructed just by looking at the board. It’s designed for efficient move make/unmake during search.\nKey insight: During search, positions are pushed/popped millions of times. Instead of copying the entire Position, Stockfish uses a linked list of StateInfo objects:\n// Search pseudocode: void search(Position\u0026 pos, int depth) { StateInfo st; // Create on stack for (Move m : generate_moves(pos)) { pos.do_move(m, st); // st.previous = old state search(pos, depth - 1); // Recurse pos.undo_move(m); // Restore from st.previous } } Memory layout during search:\nStack frame 1: StateInfo st1 ←─┐ │ Stack frame 2: StateInfo st2 ←─┼─ st2.previous │ Stack frame 3: StateInfo st3 ←─┼─ st3.previous ↑ │ └─────────────────┘ Each StateInfo points to the previous state, forming a chain that can be unwound during undo_move().\nTwo Categories of Data struct StateInfo { // Copied when making a move Key pawnKey; Key materialKey; Value nonPawnMaterial[COLOR_NB]; int castlingRights; int rule50; int pliesFromNull; Score psq; Square epSquare; // Not copied when making a move (will be recomputed anyhow) Key key; Bitboard checkersBB; Piece capturedPiece; StateInfo* previous; Bitboard blockersForKing[COLOR_NB]; Bitboard pinnersForKing[COLOR_NB]; Bitboard checkSquares[PIECE_TYPE_NB]; }; Category 1: Copied When Making a Move These values are incrementally updated (not recomputed from scratch)\nKey pawnKey; Key materialKey; Value nonPawnMaterial[COLOR_NB]; int castlingRights; int rule50; int pliesFromNull; Score psq; Square epSquare; Why copied? These can be updated incrementally faster than recomputing:\nHash keys: XOR in changes Scores: add/subtract deltas Counters: increment/decrement Category 2: Recomputed Every Move These are always calculated fresh (not worth copying)\n// Not copied when making a move (will be recomputed anyhow) Key key; Bitboard checkersBB; Piece capturedPiece; StateInfo* previous; Bitboard blockersForKing[COLOR_NB]; Bitboard pinnersForKing[COLOR_NB]; Bitboard checkSquares[PIECE_TYPE_NB]; Why not copied? Cheaper to recalculate than to copy and update.\nnonPawnMaterial Value nonPawnMaterial[COLOR_NB] Total material value excluding pawns for each color nonPawnMaterial[WHITE] = value of white knights, bishops, rooks, queens nonPawnMaterial[BLACK] = same for black Why exclude pawns?\nUsed for endgame detection “Low material” = fewer pieces (pawns don’t count toward complexity) // After capturing black knight: nonPawnMaterial[BLACK] -= KnightValue; // Incremental update // Usage: if (nonPawnMaterial[WHITE] + nonPawnMaterial[BLACK] \u003c EndgameThreshold) { // Enter endgame evaluation mode } castlingRights int castlingRights Bitfield of available castling rights Combination of: WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO castlingRights is also part of Zobrist hash key. But it can’t be read from the hash.\nrule50 int rule50 Halfmove clock for the 50-move rule Incremented every move, reset on pawn move or capture pliesFromNull int pliesFromNull How many plies since last null move in search Used to prevent consecutive null moves A null move is a fake move where: The side to move skips its turn, and the opponent moves again.\nNo piece is moved. The position stays the same except:\nside to move flips some counters update (ply, hash, etc.) en passant is cleared In chess notation: it’s like saying\n“What if I do nothing?”\nObviously illegal in real chess, but very useful in search.\nWhy would an engine do this?\nIdea behind Null Move Pruning:\nIf you can skip your move and still not get into trouble,then any real move is at least as good.\nSo:\nIf even after giving the opponent an extra move, the position is still ≥ β → prune this branch (fail-high).\nThis is called Null Move Pruning (NMP).\npliesFromNull counts how many plies have passed since the last null move. Because two null moves in a row is dangerous\nIf you allow:\nNull move Then another null move You can get:\nzugzwang bugs illegal pruning missed mates evaluation nonsense pinnersForKing Bitboard pinnersForKing[COLOR_NB] Enemy sliding pieces pinning our pieces The “other side” of blockersForKing ","wordCount":"2191","inLanguage":"en","datePublished":"2026-01-07T00:00:00Z","dateModified":"2026-01-07T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-07-board-representation/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Representation of The Game State</h1><div class=post-meta><span title='2026-01-07 00:00:00 +0000 UTC'>January 7, 2026</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-07-board-representation.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#representation-of-the-game-state aria-label="Representation of The Game State">Representation of The Game State</a><ul><li><a href=#the-position-class aria-label="The Position Class">The Position Class</a><ul><li><a href=#class-design-decisions aria-label="Class Design Decisions">Class Design Decisions</a><ul><li><a href=#1-non-copyable aria-label="1. Non-Copyable">1. Non-Copyable</a></li><li><a href=#2-default-constructor aria-label="2. Default Constructor">2. Default Constructor</a></li></ul></li><li><a href=#core-data-members aria-label="Core Data Members">Core Data Members</a><ul><li><a href=#1-board-representation---mailbox aria-label="1. Board Representation - MailBox">1. Board Representation - MailBox</a></li><li><a href=#2-bitboard-representation aria-label="2. Bitboard Representation">2. Bitboard Representation</a><ul><li><a href=#1-bytypebb aria-label="1. byTypeBB">1. byTypeBB</a></li><li><a href=#2-bycolorbb aria-label="2. byColorBB">2. byColorBB</a></li><li><a href=#3-castlingpath aria-label="3. castlingPath">3. castlingPath</a></li></ul></li><li><a href=#3-piececount aria-label="3. PieceCount">3. PieceCount</a></li><li><a href=#4-index aria-label="4. Index">4. Index</a></li><li><a href=#5-castlingrightsmask aria-label="5. castlingRightsMask">5. castlingRightsMask</a></li><li><a href=#why-multiple-representations aria-label="Why Multiple Representations?">Why Multiple Representations?</a></li></ul></li><li><a href=#game-state-members aria-label="Game State Members">Game State Members</a><ul><li><a href=#1-sidetomove aria-label="1. sideToMove">1. sideToMove</a></li><li><a href=#2-gameply aria-label="2. gamePly">2. gamePly</a></li><li><a href=#3-stateinfo aria-label="3. StateInfo">3. StateInfo</a></li><li><a href=#4-thisthread aria-label="4. thisThread">4. thisThread</a></li></ul></li></ul></li><li><a href=#the-stateinfo aria-label="The StateInfo">The StateInfo</a><ul><li><a href=#two-categories-of-data aria-label="Two Categories of Data">Two Categories of Data</a><ul><li><a href=#category-1-copied-when-making-a-move aria-label="Category 1: Copied When Making a Move">Category 1: Copied When Making a Move</a></li><li><a href=#category-2-recomputed-every-move aria-label="Category 2: Recomputed Every Move">Category 2: Recomputed Every Move</a></li></ul></li><li><a href=#nonpawnmaterial aria-label=nonPawnMaterial>nonPawnMaterial</a></li><li><a href=#castlingrights aria-label=castlingRights>castlingRights</a></li><li><a href=#rule50 aria-label=rule50>rule50</a></li><li><a href=#pliesfromnull aria-label=pliesFromNull>pliesFromNull</a></li><li><a href=#pinnersforking aria-label=pinnersForKing>pinnersForKing</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=representation-of-the-game-state>Representation of The Game State<a hidden class=anchor aria-hidden=true href=#representation-of-the-game-state>#</a></h1><h2 id=the-position-class>The Position Class<a hidden class=anchor aria-hidden=true href=#the-position-class>#</a></h2><p>The <code>Position</code> class is the core data structure in Stockfish that represents the complete state of a chess game at any given moment. It stores the board, pieces, game state, and provides methods to query and manipulate the position.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Position</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> init();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Position() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>  Position(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>  Position<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// FEN string input/output
</span></span></span><span style=display:flex><span>  Position<span style=color:#f92672>&amp;</span> set(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> fenStr, <span style=color:#66d9ef>bool</span> isChess960, StateInfo<span style=color:#f92672>*</span> si, Thread<span style=color:#f92672>*</span> th);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string fen() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Position representation
</span></span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pieces</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pieces</span>(PieceType pt) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pieces</span>(PieceType pt1, PieceType pt2) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pieces</span>(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pieces</span>(Color c, PieceType pt) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pieces</span>(Color c, PieceType pt1, PieceType pt2) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Piece <span style=color:#a6e22e>piece_on</span>(Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Square <span style=color:#a6e22e>ep_square</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>empty</span>(Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>int</span> count(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span> Square<span style=color:#f92672>*</span> squares(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span> Square square(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Castling
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>can_castle</span>(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>can_castle</span>(CastlingRight cr) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>castling_impeded</span>(CastlingRight cr) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Square <span style=color:#a6e22e>castling_rook_square</span>(CastlingRight cr) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Checking
</span></span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>checkers</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>discovered_check_candidates</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>pinned_pieces</span>(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>check_squares</span>(PieceType pt) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Attacks to/from a given square
</span></span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>attackers_to</span>(Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>attackers_to</span>(Square s, Bitboard occupied) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>attacks_from</span>(Piece pc, Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType<span style=color:#f92672>&gt;</span> Bitboard attacks_from(Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType<span style=color:#f92672>&gt;</span> Bitboard attacks_from(Square s, Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Bitboard <span style=color:#a6e22e>slider_blockers</span>(Bitboard sliders, Square s, Bitboard<span style=color:#f92672>&amp;</span> pinners) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Properties of moves
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>legal</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>pseudo_legal</span>(<span style=color:#66d9ef>const</span> Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>capture</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>capture_or_promotion</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>gives_check</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>advanced_pawn_push</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Piece <span style=color:#a6e22e>moved_piece</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Piece <span style=color:#a6e22e>captured_piece</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Piece specific
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>pawn_passed</span>(Color c, Square s) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>opposite_bishops</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Doing and undoing moves
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_move</span>(Move m, StateInfo<span style=color:#f92672>&amp;</span> st, <span style=color:#66d9ef>bool</span> givesCheck);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>undo_move</span>(Move m);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>do_null_move</span>(StateInfo<span style=color:#f92672>&amp;</span> st);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>undo_null_move</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Static Exchange Evaluation
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>see_ge</span>(Move m, Value value) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Accessing hash keys
</span></span></span><span style=display:flex><span>  Key <span style=color:#a6e22e>key</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Key <span style=color:#a6e22e>key_after</span>(Move m) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Key <span style=color:#a6e22e>material_key</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Key <span style=color:#a6e22e>pawn_key</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Other properties of the position
</span></span></span><span style=display:flex><span>  Color <span style=color:#a6e22e>side_to_move</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Phase <span style=color:#a6e22e>game_phase</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>game_ply</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is_chess960</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Thread<span style=color:#f92672>*</span> <span style=color:#a6e22e>this_thread</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> <span style=color:#a6e22e>nodes_searched</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is_draw</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>rule50_count</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Score <span style=color:#a6e22e>psq_score</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  Value <span style=color:#a6e22e>non_pawn_material</span>(Color c) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Position consistency check, for debugging
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>pos_is_ok</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> failedStep <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>flip</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Initialization helpers (used while setting up a position)
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> set_castling_right(Color c, Square rfrom);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_state</span>(StateInfo<span style=color:#f92672>*</span> si) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_check_info</span>(StateInfo<span style=color:#f92672>*</span> si) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Other helpers
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>put_piece</span>(Piece pc, Square s);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove_piece</span>(Piece pc, Square s);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>move_piece</span>(Piece pc, Square from, Square to);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span> Do<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> do_castling(Color us, Square from, Square<span style=color:#f92672>&amp;</span> to, Square<span style=color:#f92672>&amp;</span> rfrom, Square<span style=color:#f92672>&amp;</span> rto);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Data members
</span></span></span><span style=display:flex><span>  Piece board[SQUARE_NB];
</span></span><span style=display:flex><span>  Bitboard byTypeBB[PIECE_TYPE_NB];
</span></span><span style=display:flex><span>  Bitboard byColorBB[COLOR_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> pieceCount[PIECE_NB];
</span></span><span style=display:flex><span>  Square pieceList[PIECE_NB][<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> index[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> castlingRightsMask[SQUARE_NB];
</span></span><span style=display:flex><span>  Square castlingRookSquare[CASTLING_RIGHT_NB];
</span></span><span style=display:flex><span>  Bitboard castlingPath[CASTLING_RIGHT_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> nodes;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> gamePly;
</span></span><span style=display:flex><span>  Color sideToMove;
</span></span><span style=display:flex><span>  Thread<span style=color:#f92672>*</span> thisThread;
</span></span><span style=display:flex><span>  StateInfo<span style=color:#f92672>*</span> st;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> chess960;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=class-design-decisions>Class Design Decisions<a hidden class=anchor aria-hidden=true href=#class-design-decisions>#</a></h3><h4 id=1-non-copyable>1. Non-Copyable<a hidden class=anchor aria-hidden=true href=#1-non-copyable>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Position(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span><span style=display:flex><span>Position<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span></code></pre></div><ul><li>Cannot be copied (copy constructor and assignment deleted)</li><li>Why? Positions are heavy objects with complex state</li><li>Must be moved or passed by reference/pointer</li><li>Prevents accidental expensive copies</li></ul><h4 id=2-default-constructor>2. Default Constructor<a hidden class=anchor aria-hidden=true href=#2-default-constructor>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Position() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span></code></pre></div><ul><li>Creates uninitialized position</li><li>Must call <code>set()</code> to initialize with FEN string</li></ul><h3 id=core-data-members>Core Data Members<a hidden class=anchor aria-hidden=true href=#core-data-members>#</a></h3><h4 id=1-board-representation---mailbox>1. Board Representation - MailBox<a hidden class=anchor aria-hidden=true href=#1-board-representation---mailbox>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Piece board[SQUARE_NB];  <span style=color:#75715e>// SQUARE_NB = 64
</span></span></span></code></pre></div><ul><li>Mailbox representation: Direct lookup &ldquo;what piece is on square X?&rdquo;</li><li><code>board[e4]</code> → returns <code>W_KNIGHT</code> or <code>NO_PIECE</code></li><li>Fast for: &ldquo;piece_on(Square s)&rdquo;</li></ul><h4 id=2-bitboard-representation>2. Bitboard Representation<a hidden class=anchor aria-hidden=true href=#2-bitboard-representation>#</a></h4><p>Technically we need 12 bitboards to represent the all the pieces on chessboard.</p><pre tabindex=0><code>white pawns
white knights
white bishops
white rooks
white queens
white king

black pawns
black knights
black bishops
black rooks
black queens
black king
</code></pre><p><strong>Stockfish’s representation (factorized)</strong></p><h5 id=1-bytypebb>1. byTypeBB<a hidden class=anchor aria-hidden=true href=#1-bytypebb>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard byTypeBB[PIECE_TYPE_NB];  <span style=color:#75715e>// PIECE_TYPE_NB = 8
</span></span></span></code></pre></div><p><code>byTypeBB</code> is an array of 8 bitboards. This stores piece-type bitboards regardless of color:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>PieceType</span> {
</span></span><span style=display:flex><span>  NO_PIECE_TYPE,  <span style=color:#75715e>// = 0
</span></span></span><span style=display:flex><span>  PAWN,           <span style=color:#75715e>// = 1
</span></span></span><span style=display:flex><span>  KNIGHT,         <span style=color:#75715e>// = 2
</span></span></span><span style=display:flex><span>  BISHOP,         <span style=color:#75715e>// = 3
</span></span></span><span style=display:flex><span>  ROOK,           <span style=color:#75715e>// = 4
</span></span></span><span style=display:flex><span>  QUEEN,          <span style=color:#75715e>// = 5
</span></span></span><span style=display:flex><span>  KING,           <span style=color:#75715e>// = 6
</span></span></span><span style=display:flex><span>  ALL_PIECES <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#75715e>// = 0 (EXPLICIT assignment, alias for NO_PIECE_TYPE)
</span></span></span><span style=display:flex><span>  PIECE_TYPE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>  <span style=color:#75715e>// = 8 (total count for array sizing)
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>Index mapping</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> byTypeBB[NO_PIECE_TYPE] <span style=color:#f92672>=</span> byTypeBB[ALL_PIECES] <span style=color:#f92672>=</span> all pieces (both colors)
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> byTypeBB[PAWN]          <span style=color:#f92672>=</span> all pawns
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> byTypeBB[KNIGHT]        <span style=color:#f92672>=</span> all knights
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> byTypeBB[BISHOP]        <span style=color:#f92672>=</span> all bishops
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> byTypeBB[ROOK]          <span style=color:#f92672>=</span> all rooks
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> byTypeBB[QUEEN]         <span style=color:#f92672>=</span> all queens
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>6</span>] <span style=color:#f92672>=</span> byTypeBB[KING]          <span style=color:#f92672>=</span> all kings
</span></span><span style=display:flex><span>byTypeBB[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>???</span> <span style=color:#75715e>// (UNUSED, for padding)
</span></span></span></code></pre></div><h5 id=2-bycolorbb>2. byColorBB<a hidden class=anchor aria-hidden=true href=#2-bycolorbb>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard byColorBB[COLOR_NB];  <span style=color:#75715e>// COLOR_NB = 2
</span></span></span></code></pre></div><ul><li>Bitboards by color: All pieces of a color</li><li>byColorBB[WHITE] → all white pieces</li><li>byColorBB[BLACK] → all black pieces</li><li>Fast for: &ldquo;where are all black pieces?&rdquo;</li></ul><h5 id=3-castlingpath>3. castlingPath<a hidden class=anchor aria-hidden=true href=#3-castlingpath>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard castlingPath[CASTLING_RIGHT_NB]; <span style=color:#75715e>// CASTLING_RIGHT_NB = 16
</span></span></span></code></pre></div><p>THis seems like the biggest bitboard array with eleemnts <code>16 × 8 bytes = 128 bytes</code>.</p><p>Let&rsquo;s understand why its like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CastlingRight</span> {
</span></span><span style=display:flex><span>  NO_CASTLING,
</span></span><span style=display:flex><span>  WHITE_OO,
</span></span><span style=display:flex><span>  WHITE_OOO <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  BLACK_OO  <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  BLACK_OOO <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  ANY_CASTLING <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>|</span> WHITE_OOO <span style=color:#f92672>|</span> BLACK_OO <span style=color:#f92672>|</span> BLACK_OOO,
</span></span><span style=display:flex><span>  CASTLING_RIGHT_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>So the values range from:</p><pre tabindex=0><code>0000 (0)  → no castling
0001 (1)  → white O-O
0010 (2)  → white O-O-O
...
1111 (15) → all castling rights
</code></pre><p>16 possible states, hence <code>CASTLING_RIGHT_NB</code> = 16</p><p><strong>What castlingPath Actually Stores?</strong></p><p><code>castlingPath</code> stores the squares that must be empty for each individual castling move, not for each combination of rights. It has 16 bitboards but only 4 of them are used.</p><pre tabindex=0><code>castlingPath[NO_CASTLING]  // Index 0 - unused
castlingPath[WHITE_OO]     // Index 1 - squares between white king and h1 rook
castlingPath[WHITE_OOO]    // Index 2 - squares between white king and a1 rook  
castlingPath[BLACK_OO]     // Index 4 - squares between black king and h8 rook
castlingPath[BLACK_OOO]    // Index 8 - squares between black king and a8 rook
</code></pre><p>Why? Because they&rsquo;re bit flags designed to be combined with bitwise OR:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> rights <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>|</span> BLACK_OOO;  <span style=color:#75715e>// = 1 | 8 = 9 (0b1001)
</span></span></span></code></pre></div><p>We can see most of the squares of bitboards will be empty. This is a deliberate design choice, so that we can quickly compute operations like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> Position<span style=color:#f92672>::</span>castling_impeded(CastlingRight cr) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> byTypeBB[ALL_PIECES] <span style=color:#f92672>&amp;</span> castlingPath[cr];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If any overlap exists, the AND is non-zero → castling blocked.</p><p>This is:</p><ul><li>1 CPU instruction (AND)</li><li>1 branchless boolean check</li></ul><h4 id=3-piececount>3. PieceCount<a hidden class=anchor aria-hidden=true href=#3-piececount>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> pieceCount[PIECE_NB];  <span style=color:#75715e>// PIECE_NB = 16
</span></span></span></code></pre></div><ul><li>Count of each piece type per color</li><li><code>pieceCount[W_KNIGHT]</code> → number of white knights (0-10)</li><li>Fast for: &ldquo;how many white rooks exist?&rdquo;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Square pieceList[PIECE_NB][<span style=color:#ae81ff>16</span>];
</span></span></code></pre></div><ul><li>List of squares for each piece type</li><li><code>pieceList[W_KNIGHT] = {SQ_B1, SQ_G1, SQ_NONE, ...}</code></li><li>Max 16 of any piece (all pawns could promote)</li><li>Fast for: iterating over pieces (no need to scan entire board)</li><li>Terminated by <code>SQ_NONE</code></li></ul><h4 id=4-index>4. Index<a hidden class=anchor aria-hidden=true href=#4-index>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> index[SQUARE_NB];
</span></span></code></pre></div><ul><li>Reverse lookup: Which index in pieceList?</li><li><code>index[b1]</code> → 0 (first white knight in pieceList)</li><li>Used when moving/removing pieces to update pieceList efficiently</li></ul><p>For each square on the board, index[s] stores:</p><p>The index of the piece on square s inside that piece’s <code>pieceList[]</code> array (<code>index[square]</code> → position inside <code>pieceList[piece][…]</code>)</p><p><strong>Why this exists</strong></p><p>Stockfish maintains two parallel representations of pieces:
1. Bitboards → fast attacks & occupancy
2. Piece lists → fast iteration over pieces of a given type</p><p>To make removals and moves O(1), Stockfish needs a way to jump directly to the piece’s position inside the list.</p><h4 id=5-castlingrightsmask>5. castlingRightsMask<a hidden class=anchor aria-hidden=true href=#5-castlingrightsmask>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> castlingRightsMask[SQUARE_NB];
</span></span></code></pre></div><p>For each square, tells you which castling rights are lost if a piece moves from or to that square.</p><p>This allows Stockfish to update castling rights in O(1) with no conditionals.</p><p><strong>Why this exists</strong></p><p>Castling rights are affected when:</p><ul><li>The king moves</li><li>The rook moves</li><li>The rook is captured</li></ul><pre tabindex=0><code>castlingRightsMask[sq] =
    which castling rights are invalidated
    if a move touches this square
</code></pre><table><thead><tr><th>Square</th><th>Mask</th></tr></thead><tbody><tr><td>E1</td><td>WHITE_OO</td></tr><tr><td>A1</td><td>WHITE_OOO</td></tr><tr><td>H1</td><td>WHITE_OO</td></tr><tr><td>E8</td><td>BLACK_OO</td></tr><tr><td>A8</td><td>BLACK_OOO</td></tr><tr><td>H8</td><td>BLACK_OO</td></tr><tr><td>All others</td><td>0</td></tr></tbody></table><h4 id=why-multiple-representations>Why Multiple Representations?<a hidden class=anchor aria-hidden=true href=#why-multiple-representations>#</a></h4><p>Redundancy for speed! Different operations need different views:</p><table><thead><tr><th>Operation</th><th>Best Representation</th></tr></thead><tbody><tr><td>&ldquo;What piece is on e4?&rdquo;</td><td><code>board[e4]</code> (O(1))</td></tr><tr><td>&ldquo;Where are all white pieces?&rdquo;</td><td><code>byColorBB[WHITE]</code> (O(1))</td></tr><tr><td>&ldquo;Are there any black rooks on the 7th rank?&rdquo;</td><td><code>byTypeBB[ROOK] & byColorBB[BLACK] & Rank7BB</code></td></tr><tr><td>&ldquo;Loop through all white knights&rdquo;</td><td><code>pieceList[W_KNIGHT]</code> (no empty squares)</td></tr></tbody></table><h3 id=game-state-members>Game State Members<a hidden class=anchor aria-hidden=true href=#game-state-members>#</a></h3><h4 id=1-sidetomove>1. sideToMove<a hidden class=anchor aria-hidden=true href=#1-sidetomove>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Color sideToMove;
</span></span></code></pre></div><ul><li>Whose turn: <code>WHITE</code> or <code>BLACK</code></li></ul><h4 id=2-gameply>2. gamePly<a hidden class=anchor aria-hidden=true href=#2-gameply>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> gamePly;
</span></span></code></pre></div><ul><li>Full move counter (increments every move, not just every full turn)</li><li>Move 1 White = ply 0, Move 1 Black = ply 1, Move 2 White = ply 2&mldr;</li></ul><h4 id=3-stateinfo>3. StateInfo<a hidden class=anchor aria-hidden=true href=#3-stateinfo>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>StateInfo<span style=color:#f92672>*</span> st;
</span></span></code></pre></div><ul><li>Pointer to current state (zobrist key, castling rights, en passant, etc.)</li><li>Points to external <code>StateInfo</code> object</li><li>Why pointer? State is stored in a stack during search (for undo)</li></ul><p>Position stores the current board. StateInfo stores the history-dependent metadata needed to undo moves efficiently.</p><p>Every time Stockfish makes a move during search, it:</p><ol><li>Mutates the Position</li><li>Pushes a new StateInfo onto a stack</li><li>On undo, it restores the previous StateInfo pointer</li></ol><p>This gives O(1) undo with no recomputation.</p><p><em><em>Why StateInfo</em> st is a pointer</em>*</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>StateInfo<span style=color:#f92672>*</span> st;
</span></span></code></pre></div><p>Because StateInfo objects live in a stack, not inside Position.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>StateInfo states[MAX_PLY];
</span></span><span style=display:flex><span>Position.st <span style=color:#960050;background-color:#1e0010>──►</span> states[current_ply]
</span></span></code></pre></div><p>On do_move():</p><ul><li>new <code>StateInfo</code> is written into <code>states[ply+1]</code></li><li><code>Position.st</code> is updated to point to it</li></ul><p>On undo_move():</p><ul><li><code>Position.st</code> simply points back to the previous one</li></ul><h4 id=4-thisthread>4. thisThread<a hidden class=anchor aria-hidden=true href=#4-thisthread>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Thread<span style=color:#f92672>*</span> thisThread;
</span></span></code></pre></div><p>Identifies which search thread owns and is allowed to modify this Position.</p><p>Stockfish uses shared-memory parallel search (Lazy SMP).</p><p>That means:</p><ul><li>Multiple threads run searches in parallel</li><li>Threads share global structures (TT, history, eval cache)</li><li>But each thread must have its own Position and state stack</li></ul><p>Conceptually:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Thread
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> Position pos
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> StateInfo states[MAX_PLY]
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> SearchStack ss[MAX_PLY]
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>└─</span> counters <span style=color:#f92672>/</span> limits
</span></span></code></pre></div><p>Each thread searches independently, occasionally syncing via shared tables.</p><h2 id=the-stateinfo>The StateInfo<a hidden class=anchor aria-hidden=true href=#the-stateinfo>#</a></h2><p><code>StateInfo</code> stores all non-deducible state of a chess position - information that cannot be reconstructed just by looking at the board. It&rsquo;s designed for efficient move make/unmake during search.</p><p>Key insight: During search, positions are pushed/popped millions of times. Instead of copying the entire <code>Position</code>, Stockfish uses a linked list of <code>StateInfo</code> objects:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Search pseudocode:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>search</span>(Position<span style=color:#f92672>&amp;</span> pos, <span style=color:#66d9ef>int</span> depth) {
</span></span><span style=display:flex><span>    StateInfo st;  <span style=color:#75715e>// Create on stack
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Move m : generate_moves(pos)) {
</span></span><span style=display:flex><span>        pos.do_move(m, st);     <span style=color:#75715e>// st.previous = old state
</span></span></span><span style=display:flex><span>        search(pos, depth <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// Recurse
</span></span></span><span style=display:flex><span>        pos.undo_move(m);       <span style=color:#75715e>// Restore from st.previous
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Memory layout during search:</p><pre tabindex=0><code>Stack frame 1:  StateInfo st1   ←─┐
                                  │
Stack frame 2:  StateInfo st2   ←─┼─ st2.previous
                                  │
Stack frame 3:  StateInfo st3   ←─┼─ st3.previous
                ↑                 │
                └─────────────────┘
</code></pre><p>Each <code>StateInfo</code> points to the previous state, forming a chain that can be unwound during <code>undo_move()</code>.</p><h3 id=two-categories-of-data>Two Categories of Data<a hidden class=anchor aria-hidden=true href=#two-categories-of-data>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StateInfo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Copied when making a move
</span></span></span><span style=display:flex><span>  Key    pawnKey;
</span></span><span style=display:flex><span>  Key    materialKey;
</span></span><span style=display:flex><span>  Value  nonPawnMaterial[COLOR_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>    castlingRights;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>    rule50;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>    pliesFromNull;
</span></span><span style=display:flex><span>  Score  psq;
</span></span><span style=display:flex><span>  Square epSquare;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Not copied when making a move (will be recomputed anyhow)
</span></span></span><span style=display:flex><span>  Key        key;
</span></span><span style=display:flex><span>  Bitboard   checkersBB;
</span></span><span style=display:flex><span>  Piece      capturedPiece;
</span></span><span style=display:flex><span>  StateInfo<span style=color:#f92672>*</span> previous;
</span></span><span style=display:flex><span>  Bitboard   blockersForKing[COLOR_NB];
</span></span><span style=display:flex><span>  Bitboard   pinnersForKing[COLOR_NB];
</span></span><span style=display:flex><span>  Bitboard   checkSquares[PIECE_TYPE_NB];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=category-1-copied-when-making-a-move>Category 1: Copied When Making a Move<a hidden class=anchor aria-hidden=true href=#category-1-copied-when-making-a-move>#</a></h4><p>These values are incrementally updated (not recomputed from scratch)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  Key    pawnKey;
</span></span><span style=display:flex><span>  Key    materialKey;
</span></span><span style=display:flex><span>  Value  nonPawnMaterial[COLOR_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>    castlingRights;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>    rule50;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>    pliesFromNull;
</span></span><span style=display:flex><span>  Score  psq;
</span></span><span style=display:flex><span>  Square epSquare;
</span></span></code></pre></div><p>Why copied? These can be updated incrementally faster than recomputing:</p><ul><li>Hash keys: XOR in changes</li><li>Scores: add/subtract deltas</li><li>Counters: increment/decrement</li></ul><h4 id=category-2-recomputed-every-move>Category 2: Recomputed Every Move<a hidden class=anchor aria-hidden=true href=#category-2-recomputed-every-move>#</a></h4><p>These are always calculated fresh (not worth copying)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Not copied when making a move (will be recomputed anyhow)
</span></span></span><span style=display:flex><span>Key        key;
</span></span><span style=display:flex><span>Bitboard   checkersBB;
</span></span><span style=display:flex><span>Piece      capturedPiece;
</span></span><span style=display:flex><span>StateInfo<span style=color:#f92672>*</span> previous;
</span></span><span style=display:flex><span>Bitboard   blockersForKing[COLOR_NB];
</span></span><span style=display:flex><span>Bitboard   pinnersForKing[COLOR_NB];
</span></span><span style=display:flex><span>Bitboard   checkSquares[PIECE_TYPE_NB];
</span></span></code></pre></div><p>Why not copied? Cheaper to recalculate than to copy and update.</p><h3 id=nonpawnmaterial>nonPawnMaterial<a hidden class=anchor aria-hidden=true href=#nonpawnmaterial>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Value nonPawnMaterial[COLOR_NB]
</span></span></code></pre></div><ul><li>Total material value excluding pawns for each color</li><li><code>nonPawnMaterial[WHITE]</code> = value of white knights, bishops, rooks, queens</li><li><code>nonPawnMaterial[BLACK]</code> = same for black</li></ul><p><strong>Why exclude pawns?</strong></p><ul><li>Used for endgame detection</li><li>&ldquo;Low material&rdquo; = fewer pieces (pawns don&rsquo;t count toward complexity)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// After capturing black knight:
</span></span></span><span style=display:flex><span>nonPawnMaterial[BLACK] <span style=color:#f92672>-=</span> KnightValue;  <span style=color:#75715e>// Incremental update
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Usage:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (nonPawnMaterial[WHITE] <span style=color:#f92672>+</span> nonPawnMaterial[BLACK] <span style=color:#f92672>&lt;</span> EndgameThreshold) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enter endgame evaluation mode
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=castlingrights>castlingRights<a hidden class=anchor aria-hidden=true href=#castlingrights>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> castlingRights
</span></span></code></pre></div><ul><li>Bitfield of available castling rights</li><li>Combination of: <code>WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO</code></li></ul><p><code>castlingRights</code> is also part of Zobrist hash <code>key</code>. But it can&rsquo;t be read from the hash.</p><h3 id=rule50>rule50<a hidden class=anchor aria-hidden=true href=#rule50>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> rule50
</span></span></code></pre></div><ul><li>Halfmove clock for the 50-move rule</li><li>Incremented every move, reset on pawn move or capture</li></ul><h3 id=pliesfromnull>pliesFromNull<a hidden class=anchor aria-hidden=true href=#pliesfromnull>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> pliesFromNull
</span></span></code></pre></div><ul><li>How many plies since last null move in search</li><li>Used to prevent consecutive null moves</li></ul><p>A null move is a fake move where: The side to move skips its turn, and the opponent moves again.</p><p>No piece is moved.
The position stays the same except:</p><ul><li>side to move flips</li><li>some counters update (ply, hash, etc.)</li><li>en passant is cleared</li></ul><p>In chess notation: it’s like saying</p><p>“What if I do nothing?”</p><p>Obviously illegal in real chess, but very useful in search.</p><p><strong>Why would an engine do this?</strong></p><p>Idea behind Null Move Pruning:</p><p>If you can skip your move and still not get into trouble,then any real move is at least as good.</p><p>So:</p><p>If even after giving the opponent an extra move, the position is still ≥ β
→ prune this branch (fail-high).</p><p>This is called Null Move Pruning (NMP).</p><p><code>pliesFromNull</code> counts how many plies have passed since the last null move. Because two null moves in a row is dangerous</p><p>If you allow:</p><ul><li>Null move</li><li>Then another null move</li></ul><p>You can get:</p><ul><li>zugzwang bugs</li><li>illegal pruning</li><li>missed mates</li><li>evaluation nonsense</li></ul><h3 id=pinnersforking>pinnersForKing<a hidden class=anchor aria-hidden=true href=#pinnersforking>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard pinnersForKing[COLOR_NB]
</span></span></code></pre></div><ul><li>Enemy sliding pieces pinning our pieces</li><li>The &ldquo;other side&rdquo; of <code>blockersForKing</code></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/board-representation/>Board Representation</a></li><li><a href=https://sankethbk.github.io/blog/tags/position/>Position</a></li><li><a href=https://sankethbk.github.io/blog/tags/stateinfo/>StateInfo</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>