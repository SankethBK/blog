<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Move Picker | Sanketh's Blog</title><meta name=keywords content="move picker"><meta name=description content="Move Picker
Stats
/// The Stats struct stores moves statistics. According to the template parameter
/// the class can store History and Countermoves. History records how often
/// different moves have been successful or unsuccessful during the current search
/// and is used for reduction and move ordering decisions.
/// Countermoves store the move that refute a previous one. Entries are stored
/// using only the moving piece and destination square, hence two moves with
/// different origin but same destination and piece will be considered identical.
template<typename T, bool CM = false>
struct Stats {

  static const Value Max = Value(1 << 28);

  const T* operator[](Piece pc) const { return table[pc]; }
  T* operator[](Piece pc) { return table[pc]; }
  void clear() { std::memset(table, 0, sizeof(table)); }
  void update(Piece pc, Square to, Move m) { table[pc][to] = m; }
  void update(Piece pc, Square to, Value v) {

    if (abs(int(v)) >= 324)
        return;

    table[pc][to] -= table[pc][to] * abs(int(v)) / (CM ? 936 : 324);
    table[pc][to] += int(v) * 32;
  }

private:
  T table[PIECE_NB][SQUARE_NB];
};

typedef Stats<Move> MoveStats;
typedef Stats<Value, false> HistoryStats;
typedef Stats<Value,  true> CounterMoveStats;
typedef Stats<CounterMoveStats> CounterMoveHistoryStats;
It is a generic 2-D table indexed by (piece, destination square)"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Move Picker"><meta property="og:description" content="Move Picker Stats /// The Stats struct stores moves statistics. According to the template parameter /// the class can store History and Countermoves. History records how often /// different moves have been successful or unsuccessful during the current search /// and is used for reduction and move ordering decisions. /// Countermoves store the move that refute a previous one. Entries are stored /// using only the moving piece and destination square, hence two moves with /// different origin but same destination and piece will be considered identical. template<typename T, bool CM = false> struct Stats { static const Value Max = Value(1 << 28); const T* operator[](Piece pc) const { return table[pc]; } T* operator[](Piece pc) { return table[pc]; } void clear() { std::memset(table, 0, sizeof(table)); } void update(Piece pc, Square to, Move m) { table[pc][to] = m; } void update(Piece pc, Square to, Value v) { if (abs(int(v)) >= 324) return; table[pc][to] -= table[pc][to] * abs(int(v)) / (CM ? 936 : 324); table[pc][to] += int(v) * 32; } private: T table[PIECE_NB][SQUARE_NB]; }; typedef Stats<Move> MoveStats; typedef Stats<Value, false> HistoryStats; typedef Stats<Value, true> CounterMoveStats; typedef Stats<CounterMoveStats> CounterMoveHistoryStats; It is a generic 2-D table indexed by (piece, destination square)"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-15T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-15T00:00:00+00:00"><meta property="article:tag" content="Move Picker"><meta name=twitter:card content="summary"><meta name=twitter:title content="Move Picker"><meta name=twitter:description content="Move Picker
Stats
/// The Stats struct stores moves statistics. According to the template parameter
/// the class can store History and Countermoves. History records how often
/// different moves have been successful or unsuccessful during the current search
/// and is used for reduction and move ordering decisions.
/// Countermoves store the move that refute a previous one. Entries are stored
/// using only the moving piece and destination square, hence two moves with
/// different origin but same destination and piece will be considered identical.
template<typename T, bool CM = false>
struct Stats {

  static const Value Max = Value(1 << 28);

  const T* operator[](Piece pc) const { return table[pc]; }
  T* operator[](Piece pc) { return table[pc]; }
  void clear() { std::memset(table, 0, sizeof(table)); }
  void update(Piece pc, Square to, Move m) { table[pc][to] = m; }
  void update(Piece pc, Square to, Value v) {

    if (abs(int(v)) >= 324)
        return;

    table[pc][to] -= table[pc][to] * abs(int(v)) / (CM ? 936 : 324);
    table[pc][to] += int(v) * 32;
  }

private:
  T table[PIECE_NB][SQUARE_NB];
};

typedef Stats<Move> MoveStats;
typedef Stats<Value, false> HistoryStats;
typedef Stats<Value,  true> CounterMoveStats;
typedef Stats<CounterMoveStats> CounterMoveHistoryStats;
It is a generic 2-D table indexed by (piece, destination square)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Move Picker","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Move Picker","name":"Move Picker","description":"Move Picker Stats /// The Stats struct stores moves statistics. According to the template parameter /// the class can store History and Countermoves. History records how often /// different moves have been successful or unsuccessful during the current search /// and is used for reduction and move ordering decisions. /// Countermoves store the move that refute a previous one. Entries are stored /// using only the moving piece and destination square, hence two moves with /// different origin but same destination and piece will be considered identical. template\u0026lt;typename T, bool CM = false\u0026gt; struct Stats { static const Value Max = Value(1 \u0026lt;\u0026lt; 28); const T* operator[](Piece pc) const { return table[pc]; } T* operator[](Piece pc) { return table[pc]; } void clear() { std::memset(table, 0, sizeof(table)); } void update(Piece pc, Square to, Move m) { table[pc][to] = m; } void update(Piece pc, Square to, Value v) { if (abs(int(v)) \u0026gt;= 324) return; table[pc][to] -= table[pc][to] * abs(int(v)) / (CM ? 936 : 324); table[pc][to] += int(v) * 32; } private: T table[PIECE_NB][SQUARE_NB]; }; typedef Stats\u0026lt;Move\u0026gt; MoveStats; typedef Stats\u0026lt;Value, false\u0026gt; HistoryStats; typedef Stats\u0026lt;Value, true\u0026gt; CounterMoveStats; typedef Stats\u0026lt;CounterMoveStats\u0026gt; CounterMoveHistoryStats; It is a generic 2-D table indexed by (piece, destination square)\n","keywords":["move picker"],"articleBody":"Move Picker Stats /// The Stats struct stores moves statistics. According to the template parameter /// the class can store History and Countermoves. History records how often /// different moves have been successful or unsuccessful during the current search /// and is used for reduction and move ordering decisions. /// Countermoves store the move that refute a previous one. Entries are stored /// using only the moving piece and destination square, hence two moves with /// different origin but same destination and piece will be considered identical. template\u003ctypename T, bool CM = false\u003e struct Stats { static const Value Max = Value(1 \u003c\u003c 28); const T* operator[](Piece pc) const { return table[pc]; } T* operator[](Piece pc) { return table[pc]; } void clear() { std::memset(table, 0, sizeof(table)); } void update(Piece pc, Square to, Move m) { table[pc][to] = m; } void update(Piece pc, Square to, Value v) { if (abs(int(v)) \u003e= 324) return; table[pc][to] -= table[pc][to] * abs(int(v)) / (CM ? 936 : 324); table[pc][to] += int(v) * 32; } private: T table[PIECE_NB][SQUARE_NB]; }; typedef Stats\u003cMove\u003e MoveStats; typedef Stats\u003cValue, false\u003e HistoryStats; typedef Stats\u003cValue, true\u003e CounterMoveStats; typedef Stats\u003cCounterMoveStats\u003e CounterMoveHistoryStats; It is a generic 2-D table indexed by (piece, destination square)\ntable[piece][to_square] ‚Üí learned information about that move So it doesn‚Äôt care about from square.\nThis is intentional: Stockfish learns ideas, not exact moves.\n‚ÄúKnight to e4 is often good in this position family‚Äù\nWhat does it Store? Depends on template type T.\n1. MoveStats (Countermoves) typedef Stats\u003cMove\u003e MoveStats; Stores: A move for each [piece][square] Usage: ‚ÄúWhat move refutes opponent‚Äôs last move?‚Äù\nMoveStats countermoves; // Opponent played Nf6 // We responded with d4 (good response) countermoves.update(BLACK_KNIGHT, SQ_F6, MOVE_D2D4); // Later, opponent plays Nf6 again: Move response = countermoves[BLACK_KNIGHT][SQ_F6]; // response = d4 // Try this first! (likely good again) Again these are not actual moves played, because if we had already played them, we won‚Äôt be playing them in future. These are the among the millions of possibilities examined during minmax.\n2. HistoryStats (History Heuristic) typedef Stats\u003cValue, false\u003e HistoryStats; Stores: Score (Value) for each [piece][square] Usage: ‚ÄúHow often has this move been good?‚Äù Stores: [piece][square] ‚Üí scoreDoes NOT care about:\n‚ùå What the opponent‚Äôs last move was. ‚ùå What position we‚Äôre in ‚ùå What came before this move Only tracks:\n‚úÖ ‚ÄúHas [piece to square] been good lately?‚Äù HistoryStats history; // Position A: Opponent played d5 // We try Ne4 ‚Üí beta cutoff history.update(WHITE_KNIGHT, SQ_E4, +64); // Position B: Opponent played c5 // We try Ne4 ‚Üí beta cutoff again history.update(WHITE_KNIGHT, SQ_E4, +36); // Position C: Opponent played Nf6 // We try Ne4 ‚Üí beta cutoff again history.update(WHITE_KNIGHT, SQ_E4, +49); // Result: history[WHITE_KNIGHT][SQ_E4] = 5000+ (high score) // Interpretation: \"Ne4 has been good in general, regardless of what opponent did. This will be the first move we try for next couple of searches even if we don't play it now.\" 3. CounterMoveStats typedef Stats\u003cValue, true\u003e CounterMoveStats; Same as HistoryStats but:\nCM = true ‚Üí different decay formula Used for countermove history (two-move patterns) CounterMoveStats is not independently, its used by CounterMoveHistoryStats 4. CounterMoveHistoryStats (Follow-up History) typedef Stats\u003cCounterMoveStats\u003e CounterMoveHistoryStats; This is a 4D array!\n// Underlying structure: CounterMoveStats table[PIECE_NB][SQUARE_NB]; // ‚Üì // Value table2[PIECE_NB][SQUARE_NB]; // Final structure: Value table[piece1][square1][piece2][square2]; Usage: ‚ÄúIf opponent played [piece1 to square1], and we play [piece2 to square2], was that good?‚Äù\nCounterMoveHistoryStats cmHistory; // Opponent: Nf6 (BLACK_KNIGHT to f6) // We: d4 (WHITE_PAWN to d4) // Result: Good! (caused cutoff) cmHistory[BLACK_KNIGHT][SQ_F6].update(WHITE_PAWN, SQ_D4, +64); // Later: // We want to evaluate what if Opponent plays Nf6 again Value score = cmHistory[BLACK_KNIGHT][SQ_F6][WHITE_PAWN][SQ_D4]; // score = 2048 (d4 was good response to Nf6 before, let's try it first) How History and CounterMoves are Used? // HISTORY (context-free): history[WHITE_KNIGHT][SQ_E4] = 5000 \"Ne4 is often good\" // COUNTERMOVE HISTORY (context-aware): cmh[BLACK_PAWN][SQ_D5][WHITE_KNIGHT][SQ_E4] = 3000 \"Ne4 is often good WHEN opponent played d5\" cmh[BLACK_KNIGHT][SQ_F6][WHITE_KNIGHT][SQ_E4] = -500 \"Ne4 is often BAD WHEN opponent played Nf6\" // Opponent just played Nf6 // Calculate move score for Ne4: int score_Ne4 = 0; // Add general history score_Ne4 += history[WHITE_KNIGHT][SQ_E4]; // +5000 // Add context-specific history score_Ne4 += cmh[BLACK_KNIGHT][SQ_F6] // -500 [WHITE_KNIGHT][SQ_E4]; // Total: 5000 - 500 = 4500 // Calculate for Nd4: int score_Nd4 = 0; score_Nd4 += history[WHITE_KNIGHT][SQ_D4]; // +1000 score_Nd4 += cmh[BLACK_KNIGHT][SQ_F6] // +2000 [WHITE_KNIGHT][SQ_D4]; // Total: 1000 + 2000 = 3000 // Result: Try Ne4 first (4500 \u003e 3000) Update - Decay Score Calculatio void update(Piece pc, Square to, Value v) { if (abs(int(v)) \u003e= 324) return; table[pc][to] -= table[pc][to] * abs(int(v)) / (CM ? 936 : 324); table[pc][to] += int(v) * 32; } History Update Formula The Goal\nGood moves should increase their history score. Bad moves should decrease their history score.\nBut we need:\nDecay old information (recent searches more important) Don‚Äôt overflow (scores bounded) Fast convergence (respond quickly to patterns) Decay Intuition:\nRemember in both history and countermoves we don‚Äôt store at what exact position this move was good/bad.\nAs game progresses\nThe move may become not so good/bad. Not even a legal move. Like gravity pulling score toward zero - Old information gradually forgotten - Recent patterns have more weight - Allows adaptation to changing positions - Stable patterns reach equilibrium Decay rates:\nHistory: 324 (faster) ‚Üí Quick adaptation CounterMoves: 936 (slower) ‚Üí Preserve stable patterns Think of it like gravity pulling the score toward zero:\nCurrent score: +10,000 (Ne4 was good in old searches) New search: Ne4 is good again Bonus: +64 Update: ‚îú‚îÄ Decay: 10,000 - (10,000 * 64 / 324) = 10,000 - 1,975 = 8,025 ‚îî‚îÄ Bonus: 8,025 + (64 * 32) = 8,025 + 2,048 = 10,073 Result: Score stays high (move is still good) Current score: +10,000 (Ne4 was good in old searches) New search: Ne4 is BAD now Penalty: -64 Update: ‚îú‚îÄ Decay: 10,000 - (10,000 * 64 / 324) = 10,000 - 1,975 = 8,025 ‚îî‚îÄ Penalty: 8,025 + (-64 * 32) = 8,025 - 2,048 = 5,977 Result: Score drops (adapting to new information) Comparision with TT Value in Stats:\n‚ùå NOT: position evaluation ‚ùå NOT: alpha/beta bounds ‚ùå NOT: SEE score ‚úÖ IS: \"How often was this move good?\" (statistical score) MoveStats vs TT:\nTT: Stores info for EXACT position (very specific) MoveStats: Stores pattern for ANY position with this move (general) Both used together:\n1. Try TT move (best for this exact position) 2. Try countermove (good pattern across positions) 3. Try other moves ordered by history // Move ordering priority: 1. TT move ‚Üê Specific to this exact position (best!) 2. Countermove ‚Üê General pattern (good guess) 3. History ‚Üê Statistical frequency 4. Other moves FromToStats This is like HistoryStats, but more specific - it tracks moves by their from-square and to-square.\nThe Structure\nValue table[COLOR_NB][SQUARE_NB][SQUARE_NB]; // ‚Üë ‚Üë ‚Üë // Color From To // (2) (64) (64) 3D array: [color][from_square][to_square] ‚Üí score Size: 2 √ó 64 √ó 64 = 8,192 entries\nKey Difference from HistoryStats HistoryStats (2D) table[piece][to_square] // Example: history[WHITE_KNIGHT][e4] // \"Knight moves to e4\" (from anywhere) FromToStats (3D) table[color][from_square][to_square] // Example: fromTo[WHITE][f3][e4] // \"Move from f3 to e4\" (any piece!) What It Tracks Less specific than HistoryStats:\nFromToStats fromToHistory; // Move: Nf3-e5 (knight from f3 to e5) fromToHistory.update(WHITE, make_move(f3, e5), +64); // Stored at: table[WHITE][f3][e5] = 2048 // Later, any move f3‚Üíe5 gets this score: // - Nf3-e5 (knight) ‚úì // - Bf3-e5 (bishop, if possible) ‚úì // - Even pawn f3-e5 (if legal) ‚úì // But NOT: // - Nd2-e5 (different from-square) ‚úó When FromToStats Helps Captures PATH information that HistoryStats misses:\nPosition: Knight can go to e5 from two squares // From f3: history[WHITE_KNIGHT][e5] = 5000 // \"Ne5 is good\" fromTo[WHITE][f3][e5] = 8000 // \"f3‚Üíe5 path is especially good!\" // From d2: history[WHITE_KNIGHT][e5] = 5000 // \"Ne5 is good\" (same!) fromTo[WHITE][d2][e5] = 1000 // \"d2‚Üíe5 path is less good\" // Result: Prefer Nf3-e5 over Nd2-e5 So Which Is More Specific?\nNeither! They‚Äôre DIFFERENT dimensions:\nHistoryStats: PIECE-specific, PATH-agnostic FromToStats: PATH-specific, PIECE-agnostic Both used together for best ordering: score = history[piece][to] + fromTo[color][from][to] HistoryStats vs FromToStats:\nHistoryStats: [piece][to] - Knows WHAT piece - Doesn't know WHERE from - \"Is Ne5 good?\" FromToStats: [color][from][to] - Knows WHERE from - Doesn't know WHAT piece - \"Is f3‚Üíe5 good?\" Complementary information!\nMovePicker - The Move Ordering Engine This is the heart of move ordering in Stockfish.\nThe Big Picture Purpose: Generate moves one at a time in best-first order to maximize alpha-beta cutoffs.\nMovePicker mp(pos, ttMove, depth, ss); Move m; while ((m = mp.next_move()) != MOVE_NONE) { // Try move in best-first order score = -search(pos.do_move(m), ...); if (score \u003e= beta) break; // Cutoff! (hopefully on first move) } Key insight: Don‚Äôt generate all moves at once, generate them lazily in priority order.\nThe Three Constructors MovePicker(const Position\u0026, Move, Value); MovePicker(const Position\u0026, Move, Depth, Square); MovePicker(const Position\u0026, Move, Depth, Search::Stack*); Three different use cases:\nConstructor 1: Quiescence Search MovePicker(const Position\u0026 p, Move ttm, Value threshold); Parameters:\nttm: TT move (try first) threshold: Only generate captures with SEE ‚â• threshold Used in: Quiescence search (only captures)\nMovePicker mp(pos, ttMove, -100); // Only generate captures that don't lose \u003e1 pawn MovePicker::MovePicker(const Position\u0026 p, Move ttm, Value th) : pos(p), threshold(th) { assert(!pos.checkers()); stage = PROBCUT; // In ProbCut we generate captures with SEE higher than the given threshold ttMove = ttm \u0026\u0026 pos.pseudo_legal(ttm) \u0026\u0026 pos.capture(ttm) \u0026\u0026 pos.see_ge(ttm, threshold + 1)? ttm : MOVE_NONE; stage += (ttMove == MOVE_NONE); } assert(!pos.checkers()); What: Checks that we‚Äôre NOT in check Why: This constructor is for quiescence/ProbCut, which doesn‚Äôt handle check evasions\nstage = PROBCUT; What: Set initial stage to PROBCUT Stage enum (approximately):\nenum Stage { MAIN_TT = 0, // ... PROBCUT, // Only high-SEE captures PROBCUT_CAPTURES, // Generate and return them // ... }; Why PROBCUT? This constructor is used for:\nProbCut search (try only captures that gain material) Quiescence search (try only non-losing captures) TT Move Validation (The Tricky Part)\nttMove = ttm \u0026\u0026 pos.pseudo_legal(ttm) \u0026\u0026 pos.capture(ttm) \u0026\u0026 pos.see_ge(ttm, threshold + 1) ? ttm : MOVE_NONE; This is a chain of boolean conditions that must ALL be true to accept the TT move.\nCondition 1: ttm\nCheck: TT move exists (not MOVE_NONE)\nCondition 2: pos.pseudo_legal(ttm)\nCheck: TT move is pseudo-legal in current position Pseudo-legal means:\nMove syntax is valid (from/to squares exist) Piece can make that move (e.g., knight moves like a knight) But might leave king in check (not validated yet) Condition 3: pos.capture(ttm)\nCheck: TT move is a capture Why this check? In ProbCut/quiescence, we only want captures!\nCondition 4: pos.see_ge(ttm, threshold + 1)\nConstructor 2: Evasion Search MovePicker(const Position\u0026 p, Move ttm, Depth d, Square sq); Parameters:\np: Current position ttm: TT move d: Negative depth (quiescence depth) s: Recapture square (only used in one case)- Used when in check or after a capture Used in: Recapture extensions, check evasions\n// Opponent just captured on e4 MovePicker mp(pos, ttMove, depth, SQ_E4); // Prioritize recaptures on e4 MovePicker::MovePicker(const Position\u0026 p, Move ttm, Depth d, Square s) : pos(p) { assert(d \u003c= DEPTH_ZERO); if (pos.checkers()) stage = EVASION; else if (d \u003e DEPTH_QS_NO_CHECKS) stage = QSEARCH_WITH_CHECKS; else if (d \u003e DEPTH_QS_RECAPTURES) stage = QSEARCH_NO_CHECKS; else { stage = QSEARCH_RECAPTURES; recaptureSquare = s; return; } ttMove = ttm \u0026\u0026 pos.pseudo_legal(ttm) ? ttm : MOVE_NONE; stage += (ttMove == MOVE_NONE); } // Depth constants (negative values): DEPTH_ZERO = 0 DEPTH_QS_CHECKS = 0 // Try checks in quiescence DEPTH_QS_NO_CHECKS = -1 // No checks, just captures DEPTH_QS_RECAPTURES = -5 // Only recaptures on specific square // Typical quiescence depths: d = 0 ‚Üí Can try checks d = -1 ‚Üí Only captures, no checks d = -2 ‚Üí Only captures, no checks d = -5 ‚Üí Only recaptures on one square d = -7 ‚Üí Only recaptures on one square assert(d \u003c= DEPTH_ZERO); Check: Depth must be ‚â§ 0 (quiescence depths are negative/zero)\nWhy? This constructor is ONLY for quiescence search, which uses negative depths.\nWhy is Depth an enum? Stockfish needs multiple kinds of quiescence search, not just one.\nStockfish encodes the mode inside the depth number itself.\nNegative depth = different quiescence modes\nSo depth becomes a state machine.\nThe Meaning of Each Constant\nThink of them as search regimes, not depths.\nConstant Meaning DEPTH_ZERO transition point: start quiescence DEPTH_QS_CHECKS full qsearch (captures + checking moves) DEPTH_QS_NO_CHECKS captures only DEPTH_QS_RECAPTURES only recaptures on same square DEPTH_NONE stop search entirely Key idea\nThe more negative the depth ‚Üí the quieter the search becomes\nSo the engine gradually reduces tactical horizon:\nNormal search ‚Üì Qsearch with checks ‚Üì Qsearch captures only ‚Üì Recaptures only ‚Üì Stop This is called tapered quiescence.\nInstead of writing:\nif (mode == QS_CHECKS) ... else if (mode == QS_CAPTURES) ... else if (mode == QS_RECAPTURES) ... Stockfish can simply do:\ndepth-- and naturally transition between modes.\nSearch controls itself automatically.\nFour scenarios:\nIn check (any depth): Stage: EVASION Generates: Evasion moves only Depth = 0 (shallow quiescence): Stage: QSEARCH_WITH_CHECKS Generates: Captures + Checks Depth = -1 to -4 (normal quiescence): Stage: QSEARCH_NO_CHECKS Generates: Captures only Depth ‚â§ -5 (deep quiescence): Stage: QSEARCH_RECAPTURES Generates: Recaptures on square only Early return (skips TT validation) Key insight: Deeper quiescence = more selective (prune aggressively)\nConstructor 3: Normal Search MovePicker::MovePicker(const Position\u0026 p, Move ttm, Depth d, Search::Stack* s) : pos(p), ss(s), depth(d) Initializer list stores:\npos(p): Position reference ss(s): Search stack pointer depth(d): Current search depth Note: No threshold or recaptureSquare - this is full search, not quiescence!\nUsed in: Regular alpha-beta search\nOpposite of the quiescence constructor!\nassert(d \u003e DEPTH_ZERO); Get Previous Square\nSquare prevSq = to_sq((ss-1)-\u003ecurrentMove); // ss points to current ply // ss-1 points to PARENT ply Get Countermove\ncountermove = pos.this_thread()-\u003ecounterMoves[pos.piece_on(prevSq)][prevSq]; Three parts:\npos.this_thread()\n// Get the thread searching this position // Each thread has its own move statistics Thread* thread = pos.this_thread(); pos.piece_on(prevSq)\n// What piece is on the square opponent just moved to? Piece theirPiece = pos.piece_on(prevSq); // Example: // Opponent played Nd4 // prevSq = d4 // piece_on(d4) = BLACK_KNIGHT counterMoves[piece][square]\n// Look up our recorded response to this move Move cm = counterMoves[BLACK_KNIGHT][d4]; // This is the move we previously found to be good // when opponent played their knight to d4 Set Stage\nstage = pos.checkers() ? EVASION : MAIN_SEARCH; Two possibilities:\nIn Check ‚Üí EVASION\nif (pos.checkers()) stage = EVASION; // Must get out of check! // Generate only evasion moves Not in Check ‚Üí MAIN_SEARCH\nelse stage = MAIN_SEARCH; // Normal position // Generate all moves in priority order: // TT ‚Üí Captures ‚Üí Killers ‚Üí Countermove ‚Üí Quiets ‚Üí Bad Captures TT Move Validation\nttMove = ttm \u0026\u0026 pos.pseudo_legal(ttm) ? ttm : MOVE_NONE; Same as quiescence constructor:\nTT move exists? Pseudo-legal in current position? Stage Adjustment\nstage += (ttMove == MOVE_NONE); Same trick as other constructors:\n// With valid TT move: stage = MAIN_SEARCH (e.g., 0) stage += 0 // = MAIN_SEARCH (try TT move first) // Without TT move: stage = MAIN_SEARCH (0) stage += 1 // = MAIN_SEARCH + 1 (skip to captures) The Member Variables private: const Position\u0026 pos; // Current position const Search::Stack* ss; // Search stack (killers, history) Move countermove; // Countermove to try Depth depth; // Search depth Move ttMove; // TT move (highest priority) Square recaptureSquare; // For recapture prioritization Value threshold; // SEE threshold for captures int stage; // Current generation stage ExtMove *cur; // Current move pointer ExtMove *endMoves; // End of generated moves ExtMove *endBadCaptures; // Separator for bad captures ExtMove moves[MAX_MOVES]; // Move buffer (218 max) 1. pos const Position\u0026 pos; What: Reference to the current chess positionWhy needed:\nWhy needed:\nCheck if moves are legal (pos.legal(move)) Get piece types (pos.piece_on(square)) Generate moves (generate(pos, ...)) Evaluate captures with SEE (pos.see_ge(move, threshold)) 2. ss const Search::Stack* ss; We previously saw another stack anemd StateInfo, but it was used to store board state history which wil be used to make/undo moves.\nSearch::Stack ‚Üí search reasoning memory\nThis is NOT about board state.\nIt stores what the engine learned while thinking at each ply.\nEach recursive search call gets one entry:\nsearch(depth=5) ‚Üí ss[0] search(depth=4) ‚Üí ss[1] search(depth=3) ‚Üí ss[2] search(depth=2) ‚Üí ss[3] Search depth = stack depth.\nSo this stack represents:\nthe thinking path inside the search tree\nWhat is inside Search::Stack Typical fields:\nkillers[2] ‚Üí moves that caused cutoffs here before currentMove ‚Üí move being searched staticEval ‚Üí evaluation of this position excludedMove ‚Üí singular extension logic ply ‚Üí distance from root continuationHistory ‚Üí follow-up move learning This is all heuristics ‚Äî nothing about legality of position.\nA stack is initialized during the beginning of search function and it will be destroyed once the function exits.\nHowever, some information is copied into global tables:\nhistory table countermove table So the experience survives, but the stack does not.\n1. killers[2] At a given depth, positions often share tactical structure.\nExample:\nYou search 50 different branches at depth 8 In MANY of them the move: Re1+ immediately refutes opponent So next time you reach depth 8:\ntry Re1+ FIRST Because chances are high it cuts off again.\nThat move becomes a killer move\nWhy called ‚Äúkiller‚Äù?\nBecause it kills the branch instantly (beta cutoff).\nWhy two killers?\nBecause positions differ slightly.\nTypical:\nkiller1 ‚Üí most reliable killer2 ‚Üí backup candidate A killer move is NOT necessarily a good move in chess.\nIt is:\na move that refuted opponent‚Äôs plan in many sibling nodes\nExtremely powerful heuristic.\nKey properties:\nStored per ply (depth level) Only quiet moves (not captures) Usually store 2 killers per ply Updated when a quiet move causes beta cutoff Why Only Quiet Moves?\nCaptures are already ordered by material logic (SEE/MVV-LVA), killers exist to rescue quiet moves that would otherwise be searched last.\nThink about move ordering priorities\nStockfish tries moves roughly in this order: 1.\tTT move (previous best) 2.\tGood captures 3.\tKiller moves 4.\tCountermoves 5.\tHistory quiet moves 6.\tBad captures\n2. currentMove This stores the move played to reach this node.\nWhy needed?\nBecause many heuristics depend on previous move.\n3. staticEval Static evaluation = NNUE evaluation without searching.\nInstead of recomputing eval again and again, we store it once in stack.\nUsed for:\npruning decisions futility pruning razoring null move pruning 4. excludedMove ‚Äî singular extension magic This is advanced but super important.\nSingular extension asks:\n‚ÄúIs ONE move clearly much better than all others?‚Äù\nIf yes ‚Üí extend search deeper for that move.\nTo test that, engine temporarily says:\nSearch position WITHOUT best move So we must forbid it:\nexcludedMove = bestMove Search runs again ignoring that move.\nIf position collapses ‚Üí the move was singular ‚Üí extend it.\n5. ply Needed because mate scores depend on distance.\nExample:\nMate in 5 is better than mate in 7 But raw score might be same.\nSo engine adjusts using ply.\nAlso used in:\nLMR reductions pruning margins TT storage 6. continuationHistory This is extremely powerful modern heuristic.\nNot just:\nwhich move is good\nbut:\nwhich move is good AFTER another move\nExample patterns:\nBxh7+ ‚Üí Kg8 forced Ng5+ ‚Üí strong followup Qh5 ‚Üí mating attack Putting all together ‚Äî what the stack really is\nAt each depth the engine keeps:\nWhat just happened What worked before What patterns exist What position looks like So instead of blind search:\nStockfish searches informed search tree\n3. Move countermove Move countermove; What: The countermove to opponent‚Äôs last move How it‚Äôs set:\n// In constructor: if (ss \u0026\u0026 ss-\u003eply \u003e 0) { Move lastMove = (ss-1)-\u003ecurrentMove; // Opponent's last move countermove = counterMoves[lastMove]; // Our recorded response } Why stored separately:\nNeed to try it during COUNTERMOVE stage Need to avoid trying it twice (if it‚Äôs also killer or TT move) 4. depth Depth depth; What: Current search depth (in plies) Why needed:\nDecide which stages to use At low depths, skip expensive move generation History bonuses scale with depth Example usage:\nMove MovePicker::next_move() { // At depth \u003c 3, skip quiet moves (ProbCut) if (depth \u003c 3 * ONE_PLY \u0026\u0026 stage == QUIET_MOVES) stage = BAD_CAPTURES; // Skip to bad captures // History bonus: depth¬≤ int bonus = depth * depth; history.update(move, bonus); } Typical values:\nDepth 0: Quiescence search (only captures) Depth 1-3: Tactical search (captures + killer moves) Depth 4+: Full search (all moves) It tells the engine how reliable a move ordering decision is worth paying for.\nNear the leaves (small depth)\nExample: depth = 2 plies left\nUs ‚Üí Them ‚Üí evaluate You will evaluate very soon anyway.\nSpending time generating and sorting 40 quiet moves is wasteful.\nSo engine mostly tries:\ncaptures tactical moves maybe killers Because quiet positional moves cannot change evaluation much in 2 plies.\nDeep in the tree (large depth)\nExample: depth = 12 (left)\nA bad move ordering here explodes the tree:\nWrong first move ‚Üí no cutoff ‚Üí millions of nodes Right first move ‚Üí cutoff ‚Üí tiny tree So now it‚Äôs worth:\nsorting quiet moves using history scores more heuristics That‚Äôs what this means\nHistory bonuses scale with depth\nIf a move refutes at depth 12 ‚Üí extremely important If same move refutes at depth 2 ‚Üí almost meaningless\nSo Stockfish rewards it proportionally:\nbonus ‚âà depth¬≤ ProbCut ProbCut = Probabilistic Cutoff\nIt is a forward pruning technique.\nMeaning:\nSkip searching a branch because it‚Äôs almost certainly bad.\nIdea\nSometimes a move is SO winning tactically that you don‚Äôt need a full deep search to know it fails beta.\nInstead: 1.\tDo a shallow search 2.\tIf score is already huge 3.\tAssume deeper search will also fail-high 4.\tPrune immediately\nExample\nWe are searching depth 10:\nInstead of:\nsearch(move, depth=10) ‚Üí expensive We do:\nsearch(move, depth=4) if score \u003e= beta + margin: prune branch Why valid?\nBecause tactical wins rarely disappear at deeper depth.\nSo we cut based on probability.\nWhy depth matters for ProbCut\nProbCut only makes sense when:\nDepth is large enough Tactics are stable Confidence high At shallow depth ‚Üí unreliable ‚Üí disabled\nSo MovePicker uses depth to decide:\nShould we even bother generating quiet moves or just try tactical pruning?\nIntuition\nAlpha-beta pruning = mathematically safe pruning ProbCut = statistically safe pruning\n5. ttMove Move ttMove; What: Move from transposition table (best move from previous search) Why stored separately:\nHighest priority - try first (90% chance of causing cutoff) Need to avoid trying it again in later stages Need to check if it‚Äôs legal before returning it Example:\n// In search: TTEntry* tte = TT.probe(pos.key()); Move ttMove = tte ? tte-\u003emove() : MOVE_NONE; MovePicker mp(pos, ttMove, depth, ss); // First call to next_move(): Move m1 = mp.next_move(); // Returns ttMove immediately if legal Avoiding duplicates:\n// When generating captures: for (Move m : all_captures) { if (m == ttMove) continue; // Skip, already tried // ... add to list } 6. recaptureSquare Square recaptureSquare; What: Square where a piece was just captured (for recapture search) When set: In the recapture constructor\nMovePicker::MovePicker(const Position\u0026 p, Move ttm, Depth d, Square sq) : pos(p), ttMove(ttm), depth(d), recaptureSquare(sq) { // sq = square where opponent just captured } Why needed: Prioritize recaptures on that square\nExample:\nOpponent played: Nxe4 (captured our pawn on e4) recaptureSquare = e4 When scoring moves: ‚îú‚îÄ Bxe4 (recaptures on e4) ‚Üí score += 10000 (high priority!) ‚îú‚îÄ Nf3 (doesn't recapture) ‚Üí score += history[Nf3] ‚îî‚îÄ Qxe4 (recaptures on e4) ‚Üí score += 10000 Typical use case:\n// In search, after opponent captures: if (is_capture(move)) { Square capSq = to_sq(move); // Search recaptures deeply MovePicker mp(pos, ttMove, depth, capSq); } 7. threshold Value threshold; What: Minimum SEE (Static Exchange Evaluation) for captures Why needed: Filter out bad captures in quiescence search Example:\n// Quiescence constructor: MovePicker::MovePicker(const Position\u0026 p, Move ttm, Value th) : pos(p), ttMove(ttm), threshold(th) // In next_move(): Move capture = next_capture(); if (pos.see_ge(capture, threshold)) return capture; // Good capture else continue; // Skip bad capture 8. stage int stage; What: Current move generation stage (state machine) Possible values:\nenum Stage { MAIN_SEARCH, // Entry point GOOD_CAPTURES, // Return winning captures KILLERS, // Try killer moves GOOD_QUIETS, // Try quiet moves with good history BAD_CAPTURES, // Return losing captures EVASION, // In check (special) PROBCUT, // High SEE captures only QSEARCH, // Quiescence (captures only) // ... more }; Why needed: Track where we are in the move generation pipeline\nMovePicker does not generate all moves at once. Instead it produces moves step-by-step in priority order every time next_move() is called.\nSo Stages = üëâ ‚ÄúWhich category of moves should I generate/return right now?‚Äù\nThink of it like a pipeline:\nTry the most promising moves first ‚Üí maximize alpha-beta cutoffs ‚Üí avoid searching garbage moves.\n","wordCount":"4084","inLanguage":"en","datePublished":"2026-02-15T00:00:00Z","dateModified":"2026-02-15T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-15-move-picker/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Move Picker</h1><div class=post-meta><span title='2026-02-15 00:00:00 +0000 UTC'>February 15, 2026</span>&nbsp;¬∑&nbsp;20 min&nbsp;¬∑&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-02-15-move-picker.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#move-picker aria-label="Move Picker">Move Picker</a><ul><li><a href=#stats aria-label=Stats>Stats</a><ul><li><a href=#what-does-it-store aria-label="What does it Store?">What does it Store?</a><ul><li><a href=#1-movestats-countermoves aria-label="1. MoveStats (Countermoves)">1. MoveStats (Countermoves)</a></li><li><a href=#2-historystats-history-heuristic aria-label="2. HistoryStats (History Heuristic)">2. HistoryStats (History Heuristic)</a></li><li><a href=#3-countermovestats aria-label="3. CounterMoveStats">3. CounterMoveStats</a></li><li><a href=#4-countermovehistorystats-follow-up-history aria-label="4. CounterMoveHistoryStats (Follow-up History)">4. CounterMoveHistoryStats (Follow-up History)</a></li></ul></li><li><a href=#how-history-and-countermoves-are-used aria-label="How History and CounterMoves are Used?">How History and CounterMoves are Used?</a></li><li><a href=#update---decay-score-calculatio aria-label="Update - Decay Score Calculatio">Update - Decay Score Calculatio</a><ul><li><a href=#history-update-formula aria-label="History Update Formula">History Update Formula</a></li></ul></li><li><a href=#comparision-with-tt aria-label="Comparision with TT">Comparision with TT</a></li></ul></li><li><a href=#fromtostats aria-label=FromToStats>FromToStats</a><ul><li><a href=#key-difference-from-historystats aria-label="Key Difference from HistoryStats">Key Difference from HistoryStats</a><ul><li><a href=#historystats-2d aria-label="HistoryStats (2D)">HistoryStats (2D)</a></li><li><a href=#fromtostats-3d aria-label="FromToStats (3D)">FromToStats (3D)</a></li></ul></li><li><a href=#what-it-tracks aria-label="What It Tracks">What It Tracks</a><ul><li><a href=#when-fromtostats-helps aria-label="When FromToStats Helps">When FromToStats Helps</a></li></ul></li></ul></li><li><a href=#movepicker---the-move-ordering-engine aria-label="MovePicker - The Move Ordering Engine">MovePicker - The Move Ordering Engine</a><ul><li><a href=#the-big-picture aria-label="The Big Picture">The Big Picture</a></li><li><a href=#the-three-constructors aria-label="The Three Constructors">The Three Constructors</a><ul><li><a href=#constructor-1-quiescence-search aria-label="Constructor 1: Quiescence Search">Constructor 1: Quiescence Search</a></li><li><a href=#constructor-2-evasion-search aria-label="Constructor 2: Evasion Search">Constructor 2: Evasion Search</a><ul><li><a href=#why-is-depth-an-enum aria-label="Why is Depth an enum?">Why is Depth an enum?</a></li></ul></li><li><a href=#constructor-3-normal-search aria-label="Constructor 3: Normal Search">Constructor 3: Normal Search</a></li></ul></li><li><a href=#the-member-variables aria-label="The Member Variables">The Member Variables</a><ul><li><a href=#1-pos aria-label="1. pos">1. pos</a></li><li><a href=#2-ss aria-label="2. ss">2. ss</a><ul><li><a href=#what-is-inside-searchstack aria-label="What is inside Search::Stack">What is inside Search::Stack</a></li><li><a href=#1-killers2 aria-label="1. killers[2]">1. killers[2]</a></li><li><a href=#2-currentmove aria-label="2. currentMove">2. currentMove</a></li><li><a href=#3-staticeval aria-label="3. staticEval">3. staticEval</a></li><li><a href=#4-excludedmove--singular-extension-magic aria-label="4. excludedMove ‚Äî singular extension magic">4. excludedMove ‚Äî singular extension magic</a></li><li><a href=#5-ply aria-label="5. ply">5. ply</a></li><li><a href=#6-continuationhistory aria-label="6. continuationHistory">6. continuationHistory</a></li></ul></li><li><a href=#3-move-countermove aria-label="3. Move countermove">3. Move countermove</a></li><li><a href=#4-depth aria-label="4. depth">4. depth</a><ul><li><a href=#probcut aria-label=ProbCut>ProbCut</a></li></ul></li><li><a href=#5-ttmove aria-label="5. ttMove">5. ttMove</a></li><li><a href=#6-recapturesquare aria-label="6. recaptureSquare">6. recaptureSquare</a></li><li><a href=#7-threshold aria-label="7. threshold">7. threshold</a></li><li><a href=#8-stage aria-label="8. stage">8. stage</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=move-picker>Move Picker<a hidden class=anchor aria-hidden=true href=#move-picker>#</a></h1><h2 id=stats>Stats<a hidden class=anchor aria-hidden=true href=#stats>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// The Stats struct stores moves statistics. According to the template parameter
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// the class can store History and Countermoves. History records how often
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// different moves have been successful or unsuccessful during the current search
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// and is used for reduction and move ordering decisions.
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// Countermoves store the move that refute a previous one. Entries are stored
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// using only the moving piece and destination square, hence two moves with
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// different origin but same destination and piece will be considered identical.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>bool</span> CM <span style=color:#f92672>=</span> false<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Stats</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> Value Max <span style=color:#f92672>=</span> Value(<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>28</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span>[](Piece pc) <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> table[pc]; }
</span></span><span style=display:flex><span>  T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span>[](Piece pc) { <span style=color:#66d9ef>return</span> table[pc]; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>() { std<span style=color:#f92672>::</span>memset(table, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(table)); }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(Piece pc, Square to, Move m) { table[pc][to] <span style=color:#f92672>=</span> m; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(Piece pc, Square to, Value v) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (abs(<span style=color:#66d9ef>int</span>(v)) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>324</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    table[pc][to] <span style=color:#f92672>-=</span> table[pc][to] <span style=color:#f92672>*</span> abs(<span style=color:#66d9ef>int</span>(v)) <span style=color:#f92672>/</span> (CM <span style=color:#f92672>?</span> <span style=color:#ae81ff>936</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>324</span>);
</span></span><span style=display:flex><span>    table[pc][to] <span style=color:#f92672>+=</span> <span style=color:#66d9ef>int</span>(v) <span style=color:#f92672>*</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  T table[PIECE_NB][SQUARE_NB];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>Move<span style=color:#f92672>&gt;</span> MoveStats;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>Value, false<span style=color:#f92672>&gt;</span> HistoryStats;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>Value,  true<span style=color:#f92672>&gt;</span> CounterMoveStats;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>CounterMoveStats<span style=color:#f92672>&gt;</span> CounterMoveHistoryStats;
</span></span></code></pre></div><p>It is a generic 2-D table indexed by (piece, destination square)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>table[piece][to_square] <span style=color:#960050;background-color:#1e0010>‚Üí</span> learned information about that move
</span></span></code></pre></div><p>So it doesn‚Äôt care about from square.</p><p>This is intentional:
Stockfish learns ideas, not exact moves.</p><blockquote><p>‚ÄúKnight to e4 is often good in this position family‚Äù</p></blockquote><h3 id=what-does-it-store>What does it Store?<a hidden class=anchor aria-hidden=true href=#what-does-it-store>#</a></h3><p>Depends on template type T.</p><h4 id=1-movestats-countermoves>1. MoveStats (Countermoves)<a hidden class=anchor aria-hidden=true href=#1-movestats-countermoves>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>Move<span style=color:#f92672>&gt;</span> MoveStats;
</span></span></code></pre></div><p><strong>Stores:</strong> A move for each [piece][square]
<strong>Usage:</strong> &ldquo;What move refutes opponent&rsquo;s last move?&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MoveStats countermoves;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Opponent played Nf6
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We responded with d4 (good response)
</span></span></span><span style=display:flex><span>countermoves.update(BLACK_KNIGHT, SQ_F6, MOVE_D2D4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Later, opponent plays Nf6 again:
</span></span></span><span style=display:flex><span>Move response <span style=color:#f92672>=</span> countermoves[BLACK_KNIGHT][SQ_F6];
</span></span><span style=display:flex><span><span style=color:#75715e>// response = d4
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Try this first! (likely good again)
</span></span></span></code></pre></div><p>Again these are not actual moves played, because if we had already played them, we won&rsquo;t be playing them in future. These are the among the millions of possibilities examined during minmax.</p><h4 id=2-historystats-history-heuristic>2. HistoryStats (History Heuristic)<a hidden class=anchor aria-hidden=true href=#2-historystats-history-heuristic>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>Value, false<span style=color:#f92672>&gt;</span> HistoryStats;
</span></span></code></pre></div><ul><li><strong>Stores:</strong> Score (Value) for each [piece][square]</li><li><strong>Usage:</strong> &ldquo;How often has this move been good?&rdquo;</li></ul><p>Stores: [piece][square] ‚Üí scoreDoes NOT care about:</p><ul><li>‚ùå What the opponent&rsquo;s last move was.</li><li>‚ùå What position we&rsquo;re in</li><li>‚ùå What came before this move</li></ul><p>Only tracks:</p><ul><li>‚úÖ &ldquo;Has [piece to square] been good lately?&rdquo;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>HistoryStats history;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Position A: Opponent played d5
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We try Ne4 ‚Üí beta cutoff
</span></span></span><span style=display:flex><span>history.update(WHITE_KNIGHT, SQ_E4, <span style=color:#f92672>+</span><span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Position B: Opponent played c5  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We try Ne4 ‚Üí beta cutoff again
</span></span></span><span style=display:flex><span>history.update(WHITE_KNIGHT, SQ_E4, <span style=color:#f92672>+</span><span style=color:#ae81ff>36</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Position C: Opponent played Nf6
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We try Ne4 ‚Üí beta cutoff again
</span></span></span><span style=display:flex><span>history.update(WHITE_KNIGHT, SQ_E4, <span style=color:#f92672>+</span><span style=color:#ae81ff>49</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Result:
</span></span></span><span style=display:flex><span>history[WHITE_KNIGHT][SQ_E4] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span><span style=color:#f92672>+</span> (high score)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Interpretation:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Ne4 has been good in general, regardless of what opponent did. This will be the first move we try for next couple of searches even if we don&#39;t play it now.&#34;</span>
</span></span></code></pre></div><h4 id=3-countermovestats>3. CounterMoveStats<a hidden class=anchor aria-hidden=true href=#3-countermovestats>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>Value, true<span style=color:#f92672>&gt;</span> CounterMoveStats;
</span></span></code></pre></div><p>Same as HistoryStats but:</p><ul><li><code>CM = true</code> ‚Üí different decay formula</li><li>Used for countermove history (two-move patterns)</li><li>CounterMoveStats is not independently, its used by <code>CounterMoveHistoryStats</code></li></ul><h4 id=4-countermovehistorystats-follow-up-history>4. CounterMoveHistoryStats (Follow-up History)<a hidden class=anchor aria-hidden=true href=#4-countermovehistorystats-follow-up-history>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> Stats<span style=color:#f92672>&lt;</span>CounterMoveStats<span style=color:#f92672>&gt;</span> CounterMoveHistoryStats;
</span></span></code></pre></div><p><strong>This is a 4D array!</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Underlying structure:
</span></span></span><span style=display:flex><span>CounterMoveStats table[PIECE_NB][SQUARE_NB];
</span></span><span style=display:flex><span><span style=color:#75715e>//                     ‚Üì
</span></span></span><span style=display:flex><span><span style=color:#75715e>//        Value table2[PIECE_NB][SQUARE_NB];
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Final structure:
</span></span></span><span style=display:flex><span>Value table[piece1][square1][piece2][square2];
</span></span></code></pre></div><p>Usage: &ldquo;If opponent played [piece1 to square1], and we play [piece2 to square2], was that good?&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>CounterMoveHistoryStats cmHistory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Opponent: Nf6 (BLACK_KNIGHT to f6)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We: d4 (WHITE_PAWN to d4)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Result: Good! (caused cutoff)
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cmHistory[BLACK_KNIGHT][SQ_F6].update(WHITE_PAWN, SQ_D4, <span style=color:#f92672>+</span><span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Later:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We want to evaluate what if Opponent plays Nf6 again
</span></span></span><span style=display:flex><span>Value score <span style=color:#f92672>=</span> cmHistory[BLACK_KNIGHT][SQ_F6][WHITE_PAWN][SQ_D4];
</span></span><span style=display:flex><span><span style=color:#75715e>// score = 2048 (d4 was good response to Nf6 before, let&#39;s try it first)
</span></span></span></code></pre></div><h3 id=how-history-and-countermoves-are-used>How History and CounterMoves are Used?<a hidden class=anchor aria-hidden=true href=#how-history-and-countermoves-are-used>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// HISTORY (context-free):
</span></span></span><span style=display:flex><span>history[WHITE_KNIGHT][SQ_E4] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Ne4 is often good&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// COUNTERMOVE HISTORY (context-aware):
</span></span></span><span style=display:flex><span>cmh[BLACK_PAWN][SQ_D5][WHITE_KNIGHT][SQ_E4] <span style=color:#f92672>=</span> <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Ne4 is often good WHEN opponent played d5&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cmh[BLACK_KNIGHT][SQ_F6][WHITE_KNIGHT][SQ_E4] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Ne4 is often BAD WHEN opponent played Nf6&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Opponent just played Nf6
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Calculate move score for Ne4:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> score_Ne4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add general history
</span></span></span><span style=display:flex><span>score_Ne4 <span style=color:#f92672>+=</span> history[WHITE_KNIGHT][SQ_E4];          <span style=color:#75715e>// +5000
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add context-specific history
</span></span></span><span style=display:flex><span>score_Ne4 <span style=color:#f92672>+=</span> cmh[BLACK_KNIGHT][SQ_F6]               <span style=color:#75715e>// -500
</span></span></span><span style=display:flex><span>                [WHITE_KNIGHT][SQ_E4];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Total: 5000 - 500 = 4500
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Calculate for Nd4:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> score_Nd4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>score_Nd4 <span style=color:#f92672>+=</span> history[WHITE_KNIGHT][SQ_D4];          <span style=color:#75715e>// +1000
</span></span></span><span style=display:flex><span>score_Nd4 <span style=color:#f92672>+=</span> cmh[BLACK_KNIGHT][SQ_F6]               <span style=color:#75715e>// +2000
</span></span></span><span style=display:flex><span>                [WHITE_KNIGHT][SQ_D4];
</span></span><span style=display:flex><span><span style=color:#75715e>// Total: 1000 + 2000 = 3000
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Result: Try Ne4 first (4500 &gt; 3000)
</span></span></span></code></pre></div><h3 id=update---decay-score-calculatio>Update - Decay Score Calculatio<a hidden class=anchor aria-hidden=true href=#update---decay-score-calculatio>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(Piece pc, Square to, Value v) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (abs(<span style=color:#66d9ef>int</span>(v)) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>324</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    table[pc][to] <span style=color:#f92672>-=</span> table[pc][to] <span style=color:#f92672>*</span> abs(<span style=color:#66d9ef>int</span>(v)) <span style=color:#f92672>/</span> (CM <span style=color:#f92672>?</span> <span style=color:#ae81ff>936</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>324</span>);
</span></span><span style=display:flex><span>    table[pc][to] <span style=color:#f92672>+=</span> <span style=color:#66d9ef>int</span>(v) <span style=color:#f92672>*</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=history-update-formula>History Update Formula<a hidden class=anchor aria-hidden=true href=#history-update-formula>#</a></h4><p><strong>The Goal</strong></p><p>Good moves should increase their history score. Bad moves should decrease their history score.</p><p>But we need:</p><ul><li>Decay old information (recent searches more important)</li><li>Don&rsquo;t overflow (scores bounded)</li><li>Fast convergence (respond quickly to patterns)</li></ul><p><strong>Decay Intuition:</strong></p><p>Remember in both history and countermoves we don&rsquo;t store at what exact position this move was good/bad.</p><p>As game progresses</p><ul><li>The move may become not so good/bad.</li><li>Not even a legal move.</li></ul><pre tabindex=0><code>Like gravity pulling score toward zero
- Old information gradually forgotten
- Recent patterns have more weight
- Allows adaptation to changing positions
- Stable patterns reach equilibrium
</code></pre><p><strong>Decay rates:</strong></p><pre tabindex=0><code>History: 324 (faster) ‚Üí Quick adaptation
CounterMoves: 936 (slower) ‚Üí Preserve stable patterns
</code></pre><p><strong>Think of it like gravity pulling the score toward zero:</strong></p><pre tabindex=0><code>Current score: +10,000 (Ne4 was good in old searches)

New search: Ne4 is good again
Bonus: +64

Update:
‚îú‚îÄ Decay:  10,000 - (10,000 * 64 / 324) = 10,000 - 1,975 = 8,025
‚îî‚îÄ Bonus:  8,025 + (64 * 32) = 8,025 + 2,048 = 10,073

Result: Score stays high (move is still good)
</code></pre><pre tabindex=0><code>Current score: +10,000 (Ne4 was good in old searches)

New search: Ne4 is BAD now
Penalty: -64

Update:
‚îú‚îÄ Decay:  10,000 - (10,000 * 64 / 324) = 10,000 - 1,975 = 8,025
‚îî‚îÄ Penalty: 8,025 + (-64 * 32) = 8,025 - 2,048 = 5,977

Result: Score drops (adapting to new information)
</code></pre><h3 id=comparision-with-tt>Comparision with TT<a hidden class=anchor aria-hidden=true href=#comparision-with-tt>#</a></h3><p><strong>Value in Stats:</strong></p><pre tabindex=0><code>‚ùå NOT: position evaluation
‚ùå NOT: alpha/beta bounds
‚ùå NOT: SEE score

‚úÖ IS: &#34;How often was this move good?&#34; (statistical score)
</code></pre><p><strong>MoveStats vs TT:</strong></p><pre tabindex=0><code>TT:        Stores info for EXACT position (very specific)
MoveStats: Stores pattern for ANY position with this move (general)
</code></pre><p>Both used together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ae81ff>1.</span> Try TT move (best <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>this</span> exact position)
</span></span><span style=display:flex><span><span style=color:#ae81ff>2.</span> Try countermove (good pattern across positions)
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.</span> Try other moves ordered by history
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Move ordering priority:
</span></span></span><span style=display:flex><span><span style=color:#ae81ff>1.</span> TT move         <span style=color:#960050;background-color:#1e0010>‚Üê</span> Specific to <span style=color:#66d9ef>this</span> exact position (best<span style=color:#f92672>!</span>)
</span></span><span style=display:flex><span><span style=color:#ae81ff>2.</span> Countermove     <span style=color:#960050;background-color:#1e0010>‚Üê</span> General pattern (good guess)
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.</span> History         <span style=color:#960050;background-color:#1e0010>‚Üê</span> Statistical frequency
</span></span><span style=display:flex><span><span style=color:#ae81ff>4.</span> Other moves
</span></span></code></pre></div><h2 id=fromtostats>FromToStats<a hidden class=anchor aria-hidden=true href=#fromtostats>#</a></h2><p>This is like <code>HistoryStats</code>, but more specific - it tracks moves by their from-square and to-square.</p><p><strong>The Structure</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Value table[COLOR_NB][SQUARE_NB][SQUARE_NB];
</span></span><span style=display:flex><span><span style=color:#75715e>//          ‚Üë         ‚Üë           ‚Üë
</span></span></span><span style=display:flex><span><span style=color:#75715e>//        Color     From        To
</span></span></span><span style=display:flex><span><span style=color:#75715e>//        (2)       (64)        (64)
</span></span></span></code></pre></div><p>3D array: <code>[color][from_square][to_square]</code> ‚Üí score
Size: 2 √ó 64 √ó 64 = 8,192 entries</p><h3 id=key-difference-from-historystats>Key Difference from HistoryStats<a hidden class=anchor aria-hidden=true href=#key-difference-from-historystats>#</a></h3><h4 id=historystats-2d>HistoryStats (2D)<a hidden class=anchor aria-hidden=true href=#historystats-2d>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>table[piece][to_square]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example:
</span></span></span><span style=display:flex><span>history[WHITE_KNIGHT][e4]
</span></span><span style=display:flex><span><span style=color:#75715e>// &#34;Knight moves to e4&#34; (from anywhere)
</span></span></span></code></pre></div><h4 id=fromtostats-3d>FromToStats (3D)<a hidden class=anchor aria-hidden=true href=#fromtostats-3d>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>table[color][from_square][to_square]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example:
</span></span></span><span style=display:flex><span>fromTo[WHITE][f3][e4]
</span></span><span style=display:flex><span><span style=color:#75715e>// &#34;Move from f3 to e4&#34; (any piece!)
</span></span></span></code></pre></div><h3 id=what-it-tracks>What It Tracks<a hidden class=anchor aria-hidden=true href=#what-it-tracks>#</a></h3><p><strong>Less specific than HistoryStats:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>FromToStats fromToHistory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Move: Nf3-e5 (knight from f3 to e5)
</span></span></span><span style=display:flex><span>fromToHistory.update(WHITE, make_move(f3, e5), <span style=color:#f92672>+</span><span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Stored at:
</span></span></span><span style=display:flex><span>table[WHITE][f3][e5] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2048</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Later, any move f3‚Üíe5 gets this score:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - Nf3-e5 (knight) ‚úì
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - Bf3-e5 (bishop, if possible) ‚úì  
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - Even pawn f3-e5 (if legal) ‚úì
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// But NOT:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// - Nd2-e5 (different from-square) ‚úó
</span></span></span></code></pre></div><h4 id=when-fromtostats-helps>When FromToStats Helps<a hidden class=anchor aria-hidden=true href=#when-fromtostats-helps>#</a></h4><p>Captures PATH information that HistoryStats misses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Position: Knight can go to e5 from two squares
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// From f3:
</span></span></span><span style=display:flex><span>history[WHITE_KNIGHT][e5] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span>    <span style=color:#75715e>// &#34;Ne5 is good&#34;
</span></span></span><span style=display:flex><span>fromTo[WHITE][f3][e5] <span style=color:#f92672>=</span> <span style=color:#ae81ff>8000</span>        <span style=color:#75715e>// &#34;f3‚Üíe5 path is especially good!&#34;
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// From d2:
</span></span></span><span style=display:flex><span>history[WHITE_KNIGHT][e5] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span>    <span style=color:#75715e>// &#34;Ne5 is good&#34; (same!)
</span></span></span><span style=display:flex><span>fromTo[WHITE][d2][e5] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>        <span style=color:#75715e>// &#34;d2‚Üíe5 path is less good&#34;
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Result: Prefer Nf3-e5 over Nd2-e5
</span></span></span></code></pre></div><p><strong>So Which Is More Specific?</strong></p><p><strong>Neither! They&rsquo;re DIFFERENT dimensions:</strong></p><pre tabindex=0><code>HistoryStats:     PIECE-specific, PATH-agnostic
FromToStats:      PATH-specific, PIECE-agnostic

Both used together for best ordering:
score = history[piece][to] + fromTo[color][from][to]
</code></pre><p><strong>HistoryStats vs FromToStats:</strong></p><pre tabindex=0><code>HistoryStats:     [piece][to]
- Knows WHAT piece
- Doesn&#39;t know WHERE from
- &#34;Is Ne5 good?&#34;

FromToStats:      [color][from][to]
- Knows WHERE from  
- Doesn&#39;t know WHAT piece
- &#34;Is f3‚Üíe5 good?&#34;
</code></pre><p>Complementary information!</p><h2 id=movepicker---the-move-ordering-engine>MovePicker - The Move Ordering Engine<a hidden class=anchor aria-hidden=true href=#movepicker---the-move-ordering-engine>#</a></h2><p>This is the heart of move ordering in Stockfish.</p><h3 id=the-big-picture>The Big Picture<a hidden class=anchor aria-hidden=true href=#the-big-picture>#</a></h3><p><strong>Purpose:</strong> Generate moves one at a time in best-first order to maximize alpha-beta cutoffs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker <span style=color:#a6e22e>mp</span>(pos, ttMove, depth, ss);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Move m;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> ((m <span style=color:#f92672>=</span> mp.next_move()) <span style=color:#f92672>!=</span> MOVE_NONE) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Try move in best-first order
</span></span></span><span style=display:flex><span>    score <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>search(pos.do_move(m), ...);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (score <span style=color:#f92672>&gt;=</span> beta)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// Cutoff! (hopefully on first move)
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Key insight:</strong> Don&rsquo;t generate all moves at once, generate them lazily in priority order.</p><h3 id=the-three-constructors>The Three Constructors<a hidden class=anchor aria-hidden=true href=#the-three-constructors>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>, Move, Value);
</span></span><span style=display:flex><span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>, Move, Depth, Square);
</span></span><span style=display:flex><span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>, Move, Depth, Search<span style=color:#f92672>::</span>Stack<span style=color:#f92672>*</span>);
</span></span></code></pre></div><p>Three different use cases:</p><h4 id=constructor-1-quiescence-search>Constructor 1: Quiescence Search<a hidden class=anchor aria-hidden=true href=#constructor-1-quiescence-search>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Value threshold);
</span></span></code></pre></div><p><strong>Parameters:</strong></p><ul><li><code>ttm</code>: TT move (try first)</li><li><code>threshold</code>: Only generate captures with SEE ‚â• threshold</li></ul><p><strong>Used in:</strong> Quiescence search (only captures)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker <span style=color:#a6e22e>mp</span>(pos, ttMove, <span style=color:#f92672>-</span><span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// Only generate captures that don&#39;t lose &gt;1 pawn
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker<span style=color:#f92672>::</span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Value th)
</span></span><span style=display:flex><span>           <span style=color:#f92672>:</span> pos(p), threshold(th) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(<span style=color:#f92672>!</span>pos.checkers());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage <span style=color:#f92672>=</span> PROBCUT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// In ProbCut we generate captures with SEE higher than the given threshold
</span></span></span><span style=display:flex><span>  ttMove <span style=color:#f92672>=</span>   ttm
</span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> pos.pseudo_legal(ttm)
</span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> pos.capture(ttm)
</span></span><span style=display:flex><span>          <span style=color:#f92672>&amp;&amp;</span> pos.see_ge(ttm, threshold <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)<span style=color:#f92672>?</span> ttm : MOVE_NONE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stage <span style=color:#f92672>+=</span> (ttMove <span style=color:#f92672>==</span> MOVE_NONE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(<span style=color:#f92672>!</span>pos.checkers());
</span></span></code></pre></div><p><strong>What:</strong> Checks that we&rsquo;re NOT in check
<strong>Why:</strong> This constructor is for quiescence/ProbCut, which doesn&rsquo;t handle check evasions</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>stage <span style=color:#f92672>=</span> PROBCUT;
</span></span></code></pre></div><p><strong>What:</strong> Set initial stage to PROBCUT
Stage enum (approximately):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Stage</span> {
</span></span><span style=display:flex><span>    MAIN_TT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>    PROBCUT,           <span style=color:#75715e>// Only high-SEE captures
</span></span></span><span style=display:flex><span>    PROBCUT_CAPTURES,  <span style=color:#75715e>// Generate and return them
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Why PROBCUT? This constructor is used for:</p><ol><li><strong>ProbCut search</strong> (try only captures that gain material)</li><li><strong>Quiescence search</strong> (try only non-losing captures)</li></ol><p><strong>TT Move Validation (The Tricky Part)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>ttMove <span style=color:#f92672>=</span>   ttm
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span> pos.pseudo_legal(ttm)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span> pos.capture(ttm)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span> pos.see_ge(ttm, threshold <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>?</span> ttm : MOVE_NONE;
</span></span></code></pre></div><p>This is a chain of boolean conditions that must ALL be true to accept the TT move.</p><p><strong>Condition 1: ttm</strong></p><p>Check: TT move exists (not MOVE_NONE)</p><p><strong>Condition 2: pos.pseudo_legal(ttm)</strong></p><p><strong>Check:</strong> TT move is pseudo-legal in current position
<strong>Pseudo-legal</strong> means:</p><ul><li>Move syntax is valid (from/to squares exist)</li><li>Piece can make that move (e.g., knight moves like a knight)</li><li>But might leave king in check (not validated yet)</li></ul><p><strong>Condition 3: pos.capture(ttm)</strong></p><p><strong>Check:</strong> TT move is a capture
<strong>Why this check?</strong> In ProbCut/quiescence, we only want captures!</p><p><strong>Condition 4: pos.see_ge(ttm, threshold + 1)</strong></p><h4 id=constructor-2-evasion-search>Constructor 2: Evasion Search<a hidden class=anchor aria-hidden=true href=#constructor-2-evasion-search>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Depth d, Square sq);
</span></span></code></pre></div><p><strong>Parameters:</strong></p><ul><li><code>p</code>: Current position</li><li><code>ttm</code>: TT move</li><li><code>d</code>: Negative depth (quiescence depth)</li><li><code>s</code>: Recapture square (only used in one case)- Used when in check or after a capture</li></ul><p><strong>Used in:</strong> Recapture extensions, check evasions</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Opponent just captured on e4
</span></span></span><span style=display:flex><span>MovePicker <span style=color:#a6e22e>mp</span>(pos, ttMove, depth, SQ_E4);
</span></span><span style=display:flex><span><span style=color:#75715e>// Prioritize recaptures on e4
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker<span style=color:#f92672>::</span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Depth d, Square s)
</span></span><span style=display:flex><span>           <span style=color:#f92672>:</span> pos(p) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(d <span style=color:#f92672>&lt;=</span> DEPTH_ZERO);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (pos.checkers())
</span></span><span style=display:flex><span>      stage <span style=color:#f92672>=</span> EVASION;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (d <span style=color:#f92672>&gt;</span> DEPTH_QS_NO_CHECKS)
</span></span><span style=display:flex><span>      stage <span style=color:#f92672>=</span> QSEARCH_WITH_CHECKS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (d <span style=color:#f92672>&gt;</span> DEPTH_QS_RECAPTURES)
</span></span><span style=display:flex><span>      stage <span style=color:#f92672>=</span> QSEARCH_NO_CHECKS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      stage <span style=color:#f92672>=</span> QSEARCH_RECAPTURES;
</span></span><span style=display:flex><span>      recaptureSquare <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ttMove <span style=color:#f92672>=</span> ttm <span style=color:#f92672>&amp;&amp;</span> pos.pseudo_legal(ttm) <span style=color:#f92672>?</span> ttm : MOVE_NONE;
</span></span><span style=display:flex><span>  stage <span style=color:#f92672>+=</span> (ttMove <span style=color:#f92672>==</span> MOVE_NONE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Depth constants (negative values):
</span></span></span><span style=display:flex><span>DEPTH_ZERO <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>DEPTH_QS_CHECKS <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>        <span style=color:#75715e>// Try checks in quiescence
</span></span></span><span style=display:flex><span>DEPTH_QS_NO_CHECKS <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>    <span style=color:#75715e>// No checks, just captures
</span></span></span><span style=display:flex><span>DEPTH_QS_RECAPTURES <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>   <span style=color:#75715e>// Only recaptures on specific square
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Typical quiescence depths:
</span></span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>    <span style=color:#960050;background-color:#1e0010>‚Üí</span> Can <span style=color:#66d9ef>try</span> checks
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>   <span style=color:#960050;background-color:#1e0010>‚Üí</span> Only captures, no checks
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>   <span style=color:#960050;background-color:#1e0010>‚Üí</span> Only captures, no checks
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>   <span style=color:#960050;background-color:#1e0010>‚Üí</span> Only recaptures on one square
</span></span><span style=display:flex><span>d <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>7</span>   <span style=color:#960050;background-color:#1e0010>‚Üí</span> Only recaptures on one square
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(d <span style=color:#f92672>&lt;=</span> DEPTH_ZERO);
</span></span></code></pre></div><p><strong>Check:</strong> Depth must be ‚â§ 0 (quiescence depths are negative/zero)</p><p><strong>Why?</strong> This constructor is ONLY for quiescence search, which uses negative depths.</p><h5 id=why-is-depth-an-enum>Why is Depth an enum?<a hidden class=anchor aria-hidden=true href=#why-is-depth-an-enum>#</a></h5><p>Stockfish needs multiple kinds of quiescence search, not just one.</p><p>Stockfish encodes the mode inside the depth number itself.</p><blockquote><p>Negative depth = different quiescence modes</p></blockquote><p>So depth becomes a state machine.</p><p><strong>The Meaning of Each Constant</strong></p><p>Think of them as search regimes, not depths.</p><table><thead><tr><th style=text-align:left>Constant</th><th style=text-align:left>Meaning</th></tr></thead><tbody><tr><td style=text-align:left>DEPTH_ZERO</td><td style=text-align:left>transition point: start quiescence</td></tr><tr><td style=text-align:left>DEPTH_QS_CHECKS</td><td style=text-align:left>full qsearch (captures + checking moves)</td></tr><tr><td style=text-align:left>DEPTH_QS_NO_CHECKS</td><td style=text-align:left>captures only</td></tr><tr><td style=text-align:left>DEPTH_QS_RECAPTURES</td><td style=text-align:left>only recaptures on same square</td></tr><tr><td style=text-align:left>DEPTH_NONE</td><td style=text-align:left>stop search entirely</td></tr></tbody></table><p><strong>Key idea</strong></p><blockquote><p>The more negative the depth ‚Üí the quieter the search becomes</p></blockquote><p>So the engine gradually reduces tactical horizon:</p><pre tabindex=0><code>Normal search
   ‚Üì
Qsearch with checks
   ‚Üì
Qsearch captures only
   ‚Üì
Recaptures only
   ‚Üì
Stop
</code></pre><p>This is called tapered quiescence.</p><p>Instead of writing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (mode <span style=color:#f92672>==</span> QS_CHECKS) ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (mode <span style=color:#f92672>==</span> QS_CAPTURES) ...
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (mode <span style=color:#f92672>==</span> QS_RECAPTURES) ...
</span></span></code></pre></div><p>Stockfish can simply do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>depth<span style=color:#f92672>--</span>
</span></span></code></pre></div><p>and naturally transition between modes.</p><p>Search controls itself automatically.</p><p><strong>Four scenarios:</strong></p><ol><li>In check (any depth):</li></ol><ul><li>Stage: EVASION</li><li>Generates: Evasion moves only</li></ul><ol start=2><li>Depth = 0 (shallow quiescence):</li></ol><ul><li>Stage: QSEARCH_WITH_CHECKS</li><li>Generates: Captures + Checks</li></ul><ol start=3><li>Depth = -1 to -4 (normal quiescence):</li></ol><ul><li>Stage: QSEARCH_NO_CHECKS</li><li>Generates: Captures only</li></ul><ol start=4><li>Depth ‚â§ -5 (deep quiescence):</li></ol><ul><li>Stage: QSEARCH_RECAPTURES</li><li>Generates: Recaptures on square only</li><li>Early return (skips TT validation)</li></ul><p>Key insight: Deeper quiescence = more selective (prune aggressively)</p><h4 id=constructor-3-normal-search>Constructor 3: Normal Search<a hidden class=anchor aria-hidden=true href=#constructor-3-normal-search>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker<span style=color:#f92672>::</span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Depth d, Search<span style=color:#f92672>::</span>Stack<span style=color:#f92672>*</span> s)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> pos(p), ss(s), depth(d)
</span></span></code></pre></div><p><strong>Initializer list stores:</strong></p><ul><li><code>pos(p)</code>: Position reference</li><li><code>ss(s)</code>: Search stack pointer</li><li><code>depth(d)</code>: Current search depth</li></ul><p>Note: No <code>threshold</code> or <code>recaptureSquare</code> - this is full search, not quiescence!</p><p><strong>Used in:</strong> Regular alpha-beta search</p><p>Opposite of the quiescence constructor!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(d <span style=color:#f92672>&gt;</span> DEPTH_ZERO);
</span></span></code></pre></div><p>Get Previous Square</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Square prevSq <span style=color:#f92672>=</span> to_sq((ss<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>-&gt;</span>currentMove);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ss points to current ply
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ss-1 points to PARENT ply
</span></span></span></code></pre></div><p>Get Countermove</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>countermove <span style=color:#f92672>=</span> pos.this_thread()<span style=color:#f92672>-&gt;</span>counterMoves[pos.piece_on(prevSq)][prevSq];
</span></span></code></pre></div><p><strong>Three parts:</strong></p><p><code>pos.this_thread()</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Get the thread searching this position
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Each thread has its own move statistics
</span></span></span><span style=display:flex><span>Thread<span style=color:#f92672>*</span> <span style=color:#66d9ef>thread</span> <span style=color:#f92672>=</span> pos.this_thread();
</span></span></code></pre></div><p><code>pos.piece_on(prevSq)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// What piece is on the square opponent just moved to?
</span></span></span><span style=display:flex><span>Piece theirPiece <span style=color:#f92672>=</span> pos.piece_on(prevSq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Opponent played Nd4
</span></span></span><span style=display:flex><span><span style=color:#75715e>// prevSq = d4
</span></span></span><span style=display:flex><span><span style=color:#75715e>// piece_on(d4) = BLACK_KNIGHT
</span></span></span></code></pre></div><p><code>counterMoves[piece][square]</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Look up our recorded response to this move
</span></span></span><span style=display:flex><span>Move cm <span style=color:#f92672>=</span> counterMoves[BLACK_KNIGHT][d4];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// This is the move we previously found to be good
</span></span></span><span style=display:flex><span><span style=color:#75715e>// when opponent played their knight to d4
</span></span></span></code></pre></div><p>Set Stage</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>stage <span style=color:#f92672>=</span> pos.checkers() <span style=color:#f92672>?</span> EVASION : MAIN_SEARCH;
</span></span></code></pre></div><p>Two possibilities:</p><p>In Check ‚Üí EVASION</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (pos.checkers())
</span></span><span style=display:flex><span>    stage <span style=color:#f92672>=</span> EVASION;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Must get out of check!
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Generate only evasion moves
</span></span></span></code></pre></div><p>Not in Check ‚Üí MAIN_SEARCH</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    stage <span style=color:#f92672>=</span> MAIN_SEARCH;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Normal position
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Generate all moves in priority order:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// TT ‚Üí Captures ‚Üí Killers ‚Üí Countermove ‚Üí Quiets ‚Üí Bad Captures
</span></span></span></code></pre></div><p>TT Move Validation</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>ttMove <span style=color:#f92672>=</span> ttm <span style=color:#f92672>&amp;&amp;</span> pos.pseudo_legal(ttm) <span style=color:#f92672>?</span> ttm : MOVE_NONE;
</span></span></code></pre></div><p><strong>Same as quiescence constructor:</strong></p><ul><li>TT move exists?</li><li>Pseudo-legal in current position?</li></ul><p>Stage Adjustment</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>stage <span style=color:#f92672>+=</span> (ttMove <span style=color:#f92672>==</span> MOVE_NONE);
</span></span></code></pre></div><p>Same trick as other constructors:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// With valid TT move:
</span></span></span><span style=display:flex><span>stage <span style=color:#f92672>=</span> MAIN_SEARCH (e.g., <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>stage <span style=color:#f92672>+=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// = MAIN_SEARCH (try TT move first)
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Without TT move:
</span></span></span><span style=display:flex><span>stage <span style=color:#f92672>=</span> MAIN_SEARCH (<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>stage <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// = MAIN_SEARCH + 1 (skip to captures)
</span></span></span></code></pre></div><h3 id=the-member-variables>The Member Variables<a hidden class=anchor aria-hidden=true href=#the-member-variables>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos;              <span style=color:#75715e>// Current position
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Search<span style=color:#f92672>::</span>Stack<span style=color:#f92672>*</span> ss;          <span style=color:#75715e>// Search stack (killers, history)
</span></span></span><span style=display:flex><span>    Move countermove;                 <span style=color:#75715e>// Countermove to try
</span></span></span><span style=display:flex><span>    Depth depth;                      <span style=color:#75715e>// Search depth
</span></span></span><span style=display:flex><span>    Move ttMove;                      <span style=color:#75715e>// TT move (highest priority)
</span></span></span><span style=display:flex><span>    Square recaptureSquare;           <span style=color:#75715e>// For recapture prioritization
</span></span></span><span style=display:flex><span>    Value threshold;                  <span style=color:#75715e>// SEE threshold for captures
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stage;                        <span style=color:#75715e>// Current generation stage
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ExtMove <span style=color:#f92672>*</span>cur;                     <span style=color:#75715e>// Current move pointer
</span></span></span><span style=display:flex><span>    ExtMove <span style=color:#f92672>*</span>endMoves;                <span style=color:#75715e>// End of generated moves
</span></span></span><span style=display:flex><span>    ExtMove <span style=color:#f92672>*</span>endBadCaptures;          <span style=color:#75715e>// Separator for bad captures
</span></span></span><span style=display:flex><span>    ExtMove moves[MAX_MOVES];         <span style=color:#75715e>// Move buffer (218 max)
</span></span></span></code></pre></div><h4 id=1-pos>1. pos<a hidden class=anchor aria-hidden=true href=#1-pos>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos;
</span></span></code></pre></div><p><strong>What:</strong> Reference to the current chess positionWhy needed:</p><p><strong>Why needed:</strong></p><ul><li>Check if moves are legal (<code>pos.legal(move)</code>)</li><li>Get piece types (<code>pos.piece_on(square)</code>)</li><li>Generate moves (<code>generate&lt;CAPTURES>(pos, ...)</code>)</li><li>Evaluate captures with SEE (<code>pos.see_ge(move, threshold)</code>)</li></ul><h4 id=2-ss>2. ss<a hidden class=anchor aria-hidden=true href=#2-ss>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> Search<span style=color:#f92672>::</span>Stack<span style=color:#f92672>*</span> ss;
</span></span></code></pre></div><p>We previously saw another stack anemd <code>StateInfo</code>, but it was used to store board state history which wil be used to make/undo moves.</p><p><strong>Search::Stack ‚Üí search reasoning memory</strong></p><p>This is NOT about board state.</p><p>It stores what the engine learned while thinking at each ply.</p><p>Each recursive search call gets one entry:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>search(depth<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>) <span style=color:#960050;background-color:#1e0010>‚Üí</span> ss[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span> search(depth<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>) <span style=color:#960050;background-color:#1e0010>‚Üí</span> ss[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>  search(depth<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>) <span style=color:#960050;background-color:#1e0010>‚Üí</span> ss[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>   search(depth<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>) <span style=color:#960050;background-color:#1e0010>‚Üí</span> ss[<span style=color:#ae81ff>3</span>]
</span></span></code></pre></div><p>Search depth = stack depth.</p><p>So this stack represents:</p><blockquote><p>the thinking path inside the search tree</p></blockquote><h5 id=what-is-inside-searchstack>What is inside Search::Stack<a hidden class=anchor aria-hidden=true href=#what-is-inside-searchstack>#</a></h5><p><strong>Typical fields:</strong></p><pre tabindex=0><code>killers[2]          ‚Üí moves that caused cutoffs here before
currentMove         ‚Üí move being searched
staticEval          ‚Üí evaluation of this position
excludedMove        ‚Üí singular extension logic
ply                 ‚Üí distance from root
continuationHistory ‚Üí follow-up move learning
</code></pre><p>This is all heuristics ‚Äî nothing about legality of position.</p><p>A stack is initialized during the beginning of <code>search</code> function and it will be destroyed once the function exits.</p><p>However, some information is copied into global tables:</p><ul><li>history table</li><li>countermove table</li></ul><p>So the experience survives, but the stack does not.</p><h5 id=1-killers2>1. killers[2]<a hidden class=anchor aria-hidden=true href=#1-killers2>#</a></h5><p>At a given depth, positions often share tactical structure.</p><p>Example:</p><pre tabindex=0><code>You search 50 different branches at depth 8
In MANY of them the move:   Re1+   immediately refutes opponent
</code></pre><p>So next time you reach depth 8:</p><pre tabindex=0><code>try Re1+ FIRST
</code></pre><p>Because chances are high it cuts off again.</p><p>That move becomes a killer move</p><p>Why called ‚Äúkiller‚Äù?</p><p>Because it kills the branch instantly (beta cutoff).</p><p>Why two killers?</p><p>Because positions differ slightly.</p><p>Typical:</p><pre tabindex=0><code>killer1 ‚Üí most reliable
killer2 ‚Üí backup candidate
</code></pre><p>A killer move is NOT necessarily a good move in chess.</p><p>It is:</p><blockquote><p>a move that refuted opponent‚Äôs plan in many sibling nodes</p></blockquote><p>Extremely powerful heuristic.</p><p><strong>Key properties:</strong></p><ul><li>Stored <strong>per ply</strong> (depth level)</li><li>Only <strong>quiet moves</strong> (not captures)</li><li>Usually store <strong>2 killers</strong> per ply</li><li>Updated when a quiet move causes beta cutoff</li></ul><p><strong>Why Only Quiet Moves?</strong></p><p>Captures are already ordered by material logic (SEE/MVV-LVA),
killers exist to rescue quiet moves that would otherwise be searched last.</p><p><strong>Think about move ordering priorities</strong></p><p>Stockfish tries moves roughly in this order:
1. TT move (previous best)
2. Good captures
3. Killer moves
4. Countermoves
5. History quiet moves
6. Bad captures</p><h5 id=2-currentmove>2. currentMove<a hidden class=anchor aria-hidden=true href=#2-currentmove>#</a></h5><p>This stores the move played to reach this node.</p><p>Why needed?</p><p>Because many heuristics depend on previous move.</p><h5 id=3-staticeval>3. staticEval<a hidden class=anchor aria-hidden=true href=#3-staticeval>#</a></h5><p>Static evaluation = NNUE evaluation without searching.</p><p>Instead of recomputing eval again and again, we store it once in stack.</p><p>Used for:</p><ul><li>pruning decisions</li><li>futility pruning</li><li>razoring</li><li>null move pruning</li></ul><h5 id=4-excludedmove--singular-extension-magic>4. excludedMove ‚Äî singular extension magic<a hidden class=anchor aria-hidden=true href=#4-excludedmove--singular-extension-magic>#</a></h5><p>This is advanced but super important.</p><p>Singular extension asks:</p><blockquote><p>‚ÄúIs ONE move clearly much better than all others?‚Äù</p></blockquote><p>If yes ‚Üí extend search deeper for that move.</p><p>To test that, engine temporarily says:</p><pre tabindex=0><code>Search position WITHOUT best move
</code></pre><p>So we must forbid it:</p><pre tabindex=0><code>excludedMove = bestMove
</code></pre><p>Search runs again ignoring that move.</p><p>If position collapses ‚Üí the move was singular ‚Üí extend it.</p><h5 id=5-ply>5. ply<a hidden class=anchor aria-hidden=true href=#5-ply>#</a></h5><p>Needed because mate scores depend on distance.</p><p>Example:</p><pre tabindex=0><code>Mate in 5 is better than mate in 7
</code></pre><p>But raw score might be same.</p><p>So engine adjusts using ply.</p><p>Also used in:</p><ul><li>LMR reductions</li><li>pruning margins</li><li>TT storage</li></ul><h5 id=6-continuationhistory>6. continuationHistory<a hidden class=anchor aria-hidden=true href=#6-continuationhistory>#</a></h5><p>This is extremely powerful modern heuristic.</p><p>Not just:</p><blockquote><p>which move is good</p></blockquote><p>but:</p><blockquote><p>which move is good AFTER another move</p></blockquote><p>Example patterns:</p><pre tabindex=0><code>Bxh7+  ‚Üí Kg8 forced
Ng5+   ‚Üí strong followup
Qh5    ‚Üí mating attack
</code></pre><p><strong>Putting all together ‚Äî what the stack really is</strong></p><p>At each depth the engine keeps:</p><ul><li>What just happened</li><li>What worked before</li><li>What patterns exist</li><li>What position looks like</li></ul><p>So instead of blind search:</p><p>Stockfish searches informed search tree</p><h4 id=3-move-countermove>3. Move countermove<a hidden class=anchor aria-hidden=true href=#3-move-countermove>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Move countermove;
</span></span></code></pre></div><p><strong>What:</strong> The countermove to opponent&rsquo;s last move
<strong>How it&rsquo;s set:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// In constructor:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (ss <span style=color:#f92672>&amp;&amp;</span> ss<span style=color:#f92672>-&gt;</span>ply <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    Move lastMove <span style=color:#f92672>=</span> (ss<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>-&gt;</span>currentMove;  <span style=color:#75715e>// Opponent&#39;s last move
</span></span></span><span style=display:flex><span>    countermove <span style=color:#f92672>=</span> counterMoves[lastMove];  <span style=color:#75715e>// Our recorded response
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Why stored separately</strong>:</p><ul><li>Need to try it during COUNTERMOVE stage</li><li>Need to avoid trying it twice (if it&rsquo;s also killer or TT move)</li></ul><h4 id=4-depth>4. depth<a hidden class=anchor aria-hidden=true href=#4-depth>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Depth depth;
</span></span></code></pre></div><p><strong>What:</strong> Current search depth (in plies)
<strong>Why needed:</strong></p><ul><li>Decide which stages to use</li><li>At low depths, skip expensive move generation</li><li>History bonuses scale with depth</li></ul><p><strong>Example usage:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Move MovePicker<span style=color:#f92672>::</span>next_move() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// At depth &lt; 3, skip quiet moves (ProbCut)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (depth <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> ONE_PLY <span style=color:#f92672>&amp;&amp;</span> stage <span style=color:#f92672>==</span> QUIET_MOVES)
</span></span><span style=display:flex><span>        stage <span style=color:#f92672>=</span> BAD_CAPTURES;  <span style=color:#75715e>// Skip to bad captures
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// History bonus: depth¬≤
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> bonus <span style=color:#f92672>=</span> depth <span style=color:#f92672>*</span> depth;
</span></span><span style=display:flex><span>    history.update(move, bonus);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical values:</strong></p><pre tabindex=0><code>Depth 0:  Quiescence search (only captures)
Depth 1-3:  Tactical search (captures + killer moves)
Depth 4+:   Full search (all moves)
</code></pre><p>It tells the engine how reliable a move ordering decision is worth paying for.</p><p><strong>Near the leaves (small depth)</strong></p><p>Example: depth = 2 plies left</p><pre tabindex=0><code>Us ‚Üí Them ‚Üí evaluate
</code></pre><p>You will evaluate very soon anyway.</p><p>Spending time generating and sorting 40 quiet moves is wasteful.</p><p>So engine mostly tries:</p><ul><li>captures</li><li>tactical moves</li><li>maybe killers</li></ul><p>Because quiet positional moves cannot change evaluation much in 2 plies.</p><p>Deep in the tree (large depth)</p><p>Example: depth = 12 (left)</p><p>A bad move ordering here explodes the tree:</p><pre tabindex=0><code>Wrong first move ‚Üí no cutoff ‚Üí millions of nodes
Right first move ‚Üí cutoff ‚Üí tiny tree
</code></pre><p>So now it‚Äôs worth:</p><ul><li>sorting quiet moves</li><li>using history scores</li><li>more heuristics</li></ul><p><strong>That‚Äôs what this means</strong></p><blockquote><p>History bonuses scale with depth</p></blockquote><p>If a move refutes at depth 12 ‚Üí extremely important
If same move refutes at depth 2 ‚Üí almost meaningless</p><p>So Stockfish rewards it proportionally:</p><pre tabindex=0><code>bonus ‚âà depth¬≤
</code></pre><h5 id=probcut>ProbCut<a hidden class=anchor aria-hidden=true href=#probcut>#</a></h5><p>ProbCut = Probabilistic Cutoff</p><p>It is a forward pruning technique.</p><p>Meaning:</p><blockquote><p>Skip searching a branch because it‚Äôs almost certainly bad.</p></blockquote><p><strong>Idea</strong></p><p>Sometimes a move is SO winning tactically
that you don‚Äôt need a full deep search to know it fails beta.</p><p>Instead:
1. Do a shallow search
2. If score is already huge
3. Assume deeper search will also fail-high
4. Prune immediately</p><p><strong>Example</strong></p><p>We are searching depth 10:</p><p>Instead of:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>search(move, depth<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>) <span style=color:#960050;background-color:#1e0010>‚Üí</span> expensive
</span></span></code></pre></div><p>We do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>search(move, depth<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> score <span style=color:#f92672>&gt;=</span> beta <span style=color:#f92672>+</span> margin:
</span></span><span style=display:flex><span>    prune branch
</span></span></code></pre></div><p>Why valid?</p><p>Because tactical wins rarely disappear at deeper depth.</p><p>So we cut based on probability.</p><p><strong>Why depth matters for ProbCut</strong></p><p>ProbCut only makes sense when:</p><ul><li>Depth is large enough</li><li>Tactics are stable</li><li>Confidence high</li></ul><p>At shallow depth ‚Üí unreliable ‚Üí disabled</p><p>So MovePicker uses depth to decide:</p><blockquote><p>Should we even bother generating quiet moves
or just try tactical pruning?</p></blockquote><p><strong>Intuition</strong></p><p>Alpha-beta pruning = mathematically safe pruning
ProbCut = statistically safe pruning</p><h4 id=5-ttmove>5. ttMove<a hidden class=anchor aria-hidden=true href=#5-ttmove>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Move ttMove;
</span></span></code></pre></div><p><strong>What</strong>: Move from transposition table (best move from previous search)
Why stored separately:</p><ul><li><strong>Highest priority</strong> - try first (90% chance of causing cutoff)</li><li>Need to avoid trying it again in later stages</li><li>Need to check if it&rsquo;s legal before returning it</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// In search:
</span></span></span><span style=display:flex><span>TTEntry<span style=color:#f92672>*</span> tte <span style=color:#f92672>=</span> TT.probe(pos.key());
</span></span><span style=display:flex><span>Move ttMove <span style=color:#f92672>=</span> tte <span style=color:#f92672>?</span> tte<span style=color:#f92672>-&gt;</span>move() <span style=color:#f92672>:</span> MOVE_NONE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MovePicker <span style=color:#a6e22e>mp</span>(pos, ttMove, depth, ss);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// First call to next_move():
</span></span></span><span style=display:flex><span>Move m1 <span style=color:#f92672>=</span> mp.next_move();
</span></span><span style=display:flex><span><span style=color:#75715e>// Returns ttMove immediately if legal
</span></span></span></code></pre></div><p><strong>Avoiding duplicates:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// When generating captures:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (Move m : all_captures) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> ttMove)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;  <span style=color:#75715e>// Skip, already tried
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// ... add to list
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=6-recapturesquare>6. recaptureSquare<a hidden class=anchor aria-hidden=true href=#6-recapturesquare>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Square recaptureSquare;
</span></span></code></pre></div><p><strong>What:</strong> Square where a piece was just captured (for recapture search)
<strong>When set:</strong> In the recapture constructor</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>MovePicker<span style=color:#f92672>::</span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Depth d, Square sq)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> pos(p), ttMove(ttm), depth(d), recaptureSquare(sq)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// sq = square where opponent just captured
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Why needed</strong>: Prioritize recaptures on that square</p><p><strong>Example:</strong></p><pre tabindex=0><code>Opponent played: Nxe4 (captured our pawn on e4)
recaptureSquare = e4

When scoring moves:
‚îú‚îÄ Bxe4 (recaptures on e4) ‚Üí score += 10000  (high priority!)
‚îú‚îÄ Nf3 (doesn&#39;t recapture)  ‚Üí score += history[Nf3]
‚îî‚îÄ Qxe4 (recaptures on e4) ‚Üí score += 10000
</code></pre><p><strong>Typical use case:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// In search, after opponent captures:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (is_capture(move)) {
</span></span><span style=display:flex><span>    Square capSq <span style=color:#f92672>=</span> to_sq(move);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Search recaptures deeply
</span></span></span><span style=display:flex><span>    MovePicker <span style=color:#a6e22e>mp</span>(pos, ttMove, depth, capSq);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=7-threshold>7. threshold<a hidden class=anchor aria-hidden=true href=#7-threshold>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Value threshold;
</span></span></code></pre></div><p><strong>What:</strong> Minimum SEE (Static Exchange Evaluation) for captures
<strong>Why needed:</strong> Filter out bad captures in quiescence search
<strong>Example:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Quiescence constructor:
</span></span></span><span style=display:flex><span>MovePicker<span style=color:#f92672>::</span>MovePicker(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> p, Move ttm, Value th)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> pos(p), ttMove(ttm), threshold(th)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// In next_move():
</span></span></span><span style=display:flex><span>Move capture <span style=color:#f92672>=</span> next_capture();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (pos.see_ge(capture, threshold))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> capture;  <span style=color:#75715e>// Good capture
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;  <span style=color:#75715e>// Skip bad capture
</span></span></span></code></pre></div><h4 id=8-stage>8. stage<a hidden class=anchor aria-hidden=true href=#8-stage>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> stage;
</span></span></code></pre></div><p><strong>What:</strong> Current move generation stage (state machine)
<strong>Possible values:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Stage</span> {
</span></span><span style=display:flex><span>    MAIN_SEARCH,           <span style=color:#75715e>// Entry point
</span></span></span><span style=display:flex><span>    GOOD_CAPTURES,         <span style=color:#75715e>// Return winning captures
</span></span></span><span style=display:flex><span>    KILLERS,               <span style=color:#75715e>// Try killer moves
</span></span></span><span style=display:flex><span>    GOOD_QUIETS,           <span style=color:#75715e>// Try quiet moves with good history
</span></span></span><span style=display:flex><span>    BAD_CAPTURES,          <span style=color:#75715e>// Return losing captures
</span></span></span><span style=display:flex><span>    EVASION,               <span style=color:#75715e>// In check (special)
</span></span></span><span style=display:flex><span>    PROBCUT,               <span style=color:#75715e>// High SEE captures only
</span></span></span><span style=display:flex><span>    QSEARCH,               <span style=color:#75715e>// Quiescence (captures only)
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// ... more
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>Why needed:</strong> Track where we are in the move generation pipeline</p><p>MovePicker does not generate all moves at once.
Instead it produces moves step-by-step in priority order every time next_move() is called.</p><p>So Stages =
üëâ ‚ÄúWhich category of moves should I generate/return right now?‚Äù</p><p>Think of it like a pipeline:</p><blockquote><p>Try the most promising moves first ‚Üí maximize alpha-beta cutoffs ‚Üí avoid searching garbage moves.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/move-picker/>Move Picker</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>