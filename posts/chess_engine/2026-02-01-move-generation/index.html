<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Move Generation | Sanketh's Blog</title><meta name=keywords content="move generation"><meta name=description content="Move Generation
Move generation is one of the core responsibilities of a chess engine: given a Position, the engine must efficiently produce all possible moves available to the side to move.
In Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.)."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Move Generation"><meta property="og:description" content="Move Generation Move generation is one of the core responsibilities of a chess engine: given a Position, the engine must efficiently produce all possible moves available to the side to move.
In Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.)."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-01T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-01T00:00:00+00:00"><meta property="article:tag" content="Move Generation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Move Generation"><meta name=twitter:description content="Move Generation
Move generation is one of the core responsibilities of a chess engine: given a Position, the engine must efficiently produce all possible moves available to the side to move.
In Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Move Generation","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Move Generation","name":"Move Generation","description":"Move Generation Move generation is one of the core responsibilities of a chess engine: given a Position, the engine must efficiently produce all possible moves available to the side to move.\nIn Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.).\n","keywords":["move generation"],"articleBody":"Move Generation Move generation is one of the core responsibilities of a chess engine: given a Position, the engine must efficiently produce all possible moves available to the side to move.\nIn Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.).\nThe movegen.h header defines the public interface for this system:\nGenType specifies what kind of moves to generate ExtMove stores a move along with a heuristic score for move ordering generate() produces move lists using compile-time specialization MoveList provides a lightweight wrapper for iteration and convenience This module is the bridge between the board representation (Position) and the search algorithm, supplying the raw move candidates explored by alpha-beta.\nGenType enum GenType { CAPTURES, QUIETS, QUIET_CHECKS, EVASIONS, NON_EVASIONS, LEGAL }; Stockfish does not always generate all legal moves at once. Instead, it generates only the type of moves needed in a given search context.\nMeaning of Each Type CAPTURES: Generate only capturing moves (including en-passant). Used heavily in quiescence search to resolve tactical positions.\nQUIETS: Generate only non-capturing moves (normal positional moves). Used in the main search after captures are considered.\nQUIET_CHECKS: Generate quiet moves that give check. Useful in quiescence extensions, since checks can drastically change evaluation.\nEVASIONS: Generate only moves that escape check. When the king is in check, only evasions are legal.\nNON_EVASIONS: Generate all moves when not in check: captures + quiets (the normal move set).\nLEGAL: Generate the complete list of fully legal moves, filtering out illegal ones (e.g., moves leaving the king in check).\nExtMove struct ExtMove { Move move; Value value; operator Move() const { return move; } void operator=(Move m) { move = m; } }; ExtMove is an “extended move” structure used during move generation. Both Move and Value are enums.\nFields\nMove move: The actual encoded chess move (16-bit representation). Value value: A score used for move ordering (captures, killer moves, history heuristic, etc.). Stockfish generates moves along with a priority score so they can be sorted and searched in the best order.\nMoveList /// The MoveList struct is a simple wrapper around generate(). It sometimes comes /// in handy to use this class instead of the low level generate() function. template\u003cGenType T\u003e struct MoveList { explicit MoveList(const Position\u0026 pos) : last(generate\u003cT\u003e(pos, moveList)) {} const ExtMove* begin() const { return moveList; } const ExtMove* end() const { return last; } size_t size() const { return last - moveList; } bool contains(Move move) const { for (const auto\u0026 m : *this) if (m == move) return true; return false; } private: ExtMove moveList[MAX_MOVES], *last; }; MoveList is a lightweight helper class that wraps Stockfish’s low-level generate() function.\nKey Idea\nAutomatically generates all moves of type T (captures, quiets, evasions, etc.) Stores them in a fixed-size array for fast iteration private: ExtMove moveList[MAX_MOVES], *last; moveList is an array that stores generated moves last is a pointer to an ExtMove Constructor explicit MoveList(const Position\u0026 pos) : last(generate\u003cT\u003e(pos, moveList)) {} This is called a constructor initializer list.\nIt means:\nBefore the constructor body runs, initialize last with the return value of generate().\nEquivalent longer form:\nexplicit MoveList(const Position\u0026 pos) { last = generate\u003cT\u003e(pos, moveList); } Calls generate() immediately last points to the end of the generated move list Iteration Support const ExtMove* begin() const { return moveList; } const ExtMove* end() const { return last; } Makes MoveList usable in range-based loops:\nfor (const auto\u0026 m : MoveList\u003cCAPTURES\u003e(pos)) Utility Methods size_t size() const { return last - moveList; } bool contains(Move move) const { for (const auto\u0026 m : *this) if (m == move) return true; return false; } size() → number of moves generated contains(move) → checks if a move exists in the list (used for validation) Storage ExtMove moveList[MAX_MOVES]; ExtMove* last; Uses a static array (no heap allocation) Efficient and search-friendly generate_pawn_moves Pawn moves are special in chess because they have unique movement rules:\nMove forward 1 square (or 2 from starting rank) Capture diagonally Promote when reaching the 8th rank En passant capture This function generates all pawn moves for one side, depending on the requested move category:\nquiet pushes captures promotions en passant evasions (moves to escape check) quiet checks The function is templated by:\nColor Us: Which side is moving (WHITE or BLACK) GenType Type: What kind of moves to generate (CAPTURES, QUIETS, EVASIONS, etc.) The target parameter filters which destination squares are valid (used for check evasions, captures only, etc.).\nDepending on GenType, it restricts pawn moves to only squares we care about:\nCAPTURES → target = squares containing capturable enemy pieces EVASIONS → target = squares that block/capture the checking piece QUIETS / QUIET_CHECKS → target = squares where quiet pawn pushes are allowed template\u003cColor Us, GenType Type\u003e ExtMove* generate_pawn_moves(const Position\u0026 pos, ExtMove* moveList, Bitboard target) { Function template: Generate pawn moves for side Us. moveList is a pointer where we’ll write the moves, and we return the updated pointer.\nInitialization // Compute our parametrized parameters at compile time, named according to // the point of view of white side. const Color Them = (Us == WHITE ? BLACK : WHITE); const Bitboard TRank8BB = (Us == WHITE ? Rank8BB : Rank1BB); // Target promotion rank: 8th rank for WHITE, 1st rank for BLACK (where pawns promote) const Bitboard TRank7BB = (Us == WHITE ? Rank7BB : Rank2BB); // Pre-promotion rank: 7th rank for WHITE, 2nd rank for BLACK (pawns here will promote next move). const Bitboard TRank3BB = (Us == WHITE ? Rank3BB : Rank6BB); // Double-push landing rank: When a pawn moves 2 squares from its starting position, it lands here (3rd rank for WHITE, 6th for BLACK). const Square Up = (Us == WHITE ? NORTH : SOUTH); const Square Right = (Us == WHITE ? NORTH_EAST : SOUTH_WEST); const Square Left = (Us == WHITE ? NORTH_WEST : SOUTH_EAST); Bitboard emptySquares; Declare variable: Will hold bitboard of empty squares (used for pawn pushes).\nBitboard pawnsOn7 = pos.pieces(Us, PAWN) \u0026 TRank7BB; Pawns about to promote: Get all our pawns that are on the 7th rank (about to promote on next move).\nBitboard pawnsNotOn7 = pos.pieces(Us, PAWN) \u0026 ~TRank7BB; Regular pawns: Get all our pawns NOT on the 7th rank (won’t promote this move).\nBitboard enemies = (Type == EVASIONS ? pos.pieces(Them) \u0026 target: Type == CAPTURES ? target : pos.pieces(Them)); Enemy pieces to capture:\nCase 1: Type == NON_EVASIONS (normal movegen) enemies = pos.pieces(Them); Meaning:\nWe are not in check Captures can be against any enemy piece Case 2: Type == CAPTURES enemies = target; Here, target is already prepared by the caller.\nFor captures-only generation, Stockfish passes:\ntarget = pos.pieces(Them); (or sometimes only “good captures”, etc.)\nSo it says:\nDon’t recompute enemy set Just trust the filtered capture target Case 3: Type == EVASIONS (king is in check) enemies = pos.pieces(Them) \u0026 target; When in check, you cannot capture any random enemy piece.\nYou are only allowed to:\ncapture the checking piece, OR block the check, OR move king away So target here is:\nsquares that resolve the check Example:\nBlack queen is giving check on e2 Then: target = {e2} (only checking piece square) Now:\npos.pieces(Them) = all black pieces target = only squares that stop check // Single and double pawn pushes, no promotions if (Type != CAPTURES) { emptySquares = (Type == QUIETS || Type == QUIET_CHECKS ? target : ~pos.pieces()); Bitboard b1 = shift\u003cUp\u003e(pawnsNotOn7) \u0026 emptySquares; Bitboard b2 = shift\u003cUp\u003e(b1 \u0026 TRank3BB) \u0026 emptySquares; Non-capture moves section Skip this if we’re only generating captures.\n// Single and double pawn pushes, no promotions if (Type != CAPTURES) { emptySquares = (Type == QUIETS || Type == QUIET_CHECKS ? target : ~pos.pieces()); Bitboard b1 = shift\u003cUp\u003e(pawnsNotOn7) \u0026 emptySquares; Bitboard b2 = shift\u003cUp\u003e(b1 \u0026 TRank3BB) \u0026 emptySquares; Define empty squares:\nIf generating only quiet moves or quiet checks: Use target (pre-filtered valid destinations) Otherwise: All empty squares on the board (~pos.pieces() inverts the occupied bitboard) Bitboard b1 = shift\u003cUp\u003e(pawnsNotOn7) \u0026 emptySquares; Single pawn pushes: Shift all non-promoting pawns forward by one square, keep only those landing on empty squares.\nExample (WHITE):\nPawns on rank 2,3,4,5,6: Shift NORTH Filter to only empty destination squares Bitboard b2 = shift\u003cUp\u003e(b1 \u0026 TRank3BB) \u0026 emptySquares; Double pawn pushes:\nTake pawns that just pushed to rank 3 (b1 \u0026 TRank3BB) These pawns started on rank 2 (starting position) Push them forward again Keep only those landing on empty squares This ensures pawns can only double-push from their starting rank.\nif (Type == EVASIONS) // Consider only blocking squares { b1 \u0026= target; b2 \u0026= target; } Filter for evasions: If we’re in check and generating evasion moves, only keep pawn pushes that land on target squares (blocking squares or capturing the checker).\nQuiet check moves Generate pawn pushes that give check to the enemy king.\nif (Type == QUIET_CHECKS) { Square ksq = pos.square\u003cKING\u003e(Them); b1 \u0026= pos.attacks_from\u003cPAWN\u003e(ksq, Them); b2 \u0026= pos.attacks_from\u003cPAWN\u003e(ksq, Them); Square ksq = pos.square\u003cKING\u003e(Them); Get enemy king square: We need to know where the enemy king is to determine if a pawn push gives check.\nb1 \u0026= pos.attacks_from\u003cPAWN\u003e(ksq, Them); b2 \u0026= pos.attacks_from\u003cPAWN\u003e(ksq, Them); Direct pawn checks: Keep only pawn pushes that land on squares where a pawn attacks the enemy king.\nattacks_from(ksq, Them) returns squares where an enemy pawn would need to be to attack the king. If our pawn pushes there, it gives check.\nThis is the reverse lookup trick used throughout the stockfish, attacks_from(sq, BLACK) is same as attacks_to(sq, WHITE)\nDiscovered check candidates // Add pawn pushes which give discovered check. This is possible only // if the pawn is not on the same file as the enemy king, because we // don't generate captures. Note that a possible discovery check // promotion has been already generated amongst the captures. Bitboard dcCandidates = pos.discovered_check_candidates(); Get pieces that, if they move, would reveal a check from a piece behind them (e.g., pawn moves, revealing a rook/bishop attack on the king).\nIt uses blockersForKing to quickly calculate it, our pieces which are blockers for opponent’s king are discovered check candidates.\ninline Bitboard Position::discovered_check_candidates() const { return st-\u003eblockersForKing[~sideToMove] \u0026 pieces(sideToMove); } if (pawnsNotOn7 \u0026 dcCandidates) { If we have pawns (not on 7th rank) that can give discovered checks: Process them.\nBitboard dc1 = shift\u003cUp\u003e(pawnsNotOn7 \u0026 dcCandidates) \u0026 emptySquares \u0026 ~file_bb(ksq); Single-push discovered checks:\nShift discovered-check pawns forward Must land on empty squares Must NOT be on the same file as the king (~file_bb(ksq)) - if on the same file, moving wouldn’t discover Bitboard dc2 = shift\u003cUp\u003e(dc1 \u0026 TRank3BB) \u0026 emptySquares; Double-push discovered checks: Same logic as regular double pushes, but for discovered-check candidates.\nb1 |= dc1; b2 |= dc2; } } Add discovered checks to move lists: Merge discovered check moves into our existing pawn push bitboards.\nAdding Non captures to moveList while (b1) { Square to = pop_lsb(\u0026b1); *moveList++ = make_move(to - Up, to); } Generate single-push moves:\npop_lsb(\u0026b1): Extract the least significant bit (lowest square) from b1 and remove it to - Up: The origin square (one square back from destination) *moveList++ = ...: Write the move and advance the pointer while (b2) { Square to = pop_lsb(\u0026b2); *moveList++ = make_move(to - Up - Up, to); } } Generate double-push moves: Origin is two squares back (to - Up - Up).\nPromotion moves section // Promotions and underpromotions if (pawnsOn7 \u0026\u0026 (Type != EVASIONS || (target \u0026 TRank8BB))) { Only if we have pawns on the 7th rank Skip if generating evasions AND the 8th rank isn’t in target (can’t promote to block/capture) if (Type == CAPTURES) emptySquares = ~pos.pieces(); Empty squares for promotion pushes: If only generating captures, we still need to know empty squares for promotion pushes (which aren’t captures but might be needed).\nif (Type == EVASIONS) emptySquares \u0026= target; Filter empty squares for evasions: Only promotion pushes landing on target squares.\nBitboard b1 = shift\u003cRight\u003e(pawnsOn7) \u0026 enemies; Bitboard b2 = shift\u003cLeft \u003e(pawnsOn7) \u0026 enemies; Bitboard b3 = shift\u003cUp \u003e(pawnsOn7) \u0026 emptySquares; Three types of promotions:\nb1: Promote by capturing right diagonal b2: Promote by capturing left diagonal b3: Promote by pushing forward (no capture) Square ksq = pos.square\u003cKING\u003e(Them); Get enemy king square: Needed for the promotion move generator to determine if promotions give check.\nwhile (b1) moveList = make_promotions\u003cType, Right\u003e(moveList, pop_lsb(\u0026b1), ksq); while (b2) moveList = make_promotions\u003cType, Left \u003e(moveList, pop_lsb(\u0026b2), ksq); while (b3) moveList = make_promotions\u003cType, Up \u003e(moveList, pop_lsb(\u0026b3), ksq); } Generate all promotions: For each promotion square, make_promotions() generates 4 moves (Queen, Rook, Bishop, Knight) or filters based on Type. Returns the updated moveList pointer.\nRegular captures section // Standard and en-passant captures if (Type == CAPTURES || Type == EVASIONS || Type == NON_EVASIONS) { Generate non-promotion captures (we already handled promotion captures above).\nBitboard b1 = shift\u003cRight\u003e(pawnsNotOn7) \u0026 enemies; Bitboard b2 = shift\u003cLeft \u003e(pawnsNotOn7) \u0026 enemies; Diagonal captures:\nb1: Pawns that can capture to the right b2: Pawns that can capture to the left while (b1) { Square to = pop_lsb(\u0026b1); *moveList++ = make_move(to - Right, to); } while (b2) { Square to = pop_lsb(\u0026b2); *moveList++ = make_move(to - Left, to); } Generate capture moves: Origin is one diagonal square back.\nif (pos.ep_square() != SQ_NONE) { Remember epSquare is set in do_move if an en-passant oppurtunity is present.\nassert(rank_of(pos.ep_square()) == relative_rank(Us, RANK_6)); Verify en passant rank: En passant square should be on rank 6 (from our perspective). This is a sanity check.\n// An en passant capture can be an evasion only if the checking piece // is the double pushed pawn and so is in the target. Otherwise this // is a discovery check and we are forced to do otherwise. if (Type == EVASIONS \u0026\u0026 !(target \u0026 (pos.ep_square() - Up))) return moveList; En passant evasion check:\nIf generating evasions (we’re in check) The en passant capture can only help if the checking piece is the pawn that just double-pushed That pawn is at ep_square() - Up (one square behind the en passant square) If that square isn’t in target, en passant won’t help, so skip it b1 = pawnsNotOn7 \u0026 pos.attacks_from\u003cPAWN\u003e(pos.ep_square(), Them); Find pawns that can en passant: Get our pawns that can attack the en passant square (as if it were an enemy pawn).\nThis is the reverse lookup trick again, it works because epSquare is the square our pawn moves to after en-passant capture. If an enemy pawn from that location can attack any of our pawn, then en-passant is possible.\nassert(b1); Sanity check: There should always be at least one pawn that can capture en passant (otherwise the en passant square wouldn’t be set).\nwhile (b1) *moveList++ = make\u003cENPASSANT\u003e(pop_lsb(\u0026b1), pos.ep_square()); } } Generate en passant moves: Create special ENPASSANT move type for each pawn that can capture.\nreturn moveList; } Return updated pointer: The caller uses this to know where the next moves should be written.\nSummary The function generates pawn moves in this order:\nSingle and double pushes (non-promoting pawns) Promotions (pawns on 7th rank, with or without capture) Regular captures (non-promoting pawns) En passant (special capture) shift /// shift() moves a bitboard one step along direction D. Mainly for pawns template\u003cSquare D\u003e inline Bitboard shift(Bitboard b) { return D == NORTH ? b \u003c\u003c 8 : D == SOUTH ? b \u003e\u003e 8 : D == NORTH_EAST ? (b \u0026 ~FileHBB) \u003c\u003c 9 : D == SOUTH_EAST ? (b \u0026 ~FileHBB) \u003e\u003e 7 : D == NORTH_WEST ? (b \u0026 ~FileABB) \u003c\u003c 7 : D == SOUTH_WEST ? (b \u0026 ~FileABB) \u003e\u003e 9 : 0; } shift() = move a bitboard one square in some direction\nA bitboard is a 64-bit integer where each bit is a square.\nThis function shifts those bits to simulate piece movement (mainly pawns).\nHow it works\nshift\u003cNORTH\u003e(b) -\u003e b \u003c\u003c 8 Moving one rank up = shift left by 8 bits.\nshift\u003cSOUTH\u003e(b) -\u003e b \u003e\u003e 8 Moving one rank down = shift right by 8 bits.\nDiagonals (pawn captures)\nshift\u003cNORTH_EAST\u003e(b) -\u003e (b \u0026 ~FileHBB) \u003c\u003c 9 Move up + right = « 9 Mask out File H first so pieces don’t wrap from h-file to a-file. shift\u003cNORTH_WEST\u003e(b) -\u003e (b \u0026 ~FileABB) \u003c\u003c 7 Move up + left = « 7 Mask out File A to prevent wraparound. Same logic for south-east / south-west.\nmake_promotions template\u003cGenType Type, Square D\u003e ExtMove* make_promotions(ExtMove* moveList, Square to, Square ksq) { if (Type == CAPTURES || Type == EVASIONS || Type == NON_EVASIONS) *moveList++ = make\u003cPROMOTION\u003e(to - D, to, QUEEN); if (Type == QUIETS || Type == EVASIONS || Type == NON_EVASIONS) { *moveList++ = make\u003cPROMOTION\u003e(to - D, to, ROOK); *moveList++ = make\u003cPROMOTION\u003e(to - D, to, BISHOP); *moveList++ = make\u003cPROMOTION\u003e(to - D, to, KNIGHT); } // Knight promotion is the only promotion that can give a direct check // that's not already included in the queen promotion. if (Type == QUIET_CHECKS \u0026\u0026 (StepAttacksBB[W_KNIGHT][to] \u0026 ksq)) *moveList++ = make\u003cPROMOTION\u003e(to - D, to, KNIGHT); else (void)ksq; // Silence a warning under MSVC return moveList; } This function generates all promotion moves for a single pawn that’s promoting. A pawn can promote to 4 different pieces (Queen, Rook, Bishop, Knight), and this function decides which promotions to generate based on the Type parameter.\nThe D template parameter indicates the direction the pawn moved to promote (Up, Right, or Left - i.e., push forward, capture right diagonal, or capture left diagonal).\nFunction template: template\u003cGenType Type, Square D\u003e ExtMove* make_promotions(ExtMove* moveList, Square to, Square ksq) { Type: What kind of moves to generate (CAPTURES, QUIETS, etc.) D: Direction of promotion (Up = push, Right/Left = capture) to: Destination square (the promotion square on rank 8/1) ksq: Enemy king square (needed to check if knight promotion gives check) Returns: Updated moveList pointer if (Type == CAPTURES || Type == EVASIONS || Type == NON_EVASIONS) *moveList++ = make\u003cPROMOTION\u003e(to - D, to, QUEEN); Queen promotion (when capturing or all moves):\nGenerate queen promotion if we’re generating captures, evasions, or all moves to - D: Origin square (one square back in direction D) If D = Up: to - Up (one square behind) If D = Right: to - Right (one square down-left from promotion square) If D = Left: to - Left (one square down-right from promotion square) Queen promotion is included for captures because: If promotion was by capture (D = Right or Left), it’s a capturing move Queen is the most valuable piece, so always relevant for captures Underpromotions section if (Type == QUIETS || Type == EVASIONS || Type == NON_EVASIONS) { Generate promotions to pieces other than Queen.\nThese are considered “quiet” in the sense that:\nThey’re usually not tactically forcing (Queen is almost always better) But they might be needed in special positions (avoiding stalemate, giving check, etc.) *moveList++ = make\u003cPROMOTION\u003e(to - D, to, ROOK); *moveList++ = make\u003cPROMOTION\u003e(to - D, to, BISHOP); *moveList++ = make\u003cPROMOTION\u003e(to - D, to, KNIGHT); } Generate Rook, Bishop, Knight promotions: Create all three underpromotions. These are included when:\nQUIETS: Generating all quiet moves EVASIONS: In check, might need specific piece to block/capture NON_EVASIONS: Generating all legal moves (not in check) // Knight promotion is the only promotion that can give a direct check // that's not already included in the queen promotion. if (Type == QUIET_CHECKS \u0026\u0026 (StepAttacksBB[W_KNIGHT][to] \u0026 ksq)) *moveList++ = make\u003cPROMOTION\u003e(to - D, to, KNIGHT); Special case: Knight promotion giving check:\nWhen generating only quiet checks (QUIET_CHECKS):\nQueen promotions are NOT generated (already handled in capture promotions) But knight can give check in ways a queen cannot! Why knight is special:\nQueen attacks all squares a rook and bishop attack But Queen does NOT attack all squares a knight attacks (knight moves in L-shape) So knight promotion might give check when queen promotion wouldn’t else (void)ksq; // Silence a warning under MSVC Compiler warning suppression: If we’re not generating QUIET_CHECKS, the ksq parameter is unused Microsoft Visual C++ compiler warns about unused parameters (void)ksq tells the compiler “I know this is unused, it’s intentional” generate_moves This function generates moves for a specific piece type (Knight, Bishop, Rook, or Queen - NOT King or Pawn, which have their own special generators).\nThe function is templated by:\nPt: The piece type (KNIGHT, BISHOP, ROOK, or QUEEN) Checks: Whether we’re only generating moves that give check The target parameter filters which destination squares are valid (for captures only, evasions, etc.).\ntemplate\u003cPieceType Pt, bool Checks\u003e ExtMove* generate_moves(const Position\u0026 pos, ExtMove* moveList, Color us, Bitboard target) { assert(Pt != KING \u0026\u0026 Pt != PAWN); const Square* pl = pos.squares\u003cPt\u003e(us); for (Square from = *pl; from != SQ_NONE; from = *++pl) { if (Checks) { if ( (Pt == BISHOP || Pt == ROOK || Pt == QUEEN) \u0026\u0026 !(PseudoAttacks[Pt][from] \u0026 target \u0026 pos.check_squares(Pt))) continue; if (pos.discovered_check_candidates() \u0026 from) continue; } Bitboard b = pos.attacks_from\u003cPt\u003e(from) \u0026 target; if (Checks) b \u0026= pos.check_squares(Pt); while (b) *moveList++ = make_move(from, pop_lsb(\u0026b)); } return moveList; } Function template: Pt: Piece type to generate moves for Checks: If true, only generate moves that give check us: Which color is moving target: Bitboard of valid destination squares Returns: Updated moveList pointer assert(Pt != KING \u0026\u0026 Pt != PAWN); Sanity check: This function should not be called for Kings or Pawns (they have dedicated generators due to their special movement rules).\nconst Square* pl = pos.squares\u003cPt\u003e(us); Get piece list: Returns a pointer to an array of squares where our pieces of type Pt are located.\nFor example, if Pt = KNIGHT and us = WHITE, this returns a list like {b1, g1, SQ_NONE} (terminated by SQ_NONE).\nThis is more efficient than iterating through all 64 squares checking if there’s a knight.\nLoop through all pieces of this type: for (Square from = *pl; from != SQ_NONE; from = *++pl) { from = *pl: Start with the first piece’s square from != SQ_NONE: Continue until we hit the terminator from = *++pl: Pre-increment to next piece square Example iteration for WHITE knights at b1, g1:\nfrom = b1 from = g1 from = SQ_NONE → exit loop Check-giving moves If we’re only generating moves that give check, apply special filtering.\nif ( (Pt == BISHOP || Pt == ROOK || Pt == QUEEN) \u0026\u0026 !(PseudoAttacks[Pt][from] \u0026 target \u0026 pos.check_squares(Pt))) continue; Skip sliding pieces that can’t give direct check:\nBreaking this down:\n(Pt == BISHOP || Pt == ROOK || Pt == QUEEN): This is a sliding piece PseudoAttacks[Pt][from]: All squares this piece could attack (ignoring blockers) \u0026 target: Intersect with valid destination squares \u0026 pos.check_squares(Pt): Intersect with squares where this piece type would give check If this intersection is empty, the piece can’t give a direct check from this square, so skip it (continue).\nWhy only for sliding pieces?\nKnights have to be checked differently (they always move a fixed distance) Knights are handled by the later b \u0026= pos.check_squares(Pt) line if (pos.discovered_check_candidates() \u0026 from) continue; Skip discovered check candidates:\nIf this piece is a discovered check candidate (moving it would reveal a check from a piece behind it), skip it.\nWhy?\nDiscovered checks are more complex to calculate They’re handled separately or in a different part of move generation When generating only quiet checks, we want DIRECT checks, not discovered checks Bitboard b = pos.attacks_from\u003cPt\u003e(from) \u0026 target; Get all valid destination squares:\npos.attacks_from(from): All squares this piece can attack from from (considers blockers for sliding pieces) \u0026 target: Filter to only valid destinations (based on what we’re generating - captures, quiets, evasions, etc.) Example (Rook on d4):\nattacks_from(d4) = all squares on rank 4 and file d (until blocked) If target = enemy pieces (captures only), b = capturable pieces on rank 4 and file d if (Checks) b \u0026= pos.check_squares(Pt); Filter to only checking moves:\nIf we’re generating only moves that give check:\npos.check_squares(Pt): Bitboard of squares where this piece type would give check to the enemy king \u0026 b: Keep only destinations that both (a) are reachable and (b) give check Example\nattacks_from(d5) = {c3, e3, f4, f6, e7, c7, b6, b4} check_squares(KNIGHT) = squares where knight would attack e8 = {c6, d6, f6, g7, f7, c7} b = {c7, f6} (only moves that give check) while (b) *moveList++ = make_move(from, pop_lsb(\u0026b)); Generate all moves:\npop_lsb(\u0026b): Extract the least significant bit (a destination square) and remove it from b make_move(from, to): Create a move from from to this destination *moveList++ = ...: Write the move and advance pointer Loop continues until all bits in b are processed generate template\u003cGenType\u003e ExtMove* generate(const Position\u0026 pos, ExtMove* moveList); Explicit Template Instantiations // Explicit template instantiations template ExtMove* generate\u003cCAPTURES\u003e(const Position\u0026, ExtMove*); template ExtMove* generate\u003cQUIETS\u003e(const Position\u0026, ExtMove*); template ExtMove* generate\u003cNON_EVASIONS\u003e(const Position\u0026, ExtMove*); This is not a declaration - it’s actually forcing the compiler to generate code for specific template parameter values.\nWhy It’s Needed\nTemplates in C++ are “lazy” - the compiler only generates code for template instantiations that are actually used. But Stockfish has a specific reason to force these instantiations:\nWithout explicit instantiation, every .cpp file that uses eg: generate() would compile its own copy of the template code. This leads to:\nLonger compile times Larger binary size (duplicate code) Worse instruction cache performance Explicit template instantiations tells the compiler: “Generate these three versions of the function right here in movegen.cpp”\nNow other files can just call them without the compiler needing to see the template implementation.\nNotice they only instantiate CAPTURES, QUIETS, and NON_EVASIONS.\nLooking at the code, these are probably the most commonly used. Other types like EVASIONS or QUIET_CHECKS might be:\nUsed less frequently Generated on-demand when needed /// generate generates all pseudo-legal captures and queen /// promotions. Returns a pointer to the end of the move list. /// /// generate generates all pseudo-legal non-captures and /// underpromotions. Returns a pointer to the end of the move list. /// /// generate generates all pseudo-legal captures and /// non-captures. Returns a pointer to the end of the move list. template\u003cGenType Type\u003e ExtMove* generate(const Position\u0026 pos, ExtMove* moveList) { assert(Type == CAPTURES || Type == QUIETS || Type == NON_EVASIONS); assert(!pos.checkers()); Color us = pos.side_to_move(); Bitboard target = Type == CAPTURES ? pos.pieces(~us) : Type == QUIETS ? ~pos.pieces() : Type == NON_EVASIONS ? ~pos.pieces(us) : 0; return us == WHITE ? generate_all\u003cWHITE, Type\u003e(pos, moveList, target) : generate_all\u003cBLACK, Type\u003e(pos, moveList, target); } Generic entry point for normal move generation (not evasions, not legal filtering yet).\nThis generic definition is used only for 3 types of scenarios as others have specific definition.\nTarget mask Bitboard target = Type == CAPTURES ? pos.pieces(~us) : Type == QUIETS ? ~pos.pieces() : Type == NON_EVASIONS ? ~pos.pieces(us) : 0; target tells lower-level generators which destination squares are allowed.\nMode target means Result CAPTURES squares occupied by enemy only captures QUIETS empty squares only non-captures NON_EVASIONS squares NOT occupied by us captures + quiets generate /// generate generates all pseudo-legal non-captures and knight /// underpromotions that give check. Returns a pointer to the end of the move list. template\u003c\u003e ExtMove* generate\u003cQUIET_CHECKS\u003e(const Position\u0026 pos, ExtMove* moveList) { assert(!pos.checkers()); Color us = pos.side_to_move(); Bitboard dc = pos.discovered_check_candidates(); while (dc) { Square from = pop_lsb(\u0026dc); PieceType pt = type_of(pos.piece_on(from)); if (pt == PAWN) continue; // Will be generated together with direct checks Bitboard b = pos.attacks_from(Piece(pt), from) \u0026 ~pos.pieces(); if (pt == KING) b \u0026= ~PseudoAttacks[QUEEN][pos.square\u003cKING\u003e(~us)]; while (b) *moveList++ = make_move(from, pop_lsb(\u0026b)); } return us == WHITE ? generate_all\u003cWHITE, QUIET_CHECKS\u003e(pos, moveList, ~pos.pieces()) : generate_all\u003cBLACK, QUIET_CHECKS\u003e(pos, moveList, ~pos.pieces()); } /// generate generates all pseudo-legal non-captures and knight /// underpromotions that give check. Returns a pointer to the end of the move list. template\u003c\u003e ExtMove* generate\u003cQUIET_CHECKS\u003e(const Position\u0026 pos, ExtMove* moveList) { Template specialization This is a complete specialization for GenType = QUIET_CHECKS. It completely replaces any generic template implementation.\nThe \u003c\u003e after template means “this is a full specialization with no template parameters left”.\nassert(!pos.checkers()); Sanity check: We should not be in check when generating quiet checks. If we’re in check, we should be generating evasions instead. Although its possible to give check while evading enemy check, it’s considered elsewhere.\nColor us = pos.side_to_move(); `pos.checkers()` returns a bitboard of pieces giving check. It should be empty (0). Bitboard dc = pos.discovered_check_candidates(); Get discovered check candidates: Returns a bitboard of pieces that, if moved, would reveal a check from a piece behind them.\nwhile (dc) { Square from = pop_lsb(\u0026dc); PieceType pt = type_of(pos.piece_on(from)); Loop through discovered check candidates: Process each piece that can give a discovered check. Get the square of the next discovered check candidate and remove it from the bitboard. if (pt == PAWN) continue; // Will be generated together with direct checks Skip pawns: Pawn discovered checks are handled later by generate_all() because:\nPawn moves are complex (pushes, captures, promotions, en passant) They’re better handled by the specialized generate_pawn_moves() function That function already knows how to filter for checks Bitboard b = pos.attacks_from(Piece(pt), from) \u0026 ~pos.pieces(); Get quiet discovered check moves:\npos.attacks_from(Piece(pt), from): All squares this piece can attack from from \u0026 ~pos.pieces(): Filter to only empty squares (quiet moves, not captures) if (pt == KING) b \u0026= ~PseudoAttacks[QUEEN][pos.square\u003cKING\u003e(~us)]; Special case for king discovered checks:\nIf the king itself is a discovered check candidate (rare but possible), we need extra filtering:\nPseudoAttacks[QUEEN][pos.square(~us)]: All squares the enemy king can “see” (as if it were a queen - all 8 directions) ~...: Invert the bitboard b \u0026= ...: Remove these squares from valid king moves Why? Moving our king next to the enemy king would be illegal (kings can’t be adjacent). This filters out those illegal moves.\nNote: Here we are not limiting the direction of king to be 1 square, it still works because if our king is already a discovered check candidate, it cannot possibly block the ray of another sliding piece to king.\nGenerate all discovered check moves For each valid destination square, create a move and add it to the list.\nreturn us == WHITE ? generate_all\u003cWHITE, QUIET_CHECKS\u003e(pos, moveList, ~pos.pieces()) : generate_all\u003cBLACK, QUIET_CHECKS\u003e(pos, moveList, ~pos.pieces()); } Generate direct checks: After handling discovered checks, call generate_all() to generate moves that give direct checks (the moving piece itself attacks the king).\nParameters:\nTemplate: WHITE or BLACK (which side is moving) Template: QUIET_CHECKS (tells generate_all() to only generate checking moves) pos: Position moveList: Current end of move list (with discovered checks already added) ~pos.pieces(): Target bitboard = all empty squares (quiet moves only) generate This function generates all evasion moves when the king is in check. There are only 3 ways to get out of check:\nMove the king to a safe square Block the check (only works for sliding piece checks: bishop, rook, queen) Capture the checking piece The function handles these carefully, with special logic for double checks (where only king moves work).\nInitialize slider attack bitboard Will hold all squares attacked by sliding pieces (bishops, rooks, queens) that are giving check.\nBitboard sliderAttacks = 0; Bitboard sliders = pos.checkers() \u0026 ~pos.pieces(KNIGHT, PAWN); Get sliding checkers:\npos.checkers(): All pieces giving check \u0026 ~pos.pieces(KNIGHT, PAWN): Remove knights and pawns (they’re not sliders) Result: Only bishops, rooks, and queens that are giving check Why separate sliders? Because slider checks create a “ray of attack” that the king cannot move along, while knight/pawn checks don’t have this property.\nLoop through sliding checkers: // Find all the squares attacked by slider checkers. We will remove them from // the king evasions in order to skip known illegal moves, which avoids any // useless legality checks later on. while (sliders) { Square checksq = pop_lsb(\u0026sliders); sliderAttacks |= LineBB[checksq][ksq] ^ checksq; } Process each sliding piece giving check. Extract the position of the sliding checker. Add the attack ray to sliderAttacks Let me break this down:\nLineBB[checksq][ksq]: The entire line (rank, file, or diagonal) connecting the checker to our king ^ checksq: XOR (remove) the checker’s square itself from the line Why remove the checker’s square?\nBecause the king CAN capture the checking piece! We only want to exclude squares along the ray beyond the checker.\nGenerate king evasion moves // Generate evasions for king, capture and non capture moves Bitboard b = pos.attacks_from\u003cKING\u003e(ksq) \u0026 ~pos.pieces(us) \u0026 ~sliderAttacks; while (b) *moveList++ = make_move(ksq, pop_lsb(\u0026b)) Get legal king moves:\npos.attacks_from(ksq): All 8 squares around the king \u0026 ~pos.pieces(us): Can’t capture our own pieces \u0026 ~sliderAttacks: Can’t move along the slider’s attack ray For each safe square, create a king move. if (more_than_one(pos.checkers())) return moveList; // Double check, only a king move can save the day Double check special case:\nIf there are 2+ pieces giving check, the ONLY way to escape is to move the king (you can’t block two checks at once, and you can’t capture two pieces in one move).\nmore_than_one(bitboard) checks if the bitboard has more than one bit set.\n// Generate blocking evasions or captures of the checking piece Square checksq = lsb(pos.checkers()); Get the (single) checking piece’s square: Since we passed the double-check test, there’s exactly one checker. lsb() gets the least significant bit (the checker’s position).\nBitboard target = between_bb(checksq, ksq) | checksq; Calculate valid evasion squares: Pieces (other than the king) can either:\nBlock the check by moving between the checker and king Capture the checking piece between_bb(checksq, ksq): All squares between the checker and king (only non-empty for sliders) | checksq: OR with the checker’s square itself (capturing it) return us == WHITE ? generate_all\u003cWHITE, EVASIONS\u003e(pos, moveList, target) : generate_all\u003cBLACK, EVASIONS\u003e(pos, moveList, target); } Generate blocking/capturing moves:\nCall generate_all() with the target bitboard set to valid evasion squares.\nThis will generate:\nPawn moves to blocking/capturing squares Knight moves to blocking/capturing squares Bishop moves to blocking/capturing squares Rook moves to blocking/capturing squares Queen moves to blocking/capturing squares (King moves already generated above) (No castling - can’t castle out of check) The target parameter ensures pieces only move to squares that help escape check.\ngenerate_all generate_all is the central dispatcher that produces all pseudo-legal moves for one side by delegating work to specialized generators.\nIt generates moves in a fixed order: pawns → minor/major pieces → king → castling, while filtering squares using the target bitboard (captures, quiets, evasions, etc.).\nThe behavior is controlled at compile-time using templates (Color and GenType) so there are no runtime condition branches inside tight loops.\nIt focuses purely on speed and completeness — legality (king safety) is verified later, not here.\ntemplate\u003cColor Us, GenType Type\u003e ExtMove* generate_all(const Position\u0026 pos, ExtMove* moveList, Bitboard target) { const bool Checks = Type == QUIET_CHECKS; moveList = generate_pawn_moves\u003cUs, Type\u003e(pos, moveList, target); moveList = generate_moves\u003cKNIGHT, Checks\u003e(pos, moveList, Us, target); moveList = generate_moves\u003cBISHOP, Checks\u003e(pos, moveList, Us, target); moveList = generate_moves\u003c ROOK, Checks\u003e(pos, moveList, Us, target); moveList = generate_moves\u003c QUEEN, Checks\u003e(pos, moveList, Us, target); if (Type != QUIET_CHECKS \u0026\u0026 Type != EVASIONS) { Square ksq = pos.square\u003cKING\u003e(Us); Bitboard b = pos.attacks_from\u003cKING\u003e(ksq) \u0026 target; while (b) *moveList++ = make_move(ksq, pop_lsb(\u0026b)); } if (Type != CAPTURES \u0026\u0026 Type != EVASIONS \u0026\u0026 pos.can_castle(Us)) { if (pos.is_chess960()) { moveList = generate_castling\u003cMakeCastling\u003cUs, KING_SIDE\u003e::right, Checks, true\u003e(pos, moveList, Us); moveList = generate_castling\u003cMakeCastling\u003cUs, QUEEN_SIDE\u003e::right, Checks, true\u003e(pos, moveList, Us); } else { moveList = generate_castling\u003cMakeCastling\u003cUs, KING_SIDE\u003e::right, Checks, false\u003e(pos, moveList, Us); moveList = generate_castling\u003cMakeCastling\u003cUs, QUEEN_SIDE\u003e::right, Checks, false\u003e(pos, moveList, Us); } } return moveList; } const bool Checks = Type == QUIET_CHECKS; Some generators need to know whether we only want checking moves. Compile-time constant → no runtime branching inside hot loops.\nPawn moves (special case first) moveList = generate_pawn_moves\u003cUs, Type\u003e(pos, moveList, target); Pawns handled separately because they are the most complex:\npromotions double pushes en-passant discovered checks asymmetric movement Normal piece moves moveList = generate_moves\u003cKNIGHT, Checks\u003e(pos, moveList, Us, target); moveList = generate_moves\u003cBISHOP, Checks\u003e(pos, moveList, Us, target); moveList = generate_moves\u003c ROOK, Checks\u003e(pos, moveList, Us, target); moveList = generate_moves\u003c QUEEN, Checks\u003e(pos, moveList, Us, target); Generic generator reused for all non-pawn, non-king pieces.\nChecks → generate only checking moves when needed target → filters capture/quiet squares King normal moves if (Type != QUIET_CHECKS \u0026\u0026 Type != EVASIONS) { Square ksq = pos.square\u003cKING\u003e(Us); Bitboard b = pos.attacks_from\u003cKING\u003e(ksq) \u0026 target; while (b) *moveList++ = make_move(ksq, pop_lsb(\u0026b)); } King moves excluded when:\nQUIET_CHECKS: king quiet checks handled elsewhere EVASIONS: special generator required Otherwise:\nking attacks = adjacent squares \u0026 target filters captures/quiet Castling if (Type != CAPTURES \u0026\u0026 Type != EVASIONS \u0026\u0026 pos.can_castle(Us)) Castling only generated when:\nnot capture generation not in check evasions castling rights exist Chess960 vs Standard chess\nif (pos.is_chess960()) generate_castling\u003c..., true\u003e else generate_castling\u003c..., false\u003e Stockfish compiles two versions:\nnormal chess Chess960 rules No runtime branching inside generator.\nOverall structure\ngenerate_all ├─ pawns ├─ knights ├─ bishops ├─ rooks ├─ queens ├─ king moves └─ castling Each piece uses:\nbitboards target filtering compile-time specialization Key Idea\nThis function is the central move generation pipeline.\nIt does NOT check legality — only produces pseudo-legal moves efficiently.\nLegal filtering happens later.\n","wordCount":"6106","inLanguage":"en","datePublished":"2026-02-01T00:00:00Z","dateModified":"2026-02-01T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-01-move-generation/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Move Generation</h1><div class=post-meta><span title='2026-02-01 00:00:00 +0000 UTC'>February 1, 2026</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-02-01-move-generation.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#move-generation aria-label="Move Generation">Move Generation</a><ul><li><a href=#gentype aria-label=GenType>GenType</a><ul><li><a href=#meaning-of-each-type aria-label="Meaning of Each Type">Meaning of Each Type</a></li></ul></li><li><a href=#extmove aria-label=ExtMove>ExtMove</a></li><li><a href=#movelist aria-label=MoveList>MoveList</a><ul><li><a href=#constructor aria-label=Constructor>Constructor</a></li><li><a href=#iteration-support aria-label="Iteration Support">Iteration Support</a></li><li><a href=#utility-methods aria-label="Utility Methods">Utility Methods</a></li><li><a href=#storage aria-label=Storage>Storage</a></li></ul></li><li><a href=#generate_pawn_moves aria-label=generate_pawn_moves>generate_pawn_moves</a><ul><li><a href=#initialization aria-label=Initialization>Initialization</a></li><li><a href=#case-1-type--non_evasions-normal-movegen aria-label="Case 1: Type == NON_EVASIONS (normal movegen)">Case 1: Type == NON_EVASIONS (normal movegen)</a></li><li><a href=#case-2-type--captures aria-label="Case 2: Type == CAPTURES">Case 2: Type == CAPTURES</a></li><li><a href=#case-3-type--evasions-king-is-in-check aria-label="Case 3: Type == EVASIONS (king is in check)">Case 3: Type == EVASIONS (king is in check)</a></li><li><a href=#non-capture-moves-section aria-label="Non-capture moves section">Non-capture moves section</a></li><li><a href=#quiet-check-moves aria-label="Quiet check moves">Quiet check moves</a></li><li><a href=#discovered-check-candidates aria-label="Discovered check candidates">Discovered check candidates</a></li><li><a href=#adding-non-captures-to-movelist aria-label="Adding Non captures to moveList">Adding Non captures to moveList</a></li><li><a href=#promotion-moves-section aria-label="Promotion moves section">Promotion moves section</a></li><li><a href=#regular-captures-section aria-label="Regular captures section">Regular captures section</a></li></ul></li><li><a href=#shift aria-label=shift>shift</a></li><li><a href=#make_promotions aria-label=make_promotions>make_promotions</a><ul><li><a href=#function-template aria-label="Function template:">Function template:</a></li><li><a href=#underpromotions-section aria-label="Underpromotions section">Underpromotions section</a></li><li><a href=#compiler-warning-suppression aria-label="Compiler warning suppression:">Compiler warning suppression:</a></li></ul></li><li><a href=#generate_moves aria-label=generate_moves>generate_moves</a><ul><li><a href=#function-template-1 aria-label="Function template:">Function template:</a></li><li><a href=#loop-through-all-pieces-of-this-type aria-label="Loop through all pieces of this type:">Loop through all pieces of this type:</a></li><li><a href=#check-giving-moves aria-label="Check-giving moves">Check-giving moves</a></li></ul></li><li><a href=#generate aria-label=generate>generate</a><ul><li><a href=#explicit-template-instantiations aria-label="Explicit Template Instantiations">Explicit Template Instantiations</a><ul><li><a href=#target-mask aria-label="Target mask">Target mask</a></li></ul></li><li><a href=#generatequiet_checks aria-label="generate<QUIET_CHECKS>">generate&lt;QUIET_CHECKS></a><ul><li><a href=#template-specialization aria-label="Template specialization">Template specialization</a></li><li><a href=#loop-through-discovered-check-candidates aria-label="Loop through discovered check candidates:">Loop through discovered check candidates:</a></li><li><a href=#generate-all-discovered-check-moves aria-label="Generate all discovered check moves">Generate all discovered check moves</a></li></ul></li><li><a href=#generate-1 aria-label=generate>generate</a><ul><li><a href=#initialize-slider-attack-bitboard aria-label="Initialize slider attack bitboard">Initialize slider attack bitboard</a></li><li><a href=#loop-through-sliding-checkers aria-label="Loop through sliding checkers:">Loop through sliding checkers:</a></li><li><a href=#generate-king-evasion-moves aria-label="Generate king evasion moves">Generate king evasion moves</a></li><li><a href=#get-the-single-checking-pieces-square aria-label="Get the (single) checking piece&rsquo;s square:">Get the (single) checking piece&rsquo;s square:</a></li></ul></li></ul></li><li><a href=#generate_all aria-label=generate_all>generate_all</a><ul><li><a href=#pawn-moves-special-case-first aria-label="Pawn moves (special case first)">Pawn moves (special case first)</a></li><li><a href=#normal-piece-moves aria-label="Normal piece moves">Normal piece moves</a></li><li><a href=#king-normal-moves aria-label="King normal moves">King normal moves</a></li><li><a href=#castling aria-label=Castling>Castling</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=move-generation>Move Generation<a hidden class=anchor aria-hidden=true href=#move-generation>#</a></h1><p>Move generation is one of the core responsibilities of a chess engine: given a <code>Position</code>, the engine must efficiently produce all possible moves available to the side to move.</p><p>In Stockfish, move generation is designed to be extremely fast because it is executed millions of times during search. Instead of always generating every legal move, Stockfish generates different categories of moves depending on the search phase (captures only, quiet moves, evasions under check, etc.).</p><p>The <code>movegen.h</code> header defines the public interface for this system:</p><ul><li><code>GenType</code> specifies what kind of moves to generate</li><li><code>ExtMove</code> stores a move along with a heuristic score for move ordering</li><li><code>generate&lt;T>()</code> produces move lists using compile-time specialization</li><li><code>MoveList&lt;T></code> provides a lightweight wrapper for iteration and convenience</li></ul><p>This module is the bridge between the board representation (<code>Position</code>) and the search algorithm, supplying the raw move candidates explored by alpha-beta.</p><h2 id=gentype>GenType<a hidden class=anchor aria-hidden=true href=#gentype>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>GenType</span> {
</span></span><span style=display:flex><span>  CAPTURES,
</span></span><span style=display:flex><span>  QUIETS,
</span></span><span style=display:flex><span>  QUIET_CHECKS,
</span></span><span style=display:flex><span>  EVASIONS,
</span></span><span style=display:flex><span>  NON_EVASIONS,
</span></span><span style=display:flex><span>  LEGAL
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Stockfish does not always generate all legal moves at once. Instead, it generates only the type of moves needed in a given search context.</p><h3 id=meaning-of-each-type>Meaning of Each Type<a hidden class=anchor aria-hidden=true href=#meaning-of-each-type>#</a></h3><ul><li><p>CAPTURES:
Generate only capturing moves (including en-passant).
Used heavily in quiescence search to resolve tactical positions.</p></li><li><p>QUIETS:
Generate only non-capturing moves (normal positional moves).
Used in the main search after captures are considered.</p></li><li><p>QUIET_CHECKS:
Generate quiet moves that give check.
Useful in quiescence extensions, since checks can drastically change evaluation.</p></li><li><p>EVASIONS:
Generate only moves that escape check.
When the king is in check, only evasions are legal.</p></li><li><p>NON_EVASIONS:
Generate all moves when not in check:
captures + quiets (the normal move set).</p></li><li><p>LEGAL:
Generate the complete list of fully legal moves, filtering out illegal ones
(e.g., moves leaving the king in check).</p></li></ul><h2 id=extmove>ExtMove<a hidden class=anchor aria-hidden=true href=#extmove>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ExtMove</span> {
</span></span><span style=display:flex><span>  Move move;
</span></span><span style=display:flex><span>  Value value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>operator</span> <span style=color:#a6e22e>Move</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> move; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(Move m) { move <span style=color:#f92672>=</span> m; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>ExtMove is an “extended move” structure used during move generation. Both <code>Move</code> and <code>Value</code> are enums.</p><p><strong>Fields</strong></p><ul><li>Move move:
The actual encoded chess move (16-bit representation).</li><li>Value value:
A score used for move ordering (captures, killer moves, history heuristic, etc.).</li></ul><p>Stockfish generates moves along with a priority score so they can be sorted and searched in the best order.</p><h2 id=movelist>MoveList<a hidden class=anchor aria-hidden=true href=#movelist>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// The MoveList struct is a simple wrapper around generate(). It sometimes comes
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// in handy to use this class instead of the low level generate() function.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>GenType T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MoveList</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>MoveList</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos) <span style=color:#f92672>:</span> last(generate<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(pos, moveList)) {}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ExtMove<span style=color:#f92672>*</span> <span style=color:#a6e22e>begin</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> moveList; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ExtMove<span style=color:#f92672>*</span> <span style=color:#a6e22e>end</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> last; }
</span></span><span style=display:flex><span>  size_t <span style=color:#a6e22e>size</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> last <span style=color:#f92672>-</span> moveList; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>contains</span>(Move move) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> m : <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>) <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> move) <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  ExtMove moveList[MAX_MOVES], <span style=color:#f92672>*</span>last;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>MoveList</code> is a lightweight helper class that wraps Stockfish’s low-level <code>generate()</code> function.</p><p>Key Idea</p><ul><li>Automatically generates all moves of type T (captures, quiets, evasions, etc.)</li><li>Stores them in a fixed-size array for fast iteration</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  ExtMove moveList[MAX_MOVES], <span style=color:#f92672>*</span>last;
</span></span></code></pre></div><ul><li><code>moveList</code> is an array that stores generated moves</li><li><code>last</code> is a pointer to an ExtMove</li></ul><h3 id=constructor>Constructor<a hidden class=anchor aria-hidden=true href=#constructor>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>MoveList</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos)
</span></span><span style=display:flex><span>  <span style=color:#f92672>:</span> last(generate<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(pos, moveList)) {}
</span></span></code></pre></div><p>This is called a constructor initializer list.</p><p>It means:</p><blockquote><p>Before the constructor body runs, initialize last with the return value of generate<t>().</p></blockquote><p>Equivalent longer form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>MoveList</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos) {
</span></span><span style=display:flex><span>    last <span style=color:#f92672>=</span> generate<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(pos, moveList);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Calls <code>generate&lt;T>()</code> immediately</li><li><code>last</code> points to the end of the generated move list</li></ul><h3 id=iteration-support>Iteration Support<a hidden class=anchor aria-hidden=true href=#iteration-support>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ExtMove<span style=color:#f92672>*</span> <span style=color:#a6e22e>begin</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> moveList; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> ExtMove<span style=color:#f92672>*</span> <span style=color:#a6e22e>end</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> last; }
</span></span></code></pre></div><p>Makes MoveList usable in range-based loops:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> m : MoveList<span style=color:#f92672>&lt;</span>CAPTURES<span style=color:#f92672>&gt;</span>(pos))
</span></span></code></pre></div><h3 id=utility-methods>Utility Methods<a hidden class=anchor aria-hidden=true href=#utility-methods>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  size_t <span style=color:#a6e22e>size</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> last <span style=color:#f92672>-</span> moveList; }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>contains</span>(Move move) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> m : <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>) <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>==</span> move) <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li><code>size()</code> → number of moves generated</li><li><code>contains(move)</code> → checks if a move exists in the list (used for validation)</li></ul><h3 id=storage>Storage<a hidden class=anchor aria-hidden=true href=#storage>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>ExtMove moveList[MAX_MOVES];
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> last;
</span></span></code></pre></div><ul><li>Uses a static array (no heap allocation)</li><li>Efficient and search-friendly</li></ul><h2 id=generate_pawn_moves>generate_pawn_moves<a hidden class=anchor aria-hidden=true href=#generate_pawn_moves>#</a></h2><p>Pawn moves are special in chess because they have unique movement rules:</p><ul><li>Move forward 1 square (or 2 from starting rank)</li><li>Capture diagonally</li><li>Promote when reaching the 8th rank</li><li>En passant capture</li></ul><p>This function generates all pawn moves for one side, depending on the requested move category:</p><ul><li>quiet pushes</li><li>captures</li><li>promotions</li><li>en passant</li><li>evasions (moves to escape check)</li><li>quiet checks</li></ul><p>The function is templated by:</p><ul><li><code>Color Us</code>: Which side is moving (WHITE or BLACK)</li><li><code>GenType Type</code>: What kind of moves to generate (CAPTURES, QUIETS, EVASIONS, etc.)</li></ul><p>The <code>target</code> parameter filters which destination squares are valid (used for check evasions, captures only, etc.).</p><p>Depending on <code>GenType</code>, it restricts pawn moves to only squares we care about:</p><ul><li>CAPTURES → target = squares containing capturable enemy pieces</li><li>EVASIONS → target = squares that block/capture the checking piece</li><li>QUIETS / QUIET_CHECKS → target = squares where quiet pawn pushes are allowed</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>Color Us, GenType Type<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> generate_pawn_moves(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList, Bitboard target) {
</span></span></code></pre></div><p><strong>Function template:</strong> Generate pawn moves for side <code>Us</code>. <code>moveList</code> is a pointer where we&rsquo;ll write the moves, and we return the updated pointer.</p><h3 id=initialization>Initialization<a hidden class=anchor aria-hidden=true href=#initialization>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Compute our parametrized parameters at compile time, named according to
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// the point of view of white side.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Color    Them     <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> BLACK      : WHITE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Bitboard TRank8BB <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> Rank8BB    : Rank1BB); <span style=color:#75715e>// Target promotion rank: 8th rank for WHITE, 1st rank for BLACK (where pawns promote)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Bitboard TRank7BB <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> Rank7BB    : Rank2BB); <span style=color:#75715e>// Pre-promotion rank: 7th rank for WHITE, 2nd rank for BLACK (pawns here will promote next move).
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Bitboard TRank3BB <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> Rank3BB    : Rank6BB); <span style=color:#75715e>// Double-push landing rank: When a pawn moves 2 squares from its starting position, it lands here (3rd rank for WHITE, 6th for BLACK).
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Square   Up       <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> NORTH      : SOUTH);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Square   Right    <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> NORTH_EAST : SOUTH_WEST);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Square   Left     <span style=color:#f92672>=</span> (Us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> NORTH_WEST : SOUTH_EAST);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    Bitboard emptySquares;
</span></span></code></pre></div><p>Declare variable: Will hold bitboard of empty squares (used for pawn pushes).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    Bitboard pawnsOn7    <span style=color:#f92672>=</span> pos.pieces(Us, PAWN) <span style=color:#f92672>&amp;</span>  TRank7BB;
</span></span></code></pre></div><p><strong>Pawns about to promote:</strong> Get all our pawns that are on the 7th rank (about to promote on next move).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    Bitboard pawnsNotOn7 <span style=color:#f92672>=</span> pos.pieces(Us, PAWN) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>TRank7BB;
</span></span></code></pre></div><p><strong>Regular pawns:</strong> Get all our pawns NOT on the 7th rank (won&rsquo;t promote this move).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard enemies <span style=color:#f92672>=</span> (Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>?</span> pos.pieces(Them) <span style=color:#f92672>&amp;</span> target:
</span></span><span style=display:flex><span>                        Type <span style=color:#f92672>==</span> CAPTURES <span style=color:#f92672>?</span> target : pos.pieces(Them));
</span></span></code></pre></div><p>Enemy pieces to capture:</p><h3 id=case-1-type--non_evasions-normal-movegen>Case 1: Type == NON_EVASIONS (normal movegen)<a hidden class=anchor aria-hidden=true href=#case-1-type--non_evasions-normal-movegen>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>enemies <span style=color:#f92672>=</span> pos.pieces(Them);
</span></span></code></pre></div><p>Meaning:</p><ul><li>We are not in check</li><li>Captures can be against any enemy piece</li></ul><h3 id=case-2-type--captures>Case 2: Type == CAPTURES<a hidden class=anchor aria-hidden=true href=#case-2-type--captures>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>enemies <span style=color:#f92672>=</span> target;
</span></span></code></pre></div><p>Here, target is already prepared by the caller.</p><p>For captures-only generation, Stockfish passes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>target <span style=color:#f92672>=</span> pos.pieces(Them);
</span></span></code></pre></div><p>(or sometimes only “good captures”, etc.)</p><p>So it says:</p><ul><li>Don’t recompute enemy set</li><li>Just trust the filtered capture target</li></ul><h3 id=case-3-type--evasions-king-is-in-check>Case 3: Type == EVASIONS (king is in check)<a hidden class=anchor aria-hidden=true href=#case-3-type--evasions-king-is-in-check>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>enemies <span style=color:#f92672>=</span> pos.pieces(Them) <span style=color:#f92672>&amp;</span> target;
</span></span></code></pre></div><p>When in check, you cannot capture any random enemy piece.</p><p>You are only allowed to:</p><ul><li>capture the checking piece, OR</li><li>block the check, OR</li><li>move king away</li></ul><p>So target here is:</p><ul><li>squares that resolve the check</li></ul><p>Example:</p><ul><li>Black queen is giving check on e2</li><li>Then:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>target <span style=color:#f92672>=</span> {e2}  (only checking piece square)
</span></span></code></pre></div><p>Now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pos.pieces(Them) <span style=color:#f92672>=</span> all black pieces
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> only squares that stop check
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Single and double pawn pushes, no promotions
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>!=</span> CAPTURES)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        emptySquares <span style=color:#f92672>=</span> (Type <span style=color:#f92672>==</span> QUIETS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> QUIET_CHECKS <span style=color:#f92672>?</span> target : <span style=color:#f92672>~</span>pos.pieces());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Bitboard b1 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(pawnsNotOn7)   <span style=color:#f92672>&amp;</span> emptySquares;
</span></span><span style=display:flex><span>        Bitboard b2 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(b1 <span style=color:#f92672>&amp;</span> TRank3BB) <span style=color:#f92672>&amp;</span> emptySquares;
</span></span></code></pre></div><h3 id=non-capture-moves-section>Non-capture moves section<a hidden class=anchor aria-hidden=true href=#non-capture-moves-section>#</a></h3><p>Skip this if we&rsquo;re only generating captures.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Single and double pawn pushes, no promotions
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>!=</span> CAPTURES)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        emptySquares <span style=color:#f92672>=</span> (Type <span style=color:#f92672>==</span> QUIETS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> QUIET_CHECKS <span style=color:#f92672>?</span> target : <span style=color:#f92672>~</span>pos.pieces());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Bitboard b1 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(pawnsNotOn7)   <span style=color:#f92672>&amp;</span> emptySquares;
</span></span><span style=display:flex><span>        Bitboard b2 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(b1 <span style=color:#f92672>&amp;</span> TRank3BB) <span style=color:#f92672>&amp;</span> emptySquares;
</span></span></code></pre></div><p><strong>Define empty squares:</strong></p><ul><li>If generating only quiet moves or quiet checks: Use <code>target</code> (pre-filtered valid destinations)</li><li>Otherwise: All empty squares on the board (<code>~pos.pieces()</code> inverts the occupied bitboard)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        Bitboard b1 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(pawnsNotOn7)   <span style=color:#f92672>&amp;</span> emptySquares;
</span></span></code></pre></div><p><strong>Single pawn pushes:</strong> Shift all non-promoting pawns forward by one square, keep only those landing on empty squares.</p><p>Example (WHITE):</p><ul><li>Pawns on rank 2,3,4,5,6: Shift NORTH</li><li>Filter to only empty destination squares</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        Bitboard b2 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(b1 <span style=color:#f92672>&amp;</span> TRank3BB) <span style=color:#f92672>&amp;</span> emptySquares;
</span></span></code></pre></div><p><strong>Double pawn pushes:</strong></p><ul><li>Take pawns that just pushed to rank 3 (b1 & TRank3BB)</li><li>These pawns started on rank 2 (starting position)</li><li>Push them forward again</li><li>Keep only those landing on empty squares</li></ul><p>This ensures pawns can only double-push from their starting rank.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> EVASIONS) <span style=color:#75715e>// Consider only blocking squares
</span></span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            b1 <span style=color:#f92672>&amp;=</span> target;
</span></span><span style=display:flex><span>            b2 <span style=color:#f92672>&amp;=</span> target;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><strong>Filter for evasions:</strong> If we&rsquo;re in check and generating evasion moves, only keep pawn pushes that land on <code>target</code> squares (blocking squares or capturing the checker).</p><h3 id=quiet-check-moves>Quiet check moves<a hidden class=anchor aria-hidden=true href=#quiet-check-moves>#</a></h3><p>Generate pawn pushes that give check to the enemy king.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> QUIET_CHECKS)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Square ksq <span style=color:#f92672>=</span> pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(Them);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            b1 <span style=color:#f92672>&amp;=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(ksq, Them);
</span></span><span style=display:flex><span>            b2 <span style=color:#f92672>&amp;=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(ksq, Them);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            Square ksq <span style=color:#f92672>=</span> pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(Them);
</span></span></code></pre></div><p><strong>Get enemy king square:</strong> We need to know where the enemy king is to determine if a pawn push gives check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            b1 <span style=color:#f92672>&amp;=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(ksq, Them);
</span></span><span style=display:flex><span>            b2 <span style=color:#f92672>&amp;=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(ksq, Them);
</span></span></code></pre></div><p><strong>Direct pawn checks:</strong> Keep only pawn pushes that land on squares where a pawn attacks the enemy king.</p><p><code>attacks_from&lt;PAWN>(ksq, Them)</code> returns squares where an enemy pawn would need to be to attack the king. If our pawn pushes there, it gives check.</p><p>This is the reverse lookup trick used throughout the stockfish, <code>attacks_from&lt;PAWN>(sq, BLACK)</code> is same as <code>attacks_to&lt;PAWN>(sq, WHITE)</code></p><h3 id=discovered-check-candidates>Discovered check candidates<a hidden class=anchor aria-hidden=true href=#discovered-check-candidates>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            <span style=color:#75715e>// Add pawn pushes which give discovered check. This is possible only
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// if the pawn is not on the same file as the enemy king, because we
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// don&#39;t generate captures. Note that a possible discovery check
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// promotion has been already generated amongst the captures.
</span></span></span><span style=display:flex><span>            Bitboard dcCandidates <span style=color:#f92672>=</span> pos.discovered_check_candidates();
</span></span></code></pre></div><p>Get pieces that, if they move, would reveal a check from a piece behind them (e.g., pawn moves, revealing a rook/bishop attack on the king).</p><p>It uses <code>blockersForKing</code> to quickly calculate it, our pieces which are blockers for opponent&rsquo;s king are discovered check candidates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard Position<span style=color:#f92672>::</span>discovered_check_candidates() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> st<span style=color:#f92672>-&gt;</span>blockersForKing[<span style=color:#f92672>~</span>sideToMove] <span style=color:#f92672>&amp;</span> pieces(sideToMove);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pawnsNotOn7 <span style=color:#f92672>&amp;</span> dcCandidates)
</span></span><span style=display:flex><span>            {
</span></span></code></pre></div><p>If we have pawns (not on 7th rank) that can give discovered checks: Process them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>                Bitboard dc1 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(pawnsNotOn7 <span style=color:#f92672>&amp;</span> dcCandidates) <span style=color:#f92672>&amp;</span> emptySquares <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>file_bb(ksq);
</span></span></code></pre></div><p><strong>Single-push discovered checks:</strong></p><ul><li>Shift discovered-check pawns forward</li><li>Must land on empty squares</li><li>Must NOT be on the same file as the king (~file_bb(ksq)) - if on the same file, moving wouldn&rsquo;t discover</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>                Bitboard dc2 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up<span style=color:#f92672>&gt;</span>(dc1 <span style=color:#f92672>&amp;</span> TRank3BB) <span style=color:#f92672>&amp;</span> emptySquares;
</span></span></code></pre></div><p><strong>Double-push discovered checks:</strong> Same logic as regular double pushes, but for discovered-check candidates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>                b1 <span style=color:#f92672>|=</span> dc1;
</span></span><span style=display:flex><span>                b2 <span style=color:#f92672>|=</span> dc2;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><strong>Add discovered checks to move lists:</strong> Merge discovered check moves into our existing pawn push bitboards.</p><h3 id=adding-non-captures-to-movelist>Adding Non captures to moveList<a hidden class=anchor aria-hidden=true href=#adding-non-captures-to-movelist>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b1)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Square to <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b1);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(to <span style=color:#f92672>-</span> Up, to);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><strong>Generate single-push moves:</strong></p><ul><li><code>pop_lsb(&amp;b1)</code>: Extract the least significant bit (lowest square) from b1 and remove it</li><li><code>to - Up</code>: The origin square (one square back from destination)</li><li><code>*moveList++ = ...</code>: Write the move and advance the pointer</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b2)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Square to <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b2);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(to <span style=color:#f92672>-</span> Up <span style=color:#f92672>-</span> Up, to);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>Generate double-push moves</strong>: Origin is two squares back (<code>to - Up - Up</code>).</p><h3 id=promotion-moves-section>Promotion moves section<a hidden class=anchor aria-hidden=true href=#promotion-moves-section>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Promotions and underpromotions
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pawnsOn7 <span style=color:#f92672>&amp;&amp;</span> (Type <span style=color:#f92672>!=</span> EVASIONS <span style=color:#f92672>||</span> (target <span style=color:#f92672>&amp;</span> TRank8BB)))
</span></span><span style=display:flex><span>    {
</span></span></code></pre></div><ul><li>Only if we have pawns on the 7th rank</li><li>Skip if generating evasions AND the 8th rank isn&rsquo;t in target (can&rsquo;t promote to block/capture)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> CAPTURES)
</span></span><span style=display:flex><span>            emptySquares <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>pos.pieces();
</span></span></code></pre></div><p><strong>Empty squares for promotion pushes</strong>: If only generating captures, we still need to know empty squares for promotion pushes (which aren&rsquo;t captures but might be needed).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> EVASIONS)
</span></span><span style=display:flex><span>            emptySquares <span style=color:#f92672>&amp;=</span> target;
</span></span></code></pre></div><p><strong>Filter empty squares for evasions</strong>: Only promotion pushes landing on <code>target</code> squares.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        Bitboard b1 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Right<span style=color:#f92672>&gt;</span>(pawnsOn7) <span style=color:#f92672>&amp;</span> enemies;
</span></span><span style=display:flex><span>        Bitboard b2 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Left <span style=color:#f92672>&gt;</span>(pawnsOn7) <span style=color:#f92672>&amp;</span> enemies;
</span></span><span style=display:flex><span>        Bitboard b3 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Up   <span style=color:#f92672>&gt;</span>(pawnsOn7) <span style=color:#f92672>&amp;</span> emptySquares;
</span></span></code></pre></div><p>Three types of promotions:</p><ul><li><code>b1</code>: Promote by capturing right diagonal</li><li><code>b2</code>: Promote by capturing left diagonal</li><li><code>b3</code>: Promote by pushing forward (no capture)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        Square ksq <span style=color:#f92672>=</span> pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(Them);
</span></span></code></pre></div><p><strong>Get enemy king square</strong>: Needed for the promotion move generator to determine if promotions give check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b1)
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> make_promotions<span style=color:#f92672>&lt;</span>Type, Right<span style=color:#f92672>&gt;</span>(moveList, pop_lsb(<span style=color:#f92672>&amp;</span>b1), ksq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b2)
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> make_promotions<span style=color:#f92672>&lt;</span>Type, Left <span style=color:#f92672>&gt;</span>(moveList, pop_lsb(<span style=color:#f92672>&amp;</span>b2), ksq);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b3)
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> make_promotions<span style=color:#f92672>&lt;</span>Type, Up   <span style=color:#f92672>&gt;</span>(moveList, pop_lsb(<span style=color:#f92672>&amp;</span>b3), ksq);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>Generate all promotions</strong>: For each promotion square, <code>make_promotions()</code> generates 4 moves (Queen, Rook, Bishop, Knight) or filters based on Type. Returns the updated moveList pointer.</p><h3 id=regular-captures-section>Regular captures section<a hidden class=anchor aria-hidden=true href=#regular-captures-section>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Standard and en-passant captures
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> CAPTURES <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> NON_EVASIONS)
</span></span><span style=display:flex><span>    {
</span></span></code></pre></div><p>Generate non-promotion captures (we already handled promotion captures above).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        Bitboard b1 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Right<span style=color:#f92672>&gt;</span>(pawnsNotOn7) <span style=color:#f92672>&amp;</span> enemies;
</span></span><span style=display:flex><span>        Bitboard b2 <span style=color:#f92672>=</span> shift<span style=color:#f92672>&lt;</span>Left <span style=color:#f92672>&gt;</span>(pawnsNotOn7) <span style=color:#f92672>&amp;</span> enemies;
</span></span></code></pre></div><p>Diagonal captures:</p><ul><li><code>b1</code>: Pawns that can capture to the right</li><li><code>b2:</code> Pawns that can capture to the left</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b1)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Square to <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b1);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(to <span style=color:#f92672>-</span> Right, to);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b2)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Square to <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b2);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(to <span style=color:#f92672>-</span> Left, to);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><strong>Generate capture moves</strong>: Origin is one diagonal square back.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pos.ep_square() <span style=color:#f92672>!=</span> SQ_NONE)
</span></span><span style=display:flex><span>        {
</span></span></code></pre></div><p>Remember <code>epSquare</code> is set in <code>do_move</code> if an en-passant oppurtunity is present.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            assert(rank_of(pos.ep_square()) <span style=color:#f92672>==</span> relative_rank(Us, RANK_6));
</span></span></code></pre></div><p><strong>Verify en passant rank</strong>: En passant square should be on rank 6 (from our perspective). This is a sanity check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            <span style=color:#75715e>// An en passant capture can be an evasion only if the checking piece
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// is the double pushed pawn and so is in the target. Otherwise this
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// is a discovery check and we are forced to do otherwise.
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(target <span style=color:#f92672>&amp;</span> (pos.ep_square() <span style=color:#f92672>-</span> Up)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> moveList;
</span></span></code></pre></div><p>En passant evasion check:</p><ul><li>If generating evasions (we&rsquo;re in check)</li><li>The en passant capture can only help if the checking piece is the pawn that just double-pushed</li><li>That pawn is at <code>ep_square() - Up</code> (one square behind the en passant square)</li><li>If that square isn&rsquo;t in <code>target</code>, en passant won&rsquo;t help, so skip it</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            b1 <span style=color:#f92672>=</span> pawnsNotOn7 <span style=color:#f92672>&amp;</span> pos.attacks_from<span style=color:#f92672>&lt;</span>PAWN<span style=color:#f92672>&gt;</span>(pos.ep_square(), Them);
</span></span></code></pre></div><p><strong>Find pawns that can en passant</strong>: Get our pawns that can attack the en passant square (as if it were an enemy pawn).</p><p>This is the reverse lookup trick again, it works because <code>epSquare</code> is the square our pawn moves to after en-passant capture. If an enemy pawn from that location can attack any of our pawn, then en-passant is possible.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            assert(b1);
</span></span></code></pre></div><p><strong>Sanity check</strong>: There should always be at least one pawn that can capture en passant (otherwise the en passant square wouldn&rsquo;t be set).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (b1)
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>ENPASSANT<span style=color:#f92672>&gt;</span>(pop_lsb(<span style=color:#f92672>&amp;</span>b1), pos.ep_square());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>Generate en passant moves</strong>: Create special ENPASSANT move type for each pawn that can capture.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>return</span> moveList;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Return updated pointer</strong>: The caller uses this to know where the next moves should be written.</p><p>Summary
The function generates pawn moves in this order:</p><ol><li>Single and double pushes (non-promoting pawns)</li><li>Promotions (pawns on 7th rank, with or without capture)</li><li>Regular captures (non-promoting pawns)</li><li>En passant (special capture)</li></ol><h2 id=shift>shift<a hidden class=anchor aria-hidden=true href=#shift>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// shift() moves a bitboard one step along direction D. Mainly for pawns
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>Square D<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard shift(Bitboard b) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>  D <span style=color:#f92672>==</span> NORTH      <span style=color:#f92672>?</span>  b             <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>:</span> D <span style=color:#f92672>==</span> SOUTH      <span style=color:#f92672>?</span>  b             <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> D <span style=color:#f92672>==</span> NORTH_EAST <span style=color:#f92672>?</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>FileHBB) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>9</span> <span style=color:#f92672>:</span> D <span style=color:#f92672>==</span> SOUTH_EAST <span style=color:#f92672>?</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>FileHBB) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> D <span style=color:#f92672>==</span> NORTH_WEST <span style=color:#f92672>?</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>FileABB) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>:</span> D <span style=color:#f92672>==</span> SOUTH_WEST <span style=color:#f92672>?</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>FileABB) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>shift() = move a bitboard one square in some direction</p><p>A bitboard is a 64-bit integer where each bit is a square.</p><p>This function shifts those bits to simulate piece movement (mainly pawns).</p><p><strong>How it works</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>shift<span style=color:#f92672>&lt;</span>NORTH<span style=color:#f92672>&gt;</span>(b)  <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>Moving one rank up = shift left by 8 bits.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>shift<span style=color:#f92672>&lt;</span>SOUTH<span style=color:#f92672>&gt;</span>(b)  <span style=color:#f92672>-&gt;</span> b <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>Moving one rank down = shift right by 8 bits.</p><p><strong>Diagonals (pawn captures)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>shift<span style=color:#f92672>&lt;</span>NORTH_EAST<span style=color:#f92672>&gt;</span>(b) <span style=color:#f92672>-&gt;</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>FileHBB) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>9</span>
</span></span></code></pre></div><ul><li>Move up + right = &#171; 9</li><li>Mask out File H first so pieces don’t wrap from h-file to a-file.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>shift<span style=color:#f92672>&lt;</span>NORTH_WEST<span style=color:#f92672>&gt;</span>(b) <span style=color:#f92672>-&gt;</span> (b <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>FileABB) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>
</span></span></code></pre></div><ul><li>Move up + left = &#171; 7</li><li>Mask out File A to prevent wraparound.</li></ul><p>Same logic for south-east / south-west.</p><h2 id=make_promotions>make_promotions<a hidden class=anchor aria-hidden=true href=#make_promotions>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>GenType Type, Square D<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  ExtMove<span style=color:#f92672>*</span> make_promotions(ExtMove<span style=color:#f92672>*</span> moveList, Square to, Square ksq) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> CAPTURES <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> NON_EVASIONS)
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, QUEEN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> QUIETS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> NON_EVASIONS)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, ROOK);
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, BISHOP);
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, KNIGHT);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Knight promotion is the only promotion that can give a direct check
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// that&#39;s not already included in the queen promotion.
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> QUIET_CHECKS <span style=color:#f92672>&amp;&amp;</span> (StepAttacksBB[W_KNIGHT][to] <span style=color:#f92672>&amp;</span> ksq))
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, KNIGHT);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>void</span>)ksq; <span style=color:#75715e>// Silence a warning under MSVC
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> moveList;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>This function generates all promotion moves for a single pawn that&rsquo;s promoting. A pawn can promote to 4 different pieces (Queen, Rook, Bishop, Knight), and this function decides which promotions to generate based on the <code>Type</code> parameter.</p><p>The <code>D</code> template parameter indicates the direction the pawn moved to promote (Up, Right, or Left - i.e., push forward, capture right diagonal, or capture left diagonal).</p><h3 id=function-template>Function template:<a hidden class=anchor aria-hidden=true href=#function-template>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>GenType Type, Square D<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> make_promotions(ExtMove<span style=color:#f92672>*</span> moveList, Square to, Square ksq) {
</span></span></code></pre></div><ul><li><code>Type</code>: What kind of moves to generate (CAPTURES, QUIETS, etc.)</li><li><code>D</code>: Direction of promotion (Up = push, Right/Left = capture)</li><li><code>to</code>: Destination square (the promotion square on rank 8/1)</li><li><code>ksq</code>: Enemy king square (needed to check if knight promotion gives check)</li><li>Returns: Updated moveList pointer</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> CAPTURES <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> NON_EVASIONS)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, QUEEN);
</span></span></code></pre></div><p><strong>Queen promotion (when capturing or all moves):</strong></p><ul><li>Generate queen promotion if we&rsquo;re generating captures, evasions, or all moves</li><li><code>to - D</code>: Origin square (one square back in direction D)<ul><li>If<code> D = Up</code>: to - Up (one square behind)</li><li>If <code>D = Right</code>: to - Right (one square down-left from promotion square)</li><li>If<code> D = Left</code>: to - Left (one square down-right from promotion square)</li></ul></li><li>Queen promotion is included for captures because:<ul><li>If promotion was by capture (<code>D = Right</code> or <code>Left</code>), it&rsquo;s a capturing move</li><li>Queen is the most valuable piece, so always relevant for captures</li></ul></li></ul><h3 id=underpromotions-section>Underpromotions section<a hidden class=anchor aria-hidden=true href=#underpromotions-section>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> QUIETS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> EVASIONS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> NON_EVASIONS)
</span></span><span style=display:flex><span>    {
</span></span></code></pre></div><p>Generate promotions to pieces other than Queen.</p><p>These are considered &ldquo;quiet&rdquo; in the sense that:</p><ul><li>They&rsquo;re usually not tactically forcing (Queen is almost always better)</li><li>But they might be needed in special positions (avoiding stalemate, giving check, etc.)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, ROOK);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, BISHOP);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, KNIGHT);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>Generate Rook, Bishop, Knight promotions</strong>: Create all three underpromotions.
These are included when:</p><ul><li><code>QUIETS</code>: Generating all quiet moves</li><li><code>EVASIONS</code>: In check, might need specific piece to block/capture</li><li><code>NON_EVASIONS</code>: Generating all legal moves (not in check)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#75715e>// Knight promotion is the only promotion that can give a direct check
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// that&#39;s not already included in the queen promotion.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>==</span> QUIET_CHECKS <span style=color:#f92672>&amp;&amp;</span> (StepAttacksBB[W_KNIGHT][to] <span style=color:#f92672>&amp;</span> ksq))
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make<span style=color:#f92672>&lt;</span>PROMOTION<span style=color:#f92672>&gt;</span>(to <span style=color:#f92672>-</span> D, to, KNIGHT);
</span></span></code></pre></div><p><strong>Special case: Knight promotion giving check</strong>:</p><p>When generating only quiet checks (<code>QUIET_CHECKS</code>):</p><ul><li>Queen promotions are NOT generated (already handled in capture promotions)</li><li>But knight can give check in ways a queen cannot!</li></ul><p><strong>Why knight is special:</strong></p><ul><li>Queen attacks all squares a rook and bishop attack</li><li>But Queen does NOT attack all squares a knight attacks (knight moves in L-shape)</li><li>So knight promotion might give check when queen promotion wouldn&rsquo;t</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>void</span>)ksq; <span style=color:#75715e>// Silence a warning under MSVC
</span></span></span></code></pre></div><h3 id=compiler-warning-suppression>Compiler warning suppression:<a hidden class=anchor aria-hidden=true href=#compiler-warning-suppression>#</a></h3><ul><li>If we&rsquo;re not generating <code>QUIET_CHECKS</code>, the <code>ksq</code> parameter is unused</li><li>Microsoft Visual C++ compiler warns about unused parameters</li><li><code>(void)ksq</code> tells the compiler &ldquo;I know this is unused, it&rsquo;s intentional&rdquo;</li></ul><h2 id=generate_moves>generate_moves<a hidden class=anchor aria-hidden=true href=#generate_moves>#</a></h2><p>This function generates moves for a specific piece type (Knight, Bishop, Rook, or Queen - NOT King or Pawn, which have their own special generators).</p><p>The function is templated by:</p><ul><li><code>Pt</code>: The piece type (KNIGHT, BISHOP, ROOK, or QUEEN)</li><li><code>Checks</code>: Whether we&rsquo;re only generating moves that give check</li></ul><p>The <code>target</code> parameter filters which destination squares are valid (for captures only, evasions, etc.).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt, <span style=color:#66d9ef>bool</span> Checks<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  ExtMove<span style=color:#f92672>*</span> generate_moves(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList, Color us,
</span></span><span style=display:flex><span>                          Bitboard target) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert(Pt <span style=color:#f92672>!=</span> KING <span style=color:#f92672>&amp;&amp;</span> Pt <span style=color:#f92672>!=</span> PAWN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> Square<span style=color:#f92672>*</span> pl <span style=color:#f92672>=</span> pos.squares<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(us);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Square from <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>pl; from <span style=color:#f92672>!=</span> SQ_NONE; from <span style=color:#f92672>=</span> <span style=color:#f92672>*++</span>pl)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Checks)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (    (Pt <span style=color:#f92672>==</span> BISHOP <span style=color:#f92672>||</span> Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>||</span> Pt <span style=color:#f92672>==</span> QUEEN)
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(PseudoAttacks[Pt][from] <span style=color:#f92672>&amp;</span> target <span style=color:#f92672>&amp;</span> pos.check_squares(Pt)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pos.discovered_check_candidates() <span style=color:#f92672>&amp;</span> from)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Bitboard b <span style=color:#f92672>=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(from) <span style=color:#f92672>&amp;</span> target;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Checks)
</span></span><span style=display:flex><span>            b <span style=color:#f92672>&amp;=</span> pos.check_squares(Pt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(from, pop_lsb(<span style=color:#f92672>&amp;</span>b));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> moveList;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=function-template-1>Function template:<a hidden class=anchor aria-hidden=true href=#function-template-1>#</a></h3><ul><li><code>Pt</code>: Piece type to generate moves for</li><li><code>Checks</code>: If <code>true</code>, only generate moves that give check</li><li><code>us</code>: Which color is moving</li><li><code>target</code>: Bitboard of valid destination squares</li><li>Returns: Updated moveList pointer</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(Pt <span style=color:#f92672>!=</span> KING <span style=color:#f92672>&amp;&amp;</span> Pt <span style=color:#f92672>!=</span> PAWN);
</span></span></code></pre></div><p><strong>Sanity check</strong>: This function should not be called for Kings or Pawns (they have dedicated generators due to their special movement rules).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> Square<span style=color:#f92672>*</span> pl <span style=color:#f92672>=</span> pos.squares<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(us);
</span></span></code></pre></div><p><strong>Get piece list:</strong> Returns a pointer to an array of squares where our pieces of type <code>Pt</code> are located.</p><p>For example, if <code>Pt = KNIGHT</code> and <code>us = WHITE</code>, this returns a list like <code>{b1, g1, SQ_NONE}</code> (terminated by <code>SQ_NONE</code>).</p><p>This is more efficient than iterating through all 64 squares checking if there&rsquo;s a knight.</p><h3 id=loop-through-all-pieces-of-this-type>Loop through all pieces of this type:<a hidden class=anchor aria-hidden=true href=#loop-through-all-pieces-of-this-type>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (Square from <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>pl; from <span style=color:#f92672>!=</span> SQ_NONE; from <span style=color:#f92672>=</span> <span style=color:#f92672>*++</span>pl)
</span></span><span style=display:flex><span>    {
</span></span></code></pre></div><ul><li><code>from = *pl</code>: Start with the first piece&rsquo;s square</li><li><code>from != SQ_NONE</code>: Continue until we hit the terminator</li><li><code>from = *++pl</code>: Pre-increment to next piece square</li></ul><p>Example iteration for WHITE knights at b1, g1:</p><ol><li><code>from = b1</code></li><li><code>from = g1</code></li><li><code>from = SQ_NONE</code> → exit loop</li></ol><h3 id=check-giving-moves>Check-giving moves<a hidden class=anchor aria-hidden=true href=#check-giving-moves>#</a></h3><p>If we&rsquo;re only generating moves that give check, apply special filtering.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (    (Pt <span style=color:#f92672>==</span> BISHOP <span style=color:#f92672>||</span> Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>||</span> Pt <span style=color:#f92672>==</span> QUEEN)
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(PseudoAttacks[Pt][from] <span style=color:#f92672>&amp;</span> target <span style=color:#f92672>&amp;</span> pos.check_squares(Pt)))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;
</span></span></code></pre></div><p><strong>Skip sliding pieces that can&rsquo;t give direct check</strong>:</p><p>Breaking this down:</p><ul><li><code>(Pt == BISHOP || Pt == ROOK || Pt == QUEEN)</code>: This is a sliding piece</li><li><code>PseudoAttacks[Pt][from]</code>: All squares this piece could attack (ignoring blockers)</li><li><code>& target</code>: Intersect with valid destination squares</li><li><code>& pos.check_squares(Pt)</code>: Intersect with squares where this piece type would give check</li></ul><p>If this intersection is empty, the piece can&rsquo;t give a direct check from this square, so skip it (<code>continue</code>).</p><p><strong>Why only for sliding pieces?</strong></p><ul><li>Knights have to be checked differently (they always move a fixed distance)</li><li>Knights are handled by the later <code>b &= pos.check_squares(Pt)</code> line</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (pos.discovered_check_candidates() <span style=color:#f92672>&amp;</span> from)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;
</span></span></code></pre></div><p><strong>Skip discovered check candidates</strong>:</p><p>If this piece is a discovered check candidate (moving it would reveal a check from a piece behind it), skip it.</p><p><strong>Why?</strong></p><ul><li>Discovered checks are more complex to calculate</li><li>They&rsquo;re handled separately or in a different part of move generation</li><li>When generating only quiet checks, we want DIRECT checks, not discovered checks</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard b <span style=color:#f92672>=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(from) <span style=color:#f92672>&amp;</span> target;
</span></span></code></pre></div><p>Get all valid destination squares:</p><ul><li><code>pos.attacks_from&lt;Pt>(from)</code>: All squares this piece can attack from <code>from</code> (considers blockers for sliding pieces)</li><li><code>& target</code>: Filter to only valid destinations (based on what we&rsquo;re generating - captures, quiets, evasions, etc.)</li></ul><p>Example (Rook on d4):</p><ul><li><code>attacks_from&lt;ROOK>(d4)</code> = all squares on rank 4 and file d (until blocked)</li><li>If <code>target</code> = enemy pieces (captures only), b = capturable pieces on rank 4 and file d</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (Checks)
</span></span><span style=display:flex><span>    b <span style=color:#f92672>&amp;=</span> pos.check_squares(Pt);
</span></span></code></pre></div><p><strong>Filter to only checking moves</strong>:</p><p>If we&rsquo;re generating only moves that give check:</p><ul><li><code>pos.check_squares(Pt)</code>: Bitboard of squares where this piece type would give check to the enemy king</li><li><code>& b</code>: Keep only destinations that both (a) are reachable and (b) give check</li></ul><p>Example</p><ul><li><code>attacks_from&lt;KNIGHT>(d5)</code> = {c3, e3, f4, f6, e7, c7, b6, b4}</li><li><code>check_squares(KNIGHT)</code> = squares where knight would attack e8 = {c6, d6, f6, g7, f7, c7}</li><li><code>b = {c7, f6}</code> (only moves that give check)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(from, pop_lsb(<span style=color:#f92672>&amp;</span>b));
</span></span></code></pre></div><p><strong>Generate all moves</strong>:</p><ul><li><code>pop_lsb(&amp;b)</code>: Extract the least significant bit (a destination square) and remove it from b</li><li><code>make_move(from, to)</code>: Create a move from from to this destination</li><li><code>*moveList++ = ...</code>: Write the move and advance pointer
Loop continues until all bits in b are processed</li></ul><h2 id=generate>generate<a hidden class=anchor aria-hidden=true href=#generate>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>GenType<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> generate(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList);
</span></span></code></pre></div><h3 id=explicit-template-instantiations>Explicit Template Instantiations<a hidden class=anchor aria-hidden=true href=#explicit-template-instantiations>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Explicit template instantiations
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> ExtMove<span style=color:#f92672>*</span> generate<span style=color:#f92672>&lt;</span>CAPTURES<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>, ExtMove<span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> ExtMove<span style=color:#f92672>*</span> generate<span style=color:#f92672>&lt;</span>QUIETS<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>, ExtMove<span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> ExtMove<span style=color:#f92672>*</span> generate<span style=color:#f92672>&lt;</span>NON_EVASIONS<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span>, ExtMove<span style=color:#f92672>*</span>);
</span></span></code></pre></div><p>This is not a declaration - it&rsquo;s actually forcing the compiler to generate code for specific template parameter values.</p><p><strong>Why It&rsquo;s Needed</strong></p><p>Templates in C++ are &ldquo;lazy&rdquo; - the compiler only generates code for template instantiations that are actually used. But Stockfish has a specific reason to force these instantiations:</p><p>Without explicit instantiation, every .cpp file that uses eg: <code>generate&lt;CAPTURES>()</code> would compile its own copy of the template code. This leads to:</p><ul><li>Longer compile times</li><li>Larger binary size (duplicate code)</li><li>Worse instruction cache performance</li></ul><p>Explicit template instantiations tells the compiler: &ldquo;Generate these three versions of the function right here in <code>movegen.cpp</code>&rdquo;</p><p>Now other files can just call them without the compiler needing to see the template implementation.</p><p>Notice they only instantiate <code>CAPTURES</code>, <code>QUIETS</code>, and <code>NON_EVASIONS</code>.</p><p>Looking at the code, these are probably the most commonly used. Other types like <code>EVASIONS</code> or <code>QUIET_CHECKS</code> might be:</p><ul><li>Used less frequently</li><li>Generated on-demand when needed</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// generate&lt;CAPTURES&gt; generates all pseudo-legal captures and queen
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// promotions. Returns a pointer to the end of the move list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>///
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// generate&lt;QUIETS&gt; generates all pseudo-legal non-captures and
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// underpromotions. Returns a pointer to the end of the move list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>///
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// generate&lt;NON_EVASIONS&gt; generates all pseudo-legal captures and
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// non-captures. Returns a pointer to the end of the move list.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>GenType Type<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> generate(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(Type <span style=color:#f92672>==</span> CAPTURES <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> QUIETS <span style=color:#f92672>||</span> Type <span style=color:#f92672>==</span> NON_EVASIONS);
</span></span><span style=display:flex><span>  assert(<span style=color:#f92672>!</span>pos.checkers());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Color us <span style=color:#f92672>=</span> pos.side_to_move();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Bitboard target <span style=color:#f92672>=</span>  Type <span style=color:#f92672>==</span> CAPTURES     <span style=color:#f92672>?</span>  pos.pieces(<span style=color:#f92672>~</span>us)
</span></span><span style=display:flex><span>                   <span style=color:#f92672>:</span> Type <span style=color:#f92672>==</span> QUIETS       <span style=color:#f92672>?</span> <span style=color:#f92672>~</span>pos.pieces()
</span></span><span style=display:flex><span>                   <span style=color:#f92672>:</span> Type <span style=color:#f92672>==</span> NON_EVASIONS <span style=color:#f92672>?</span> <span style=color:#f92672>~</span>pos.pieces(us) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> generate_all<span style=color:#f92672>&lt;</span>WHITE, Type<span style=color:#f92672>&gt;</span>(pos, moveList, target)
</span></span><span style=display:flex><span>                     <span style=color:#f92672>:</span> generate_all<span style=color:#f92672>&lt;</span>BLACK, Type<span style=color:#f92672>&gt;</span>(pos, moveList, target);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Generic entry point for normal move generation (not evasions, not legal filtering yet).</p><p>This generic definition is used only for 3 types of scenarios as others have specific definition.</p><h4 id=target-mask>Target mask<a hidden class=anchor aria-hidden=true href=#target-mask>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard target <span style=color:#f92672>=</span>  Type <span style=color:#f92672>==</span> CAPTURES     <span style=color:#f92672>?</span>  pos.pieces(<span style=color:#f92672>~</span>us)
</span></span><span style=display:flex><span>                 <span style=color:#f92672>:</span> Type <span style=color:#f92672>==</span> QUIETS       <span style=color:#f92672>?</span> <span style=color:#f92672>~</span>pos.pieces()
</span></span><span style=display:flex><span>                 <span style=color:#f92672>:</span> Type <span style=color:#f92672>==</span> NON_EVASIONS <span style=color:#f92672>?</span> <span style=color:#f92672>~</span>pos.pieces(us) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p><code>target</code> tells lower-level generators which destination squares are allowed.</p><table><thead><tr><th>Mode</th><th>target means</th><th>Result</th></tr></thead><tbody><tr><td>CAPTURES</td><td>squares occupied by enemy</td><td>only captures</td></tr><tr><td>QUIETS</td><td>empty squares</td><td>only non-captures</td></tr><tr><td>NON_EVASIONS</td><td>squares NOT occupied by us</td><td>captures + quiets</td></tr></tbody></table><h3 id=generatequiet_checks>generate&lt;QUIET_CHECKS><a hidden class=anchor aria-hidden=true href=#generatequiet_checks>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// generate&lt;QUIET_CHECKS&gt; generates all pseudo-legal non-captures and knight
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// underpromotions that give check. Returns a pointer to the end of the move list.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> generate<span style=color:#f92672>&lt;</span>QUIET_CHECKS<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  assert(<span style=color:#f92672>!</span>pos.checkers());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Color us <span style=color:#f92672>=</span> pos.side_to_move();
</span></span><span style=display:flex><span>  Bitboard dc <span style=color:#f92672>=</span> pos.discovered_check_candidates();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (dc)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>     Square from <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>dc);
</span></span><span style=display:flex><span>     PieceType pt <span style=color:#f92672>=</span> type_of(pos.piece_on(from));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (pt <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// Will be generated together with direct checks
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     Bitboard b <span style=color:#f92672>=</span> pos.attacks_from(Piece(pt), from) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>pos.pieces();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (pt <span style=color:#f92672>==</span> KING)
</span></span><span style=display:flex><span>         b <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>PseudoAttacks[QUEEN][pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>~</span>us)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>         <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(from, pop_lsb(<span style=color:#f92672>&amp;</span>b));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> generate_all<span style=color:#f92672>&lt;</span>WHITE, QUIET_CHECKS<span style=color:#f92672>&gt;</span>(pos, moveList, <span style=color:#f92672>~</span>pos.pieces())
</span></span><span style=display:flex><span>                     <span style=color:#f92672>:</span> generate_all<span style=color:#f92672>&lt;</span>BLACK, QUIET_CHECKS<span style=color:#f92672>&gt;</span>(pos, moveList, <span style=color:#f92672>~</span>pos.pieces());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// generate&lt;QUIET_CHECKS&gt; generates all pseudo-legal non-captures and knight
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// underpromotions that give check. Returns a pointer to the end of the move list.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span>ExtMove<span style=color:#f92672>*</span> generate<span style=color:#f92672>&lt;</span>QUIET_CHECKS<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList) {
</span></span></code></pre></div><h4 id=template-specialization>Template specialization<a hidden class=anchor aria-hidden=true href=#template-specialization>#</a></h4><p>This is a complete specialization for <code>GenType = QUIET_CHECKS</code>. It completely replaces any generic template implementation.</p><p>The <code>&lt;></code> after <code>template</code> means &ldquo;this is a full specialization with no template parameters left&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>assert(<span style=color:#f92672>!</span>pos.checkers());
</span></span></code></pre></div><p><strong>Sanity check:</strong> We should not be in check when generating quiet checks. If we&rsquo;re in check, we should be generating evasions instead.
Although its possible to give check while evading enemy check, it&rsquo;s considered elsewhere.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Color us <span style=color:#f92672>=</span> pos.side_to_move();
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>`</span>pos.checkers()<span style=color:#960050;background-color:#1e0010>`</span> returns a bitboard of pieces giving check. It should be empty (<span style=color:#ae81ff>0</span>).
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bitboard dc <span style=color:#f92672>=</span> pos.discovered_check_candidates();
</span></span></code></pre></div><p><strong>Get discovered check candidates</strong>: Returns a bitboard of pieces that, if moved, would reveal a check from a piece behind them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (dc)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>     Square from <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>dc);
</span></span><span style=display:flex><span>     PieceType pt <span style=color:#f92672>=</span> type_of(pos.piece_on(from));
</span></span></code></pre></div><h4 id=loop-through-discovered-check-candidates>Loop through discovered check candidates:<a hidden class=anchor aria-hidden=true href=#loop-through-discovered-check-candidates>#</a></h4><ul><li>Process each piece that can give a discovered check.</li><li>Get the square of the next discovered check candidate and remove it from the bitboard.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (pt <span style=color:#f92672>==</span> PAWN)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// Will be generated together with direct checks
</span></span></span></code></pre></div><p><strong>Skip pawns:</strong> Pawn discovered checks are handled later by <code>generate_all()</code> because:</p><ul><li>Pawn moves are complex (pushes, captures, promotions, en passant)</li><li>They&rsquo;re better handled by the specialized <code>generate_pawn_moves()</code> function</li><li>That function already knows how to filter for checks</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard b <span style=color:#f92672>=</span> pos.attacks_from(Piece(pt), from) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>pos.pieces();
</span></span></code></pre></div><p><strong>Get quiet discovered check moves</strong>:</p><ul><li><code>pos.attacks_from(Piece(pt), from)</code>: All squares this piece can attack from <code>from</code></li><li><code>& ~pos.pieces()</code>: Filter to only <strong>empty squares</strong> (quiet moves, not captures)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (pt <span style=color:#f92672>==</span> KING)
</span></span><span style=display:flex><span>    b <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>PseudoAttacks[QUEEN][pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>~</span>us)];
</span></span></code></pre></div><p><strong>Special case for king discovered checks</strong>:</p><p>If the king itself is a discovered check candidate (rare but possible), we need extra filtering:</p><ul><li><code>PseudoAttacks[QUEEN][pos.square&lt;KING>(~us)]</code>: All squares the enemy king can &ldquo;see&rdquo; (as if it were a queen - all 8 directions)</li><li><code>~...</code>: Invert the bitboard</li><li><code>b &= ...</code>: Remove these squares from valid king moves</li></ul><p><strong>Why?</strong> Moving our king next to the enemy king would be illegal (kings can&rsquo;t be adjacent). This filters out those illegal moves.</p><p><strong>Note:</strong> Here we are not limiting the direction of king to be 1 square, it still works because if our king is already a discovered check candidate, it cannot possibly block the ray of another sliding piece to king.</p><h4 id=generate-all-discovered-check-moves>Generate all discovered check moves<a hidden class=anchor aria-hidden=true href=#generate-all-discovered-check-moves>#</a></h4><p>For each valid destination square, create a move and add it to the list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>return</span> us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> generate_all<span style=color:#f92672>&lt;</span>WHITE, QUIET_CHECKS<span style=color:#f92672>&gt;</span>(pos, moveList, <span style=color:#f92672>~</span>pos.pieces())
</span></span><span style=display:flex><span>                   <span style=color:#f92672>:</span> generate_all<span style=color:#f92672>&lt;</span>BLACK, QUIET_CHECKS<span style=color:#f92672>&gt;</span>(pos, moveList, <span style=color:#f92672>~</span>pos.pieces());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Generate direct checks</strong>: After handling discovered checks, call <code>generate_all()</code> to generate moves that give <strong>direct checks</strong> (the moving piece itself attacks the king).</p><p><strong>Parameters:</strong></p><ul><li>Template: <code>WHITE</code> or <code>BLACK</code> (which side is moving)</li><li>Template: <code>QUIET_CHECKS</code> (tells <code>generate_all()</code> to only generate checking moves)</li><li><code>pos</code>: Position</li><li><code>moveList</code>: Current end of move list (with discovered checks already added)</li><li><code>~pos.pieces()</code>: Target bitboard = all empty squares (quiet moves only)</li></ul><h3 id=generate-1>generate<evasions><a hidden class=anchor aria-hidden=true href=#generate-1>#</a></h3><p>This function generates all evasion moves when the king is in check. There are only 3 ways to get out of check:</p><ol><li>Move the king to a safe square</li><li>Block the check (only works for sliding piece checks: bishop, rook, queen)</li><li>Capture the checking piece</li></ol><p>The function handles these carefully, with special logic for double checks (where only king moves work).</p><h4 id=initialize-slider-attack-bitboard>Initialize slider attack bitboard<a hidden class=anchor aria-hidden=true href=#initialize-slider-attack-bitboard>#</a></h4><p>Will hold all squares attacked by sliding pieces (bishops, rooks, queens) that are giving check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard sliderAttacks <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>Bitboard sliders <span style=color:#f92672>=</span> pos.checkers() <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>pos.pieces(KNIGHT, PAWN);
</span></span></code></pre></div><p><strong>Get sliding checkers:</strong></p><ul><li><code>pos.checkers()</code>: All pieces giving check</li><li><code>& ~pos.pieces(KNIGHT, PAWN)</code>: Remove knights and pawns (they&rsquo;re not sliders)</li><li>Result: Only bishops, rooks, and queens that are giving check</li></ul><p><strong>Why separate sliders?</strong> Because slider checks create a &ldquo;ray of attack&rdquo; that the king cannot move along, while knight/pawn checks don&rsquo;t have this property.</p><h4 id=loop-through-sliding-checkers>Loop through sliding checkers:<a hidden class=anchor aria-hidden=true href=#loop-through-sliding-checkers>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#75715e>// Find all the squares attacked by slider checkers. We will remove them from
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// the king evasions in order to skip known illegal moves, which avoids any
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// useless legality checks later on.
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (sliders)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square checksq <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>sliders);
</span></span><span style=display:flex><span>      sliderAttacks <span style=color:#f92672>|=</span> LineBB[checksq][ksq] <span style=color:#f92672>^</span> checksq;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>Process each sliding piece giving check.</li><li>Extract the position of the sliding checker.</li><li>Add the attack ray to <code>sliderAttacks</code></li></ul><p>Let me break this down:</p><ul><li><code>LineBB[checksq][ksq]</code>: The <strong>entire line</strong> (rank, file, or diagonal) connecting the checker to our king</li><li><code>^ checksq</code>: <strong>XOR</strong> (remove) the checker&rsquo;s square itself from the line</li></ul><p><strong>Why remove the checker&rsquo;s square?</strong></p><p>Because the king <strong>CAN</strong> capture the checking piece! We only want to exclude squares along the ray <strong>beyond</strong> the checker.</p><h4 id=generate-king-evasion-moves>Generate king evasion moves<a hidden class=anchor aria-hidden=true href=#generate-king-evasion-moves>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#75715e>// Generate evasions for king, capture and non capture moves
</span></span></span><span style=display:flex><span>  Bitboard b <span style=color:#f92672>=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(ksq) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>pos.pieces(us) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>sliderAttacks;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(ksq, pop_lsb(<span style=color:#f92672>&amp;</span>b))
</span></span></code></pre></div><p><strong>Get legal king moves</strong>:</p><ul><li><code>pos.attacks_from&lt;KING>(ksq)</code>: All 8 squares around the king</li><li><code>& ~pos.pieces(us)</code>: Can&rsquo;t capture our own pieces</li><li><code>& ~sliderAttacks</code>: Can&rsquo;t move along the slider&rsquo;s attack ray</li><li>For each safe square, create a king move.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (more_than_one(pos.checkers()))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> moveList; <span style=color:#75715e>// Double check, only a king move can save the day
</span></span></span></code></pre></div><p><strong>Double check special case</strong>:</p><p>If there are 2+ pieces giving check, the ONLY way to escape is to move the king (you can&rsquo;t block two checks at once, and you can&rsquo;t capture two pieces in one move).</p><p><code>more_than_one(bitboard)</code> checks if the bitboard has more than one bit set.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Generate blocking evasions or captures of the checking piece
</span></span></span><span style=display:flex><span>Square checksq <span style=color:#f92672>=</span> lsb(pos.checkers());
</span></span></code></pre></div><h4 id=get-the-single-checking-pieces-square>Get the (single) checking piece&rsquo;s square:<a hidden class=anchor aria-hidden=true href=#get-the-single-checking-pieces-square>#</a></h4><p>Since we passed the double-check test, there&rsquo;s exactly one checker. <code>lsb()</code> gets the least significant bit (the checker&rsquo;s position).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard target <span style=color:#f92672>=</span> between_bb(checksq, ksq) <span style=color:#f92672>|</span> checksq;
</span></span></code></pre></div><p><strong>Calculate valid evasion squares</strong>: Pieces (other than the king) can either:</p><ol><li><strong>Block</strong> the check by moving between the checker and king</li><li><strong>Capture</strong> the checking piece</li></ol><ul><li><code>between_bb(checksq, ksq)</code>: All squares <strong>between</strong> the checker and king (only non-empty for sliders)</li><li><code>| checksq</code>: OR with the checker&rsquo;s square itself (capturing it)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>return</span> us <span style=color:#f92672>==</span> WHITE <span style=color:#f92672>?</span> generate_all<span style=color:#f92672>&lt;</span>WHITE, EVASIONS<span style=color:#f92672>&gt;</span>(pos, moveList, target)
</span></span><span style=display:flex><span>                   <span style=color:#f92672>:</span> generate_all<span style=color:#f92672>&lt;</span>BLACK, EVASIONS<span style=color:#f92672>&gt;</span>(pos, moveList, target);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Generate blocking/capturing moves</strong>:</p><p>Call <code>generate_all()</code> with the <code>target</code> bitboard set to valid evasion squares.</p><p>This will generate:</p><ul><li>Pawn moves to blocking/capturing squares</li><li>Knight moves to blocking/capturing squares</li><li>Bishop moves to blocking/capturing squares</li><li>Rook moves to blocking/capturing squares</li><li>Queen moves to blocking/capturing squares</li><li>(King moves already generated above)</li><li>(No castling - can&rsquo;t castle out of check)</li></ul><p>The <code>target</code> parameter ensures pieces only move to squares that help escape check.</p><h2 id=generate_all>generate_all<a hidden class=anchor aria-hidden=true href=#generate_all>#</a></h2><p><code>generate_all</code> is the central dispatcher that produces all pseudo-legal moves for one side by delegating work to specialized generators.</p><p>It generates moves in a fixed order: pawns → minor/major pieces → king → castling, while filtering squares using the target bitboard (captures, quiets, evasions, etc.).</p><p>The behavior is controlled at compile-time using templates (Color and GenType) so there are no runtime condition branches inside tight loops.</p><p>It focuses purely on speed and completeness — legality (king safety) is verified later, not here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>Color Us, GenType Type<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  ExtMove<span style=color:#f92672>*</span> generate_all(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos, ExtMove<span style=color:#f92672>*</span> moveList, Bitboard target) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> Checks <span style=color:#f92672>=</span> Type <span style=color:#f92672>==</span> QUIET_CHECKS;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    moveList <span style=color:#f92672>=</span> generate_pawn_moves<span style=color:#f92672>&lt;</span>Us, Type<span style=color:#f92672>&gt;</span>(pos, moveList, target);
</span></span><span style=display:flex><span>    moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span>KNIGHT, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>    moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span>BISHOP, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>    moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span>  ROOK, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>    moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span> QUEEN, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>!=</span> QUIET_CHECKS <span style=color:#f92672>&amp;&amp;</span> Type <span style=color:#f92672>!=</span> EVASIONS)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Square ksq <span style=color:#f92672>=</span> pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(Us);
</span></span><span style=display:flex><span>        Bitboard b <span style=color:#f92672>=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(ksq) <span style=color:#f92672>&amp;</span> target;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(ksq, pop_lsb(<span style=color:#f92672>&amp;</span>b));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>!=</span> CAPTURES <span style=color:#f92672>&amp;&amp;</span> Type <span style=color:#f92672>!=</span> EVASIONS <span style=color:#f92672>&amp;&amp;</span> pos.can_castle(Us))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pos.is_chess960())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> generate_castling<span style=color:#f92672>&lt;</span>MakeCastling<span style=color:#f92672>&lt;</span>Us,  KING_SIDE<span style=color:#f92672>&gt;::</span>right, Checks, true<span style=color:#f92672>&gt;</span>(pos, moveList, Us);
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> generate_castling<span style=color:#f92672>&lt;</span>MakeCastling<span style=color:#f92672>&lt;</span>Us, QUEEN_SIDE<span style=color:#f92672>&gt;::</span>right, Checks, true<span style=color:#f92672>&gt;</span>(pos, moveList, Us);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> generate_castling<span style=color:#f92672>&lt;</span>MakeCastling<span style=color:#f92672>&lt;</span>Us,  KING_SIDE<span style=color:#f92672>&gt;::</span>right, Checks, false<span style=color:#f92672>&gt;</span>(pos, moveList, Us);
</span></span><span style=display:flex><span>            moveList <span style=color:#f92672>=</span> generate_castling<span style=color:#f92672>&lt;</span>MakeCastling<span style=color:#f92672>&lt;</span>Us, QUEEN_SIDE<span style=color:#f92672>&gt;::</span>right, Checks, false<span style=color:#f92672>&gt;</span>(pos, moveList, Us);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> moveList;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>bool</span> Checks <span style=color:#f92672>=</span> Type <span style=color:#f92672>==</span> QUIET_CHECKS;
</span></span></code></pre></div><p>Some generators need to know whether we only want checking moves.
Compile-time constant → no runtime branching inside hot loops.</p><h3 id=pawn-moves-special-case-first>Pawn moves (special case first)<a hidden class=anchor aria-hidden=true href=#pawn-moves-special-case-first>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>moveList <span style=color:#f92672>=</span> generate_pawn_moves<span style=color:#f92672>&lt;</span>Us, Type<span style=color:#f92672>&gt;</span>(pos, moveList, target);
</span></span></code></pre></div><p>Pawns handled separately because they are the most complex:</p><ul><li>promotions</li><li>double pushes</li><li>en-passant</li><li>discovered checks</li><li>asymmetric movement</li></ul><h3 id=normal-piece-moves>Normal piece moves<a hidden class=anchor aria-hidden=true href=#normal-piece-moves>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span>KNIGHT, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span>BISHOP, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span>  ROOK, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span><span style=display:flex><span>moveList <span style=color:#f92672>=</span> generate_moves<span style=color:#f92672>&lt;</span> QUEEN, Checks<span style=color:#f92672>&gt;</span>(pos, moveList, Us, target);
</span></span></code></pre></div><p>Generic generator reused for all non-pawn, non-king pieces.</p><ul><li>Checks → generate only checking moves when needed</li><li>target → filters capture/quiet squares</li></ul><h3 id=king-normal-moves>King normal moves<a hidden class=anchor aria-hidden=true href=#king-normal-moves>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>!=</span> QUIET_CHECKS <span style=color:#f92672>&amp;&amp;</span> Type <span style=color:#f92672>!=</span> EVASIONS)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Square ksq <span style=color:#f92672>=</span> pos.square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(Us);
</span></span><span style=display:flex><span>    Bitboard b <span style=color:#f92672>=</span> pos.attacks_from<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(ksq) <span style=color:#f92672>&amp;</span> target;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>moveList<span style=color:#f92672>++</span> <span style=color:#f92672>=</span> make_move(ksq, pop_lsb(<span style=color:#f92672>&amp;</span>b));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>King moves excluded when:</p><ul><li>QUIET_CHECKS: king quiet checks handled elsewhere</li><li>EVASIONS: special generator required</li></ul><p>Otherwise:</p><ul><li>king attacks = adjacent squares</li><li>& target filters captures/quiet</li></ul><h3 id=castling>Castling<a hidden class=anchor aria-hidden=true href=#castling>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (Type <span style=color:#f92672>!=</span> CAPTURES <span style=color:#f92672>&amp;&amp;</span> Type <span style=color:#f92672>!=</span> EVASIONS <span style=color:#f92672>&amp;&amp;</span> pos.can_castle(Us))
</span></span></code></pre></div><p>Castling only generated when:</p><ul><li>not capture generation</li><li>not in check evasions</li><li>castling rights exist</li></ul><p><strong>Chess960 vs Standard chess</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (pos.is_chess960())
</span></span><span style=display:flex><span>    generate_castling<span style=color:#f92672>&lt;</span>..., true<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    generate_castling<span style=color:#f92672>&lt;</span>..., false<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>Stockfish compiles two versions:</p><ul><li>normal chess</li><li>Chess960 rules</li></ul><p>No runtime branching inside generator.</p><p><strong>Overall structure</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>generate_all
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> pawns
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> knights
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> bishops
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> rooks
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> queens
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>├─</span> king moves
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>└─</span> castling
</span></span></code></pre></div><p>Each piece uses:</p><ul><li>bitboards</li><li>target filtering</li><li>compile-time specialization</li></ul><p><strong>Key Idea</strong></p><p>This function is the central move generation pipeline.</p><p>It does NOT check legality — only produces pseudo-legal moves efficiently.</p><p>Legal filtering happens later.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/move-generation/>Move Generation</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>