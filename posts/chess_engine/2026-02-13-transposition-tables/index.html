<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Transposition Tables | Sanketh's Blog</title><meta name=keywords content="transposition tables"><meta name=description content="Transposition Tables
The transposition table is the engine’s memory of previously analyzed positions.
Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.
Stockfish stores a compact 10-byte entry per position.
TTEntry — What is stored
Each entry stores just enough info to help pruning and move ordering:
struct TTEntry {
    private:
        friend class TranspositionTable;

        uint16_t key16;
        uint16_t move16;
        int16_t  value16;
        int16_t  eval16;
        uint8_t  genBound8;
        int8_t   depth8;
};
C++ Used here
Structs in C++
In C++, struct and class are almost identical, with one default difference:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Transposition Tables"><meta property="og:description" content="Transposition Tables The transposition table is the engine’s memory of previously analyzed positions. Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.
Stockfish stores a compact 10-byte entry per position.
TTEntry — What is stored Each entry stores just enough info to help pruning and move ordering:
struct TTEntry { private: friend class TranspositionTable; uint16_t key16; uint16_t move16; int16_t value16; int16_t eval16; uint8_t genBound8; int8_t depth8; }; C++ Used here Structs in C++ In C++, struct and class are almost identical, with one default difference:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-13T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-13T00:00:00+00:00"><meta property="article:tag" content="Transposition Tables"><meta name=twitter:card content="summary"><meta name=twitter:title content="Transposition Tables"><meta name=twitter:description content="Transposition Tables
The transposition table is the engine’s memory of previously analyzed positions.
Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.
Stockfish stores a compact 10-byte entry per position.
TTEntry — What is stored
Each entry stores just enough info to help pruning and move ordering:
struct TTEntry {
    private:
        friend class TranspositionTable;

        uint16_t key16;
        uint16_t move16;
        int16_t  value16;
        int16_t  eval16;
        uint8_t  genBound8;
        int8_t   depth8;
};
C++ Used here
Structs in C++
In C++, struct and class are almost identical, with one default difference:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Transposition Tables","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Transposition Tables","name":"Transposition Tables","description":"Transposition Tables The transposition table is the engine’s memory of previously analyzed positions. Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.\nStockfish stores a compact 10-byte entry per position.\nTTEntry — What is stored Each entry stores just enough info to help pruning and move ordering:\nstruct TTEntry { private: friend class TranspositionTable; uint16_t key16; uint16_t move16; int16_t value16; int16_t eval16; uint8_t genBound8; int8_t depth8; }; C++ Used here Structs in C++ In C++, struct and class are almost identical, with one default difference:\n","keywords":["transposition tables"],"articleBody":"Transposition Tables The transposition table is the engine’s memory of previously analyzed positions. Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.\nStockfish stores a compact 10-byte entry per position.\nTTEntry — What is stored Each entry stores just enough info to help pruning and move ordering:\nstruct TTEntry { private: friend class TranspositionTable; uint16_t key16; uint16_t move16; int16_t value16; int16_t eval16; uint8_t genBound8; int8_t depth8; }; C++ Used here Structs in C++ In C++, struct and class are almost identical, with one default difference:\nstruct MyStruct { int x; // PUBLIC by default }; class MyClass { int x; // PRIVATE by default }; But you can override the defaults:\nstruct MyStruct { private: // ← Explicitly make it private int x; }; class MyClass { public: // ← Explicitly make it public int x; }; Friend Class - Controlled Access The Problem\nstruct TTEntry { private: uint16_t key16; // ... other fields }; class TranspositionTable { TTEntry entries[MILLIONS]; void store(uint64_t hash, int value) { // Need to access TTEntry internals! entries[index].key16 = ???; // ❌ ERROR: private! } }; TranspositionTable needs to manipulate TTEntry internals, but they’re private!\nThe Solution: friend\nstruct TTEntry { private: friend class TranspositionTable; // ← Grant access! uint16_t key16; uint16_t move16; // ... }; class TranspositionTable { TTEntry entries[MILLIONS]; void store(uint64_t hash, int value) { entries[index].key16 = hash \u003e\u003e 48; // ✓ OK! (friend access) entries[index].value16 = compress(value); } }; friend class TranspositionTable means:\n“TranspositionTable is my friend - it can access my private parts”\nCollision Probability in Transposition Tables A TT hit is accepted only if all 3 filters pass: 1.\tSame table index (lower bits match) 2.\tSame verification key (key16) 3.\tSame Zobrist hash (no real hash collision)\nSo a wrong reuse requires ALL THREE to collide simultaneously.\nWe estimate probability layer-by-layer.\nLayer 1 — Index Collision (Bucket Clash) We index using lower N bits:\nindex = zobrist \u0026 (tableSize - 1) For a table of size:\n2^27 ≈ 134 million entries Two random positions collide in index with probability:\nP1 = 1 / 2^27\nSo:\n≈ 1 in 134,217,728 But engines search billions of nodes → this happens often. That’s why we need a verification key.\nLayer 2 — Partial Key Verification (key16) We store upper 16 bits:\nstored.key16 == key \u003e\u003e 48 Probability a random different position matches:\nP2 = 1 / 2^16\n≈ 1 in 65,536 Now combined probability:\nP_{1+2} = 1 / 2^{27} × 1 / 2^{16} = 1 / 2^{43} ≈ 1 in 8.8 trillion Already astronomically small.\nLayer 3 — Real Zobrist Collision Zobrist hashing is 64-bit random hashing.\nProbability two different chess positions share the same hash:\nP3 = 1 / 2^64\n≈ 1 in 18,446,744,073,709,551,616 Final Probability (All Layers Fail) P_{total} = 1 / 2^{27} × 1 / 2^{16} × 1 / 2^{64} = 1 / 2^{107} ≈ 1 in 1.6 × 10^32 For perspective:\nYou are more likely to win the lottery every week for the rest of your life than hit a harmful TT collision.\nChess engines choose a practically perfect approach.\nEven if a collision happens:\nevaluation error is small future searches overwrite it alpha-beta is resilient TTEntry Fields | Field | Size | Purpose | | ----------- | -------- | -------------------------------------------- | | `key16` | 16 bits | Upper part of Zobrist key (verification) | | `move16` | 16 bits | Best move found from this position | | `value16` | 16 bits | Search result (score from search) | | `eval16` | 16 bits | Static evaluation (NNUE eval, before search) | | `genBound8` | 6+2 bits | Entry age + bound type | | `depth8` | 8 bits | Depth searched | 1. uint16_t key16 - Hash Verification What it stores: upper 16 bits of the 64-bit Zobrist hash\nWhy not store full 64-bit key?\nMemory.\nA TT may contain hundreds of millions of entries. Storing full keys would double the size → halve usable depth.\nkey16 is not the key used to index the table. It is only a collision checker.\nA transposition table lookup has two stages:\nuint64_t fullHash = zobristHash(position); // 64-bit hash // Step 1: Find the slot size_t index = fullHash \u0026 (tableSize - 1); // Use lower bits // Example: bits 0-26 for 128M entries // Step 2: Store verification key entry-\u003ekey16 = fullHash \u003e\u003e 48; // Store upper 16 bits // Later, when probing: TTEntry* entry = table[index]; if (entry-\u003ekey16 == (fullHash \u003e\u003e 48)) { // Verify match // Same position! } else { // Collision - different position in same slot } 1. Indexing (where in the table?) We want to map a 64-bit hash to a valid table index:\nfullHash = 0xABCD_1234_5678_9EF0 (any 64-bit number) tableSize = 134,217,728 (128 million entries) Need: index in range [0, 134,217,727] Naive Approach: Modulo\nsize_t index = fullHash % tableSize; Problem: Modulo (%) is slow on most CPUs (10-40 cycles).\nFast Approach: Bitwise AND (When Size is Power of 2)\nThe Trick: If tableSize is a power of 2, we can use bitwise AND instead:\nsize_t index = fullHash \u0026 (tableSize - 1); Bitwise AND (\u0026) is extremely fast (1 cycle).\nWhy This Works?\nUnderstanding Powers of 2 in Binary\ntableSize = 128M = 2^27 = 134,217,728 In binary: 2^27 = 1000_0000_0000_0000_0000_0000_0000 (1 followed by 27 zeros) 2^27 - 1 = 0111_1111_1111_1111_1111_1111_1111 (27 ones) The Magic of AND with (2^n - 1)\nWhen you AND any number with (2^n - 1), you keep only the lower n bits:\nfullHash: ????_????_????_????_????_????_???? (any bits) (tableSize - 1): 0000_0000_0000_0000_0111_1111_1111 (27 ones) ───────────────────────────────── Result: 0000_0000_0000_0000_0???_????_???? (lower 27 bits) This is exactly the same as fullHash % tableSize!\nThe important observation here is there are 27 ones in lower bits. So it has potentially select all numbers between 0 and 2^27. This wouldn’t have been possible if all lower 27 bits weren’t ones, Thus taking (2^n - 1) is important.\n2. Verification (is it the same position?) Uses UPPER 16 bits\nstored.key16 == key \u003e\u003e 48 This only checks:\n“Did we land on the correct position or just collide?”\n2. move16 — Best move (move ordering weapon) Stores: the best move previously found from this position\nRemember enum Move is 16 bits.\nWhy this is insanely important\nAlpha-beta effectiveness depends on searching the best move first.\nBecause if the best move is searched first:\nbeta cutoff happens earlier → whole branches disappear → exponential speedup So TT move is used as:\nFIRST move to search at this node Even if evaluation is outdated, move ordering value remains huge.\nTT move ordering is one of the strongest heuristics in chess engines.\n3. value16 — Search result (alpha-beta bound) Stores: the search score returned by alpha-beta\nBut important: This is not always exact.\nThe key idea:\nA transposition table usually does not store the position value. It stores information about the search window result.\nIt doesn’t ask:\n“What is the exact value of this position?”\nIt asks:\n“Is the value inside the window [alpha, beta]?”\nSo most nodes never compute the exact score.\nWhy alpha-beta rarely knows the real value\nSuppose we search with window:\nalpha = -0.50 beta = +0.50 We are basically asking:\n“Is the position worse than -0.50, better than +0.50, or inside?”\nWe stop searching as soon as we can prove one of those.\nSo the engine often returns inequalities, not numbers.\nThe Three Possible Results 1. Exact value (PV node):\nWe searched fully without cutoff.\nalpha \u003c score \u003c beta Example:\nwindow = [-0.50, +0.50] real score = +0.20 We had to examine all moves → we now KNOW the exact value.\nStored as:\nBOUND_EXACT value16 = +0.20 This is rare — only principal variation nodes.\n2. Fail-High (Lower Bound)\nSearch proves position is at least beta.\nscore ≥ beta Example:\nwindow = [-0.50, +0.50] we find a move giving +1.80 Opponent would never allow this → we stop immediately.\nWe do NOT know the real score. It might be +1.80, +3.00, or mate.\nWe only know:\nposition ≥ +0.50\nStored as:\nBOUND_LOWER value16 = beta (or score) meaning: score ≥ value16 3. Fail-Low (Upper Bound)\nSearch proves position is at most alpha.\nscore ≤ alpha Example:\nwindow = [-0.50, +0.50] all moves ≤ -0.80 We stop — too bad for us.\nWe only know:\nposition ≤ -0.50\nStored as:\nBOUND_UPPER value16 = alpha meaning: score ≤ value16 Why this is powerful (instant pruning) Later we revisit the same position with window:\nalpha = -0.30 beta = +0.30 We probe TT.\nCase A — Stored LOWER bound ≥ beta\nStored:\nscore ≥ +0.50 Current search asks:\nIs score \u003c +0.30 ? Impossible.\nSo we instantly prune — no search.\nCase B — Stored UPPER bound ≤ alpha\nStored:\nscore ≤ -0.50 Current search asks:\nIs score \u003e -0.30 ? Impossible.\nInstant prune again.\nCase C — Stored EXACT\nWe directly return value.\nNo search at all.\nSo the general idea is when we start to search initally, we obviously want to know the exact score for that position not some alpha, beta range, but while doing so we will encounter millions of intermediate positions for whom we may not calculate exact score and prune if they are out of range, only if they lie in range we get exact value since it can contribute to final asnwer.\nValue Range and Encoding // Stockfish value range: VALUE_ZERO = 0 VALUE_DRAW = 0 VALUE_MATE = 32000 VALUE_INFINITE = 32001 // All fit in int16_t (-32768 to +32767) // Positive = good for White // Negative = good for Black Mate Distance Adjustment\nEngines encode mate as very large numbers:\n+32000 → winning mate -32000 → getting mated But they don’t store just mate yes/no — they store mate in N.\nWhy?\nBecause:\nMate in 3 is better than mate in 10\nSo engines encode:\nmate in N = +MATE - N mated in N = -MATE + N Example:\nMATE = 32000 Mate in 1 = 31999 Mate in 2 = 31998 Mate in 3 = 31997 Higher = faster win\nWhere the bug appears (Transposition Table)\nThe SAME board position can appear at different depths in the tree.\nBut distance to mate from root is different.\nExample tree:\nFrom root:\nRoot └── A └── B └── C ← position P └── forced mate in 3 At node P, engine finds:\nmate in 3\nSo evaluation stored:\nscore = 31997 But this means:\nmate in 3 FROM P NOT from root\nFrom root it’s actually:\nRoot → A → B → C → mate in 3 distance from root = 3 + 3 = 6 plies So correct root interpretation = mate in 6\nNow suppose same position appears elsewhere:\nRoot └── X └── Y └── Z └── W └── P ← same board again Now P is deeper!\nFrom here:\nmate in 3 from P = mate in 7 from root BUT TT stored 31997 without context Engine would think it’s mate in 3 again ❌\nSo engine thinks:\nThis line mates faster than it really does\n→ causes wrong move ordering → even wrong best move selection\nThe Fix: Store relative to ply\nWe store mate score shifted by current depth (ply).\nWhen storing\nAt node P:\ntrue local score = +31997 (mate in 3 from here) current ply = 5 from root storedValue = score + ply = 31997 + 5 = 32002 We convert:\nfrom “mate from here” → “mate from root”\nWhen retrieving later\nSuppose we reach P again at ply = 8:\nretrievedScore = storedValue - ply = 32002 - 8 = 31994 Which equals:\nmate in 6 from here 4. int16_t eval16 - Static Evaluation Stores: evaluation without search (NNUE / handcrafted eval)\nWhy store this separately from value16?\nBecause:\nvalue = eval + tactics discovered during search Later when probing:\nIf depth too shallow to trust value → engine still reuses eval\nThis avoids recomputing expensive evaluation (especially NNUE).\nThink of it as an evaluation memoization cache.\nStatic vs Search Evaluation STATIC EVAL (eval16):\nJust look at current position Count material, position, king safety No search ahead Fast: ~1 microsecond Example: +0.5 pawns SEARCH VALUE (value16):\nMinimax result after searching ahead Considers tactics, forced sequences Slow: varies with depth Example: +2.0 pawns (found tactic) 5. uint8_t genBound8 - Generation \u0026 Bound Type Two Pieces of Information Packed This 8-bit field contains:\nGeneration (upper 6 bits): Which search iteration stored this Bound type (lower 2 bits): EXACT, LOWER_BOUND, or UPPER_BOUND Part A: Generation (Replacement Scheme)\nPurpose: Decide which entries to replace when TT is full.\n// At start of each search: TT.new_search(); // generation++ (0 → 1 → 2 → ... → 63 → 0) // When storing entry: entry-\u003egenBound8 = (generation \u003c\u003c 2) | bound; // When deciding to replace: if (entry-\u003egeneration() != currentGeneration) { // Old entry from previous search // More likely to replace } Generation wraparound (6 bits = 0-63):\nSearch 1: generation = 1 Search 2: generation = 2 ... Search 63: generation = 63 Search 64: generation = 0 (wraps around) Replacement logic:\nbool shouldReplace(TTEntry* existing, int newDepth, int currentGen) { // Always replace if: // 1. Empty slot if (existing-\u003edepth8 == 0) return true; // 2. Same position (update) if (existing-\u003ekey16 == newKey) return true; // 3. Old generation AND new search is deeper if (existing-\u003egeneration() != currentGen \u0026\u0026 newDepth \u003e= existing-\u003edepth8) return true; // 4. Much deeper search if (newDepth \u003e existing-\u003edepth8 + 4) return true; return false; } Part B: Bound Type (Node Type)\nPurpose: Know how to use the stored value.\nenum Bound { BOUND_NONE = 0, // 00 BOUND_UPPER = 1, // 01 (fail-low, all node) BOUND_LOWER = 2, // 10 (fail-high, cut node) BOUND_EXACT = 3 // 11 (PV node) }; How bound is determined:\n// After search: Bound bound; if (value \u003c= alphaOrig) bound = BOUND_UPPER; // Fail-low else if (value \u003e= beta) bound = BOUND_LOWER; // Fail-high else bound = BOUND_EXACT; // Within window entry-\u003egenBound8 = (generation \u003c\u003c 2) | bound; Usage when retrieving:\nif (tte-\u003edepth() \u003e= depth) { int score = tte-\u003evalue(); if (tte-\u003ebound() == BOUND_EXACT) { return score; // Use as-is } else if (tte-\u003ebound() == BOUND_LOWER) { alpha = max(alpha, score); // At least this good } else if (tte-\u003ebound() == BOUND_UPPER) { beta = min(beta, score); // At most this good } if (alpha \u003e= beta) return score; // Cutoff } 6. int8_t depth8 - Search Depth Purpose:\nTrack how deeply this position was searched - to decide if we can use this entry.\nThe Rule\nCan use TT entry ONLY if: storedDepth \u003e= currentSearchDepth Why?\nPreviously searched to depth 5: value = +0.3 Now searching to depth 10\n→ Depth 5 result is NOT good enough for depth 10! → Must search deeper → Don’t use TT entry (except for move ordering)\nDepth Values // Depth is measured in plies (half-moves): DEPTH_ZERO = 0 ONE_PLY = 1 // Example values: depth8 = 0: Leaf node (just eval) depth8 = 1: Searched 1 ply (half-move) depth8 = 10: Searched 10 plies (5 full moves) depth8 = 20: Searched 20 plies (10 full moves) // Can be negative due to reductions! depth8 = -1: Reduced below quiescence search Usage Example\n// Searching position at depth 12 TTEntry* tte = TT.probe(hash, found); if (found) { if (tte-\u003edepth() \u003e= 12) { // Previous search was deep enough // → Use stored value (if bound allows) return tte-\u003evalue(); } else if (tte-\u003edepth() \u003e= 8) { // Not deep enough for cutoff, but use move! Move bestMove = tte-\u003emove(); // Try this move first } else { // Very shallow, might ignore completely } } // If not usable, search and store new result: value = search(...); TT.store(hash, value, depth=12, ...); Depth and Replacement\nDeeper searches are more valuable:\n// Replacement prefers keeping deeper searches: if (newDepth \u003c= existingDepth - 4) { // Don't replace much deeper entry return; // Keep existing } Example:\nSlot contains: depth=15, value=+0.5, generation=5 New entry: depth=8, value=+0.3, generation=6 → Don't replace! (15 \u003e\u003e 8, even though newer) New entry: depth=16, value=+0.4, generation=6 → Replace! (16 \u003e 15, deeper search) Why int8_t? (Signed) Range: -128 to +127 Needs to be signed for:\nReductions: Search can go below depth 0 Extensions: Depth can increase beyond nominal Quiescence: Depth 0, -1, -2 during qsearch // During search: if (dangerousMove) depth += 1; // Extend (depth could be 21, 22, etc.) if (likelyBad) depth -= 2; // Reduce (could go negative) TranspositionTable The transposition table (TT) is a large hash table storing previously searched positions so the engine can reuse search results instead of re-searching the tree\n/// A TranspositionTable consists of a power of 2 number of clusters and each /// cluster consists of ClusterSize number of TTEntry. Each non-empty entry /// contains information of exactly one position. The size of a cluster should /// divide the size of a cache line size, to ensure that clusters never cross /// cache lines. This ensures best cache performance, as the cacheline is /// prefetched, as soon as possible. class TranspositionTable { static const int CacheLineSize = 64; static const int ClusterSize = 3; struct Cluster { TTEntry entry[ClusterSize]; char padding[2]; // Align to a divisor of the cache line size }; static_assert(CacheLineSize % sizeof(Cluster) == 0, \"Cluster size incorrect\"); public: ~TranspositionTable() { free(mem); } void new_search() { generation8 += 4; } // Lower 2 bits are used by Bound uint8_t generation() const { return generation8; } TTEntry* probe(const Key key, bool\u0026 found) const; int hashfull() const; void resize(size_t mbSize); void clear(); // The lowest order bits of the key are used to get the index of the cluster TTEntry* first_entry(const Key key) const { return \u0026table[(size_t)key \u0026 (clusterCount - 1)].entry[0]; } private: size_t clusterCount; Cluster* table; void* mem; uint8_t generation8; // Size must be not bigger than TTEntry::genBound8 }; Clustered Layout (Important Performance Trick) What is a Cluster A cluster is a small bucket that contains multiple TT entries.\nLayout\nTransposition Table │ ├─ index 0 → Cluster → [ entry0, entry1, entry2 ] ├─ index 1 → Cluster → [ entry0, entry1, entry2 ] ├─ index 2 → Cluster → [ entry0, entry1, entry2 ] ... In Stockfish:\nClusterSize = 3 It means each hash index can store up to 3 different positions\nWhy this exists\nIf only 1 entry per index:\nhash collision → overwrite immediately → lose useful info With clusters:\nhash collision → try next slot in same cluster What happens during probe 1.\tCompute index from key 2.\tLook at 3 entries in that cluster 3.\tIf any matches key16 → hit 4.\tOtherwise choose a victim entry to replace (usually oldest / shallowest)\nWhy 3?\nBecause the entire cluster must fit in one 64-byte cache line\nThat gives maximum CPU memory efficiency while still tolerating collisions.\nstatic const int CacheLineSize = 64; static const int ClusterSize = 3; struct Cluster { TTEntry entry[ClusterSize]; // 10 * 3 = 30 bytes char padding[2]; // 2 bytes padding }; static_assert(CacheLineSize % sizeof(Cluster) == 0, \"Cluster size incorrect\"); Each Cluster is 32 bytes, keeping it aligned with 64 byte cache lines.\nMethods of TranspositionTable first_entry TTEntry* first_entry(const Key key) const { return \u0026table[(size_t)key \u0026 (clusterCount - 1)].entry[0]; } This function takes the zobrist hash key and returns the first entry of TT cluster which could potentially have the position representing the key.\nInstead of modulo:\nindex = key % size (slow) Stockfish uses:\nindex = key \u0026 (size - 1) (1 CPU cycle) Works because table size is power of 2. (discussed earlier)\nGeneration (Aging Mechanism) void new_search() { generation8 += 4; } uint8_t generation8; TT entries get “older” across searches.\nPurpose:\nprefer replacing old positions keep recent analysis relevant prevents table pollution Lower 2 bits of generation8 store bound type, upper bits store age.\nWhy += 4 Instead of += 1?\nRemember genBound8 packing:\ngenBound8 (8 bits): ┌─────────────┬─────┐ │ Generation │Bound│ │ (6 bits) │(2b) │ └─────────────┴─────┘ Bits 7-2 Bits 1-0 TranspositionTable::generation8 represents global search age. It goes on from 0 to 65 and wraps back to 0.\nprobe /// TranspositionTable::probe() looks up the current position in the transposition /// table. It returns true and a pointer to the TTEntry if the position is found. /// Otherwise, it returns false and a pointer to an empty or least valuable TTEntry /// to be replaced later. The replace value of an entry is calculated as its depth /// minus 8 times its relative age. TTEntry t1 is considered more valuable than /// TTEntry t2 if its replace value is greater than that of t2. TTEntry* TranspositionTable::probe(const Key key, bool\u0026 found) const { TTEntry* const tte = first_entry(key); const uint16_t key16 = key \u003e\u003e 48; // Use the high 16 bits as key inside the cluster for (int i = 0; i \u003c ClusterSize; ++i) if (!tte[i].key16 || tte[i].key16 == key16) { if ((tte[i].genBound8 \u0026 0xFC) != generation8 \u0026\u0026 tte[i].key16) tte[i].genBound8 = uint8_t(generation8 | tte[i].bound()); // Refresh return found = (bool)tte[i].key16, \u0026tte[i]; } // Find an entry to be replaced according to the replacement strategy TTEntry* replace = tte; for (int i = 1; i \u003c ClusterSize; ++i) // Due to our packed storage format for generation and its cyclic // nature we add 259 (256 is the modulus plus 3 to keep the lowest // two bound bits from affecting the result) to calculate the entry // age correctly even after generation8 overflows into the next cycle. if ( replace-\u003edepth8 - ((259 + generation8 - replace-\u003egenBound8) \u0026 0xFC) * 2 \u003e tte[i].depth8 - ((259 + generation8 - tte[i].genBound8) \u0026 0xFC) * 2) replace = \u0026tte[i]; return found = false, replace; } first_entry returns the pointer to potential cluster containing the position. The for loop iterates through all 3 indexes of cluster. key16 i.e., upper 16 bits of zobrist hash is used for validation.\nRefresh aging\nif ((tte[i].genBound8 \u0026 0xFC) != generation8 \u0026\u0026 tte[i].key16) tte[i].genBound8 = uint8_t(generation8 | tte[i].bound()); 0xFC = 11111100 This masks out the lower 2 bits (bound).\nSo we compare only generation (age):\nstored generation != current generation Meaning:\n“We touched this entry again in the new search — mark it as fresh.”\nThis prevents good entries from being replaced too early.\nreturn found = (bool)tte[i].key16, \u0026tte[i]; The function returns TTEntry*, a pointer to the chosen entry.\nBut this line looks weird because it uses a C/C++ trick:\nIt uses the comma operator.\nIn C/C++:\nA, B means: 1.\tEvaluate A 2.\tThen evaluate B 3.\tThe whole expression becomes B\nfound will be assigned true, if key16 is non-empty (cache-hit), since found is a pointer, its value will be used by caller.\nReplacement Strategy The replacement policy (which old entry to overwrite when the cluster is full).\nStep 1 — Start with first candidate\nTTEntry* replace = tte; Assume first slot is worst (for now).\nStep 2 — Compare with other 2 entries\nfor (int i = 1; i \u003c ClusterSize; ++i) We compare slot 0 vs 1 vs 2 and keep the worst one in replace.\nWhat Stockfish cares about\nA TT entry is valuable if: 1.\tSearched deeper (depth) ✔ important 2.\tRecently used (generation) ✔ important\nSo they combine:\nquality = depth - age_penalty The formula\nreplace-\u003edepth8 - ((259 + generation8 - replace-\u003egenBound8) \u0026 0xFC) * 2 \u003e tte[i].depth8 - ((259 + generation8 - tte[i].genBound8) \u0026 0xFC) * 2 (259 + generation8 - entry.genBound8) \u0026 0xFC This computes:\nHow old is this entry? (even if generation wrapped around 255 → 0)\nThe general idea is\n// Replacement score = depth - age_penalty score = depth8 - (currentGen - entryGen) * 2 Since generation is more important, its multiplied by 2 to give higher weightage.\nIts subtracted by 259 to handle wrap around.\nhashfull /// TranspositionTable::hashfull() returns an approximation of the hashtable /// occupation during a search. The hash is x permill full, as per UCI protocol. int TranspositionTable::hashfull() const { int cnt = 0; for (int i = 0; i \u003c 1000 / ClusterSize; i++) { const TTEntry* tte = \u0026table[i].entry[0]; for (int j = 0; j \u003c ClusterSize; j++) if ((tte[j].genBound8 \u0026 0xFC) == generation8) cnt++; } return cnt; } Purpose: Estimate how full the TT is (for time management)\nStockfish does sampling instead of scanning the entire table (which could be hundreds of MB).\nHow it works\nfor (int i = 0; i \u003c 1000 / ClusterSize; i++) Quick note: 1000 / ClusterSize might seem like we are performing division on every loop, but since ClusterSize is also a compile time constant, compiler evaluates it to 333 at compile time itself.\nClusterSize = 3 → 1000/3 ≈ 333 clusters\nSo engine checks about 1000 entries total:\n333 clusters × 3 entries each ≈ 999 entries Why this works (statistics intuition)\nThe TT entries are essentially randomly distributed because:\nZobrist hashes are random → positions land uniformly in table\nSo:\nChecking 1000 random entries ≈ same ratio as checking 10 million entries\nPer-mille means:\nparts per thousand (like percent = per hundred)\n1‰ = 1 / 1000\n","wordCount":"4195","inLanguage":"en","datePublished":"2026-02-13T00:00:00Z","dateModified":"2026-02-13T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-02-13-transposition-tables/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Transposition Tables</h1><div class=post-meta><span title='2026-02-13 00:00:00 +0000 UTC'>February 13, 2026</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-02-13-transposition-tables.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#transposition-tables aria-label="Transposition Tables">Transposition Tables</a><ul><li><a href=#ttentry--what-is-stored aria-label="TTEntry — What is stored">TTEntry — What is stored</a><ul><li><a href=#c-used-here aria-label="C++ Used here">C++ Used here</a><ul><li><a href=#structs-in-c aria-label="Structs in C++">Structs in C++</a></li><li><a href=#friend-class---controlled-access aria-label="Friend Class - Controlled Access">Friend Class - Controlled Access</a></li></ul></li><li><a href=#collision-probability-in-transposition-tables aria-label="Collision Probability in Transposition Tables">Collision Probability in Transposition Tables</a><ul><li><a href=#layer-1--index-collision-bucket-clash aria-label="Layer 1 — Index Collision (Bucket Clash)">Layer 1 — Index Collision (Bucket Clash)</a></li><li><a href=#layer-2--partial-key-verification-key16 aria-label="Layer 2 — Partial Key Verification (key16)">Layer 2 — Partial Key Verification (key16)</a></li><li><a href=#layer-3--real-zobrist-collision aria-label="Layer 3 — Real Zobrist Collision">Layer 3 — Real Zobrist Collision</a></li><li><a href=#final-probability-all-layers-fail aria-label="Final Probability (All Layers Fail)">Final Probability (All Layers Fail)</a></li></ul></li><li><a href=#ttentry-fields aria-label="TTEntry Fields">TTEntry Fields</a><ul><li><a href=#1-uint16_t-key16---hash-verification aria-label="1. uint16_t key16 - Hash Verification">1. uint16_t key16 - Hash Verification</a><ul><li><a href=#1-indexing-where-in-the-table aria-label="1. Indexing (where in the table?)">1. Indexing (where in the table?)</a></li><li><a href=#2-verification-is-it-the-same-position aria-label="2. Verification (is it the same position?)">2. Verification (is it the same position?)</a></li></ul></li><li><a href=#2-move16--best-move-move-ordering-weapon aria-label="2. move16 — Best move (move ordering weapon)">2. move16 — Best move (move ordering weapon)</a></li><li><a href=#3-value16--search-result-alpha-beta-bound aria-label="3. value16 — Search result (alpha-beta bound)">3. value16 — Search result (alpha-beta bound)</a><ul><li><a href=#the-three-possible-results aria-label="The Three Possible Results">The Three Possible Results</a></li><li><a href=#why-this-is-powerful-instant-pruning aria-label="Why this is powerful (instant pruning)">Why this is powerful (instant pruning)</a></li><li><a href=#value-range-and-encoding aria-label="Value Range and Encoding">Value Range and Encoding</a></li></ul></li><li><a href=#4-int16_t-eval16---static-evaluation aria-label="4. int16_t eval16 - Static Evaluation">4. int16_t eval16 - Static Evaluation</a><ul><li><a href=#static-vs-search-evaluation aria-label="Static vs Search Evaluation">Static vs Search Evaluation</a></li></ul></li><li><a href=#5-uint8_t-genbound8---generation--bound-type aria-label="5. uint8_t genBound8 - Generation & Bound Type">5. uint8_t genBound8 - Generation & Bound Type</a></li><li><a href=#6-int8_t-depth8---search-depth aria-label="6. int8_t depth8 - Search Depth">6. int8_t depth8 - Search Depth</a><ul><li><a href=#depth-values aria-label="Depth Values">Depth Values</a></li></ul></li></ul></li></ul></li><li><a href=#transpositiontable aria-label=TranspositionTable>TranspositionTable</a><ul><li><a href=#clustered-layout-important-performance-trick aria-label="Clustered Layout (Important Performance Trick)">Clustered Layout (Important Performance Trick)</a><ul><li><a href=#what-is-a-cluster aria-label="What is a Cluster">What is a Cluster</a></li></ul></li><li><a href=#methods-of-transpositiontable aria-label="Methods of TranspositionTable">Methods of TranspositionTable</a><ul><li><a href=#first_entry aria-label=first_entry>first_entry</a></li><li><a href=#generation-aging-mechanism aria-label="Generation (Aging Mechanism)">Generation (Aging Mechanism)</a></li><li><a href=#probe aria-label=probe>probe</a><ul><li><a href=#replacement-strategy aria-label="Replacement Strategy">Replacement Strategy</a></li></ul></li><li><a href=#hashfull aria-label=hashfull>hashfull</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=transposition-tables>Transposition Tables<a hidden class=anchor aria-hidden=true href=#transposition-tables>#</a></h1><p>The transposition table is the engine’s memory of previously analyzed positions.
Because the same chess position can be reached through different move orders (transpositions), storing results avoids re-searching identical subtrees — this is one of the biggest speedups in modern engines.</p><p>Stockfish stores a compact 10-byte entry per position.</p><h2 id=ttentry--what-is-stored>TTEntry — What is stored<a hidden class=anchor aria-hidden=true href=#ttentry--what-is-stored>#</a></h2><p>Each entry stores just enough info to help pruning and move ordering:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TTEntry</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TranspositionTable</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint16_t</span> key16;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint16_t</span> move16;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int16_t</span>  value16;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int16_t</span>  eval16;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint8_t</span>  genBound8;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int8_t</span>   depth8;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=c-used-here>C++ Used here<a hidden class=anchor aria-hidden=true href=#c-used-here>#</a></h3><h4 id=structs-in-c>Structs in C++<a hidden class=anchor aria-hidden=true href=#structs-in-c>#</a></h4><p>In C++, struct and class are almost identical, with one default difference:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyStruct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;  <span style=color:#75715e>// PUBLIC by default
</span></span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;  <span style=color:#75715e>// PRIVATE by default
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>But you can override the defaults:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyStruct</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>     <span style=color:#75715e>// ← Explicitly make it private
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>      <span style=color:#75715e>// ← Explicitly make it public
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=friend-class---controlled-access>Friend Class - Controlled Access<a hidden class=anchor aria-hidden=true href=#friend-class---controlled-access>#</a></h4><p><strong>The Problem</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TTEntry</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> key16;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... other fields
</span></span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TranspositionTable</span> {
</span></span><span style=display:flex><span>    TTEntry entries[MILLIONS];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>store</span>(<span style=color:#66d9ef>uint64_t</span> hash, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Need to access TTEntry internals!
</span></span></span><span style=display:flex><span>        entries[index].key16 <span style=color:#f92672>=</span> <span style=color:#f92672>???</span>;  <span style=color:#75715e>// ❌ ERROR: private!
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>TranspositionTable</strong> needs to manipulate TTEntry internals, but they&rsquo;re private!</p><p>The Solution: <code>friend</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TTEntry</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TranspositionTable</span>;  <span style=color:#75715e>// ← Grant access!
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> key16;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> move16;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TranspositionTable</span> {
</span></span><span style=display:flex><span>    TTEntry entries[MILLIONS];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>store</span>(<span style=color:#66d9ef>uint64_t</span> hash, <span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        entries[index].key16 <span style=color:#f92672>=</span> hash <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>48</span>;  <span style=color:#75715e>// ✓ OK! (friend access)
</span></span></span><span style=display:flex><span>        entries[index].value16 <span style=color:#f92672>=</span> compress(value);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>friend class TranspositionTable</code> means:</p><blockquote><p>&ldquo;TranspositionTable is my friend - it can access my private parts&rdquo;</p></blockquote><h3 id=collision-probability-in-transposition-tables>Collision Probability in Transposition Tables<a hidden class=anchor aria-hidden=true href=#collision-probability-in-transposition-tables>#</a></h3><p>A TT hit is accepted only if all 3 filters pass:
1. Same table index (lower bits match)
2. Same verification key (key16)
3. Same Zobrist hash (no real hash collision)</p><p>So a wrong reuse requires ALL THREE to collide simultaneously.</p><p>We estimate probability layer-by-layer.</p><h4 id=layer-1--index-collision-bucket-clash>Layer 1 — Index Collision (Bucket Clash)<a hidden class=anchor aria-hidden=true href=#layer-1--index-collision-bucket-clash>#</a></h4><p>We index using lower N bits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>index <span style=color:#f92672>=</span> zobrist <span style=color:#f92672>&amp;</span> (tableSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>For a table of size:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ae81ff>2</span><span style=color:#f92672>^</span><span style=color:#ae81ff>27</span> <span style=color:#960050;background-color:#1e0010>≈</span> <span style=color:#ae81ff>134</span> million entries
</span></span></code></pre></div><p>Two random positions collide in index with probability:</p><p>P1 = 1 / 2^27</p><p>So:</p><pre tabindex=0><code>≈ 1 in 134,217,728
</code></pre><p>But engines search billions of nodes → this happens often.
That’s why we need a verification key.</p><h4 id=layer-2--partial-key-verification-key16>Layer 2 — Partial Key Verification (key16)<a hidden class=anchor aria-hidden=true href=#layer-2--partial-key-verification-key16>#</a></h4><p>We store upper 16 bits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>stored.key16 <span style=color:#f92672>==</span> key <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>48</span>
</span></span></code></pre></div><p>Probability a random different position matches:</p><p>P2 = 1 / 2^16</p><pre tabindex=0><code>≈ 1 in 65,536
</code></pre><p>Now combined probability:</p><pre tabindex=0><code>P_{1+2} = 1 / 2^{27} × 1 / 2^{16} = 1 / 2^{43}

≈ 1 in 8.8 trillion
</code></pre><p>Already astronomically small.</p><h4 id=layer-3--real-zobrist-collision>Layer 3 — Real Zobrist Collision<a hidden class=anchor aria-hidden=true href=#layer-3--real-zobrist-collision>#</a></h4><p>Zobrist hashing is 64-bit random hashing.</p><p>Probability two different chess positions share the same hash:</p><p>P3 = 1 / 2^64</p><pre tabindex=0><code>≈ 1 in 18,446,744,073,709,551,616
</code></pre><h4 id=final-probability-all-layers-fail>Final Probability (All Layers Fail)<a hidden class=anchor aria-hidden=true href=#final-probability-all-layers-fail>#</a></h4><pre tabindex=0><code>P_{total} = 1 / 2^{27} × 1 / 2^{16} × 1 / 2^{64}
= 1 / 2^{107}

≈ 1 in 1.6 × 10^32
</code></pre><p>For perspective:</p><blockquote><p>You are more likely to win the lottery every week for the rest of your life than hit a harmful TT collision.</p></blockquote><p>Chess engines choose a practically perfect approach.</p><p>Even if a collision happens:</p><ul><li>evaluation error is small</li><li>future searches overwrite it</li><li>alpha-beta is resilient</li></ul><h3 id=ttentry-fields>TTEntry Fields<a hidden class=anchor aria-hidden=true href=#ttentry-fields>#</a></h3><pre tabindex=0><code>| Field       | Size     | Purpose                                      |
| ----------- | -------- | -------------------------------------------- |
| `key16`     | 16 bits  | Upper part of Zobrist key (verification)     |
| `move16`    | 16 bits  | Best move found from this position           |
| `value16`   | 16 bits  | Search result (score from search)            |
| `eval16`    | 16 bits  | Static evaluation (NNUE eval, before search) |
| `genBound8` | 6+2 bits | Entry age + bound type                       |
| `depth8`    | 8 bits   | Depth searched                               |
</code></pre><h4 id=1-uint16_t-key16---hash-verification>1. <code>uint16_t key16</code> - Hash Verification<a hidden class=anchor aria-hidden=true href=#1-uint16_t-key16---hash-verification>#</a></h4><p><strong>What it stores:</strong> upper 16 bits of the 64-bit Zobrist hash</p><p><strong>Why not store full 64-bit key?</strong></p><p>Memory.</p><p>A TT may contain hundreds of millions of entries.
Storing full keys would double the size → halve usable depth.</p><p>key16 is not the key used to index the table. It is only a collision checker.</p><p>A transposition table lookup has two stages:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> fullHash <span style=color:#f92672>=</span> zobristHash(position);  <span style=color:#75715e>// 64-bit hash
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Step 1: Find the slot
</span></span></span><span style=display:flex><span>size_t index <span style=color:#f92672>=</span> fullHash <span style=color:#f92672>&amp;</span> (tableSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// Use lower bits
</span></span></span><span style=display:flex><span>                                             <span style=color:#75715e>// Example: bits 0-26 for 128M entries
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Step 2: Store verification key
</span></span></span><span style=display:flex><span>entry<span style=color:#f92672>-&gt;</span>key16 <span style=color:#f92672>=</span> fullHash <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>48</span>;              <span style=color:#75715e>// Store upper 16 bits
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Later, when probing:
</span></span></span><span style=display:flex><span>TTEntry<span style=color:#f92672>*</span> entry <span style=color:#f92672>=</span> table[index];
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (entry<span style=color:#f92672>-&gt;</span>key16 <span style=color:#f92672>==</span> (fullHash <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>48</span>)) {     <span style=color:#75715e>// Verify match
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// Same position!
</span></span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Collision - different position in same slot
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=1-indexing-where-in-the-table>1. Indexing (where in the table?)<a hidden class=anchor aria-hidden=true href=#1-indexing-where-in-the-table>#</a></h5><p>We want to map a 64-bit hash to a valid table index:</p><pre tabindex=0><code>fullHash = 0xABCD_1234_5678_9EF0  (any 64-bit number)
tableSize = 134,217,728           (128 million entries)

Need: index in range [0, 134,217,727]
</code></pre><p><strong>Naive Approach: Modulo</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>size_t index <span style=color:#f92672>=</span> fullHash <span style=color:#f92672>%</span> tableSize;
</span></span></code></pre></div><p>Problem: Modulo (<code>%</code>) is slow on most CPUs (10-40 cycles).</p><p><strong>Fast Approach: Bitwise AND (When Size is Power of 2)</strong></p><p><strong>The Trick:</strong>
<strong>If tableSize is a power of 2</strong>, we can use bitwise AND instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>size_t index <span style=color:#f92672>=</span> fullHash <span style=color:#f92672>&amp;</span> (tableSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><p><strong>Bitwise AND (<code>&</code>) is extremely fast</strong> (1 cycle).</p><p><strong>Why This Works?</strong></p><p>Understanding Powers of 2 in Binary</p><pre tabindex=0><code>tableSize = 128M = 2^27 = 134,217,728

In binary:
2^27 = 1000_0000_0000_0000_0000_0000_0000  (1 followed by 27 zeros)

2^27 - 1 = 0111_1111_1111_1111_1111_1111_1111  (27 ones)
</code></pre><p><strong>The Magic of AND with (2^n - 1)</strong></p><p>When you AND any number with <code>(2^n - 1)</code>, you <strong>keep only the lower n bits</strong>:</p><pre tabindex=0><code>fullHash:        ????_????_????_????_????_????_????  (any bits)
(tableSize - 1): 0000_0000_0000_0000_0111_1111_1111  (27 ones)
                 ─────────────────────────────────
Result:          0000_0000_0000_0000_0???_????_????  (lower 27 bits)
</code></pre><p><strong>This is exactly the same as <code>fullHash % tableSize</code>!</strong></p><p>The important observation here is there are 27 ones in lower bits. So it has potentially select all numbers between 0 and 2^27. This wouldn&rsquo;t have been possible if all lower 27 bits weren&rsquo;t ones, Thus taking <code>(2^n - 1)</code> is important.</p><h5 id=2-verification-is-it-the-same-position>2. Verification (is it the same position?)<a hidden class=anchor aria-hidden=true href=#2-verification-is-it-the-same-position>#</a></h5><p>Uses UPPER 16 bits</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>stored.key16 <span style=color:#f92672>==</span> key <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>48</span>
</span></span></code></pre></div><p>This only checks:</p><blockquote><p>“Did we land on the correct position or just collide?”</p></blockquote><h4 id=2-move16--best-move-move-ordering-weapon>2. <code>move16</code> — Best move (move ordering weapon)<a hidden class=anchor aria-hidden=true href=#2-move16--best-move-move-ordering-weapon>#</a></h4><p>Stores: the best move previously found from this position</p><p>Remember <code>enum Move</code> is 16 bits.</p><p><strong>Why this is insanely important</strong></p><p>Alpha-beta effectiveness depends on searching the best move first.</p><p>Because if the best move is searched first:</p><pre tabindex=0><code>beta cutoff happens earlier
→ whole branches disappear
→ exponential speedup
</code></pre><p>So TT move is used as:</p><pre tabindex=0><code>FIRST move to search at this node
</code></pre><p>Even if evaluation is outdated, move ordering value remains huge.</p><blockquote><p>TT move ordering is one of the strongest heuristics in chess engines.</p></blockquote><h4 id=3-value16--search-result-alpha-beta-bound>3. <code>value16</code> — Search result (alpha-beta bound)<a hidden class=anchor aria-hidden=true href=#3-value16--search-result-alpha-beta-bound>#</a></h4><p><strong>Stores:</strong> the search score returned by alpha-beta</p><p>But important:
This is not always exact.</p><p>The key idea:</p><blockquote><p>A transposition table usually does not store the position value.
It stores information about the search window result.</p></blockquote><p>It doesn’t ask:</p><blockquote><p>“What is the exact value of this position?”</p></blockquote><p>It asks:</p><blockquote><p>“Is the value inside the window [alpha, beta]?”</p></blockquote><p>So most nodes never compute the exact score.</p><p><strong>Why alpha-beta rarely knows the real value</strong></p><p>Suppose we search with window:</p><pre tabindex=0><code>alpha = -0.50
beta  = +0.50
</code></pre><p>We are basically asking:</p><blockquote><p>“Is the position worse than -0.50, better than +0.50, or inside?”</p></blockquote><p>We stop searching as soon as we can prove one of those.</p><p>So the engine often returns <strong>inequalities</strong>, not numbers.</p><h5 id=the-three-possible-results>The Three Possible Results<a hidden class=anchor aria-hidden=true href=#the-three-possible-results>#</a></h5><p><strong>1. Exact value (PV node):</strong></p><p>We searched fully without cutoff.</p><pre tabindex=0><code>alpha &lt; score &lt; beta
</code></pre><p>Example:</p><pre tabindex=0><code>window = [-0.50, +0.50]
real score = +0.20
</code></pre><p>We had to examine all moves → we now KNOW the exact value.</p><p>Stored as:</p><pre tabindex=0><code>BOUND_EXACT
value16 = +0.20
</code></pre><p>This is rare — only principal variation nodes.</p><p><strong>2. Fail-High (Lower Bound)</strong></p><p>Search proves position is at least beta.</p><pre tabindex=0><code>score ≥ beta
</code></pre><p>Example:</p><pre tabindex=0><code>window = [-0.50, +0.50]
we find a move giving +1.80
</code></pre><p>Opponent would never allow this → we stop immediately.</p><p>We do NOT know the real score.
It might be +1.80, +3.00, or mate.</p><p>We only know:</p><blockquote><p>position ≥ +0.50</p></blockquote><p>Stored as:</p><pre tabindex=0><code>BOUND_LOWER
value16 = beta (or score)
meaning: score ≥ value16
</code></pre><p><strong>3. Fail-Low (Upper Bound)</strong></p><p>Search proves position is at most alpha.</p><pre tabindex=0><code>score ≤ alpha
</code></pre><p>Example:</p><pre tabindex=0><code>window = [-0.50, +0.50]
all moves ≤ -0.80
</code></pre><p>We stop — too bad for us.</p><p>We only know:</p><blockquote><p>position ≤ -0.50</p></blockquote><p>Stored as:</p><pre tabindex=0><code>BOUND_UPPER
value16 = alpha
meaning: score ≤ value16
</code></pre><h5 id=why-this-is-powerful-instant-pruning>Why this is powerful (instant pruning)<a hidden class=anchor aria-hidden=true href=#why-this-is-powerful-instant-pruning>#</a></h5><p>Later we revisit the same position with window:</p><pre tabindex=0><code>alpha = -0.30
beta  = +0.30
</code></pre><p>We probe TT.</p><p><strong>Case A — Stored LOWER bound ≥ beta</strong></p><p>Stored:</p><pre tabindex=0><code>score ≥ +0.50
</code></pre><p>Current search asks:</p><pre tabindex=0><code>Is score &lt; +0.30 ?
</code></pre><p>Impossible.</p><p>So we instantly prune — no search.</p><p><strong>Case B — Stored UPPER bound ≤ alpha</strong></p><p>Stored:</p><pre tabindex=0><code>score ≤ -0.50
</code></pre><p>Current search asks:</p><pre tabindex=0><code>Is score &gt; -0.30 ?
</code></pre><p>Impossible.</p><p>Instant prune again.</p><p><strong>Case C — Stored EXACT</strong></p><p>We directly return value.</p><p>No search at all.</p><p>So the general idea is when we start to search initally, we obviously want to know the exact score for that position not some alpha, beta range, but while doing so we will encounter millions of intermediate positions for whom we may not calculate exact score and prune if they are out of range, only if they lie in range we get exact value since it can contribute to final asnwer.</p><h5 id=value-range-and-encoding>Value Range and Encoding<a hidden class=anchor aria-hidden=true href=#value-range-and-encoding>#</a></h5><pre tabindex=0><code>// Stockfish value range:
VALUE_ZERO      = 0
VALUE_DRAW      = 0
VALUE_MATE      = 32000
VALUE_INFINITE  = 32001

// All fit in int16_t (-32768 to +32767)
// Positive = good for White
// Negative = good for Black
</code></pre><p><strong>Mate Distance Adjustment</strong></p><p>Engines encode mate as very large numbers:</p><pre tabindex=0><code>+32000  → winning mate
-32000  → getting mated
</code></pre><p>But they don’t store just mate yes/no — they store mate in N.</p><p>Why?</p><p>Because:</p><blockquote><p>Mate in 3 is better than mate in 10</p></blockquote><p>So engines encode:</p><pre tabindex=0><code>mate in N  =  +MATE - N
mated in N =  -MATE + N
</code></pre><p>Example:</p><pre tabindex=0><code>MATE = 32000

Mate in 1 = 31999
Mate in 2 = 31998
Mate in 3 = 31997
</code></pre><p>Higher = faster win</p><p><strong>Where the bug appears (Transposition Table)</strong></p><p>The SAME board position can appear at different depths in the tree.</p><p>But distance to mate from root is different.</p><p>Example tree:</p><p>From root:</p><pre tabindex=0><code>Root
 └── A
     └── B
         └── C  ← position P
             └── forced mate in 3
</code></pre><p>At node P, engine finds:</p><blockquote><p>mate in 3</p></blockquote><p>So evaluation stored:</p><pre tabindex=0><code>score = 31997
</code></pre><p>But this means:</p><blockquote><p>mate in 3 FROM P
NOT from root</p></blockquote><p>From root it’s actually:</p><pre tabindex=0><code>Root → A → B → C → mate in 3
distance from root = 3 + 3 = 6 plies
</code></pre><p>So correct root interpretation = mate in 6</p><p>Now suppose same position appears elsewhere:</p><pre tabindex=0><code>Root
 └── X
     └── Y
         └── Z
             └── W
                 └── P   ← same board again
</code></pre><p>Now P is deeper!</p><p>From here:</p><pre tabindex=0><code>mate in 3 from P = mate in 7 from root
</code></pre><p>BUT TT stored 31997 without context
Engine would think it’s mate in 3 again ❌</p><p>So engine thinks:</p><blockquote><p>This line mates faster than it really does</p></blockquote><p>→ causes wrong move ordering
→ even wrong best move selection</p><p><strong>The Fix: Store relative to ply</strong></p><p>We store mate score shifted by current depth (ply).</p><p>When storing</p><p>At node P:</p><pre tabindex=0><code>true local score = +31997 (mate in 3 from here)
current ply = 5 from root

storedValue = score + ply
            = 31997 + 5
            = 32002
</code></pre><p>We convert:</p><blockquote><p>from “mate from here” → “mate from root”</p></blockquote><p><strong>When retrieving later</strong></p><p>Suppose we reach P again at ply = 8:</p><pre tabindex=0><code>retrievedScore = storedValue - ply
               = 32002 - 8
               = 31994
</code></pre><p>Which equals:</p><pre tabindex=0><code>mate in 6 from here
</code></pre><h4 id=4-int16_t-eval16---static-evaluation>4. <code>int16_t eval16</code> - Static Evaluation<a hidden class=anchor aria-hidden=true href=#4-int16_t-eval16---static-evaluation>#</a></h4><p>Stores: evaluation without search (NNUE / handcrafted eval)</p><p><strong>Why store this separately from value16?</strong></p><p>Because:</p><pre tabindex=0><code>value = eval + tactics discovered during search
</code></pre><p>Later when probing:</p><p>If depth too shallow to trust value
→ engine still reuses eval</p><p>This avoids recomputing expensive evaluation (especially NNUE).</p><blockquote><p>Think of it as an evaluation memoization cache.</p></blockquote><h5 id=static-vs-search-evaluation>Static vs Search Evaluation<a hidden class=anchor aria-hidden=true href=#static-vs-search-evaluation>#</a></h5><p>STATIC EVAL (eval16):</p><ul><li>Just look at current position</li><li>Count material, position, king safety</li><li>No search ahead</li><li>Fast: ~1 microsecond</li><li>Example: +0.5 pawns</li></ul><p>SEARCH VALUE (value16):</p><ul><li>Minimax result after searching ahead</li><li>Considers tactics, forced sequences</li><li>Slow: varies with depth</li><li>Example: +2.0 pawns (found tactic)</li></ul><h4 id=5-uint8_t-genbound8---generation--bound-type>5. <code>uint8_t genBound8</code> - Generation & Bound Type<a hidden class=anchor aria-hidden=true href=#5-uint8_t-genbound8---generation--bound-type>#</a></h4><p>Two Pieces of Information Packed
This 8-bit field contains:</p><ol><li>Generation (upper 6 bits): Which search iteration stored this</li><li>Bound type (lower 2 bits): EXACT, LOWER_BOUND, or UPPER_BOUND</li></ol><p><strong>Part A: Generation (Replacement Scheme)</strong></p><p><strong>Purpose:</strong> Decide which entries to replace when TT is full.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// At start of each search:
</span></span></span><span style=display:flex><span>TT.new_search();  <span style=color:#75715e>// generation++ (0 → 1 → 2 → ... → 63 → 0)
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// When storing entry:
</span></span></span><span style=display:flex><span>entry<span style=color:#f92672>-&gt;</span>genBound8 <span style=color:#f92672>=</span> (generation <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>|</span> bound;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// When deciding to replace:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (entry<span style=color:#f92672>-&gt;</span>generation() <span style=color:#f92672>!=</span> currentGeneration) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Old entry from previous search
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// More likely to replace
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Generation wraparound</strong> (6 bits = 0-63):</p><pre tabindex=0><code>Search 1: generation = 1
Search 2: generation = 2
...
Search 63: generation = 63
Search 64: generation = 0 (wraps around)
</code></pre><p><strong>Replacement logic:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>shouldReplace</span>(TTEntry<span style=color:#f92672>*</span> existing, <span style=color:#66d9ef>int</span> newDepth, <span style=color:#66d9ef>int</span> currentGen) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Always replace if:
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. Empty slot
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (existing<span style=color:#f92672>-&gt;</span>depth8 <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. Same position (update)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (existing<span style=color:#f92672>-&gt;</span>key16 <span style=color:#f92672>==</span> newKey)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. Old generation AND new search is deeper
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (existing<span style=color:#f92672>-&gt;</span>generation() <span style=color:#f92672>!=</span> currentGen <span style=color:#f92672>&amp;&amp;</span> newDepth <span style=color:#f92672>&gt;=</span> existing<span style=color:#f92672>-&gt;</span>depth8)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. Much deeper search
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newDepth <span style=color:#f92672>&gt;</span> existing<span style=color:#f92672>-&gt;</span>depth8 <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Part B: Bound Type (Node Type)</strong></p><p><strong>Purpose:</strong> Know how to use the stored value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Bound</span> {
</span></span><span style=display:flex><span>    BOUND_NONE  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,  <span style=color:#75715e>// 00
</span></span></span><span style=display:flex><span>    BOUND_UPPER <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,  <span style=color:#75715e>// 01 (fail-low, all node)
</span></span></span><span style=display:flex><span>    BOUND_LOWER <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,  <span style=color:#75715e>// 10 (fail-high, cut node)  
</span></span></span><span style=display:flex><span>    BOUND_EXACT <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>   <span style=color:#75715e>// 11 (PV node)
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>How bound is determined:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// After search:
</span></span></span><span style=display:flex><span>Bound bound;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (value <span style=color:#f92672>&lt;=</span> alphaOrig)
</span></span><span style=display:flex><span>    bound <span style=color:#f92672>=</span> BOUND_UPPER;  <span style=color:#75715e>// Fail-low
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (value <span style=color:#f92672>&gt;=</span> beta)
</span></span><span style=display:flex><span>    bound <span style=color:#f92672>=</span> BOUND_LOWER;  <span style=color:#75715e>// Fail-high
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    bound <span style=color:#f92672>=</span> BOUND_EXACT;  <span style=color:#75715e>// Within window
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>entry<span style=color:#f92672>-&gt;</span>genBound8 <span style=color:#f92672>=</span> (generation <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>|</span> bound;
</span></span></code></pre></div><p><strong>Usage when retrieving:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (tte<span style=color:#f92672>-&gt;</span>depth() <span style=color:#f92672>&gt;=</span> depth) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> score <span style=color:#f92672>=</span> tte<span style=color:#f92672>-&gt;</span>value();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tte<span style=color:#f92672>-&gt;</span>bound() <span style=color:#f92672>==</span> BOUND_EXACT) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> score;  <span style=color:#75715e>// Use as-is
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (tte<span style=color:#f92672>-&gt;</span>bound() <span style=color:#f92672>==</span> BOUND_LOWER) {
</span></span><span style=display:flex><span>        alpha <span style=color:#f92672>=</span> max(alpha, score);  <span style=color:#75715e>// At least this good
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (tte<span style=color:#f92672>-&gt;</span>bound() <span style=color:#f92672>==</span> BOUND_UPPER) {
</span></span><span style=display:flex><span>        beta <span style=color:#f92672>=</span> min(beta, score);    <span style=color:#75715e>// At most this good
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (alpha <span style=color:#f92672>&gt;=</span> beta)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> score;  <span style=color:#75715e>// Cutoff
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=6-int8_t-depth8---search-depth>6. <code>int8_t depth8</code> - Search Depth<a hidden class=anchor aria-hidden=true href=#6-int8_t-depth8---search-depth>#</a></h4><p><strong>Purpose:</strong></p><p><strong>Track how deeply this position was searched</strong> - to decide if we can use this entry.</p><p>The Rule</p><pre tabindex=0><code>Can use TT entry ONLY if:
  storedDepth &gt;= currentSearchDepth
</code></pre><p><strong>Why?</strong></p><p>Previously searched to depth 5: value = +0.3
Now searching to depth 10</p><p>→ Depth 5 result is NOT good enough for depth 10!
→ Must search deeper
→ Don&rsquo;t use TT entry (except for move ordering)</p><h5 id=depth-values>Depth Values<a hidden class=anchor aria-hidden=true href=#depth-values>#</a></h5><pre tabindex=0><code>// Depth is measured in plies (half-moves):
DEPTH_ZERO = 0
ONE_PLY = 1

// Example values:
depth8 = 0:  Leaf node (just eval)
depth8 = 1:  Searched 1 ply (half-move)  
depth8 = 10: Searched 10 plies (5 full moves)
depth8 = 20: Searched 20 plies (10 full moves)

// Can be negative due to reductions!
depth8 = -1: Reduced below quiescence search
</code></pre><p><strong>Usage Example</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Searching position at depth 12
</span></span></span><span style=display:flex><span>TTEntry<span style=color:#f92672>*</span> tte <span style=color:#f92672>=</span> TT.probe(hash, found);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (found) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tte<span style=color:#f92672>-&gt;</span>depth() <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>12</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Previous search was deep enough
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// → Use stored value (if bound allows)
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> tte<span style=color:#f92672>-&gt;</span>value();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (tte<span style=color:#f92672>-&gt;</span>depth() <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>8</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Not deep enough for cutoff, but use move!
</span></span></span><span style=display:flex><span>        Move bestMove <span style=color:#f92672>=</span> tte<span style=color:#f92672>-&gt;</span>move();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try this move first
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Very shallow, might ignore completely
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// If not usable, search and store new result:
</span></span></span><span style=display:flex><span>value <span style=color:#f92672>=</span> search(...);
</span></span><span style=display:flex><span>TT.store(hash, value, depth<span style=color:#f92672>=</span><span style=color:#ae81ff>12</span>, ...);
</span></span></code></pre></div><p><strong>Depth and Replacement</strong></p><p>Deeper searches are more valuable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Replacement prefers keeping deeper searches:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (newDepth <span style=color:#f92672>&lt;=</span> existingDepth <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Don&#39;t replace much deeper entry
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;  <span style=color:#75715e>// Keep existing
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Example:</strong></p><pre tabindex=0><code>Slot contains: depth=15, value=+0.5, generation=5

New entry: depth=8, value=+0.3, generation=6
→ Don&#39;t replace! (15 &gt;&gt; 8, even though newer)

New entry: depth=16, value=+0.4, generation=6  
→ Replace! (16 &gt; 15, deeper search)
</code></pre><p><strong>Why int8_t? (Signed)</strong>
Range: -128 to +127
Needs to be signed for:</p><ol><li><strong>Reductions</strong>: Search can go below depth 0</li><li><strong>Extensions</strong>: Depth can increase beyond nominal</li><li><strong>Quiescence</strong>: Depth 0, -1, -2 during qsearch</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// During search:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (dangerousMove)
</span></span><span style=display:flex><span>    depth <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// Extend (depth could be 21, 22, etc.)
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (likelyBad)
</span></span><span style=display:flex><span>    depth <span style=color:#f92672>-=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>// Reduce (could go negative)
</span></span></span></code></pre></div><h2 id=transpositiontable>TranspositionTable<a hidden class=anchor aria-hidden=true href=#transpositiontable>#</a></h2><p>The transposition table (TT) is a large hash table storing previously searched positions so the engine can reuse search results instead of re-searching the tree</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// A TranspositionTable consists of a power of 2 number of clusters and each
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// cluster consists of ClusterSize number of TTEntry. Each non-empty entry
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// contains information of exactly one position. The size of a cluster should
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// divide the size of a cache line size, to ensure that clusters never cross
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// cache lines. This ensures best cache performance, as the cacheline is
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// prefetched, as soon as possible.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TranspositionTable</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> CacheLineSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ClusterSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cluster</span> {
</span></span><span style=display:flex><span>    TTEntry entry[ClusterSize];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> padding[<span style=color:#ae81ff>2</span>]; <span style=color:#75715e>// Align to a divisor of the cache line size
</span></span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static_assert</span>(CacheLineSize <span style=color:#f92672>%</span> <span style=color:#66d9ef>sizeof</span>(Cluster) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Cluster size incorrect&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>~</span>TranspositionTable() { free(mem); }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>new_search</span>() { generation8 <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>; } <span style=color:#75715e>// Lower 2 bits are used by Bound
</span></span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> <span style=color:#a6e22e>generation</span>() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> generation8; }
</span></span><span style=display:flex><span>  TTEntry<span style=color:#f92672>*</span> <span style=color:#a6e22e>probe</span>(<span style=color:#66d9ef>const</span> Key key, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&amp;</span> found) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hashfull</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>resize</span>(size_t mbSize);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The lowest order bits of the key are used to get the index of the cluster
</span></span></span><span style=display:flex><span>  TTEntry<span style=color:#f92672>*</span> <span style=color:#a6e22e>first_entry</span>(<span style=color:#66d9ef>const</span> Key key) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>table[(size_t)key <span style=color:#f92672>&amp;</span> (clusterCount <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)].entry[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  size_t clusterCount;
</span></span><span style=display:flex><span>  Cluster<span style=color:#f92672>*</span> table;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> mem;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> generation8; <span style=color:#75715e>// Size must be not bigger than TTEntry::genBound8
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=clustered-layout-important-performance-trick>Clustered Layout (Important Performance Trick)<a hidden class=anchor aria-hidden=true href=#clustered-layout-important-performance-trick>#</a></h3><h4 id=what-is-a-cluster>What is a Cluster<a hidden class=anchor aria-hidden=true href=#what-is-a-cluster>#</a></h4><p>A cluster is a small bucket that contains multiple TT entries.</p><p><strong>Layout</strong></p><pre tabindex=0><code>Transposition Table
│
├─ index 0 → Cluster → [ entry0, entry1, entry2 ]
├─ index 1 → Cluster → [ entry0, entry1, entry2 ]
├─ index 2 → Cluster → [ entry0, entry1, entry2 ]
...
</code></pre><p>In Stockfish:</p><pre tabindex=0><code>ClusterSize = 3
</code></pre><p>It means each hash index can store up to 3 different positions</p><p><strong>Why this exists</strong></p><p>If only 1 entry per index:</p><pre tabindex=0><code>hash collision → overwrite immediately → lose useful info
</code></pre><p>With clusters:</p><pre tabindex=0><code>hash collision → try next slot in same cluster
</code></pre><p><strong>What happens during probe</strong>
1. Compute index from key
2. Look at 3 entries in that cluster
3. If any matches key16 → hit
4. Otherwise choose a victim entry to replace (usually oldest / shallowest)</p><p><strong>Why 3?</strong></p><p>Because the entire cluster must fit in one 64-byte cache line</p><p>That gives maximum CPU memory efficiency while still tolerating collisions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> CacheLineSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> ClusterSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cluster</span> {
</span></span><span style=display:flex><span>    TTEntry entry[ClusterSize]; <span style=color:#75715e>// 10 * 3 = 30 bytes
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> padding[<span style=color:#ae81ff>2</span>]; <span style=color:#75715e>// 2 bytes padding 
</span></span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static_assert</span>(CacheLineSize <span style=color:#f92672>%</span> <span style=color:#66d9ef>sizeof</span>(Cluster) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Cluster size incorrect&#34;</span>);
</span></span></code></pre></div><p>Each <code>Cluster</code> is 32 bytes, keeping it aligned with 64 byte cache lines.</p><h3 id=methods-of-transpositiontable>Methods of TranspositionTable<a hidden class=anchor aria-hidden=true href=#methods-of-transpositiontable>#</a></h3><h4 id=first_entry>first_entry<a hidden class=anchor aria-hidden=true href=#first_entry>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>TTEntry<span style=color:#f92672>*</span> <span style=color:#a6e22e>first_entry</span>(<span style=color:#66d9ef>const</span> Key key) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>table[(size_t)key <span style=color:#f92672>&amp;</span> (clusterCount <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)].entry[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function takes the zobrist hash key and returns the first entry of TT cluster which could potentially have the position representing the key.</p><p>Instead of modulo:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>index <span style=color:#f92672>=</span> key <span style=color:#f92672>%</span> size   (slow)
</span></span></code></pre></div><p>Stockfish uses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>index <span style=color:#f92672>=</span> key <span style=color:#f92672>&amp;</span> (size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)   (<span style=color:#ae81ff>1</span> CPU cycle)
</span></span></code></pre></div><p>Works because table size is power of 2. (discussed earlier)</p><h4 id=generation-aging-mechanism>Generation (Aging Mechanism)<a hidden class=anchor aria-hidden=true href=#generation-aging-mechanism>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>new_search</span>() { generation8 <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> generation8;
</span></span></code></pre></div><p>TT entries get “older” across searches.</p><p>Purpose:</p><ul><li>prefer replacing old positions</li><li>keep recent analysis relevant</li><li>prevents table pollution</li></ul><p>Lower 2 bits of generation8 store bound type, upper bits store age.</p><p>Why <code>+= 4</code> Instead of <code>+= 1</code>?</p><p><strong>Remember <code>genBound8</code> packing:</strong></p><pre tabindex=0><code>genBound8 (8 bits):
┌─────────────┬─────┐
│ Generation  │Bound│
│  (6 bits)   │(2b) │
└─────────────┴─────┘
  Bits 7-2      Bits 1-0
</code></pre><p><code>TranspositionTable::generation8</code> represents global search age. It goes on from 0 to 65 and wraps back to 0.</p><h4 id=probe>probe<a hidden class=anchor aria-hidden=true href=#probe>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// TranspositionTable::probe() looks up the current position in the transposition
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// table. It returns true and a pointer to the TTEntry if the position is found.
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// Otherwise, it returns false and a pointer to an empty or least valuable TTEntry
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// to be replaced later. The replace value of an entry is calculated as its depth
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// minus 8 times its relative age. TTEntry t1 is considered more valuable than
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// TTEntry t2 if its replace value is greater than that of t2.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TTEntry<span style=color:#f92672>*</span> TranspositionTable<span style=color:#f92672>::</span>probe(<span style=color:#66d9ef>const</span> Key key, <span style=color:#66d9ef>bool</span><span style=color:#f92672>&amp;</span> found) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  TTEntry<span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> tte <span style=color:#f92672>=</span> first_entry(key);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint16_t</span> key16 <span style=color:#f92672>=</span> key <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>48</span>;  <span style=color:#75715e>// Use the high 16 bits as key inside the cluster
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ClusterSize; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tte[i].key16 <span style=color:#f92672>||</span> tte[i].key16 <span style=color:#f92672>==</span> key16)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> ((tte[i].genBound8 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>!=</span> generation8 <span style=color:#f92672>&amp;&amp;</span> tte[i].key16)
</span></span><span style=display:flex><span>              tte[i].genBound8 <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint8_t</span>(generation8 <span style=color:#f92672>|</span> tte[i].bound()); <span style=color:#75715e>// Refresh
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> found <span style=color:#f92672>=</span> (<span style=color:#66d9ef>bool</span>)tte[i].key16, <span style=color:#f92672>&amp;</span>tte[i];
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Find an entry to be replaced according to the replacement strategy
</span></span></span><span style=display:flex><span>  TTEntry<span style=color:#f92672>*</span> replace <span style=color:#f92672>=</span> tte;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> ClusterSize; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Due to our packed storage format for generation and its cyclic
</span></span></span><span style=display:flex><span>      <span style=color:#75715e>// nature we add 259 (256 is the modulus plus 3 to keep the lowest
</span></span></span><span style=display:flex><span>      <span style=color:#75715e>// two bound bits from affecting the result) to calculate the entry
</span></span></span><span style=display:flex><span>      <span style=color:#75715e>// age correctly even after generation8 overflows into the next cycle.
</span></span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (  replace<span style=color:#f92672>-&gt;</span>depth8 <span style=color:#f92672>-</span> ((<span style=color:#ae81ff>259</span> <span style=color:#f92672>+</span> generation8 <span style=color:#f92672>-</span> replace<span style=color:#f92672>-&gt;</span>genBound8) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>&gt;</span>   tte[i].depth8 <span style=color:#f92672>-</span> ((<span style=color:#ae81ff>259</span> <span style=color:#f92672>+</span> generation8 <span style=color:#f92672>-</span>   tte[i].genBound8) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>          replace <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>tte[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> found <span style=color:#f92672>=</span> false, replace;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>first_entry</code> returns the pointer to potential cluster containing the position. The for loop iterates through all 3 indexes of cluster. <code>key16</code> i.e., upper 16 bits of zobrist hash is used for validation.</p><p><strong>Refresh aging</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> ((tte[i].genBound8 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>!=</span> generation8 <span style=color:#f92672>&amp;&amp;</span> tte[i].key16)
</span></span><span style=display:flex><span>    tte[i].genBound8 <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint8_t</span>(generation8 <span style=color:#f92672>|</span> tte[i].bound());
</span></span></code></pre></div><pre tabindex=0><code>0xFC = 11111100
</code></pre><p>This masks out the lower 2 bits (bound).</p><p>So we compare only generation (age):</p><pre tabindex=0><code>stored generation != current generation
</code></pre><p>Meaning:</p><blockquote><p>“We touched this entry again in the new search — mark it as fresh.”</p></blockquote><p>This prevents good entries from being replaced too early.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>return</span> found <span style=color:#f92672>=</span> (<span style=color:#66d9ef>bool</span>)tte[i].key16, <span style=color:#f92672>&amp;</span>tte[i];
</span></span></code></pre></div><p>The function returns TTEntry*, a pointer to the chosen entry.</p><p>But this line looks weird because it uses a C/C++ trick:</p><p>It uses the comma operator.</p><p>In C/C++:</p><pre tabindex=0><code>A, B
</code></pre><p>means:
1. Evaluate A
2. Then evaluate B
3. The whole expression becomes B</p><p><code>found</code> will be assigned true, if <code>key16</code> is non-empty (cache-hit), since <code>found</code> is a pointer, its value will be used by caller.</p><h5 id=replacement-strategy>Replacement Strategy<a hidden class=anchor aria-hidden=true href=#replacement-strategy>#</a></h5><p>The replacement policy (which old entry to overwrite when the cluster is full).</p><p><strong>Step 1 — Start with first candidate</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>TTEntry<span style=color:#f92672>*</span> replace <span style=color:#f92672>=</span> tte;
</span></span></code></pre></div><p>Assume first slot is worst (for now).</p><p><strong>Step 2 — Compare with other 2 entries</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> ClusterSize; <span style=color:#f92672>++</span>i)
</span></span></code></pre></div><p>We compare slot 0 vs 1 vs 2
and keep the worst one in replace.</p><p>What Stockfish cares about</p><p>A TT entry is valuable if:
1. Searched deeper (depth) ✔ important
2. Recently used (generation) ✔ important</p><p>So they combine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>quality <span style=color:#f92672>=</span> depth <span style=color:#f92672>-</span> age_penalty
</span></span></code></pre></div><p>The formula</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>replace<span style=color:#f92672>-&gt;</span>depth8 <span style=color:#f92672>-</span> ((<span style=color:#ae81ff>259</span> <span style=color:#f92672>+</span> generation8 <span style=color:#f92672>-</span> replace<span style=color:#f92672>-&gt;</span>genBound8) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>tte[i].depth8 <span style=color:#f92672>-</span> ((<span style=color:#ae81ff>259</span> <span style=color:#f92672>+</span> generation8 <span style=color:#f92672>-</span> tte[i].genBound8) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>(<span style=color:#ae81ff>259</span> <span style=color:#f92672>+</span> generation8 <span style=color:#f92672>-</span> entry.genBound8) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>
</span></span></code></pre></div><p>This computes:</p><blockquote><p>How old is this entry? (even if generation wrapped around 255 → 0)</p></blockquote><p>The general idea is</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Replacement score = depth - age_penalty
</span></span></span><span style=display:flex><span>score <span style=color:#f92672>=</span> depth8 <span style=color:#f92672>-</span> (currentGen <span style=color:#f92672>-</span> entryGen) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Since generation is more important, its multiplied by 2 to give higher weightage.</p><p>Its subtracted by 259 to handle wrap around.</p><h4 id=hashfull>hashfull<a hidden class=anchor aria-hidden=true href=#hashfull>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// TranspositionTable::hashfull() returns an approximation of the hashtable
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// occupation during a search. The hash is x permill full, as per UCI protocol.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> TranspositionTable<span style=color:#f92672>::</span>hashfull() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000</span> <span style=color:#f92672>/</span> ClusterSize; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> TTEntry<span style=color:#f92672>*</span> tte <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>table[i].entry[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> ClusterSize; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> ((tte[j].genBound8 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFC</span>) <span style=color:#f92672>==</span> generation8)
</span></span><span style=display:flex><span>              cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> cnt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Purpose: Estimate how full the TT is (for time management)</p><p>Stockfish does sampling instead of scanning the entire table (which could be hundreds of MB).</p><p><strong>How it works</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000</span> <span style=color:#f92672>/</span> ClusterSize; i<span style=color:#f92672>++</span>)
</span></span></code></pre></div><p>Quick note: <code>1000 / ClusterSize</code> might seem like we are performing division on every loop, but since <code>ClusterSize</code> is also a compile time constant, compiler evaluates it to 333 at compile time itself.</p><p>ClusterSize = 3 → 1000/3 ≈ 333 clusters</p><p>So engine checks about 1000 entries total:</p><pre tabindex=0><code>333 clusters × 3 entries each ≈ 999 entries
</code></pre><p><strong>Why this works (statistics intuition)</strong></p><p>The TT entries are essentially randomly distributed because:</p><blockquote><p>Zobrist hashes are random → positions land uniformly in table</p></blockquote><p>So:</p><p>Checking 1000 random entries
≈ same ratio as checking 10 million entries</p><p>Per-mille means:</p><blockquote><p>parts per thousand (like percent = per hundred)</p></blockquote><p>1‰ = 1 / 1000</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/transposition-tables/>Transposition Tables</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>