<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ Used in Stockfish | Sanketh's Blog</title><meta name=keywords content="c++,stockfish"><meta name=description content="C++ Used in Stockfish
Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.
Enums as Core Types
Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="C++ Used in Stockfish"><meta property="og:description" content="C++ Used in Stockfish Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.
Enums as Core Types Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-05T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-05T00:00:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Stockfish"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ Used in Stockfish"><meta name=twitter:description content="C++ Used in Stockfish
Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.
Enums as Core Types
Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"C++ Used in Stockfish","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ Used in Stockfish","name":"C\u002b\u002b Used in Stockfish","description":"C++ Used in Stockfish Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.\nEnums as Core Types Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values.\n","keywords":["c++","stockfish"],"articleBody":"C++ Used in Stockfish Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.\nEnums as Core Types Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values.\nExamples include:\nColor → WHITE, BLACK PieceType → PAWN, KNIGHT, BISHOP, … Piece → W_PAWN, B_QUEEN, … Square → SQ_A1 … SQ_H8 Move → encoded 16-bit integer These enums are not just labels — their numeric values are deliberately chosen so that:\nBitwise operations are meaningful Conversions are cheap Lookups can be done via array indexing Arithmetic on enums is valid and efficient Inline Functions An inline function is a function that the compiler is allowed (not forced) to replace with the function’s body at the call site.\nint f(int x) { return x + 1; } int y = f(a); The compiler may generate:\nint y = a + 1; Why inline functions matter in Stockfish\nNo function call overhead (no stack push/pop, no jumps) Enables constant folding and dead code elimination Allows bit-level operations to be optimized aggressively Critical in hot loops (move generation, evaluation, search) Most Stockfish inline functions:\nAre tiny (1–3 operations) Operate on enums or bitboards Exist purely to give meaning to raw integers Attaching Behavior with Inline Functions Instead of member functions on classes, Stockfish attaches behavior to enums using free inline functions.\ninline File file_of(Square s) { return File(s \u0026 7); } inline Rank rank_of(Square s) { return Rank(s \u003e\u003e 3); } inline PieceType type_of(Piece pc) { return PieceType(pc \u0026 7); } inline Color color_of(Piece pc) { return Color(pc \u003e\u003e 3); } This approach replaces methods like:\nsquare.file() piece.color() with faster, simpler operations.\nOperator Overloading on Enums Stockfish overloads arithmetic and logical operators on enums to make them behave like small, type-safe integers.\nENABLE_FULL_OPERATORS_ON(Square) ENABLE_FULL_OPERATORS_ON(PieceType) ENABLE_FULL_OPERATORS_ON(Value) This allows expressions such as:\nSquare s = SQ_E2 + NORTH; Value v = VALUE_MATE - ply; without runtime overhead or loss of clarity.\nENABLE_FULL_OPERATORS_ON is a macro that generates operator overloads for enum-like types.\nThe macro (simplified idea)\n#define ENABLE_FULL_OPERATORS_ON(T) \\ inline T operator+(T a, T b) { return T(int(a) + int(b)); } \\ inline T operator-(T a, T b) { return T(int(a) - int(b)); } \\ inline T\u0026 operator++(T\u0026 a) { return a = T(int(a) + 1); } \\ Enums + Templates = Compile-Time Polymorphism Instead of object-oriented polymorphism, Stockfish uses templates to specialize code at compile time.\ntemplate\u003cPieceType Pt\u003e Bitboard attacks_from(Square s); This lets the compiler generate separate, fully optimized code paths for knights, bishops, rooks, etc., without branches or virtual dispatch.\npos.attacks_from\u003cKNIGHT\u003e(s); pos.attacks_from\u003cBISHOP\u003e(s) This pattern appears everywhere in evaluation, move generation, and attack calculation.\nGenerics and Metaprogramming in Stockfish Stockfish makes heavy use of compile-time polymorphism rather than runtime polymorphism. Instead of relying on inheritance, virtual functions, or dynamic dispatch, it uses templates, constexpr logic, and specialization to generate highly optimized code paths at compile time. This approach is central to Stockfish’s performance.\nTemplates as Zero-Cost Abstractions In Stockfish, templates are used to express conceptual differences—such as piece type, color, or evaluation mode—without paying any runtime cost.\nWhen a template function is instantiated with a specific PieceType, the compiler generates a separate function containing only the code relevant to that piece. Conditional logic depending on the template parameter is resolved at compile time, and all unused branches are completely removed.\nWhen the compiler sees:\ntemplate\u003cPieceType Pt\u003e inline Bitboard attacks_bb(Square s, Bitboard occupied) { return (Pt == ROOK ? RookAttacks : BishopAttacks) [s][magic_index\u003cPt\u003e(s, occupied)]; } it does not generate one generic function and branch at runtime.\nInstead, it generates separate concrete functions, and each one contains only the relevant code.\nFor Pt = ROOK, i.e., when compiler sees a call like\nattacks_bb\u003c ROOK\u003e(s, pos.pieces() ^ pos.pieces(Us, ROOK, QUEEN)) It generates a function attacks_bb_rook\ninline Bitboard attacks_bb_rook(Square s, Bitboard occupied) { return RookAttacks[s][magic_index\u003cROOK\u003e(s, occupied)]; } The condition Pt == ROOK is true at compile time The BishopAttacks branch is removed No ternary operator remains No runtime check exists For Pt = BISHOP\nattacks_bb\u003cBISHOP\u003e(s, pos.pieces() ^ pos.pieces(Us, QUEEN)) inline Bitboard attacks_bb_bishop(Square s, Bitboard occupied) { return BishopAttacks[s][magic_index\u003cBISHOP\u003e(s, occupied)]; } Sometimes when type is not known at compile time, we can use the runtime version, which does explicit branching based on the template type, this introduces branching which is not free.\ninline Bitboard attacks_bb(Piece pc, Square s, Bitboard occupied) { switch (type_of(pc)) { case BISHOP: return attacks_bb\u003cBISHOP\u003e(s, occupied); case ROOK : return attacks_bb\u003cROOK\u003e(s, occupied); case QUEEN : return attacks_bb\u003cBISHOP\u003e(s, occupied) | attacks_bb\u003cROOK\u003e(s, occupied); default : return StepAttacksBB[pc][s]; } } Template Specialization for Termination and Control Templates are also used to express recursive logic at compile time.\ntemplate\u003cbool DoTrace, Color Us, PieceType Pt\u003e Score evaluate_pieces(...); This function recursively evaluates piece types:\nKNIGHT → BISHOP → ROOK → QUEEN → KING Termination is handled via explicit specialization:\ntemplate\u003c\u003e Score evaluate_pieces\u003cfalse, WHITE, KING\u003e(...) { return SCORE_ZERO; } This avoids:\nRuntime loops Dynamic type checks Virtual dispatch The recursion is unrolled at compile time.\nBoolean Template Parameters for Feature Stripping Stockfish often uses boolean template parameters like:\ntemplate\u003cbool DoTrace\u003e Value evaluate(const Position\u0026 pos); This allows:\nTracing logic to be completely removed when DoTrace == false Zero overhead in production builds Debug-only code without if checks Two Ways Templates Create Multiple Versions of a Function In C++, templates can produce multiple concrete versions of a function in two distinct ways. Stockfish relies on both mechanisms to precisely control performance and code generation.\nA. Implicit Instantiation (Compiler-Generated) Implicit instantiation occurs when a template function is used with a specific set of template parameters, but no explicit specialization is provided by the programmer.\ntemplate\u003cPieceType Pt\u003e Bitboard attacks_bb(Square s, Bitboard occupied); When the code calls:\nattacks_bb\u003cBISHOP\u003e(s, occupied); attacks_bb\u003cROOK\u003e(s, occupied); the compiler automatically:\nGenerates a separate concrete function for each template argument Substitutes the template parameter (Pt) with a compile-time constant Eliminates all code paths that depend on other values of Pt Aggressively inlines the resulting function Each instantiation is fully specialized and optimized as if it had been written by hand for that specific piece type.\nThis is the most common form of template usage in Stockfish and forms the backbone of its compile-time polymorphism.\nB. Explicit Specialization (Programmer-Defined) In some cases, Stockfish explicitly defines a custom implementation for a specific set of template parameters.\ntemplate\u003c\u003e Score evaluate_pieces\u003cfalse, WHITE, KING\u003e(...) { return SCORE_ZERO; } This tells the compiler:\nDo not generate a default implementation for this parameter combination Use this explicitly defined version instead Explicit specialization is used to:\nTerminate compile-time recursion Handle special cases cleanly Avoid runtime conditionals Keep performance-critical paths minimal Linkage, extern, and the One Definition Rule (ODR) Stockfish is split across many translation units (.cpp files), but large parts of its logic depend on shared global data such as piece values, attack tables, and evaluation constants. To make this work efficiently and correctly, Stockfish relies on C++ linkage rules, especially extern.\nWhat Linkage Means in C++ Linkage determines whether a symbol (variable or function) refers to the same entity across different source files.\nExternal linkage → the symbol is shared across translation units Internal linkage → the symbol exists only within one translation unit By default:\nFunctions have external linkage Global variables have external linkage unless marked static Why extern Is Used in Stockfish Consider this declaration in a header file:\nextern Value PieceValue[PHASE_NB][PIECE_NB]; This tells the compiler:\n“This variable exists somewhere” “Do not allocate storage here” “The definition will be provided in exactly one .cpp file” The actual definition appears in psqt.cpp:\nValue PieceValue[PHASE_NB][PIECE_NB] = { { VALUE_ZERO, PawnValueMg, KnightValueMg, BishopValueMg, RookValueMg, QueenValueMg }, { VALUE_ZERO, PawnValueEg, KnightValueEg, BishopValueEg, RookValueEg, QueenValueEg } }; This separation allows:\nThe variable to be shared across the entire engine Only one copy to exist in memory Fast direct access without function calls This is a global variable, one copy maintained across the entire program Internal Linkage Consider this definition in types.h\nconst Piece Pieces[] = { W_PAWN, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING }; Technically: This declares a global array.\nPractically: The const keyword gives it internal linkage in C++, meaning:\nEach translation unit (.cpp file) that includes types.h gets its own copy No linker errors about “multiple definitions” Still problematic if you want a single shared instance If we remove const, then it will be considered as external linkage. The linker would see: multiple definition of Pieces and throws error.\n","wordCount":"1450","inLanguage":"en","datePublished":"2026-01-05T00:00:00Z","dateModified":"2026-01-05T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-05-c++-used-in-stockfish/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">C++ Used in Stockfish</h1><div class=post-meta><span title='2026-01-05 00:00:00 +0000 UTC'>January 5, 2026</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-05-c++-used-in-stockfish.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c-used-in-stockfish aria-label="C++ Used in Stockfish">C++ Used in Stockfish</a><ul><li><a href=#enums-as-core-types aria-label="Enums as Core Types">Enums as Core Types</a><ul><li><a href=#inline-functions aria-label="Inline Functions">Inline Functions</a></li><li><a href=#attaching-behavior-with-inline-functions aria-label="Attaching Behavior with Inline Functions">Attaching Behavior with Inline Functions</a></li><li><a href=#operator-overloading-on-enums aria-label="Operator Overloading on Enums">Operator Overloading on Enums</a></li><li><a href=#enums--templates--compile-time-polymorphism aria-label="Enums + Templates = Compile-Time Polymorphism">Enums + Templates = Compile-Time Polymorphism</a></li></ul></li><li><a href=#generics-and-metaprogramming-in-stockfish aria-label="Generics and Metaprogramming in Stockfish">Generics and Metaprogramming in Stockfish</a><ul><li><a href=#templates-as-zero-cost-abstractions aria-label="Templates as Zero-Cost Abstractions">Templates as Zero-Cost Abstractions</a></li><li><a href=#template-specialization-for-termination-and-control aria-label="Template Specialization for Termination and Control">Template Specialization for Termination and Control</a></li><li><a href=#boolean-template-parameters-for-feature-stripping aria-label="Boolean Template Parameters for Feature Stripping">Boolean Template Parameters for Feature Stripping</a></li><li><a href=#two-ways-templates-create-multiple-versions-of-a-function aria-label="Two Ways Templates Create Multiple Versions of a Function">Two Ways Templates Create Multiple Versions of a Function</a><ul><li><a href=#a-implicit-instantiation-compiler-generated aria-label="A. Implicit Instantiation (Compiler-Generated)">A. Implicit Instantiation (Compiler-Generated)</a></li><li><a href=#b-explicit-specialization-programmer-defined aria-label="B. Explicit Specialization (Programmer-Defined)">B. Explicit Specialization (Programmer-Defined)</a></li></ul></li></ul></li><li><a href=#linkage-extern-and-the-one-definition-rule-odr aria-label="Linkage, extern, and the One Definition Rule (ODR)">Linkage, extern, and the One Definition Rule (ODR)</a><ul><li><a href=#what-linkage-means-in-c aria-label="What Linkage Means in C++">What Linkage Means in C++</a></li><li><a href=#why-extern-is-used-in-stockfish aria-label="Why extern Is Used in Stockfish">Why extern Is Used in Stockfish</a></li><li><a href=#internal-linkage aria-label="Internal Linkage">Internal Linkage</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=c-used-in-stockfish>C++ Used in Stockfish<a hidden class=anchor aria-hidden=true href=#c-used-in-stockfish>#</a></h1><p>Stockfish is written in a style of C++ that prioritizes performance, predictability, and compile-time resolution over traditional object-oriented design. Rather than heavy use of classes, inheritance, or virtual functions, the engine relies on enums, inline functions, templates, bitwise operations, and plain data structures. This makes the code extremely fast, cache-friendly, and suitable for deep search loops executed billions of times.</p><h2 id=enums-as-core-types>Enums as Core Types<a hidden class=anchor aria-hidden=true href=#enums-as-core-types>#</a></h2><p>Enums form the backbone of Stockfish’s type system. Instead of using classes for concepts like pieces, squares, colors, or moves, Stockfish represents them as enums with carefully chosen integer values.</p><p>Examples include:</p><ul><li>Color → WHITE, BLACK</li><li>PieceType → PAWN, KNIGHT, BISHOP, …</li><li>Piece → W_PAWN, B_QUEEN, …</li><li>Square → SQ_A1 … SQ_H8</li><li>Move → encoded 16-bit integer</li></ul><p>These enums are not just labels — their numeric values are deliberately chosen so that:</p><ul><li>Bitwise operations are meaningful</li><li>Conversions are cheap</li><li>Lookups can be done via array indexing</li><li>Arithmetic on enums is valid and efficient</li></ul><h3 id=inline-functions>Inline Functions<a hidden class=anchor aria-hidden=true href=#inline-functions>#</a></h3><p>An inline function is a function that the compiler is allowed (not forced) to replace with the function’s body at the call site.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span> x) { <span style=color:#66d9ef>return</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> f(a);
</span></span></code></pre></div><p>The compiler may generate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>Why inline functions matter in Stockfish</p><ul><li>No function call overhead (no stack push/pop, no jumps)</li><li>Enables constant folding and dead code elimination</li><li>Allows bit-level operations to be optimized aggressively</li><li>Critical in hot loops (move generation, evaluation, search)</li></ul><p>Most Stockfish inline functions:</p><ul><li>Are tiny (1–3 operations)</li><li>Operate on enums or bitboards</li><li>Exist purely to give meaning to raw integers</li></ul><h3 id=attaching-behavior-with-inline-functions>Attaching Behavior with Inline Functions<a hidden class=anchor aria-hidden=true href=#attaching-behavior-with-inline-functions>#</a></h3><p>Instead of member functions on classes, Stockfish attaches behavior to enums using free inline functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>inline</span> File <span style=color:#a6e22e>file_of</span>(Square s) { <span style=color:#66d9ef>return</span> File(s <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Rank <span style=color:#a6e22e>rank_of</span>(Square s) { <span style=color:#66d9ef>return</span> Rank(s <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> PieceType <span style=color:#a6e22e>type_of</span>(Piece pc) { <span style=color:#66d9ef>return</span> PieceType(pc <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Color <span style=color:#a6e22e>color_of</span>(Piece pc) { <span style=color:#66d9ef>return</span> Color(pc <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>); }
</span></span></code></pre></div><p>This approach replaces methods like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>square.file()
</span></span><span style=display:flex><span>piece.color()
</span></span></code></pre></div><p>with faster, simpler operations.</p><h3 id=operator-overloading-on-enums>Operator Overloading on Enums<a hidden class=anchor aria-hidden=true href=#operator-overloading-on-enums>#</a></h3><p>Stockfish overloads arithmetic and logical operators on enums to make them behave like small, type-safe integers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>ENABLE_FULL_OPERATORS_ON(Square)
</span></span><span style=display:flex><span>ENABLE_FULL_OPERATORS_ON(PieceType)
</span></span><span style=display:flex><span>ENABLE_FULL_OPERATORS_ON(Value)
</span></span></code></pre></div><p>This allows expressions such as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>Square s <span style=color:#f92672>=</span> SQ_E2 <span style=color:#f92672>+</span> NORTH;
</span></span><span style=display:flex><span>Value v <span style=color:#f92672>=</span> VALUE_MATE <span style=color:#f92672>-</span> ply;
</span></span></code></pre></div><p>without runtime overhead or loss of clarity.</p><p><code>ENABLE_FULL_OPERATORS_ON</code> is a macro that generates operator overloads for enum-like types.</p><p>The macro (simplified idea)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define ENABLE_FULL_OPERATORS_ON(T) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>inline T operator+(T a, T b) { return T(int(a) + int(b)); } \
</span></span></span><span style=display:flex><span><span style=color:#75715e>inline T operator-(T a, T b) { return T(int(a) - int(b)); } \
</span></span></span><span style=display:flex><span><span style=color:#75715e>inline T&amp; operator++(T&amp; a)   { return a = T(int(a) + 1); } \
</span></span></span></code></pre></div><h3 id=enums--templates--compile-time-polymorphism>Enums + Templates = Compile-Time Polymorphism<a hidden class=anchor aria-hidden=true href=#enums--templates--compile-time-polymorphism>#</a></h3><p>Instead of object-oriented polymorphism, Stockfish uses templates to specialize code at compile time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>Bitboard attacks_from(Square s);
</span></span></code></pre></div><p>This lets the compiler generate separate, fully optimized code paths for knights, bishops, rooks, etc., without branches or virtual dispatch.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>pos.attacks_from<span style=color:#f92672>&lt;</span>KNIGHT<span style=color:#f92672>&gt;</span>(s);
</span></span><span style=display:flex><span>pos.attacks_from<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s)
</span></span></code></pre></div><p>This pattern appears everywhere in evaluation, move generation, and attack calculation.</p><h2 id=generics-and-metaprogramming-in-stockfish>Generics and Metaprogramming in Stockfish<a hidden class=anchor aria-hidden=true href=#generics-and-metaprogramming-in-stockfish>#</a></h2><p>Stockfish makes heavy use of compile-time polymorphism rather than runtime polymorphism. Instead of relying on inheritance, virtual functions, or dynamic dispatch, it uses templates, constexpr logic, and specialization to generate highly optimized code paths at compile time. This approach is central to Stockfish’s performance.</p><h3 id=templates-as-zero-cost-abstractions>Templates as Zero-Cost Abstractions<a hidden class=anchor aria-hidden=true href=#templates-as-zero-cost-abstractions>#</a></h3><p>In Stockfish, templates are used to express conceptual differences—such as piece type, color, or evaluation mode—without paying any runtime cost.</p><p>When a template function is instantiated with a specific PieceType, the compiler generates a separate function containing only the code relevant to that piece. Conditional logic depending on the template parameter is resolved at compile time, and all unused branches are completely removed.</p><p>When the compiler sees:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard attacks_bb(Square s, Bitboard occupied) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>?</span> RookAttacks : BishopAttacks)
</span></span><span style=display:flex><span>         [s][magic_index<span style=color:#f92672>&lt;</span>Pt<span style=color:#f92672>&gt;</span>(s, occupied)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>it does not generate one generic function and branch at runtime.</p><p>Instead, it generates separate concrete functions, and each one contains only the relevant code.</p><p>For Pt = ROOK, i.e., when compiler sees a call like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>attacks_bb<span style=color:#f92672>&lt;</span>  ROOK<span style=color:#f92672>&gt;</span>(s, pos.pieces() <span style=color:#f92672>^</span> pos.pieces(Us, ROOK, QUEEN))
</span></span></code></pre></div><p>It generates a function <code>attacks_bb_rook</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard <span style=color:#a6e22e>attacks_bb_rook</span>(Square s, Bitboard occupied) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> RookAttacks[s][magic_index<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(s, occupied)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>The condition Pt == ROOK is true at compile time</li><li>The BishopAttacks branch is removed</li><li>No ternary operator remains</li><li>No runtime check exists</li></ul><p>For Pt = BISHOP</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s, pos.pieces() <span style=color:#f92672>^</span> pos.pieces(Us, QUEEN))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard <span style=color:#a6e22e>attacks_bb_bishop</span>(Square s, Bitboard occupied) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> BishopAttacks[s][magic_index<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s, occupied)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sometimes when type is not known at compile time, we can use the runtime version, which does explicit branching based on the template type, this introduces branching which is not free.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>inline</span> Bitboard <span style=color:#a6e22e>attacks_bb</span>(Piece pc, Square s, Bitboard occupied) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (type_of(pc))
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> BISHOP: <span style=color:#66d9ef>return</span> attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s, occupied);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> ROOK  : <span style=color:#66d9ef>return</span> attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(s, occupied);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> QUEEN : <span style=color:#66d9ef>return</span> attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s, occupied) <span style=color:#f92672>|</span> attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(s, occupied);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>default</span>    <span style=color:#f92672>:</span> <span style=color:#66d9ef>return</span> StepAttacksBB[pc][s];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=template-specialization-for-termination-and-control>Template Specialization for Termination and Control<a hidden class=anchor aria-hidden=true href=#template-specialization-for-termination-and-control>#</a></h3><p>Templates are also used to express recursive logic at compile time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span> DoTrace, Color Us, PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>Score evaluate_pieces(...);
</span></span></code></pre></div><p>This function recursively evaluates piece types:</p><ul><li>KNIGHT → BISHOP → ROOK → QUEEN → KING</li></ul><p>Termination is handled via explicit specialization:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span>Score evaluate_pieces<span style=color:#f92672>&lt;</span>false, WHITE, KING<span style=color:#f92672>&gt;</span>(...) { <span style=color:#66d9ef>return</span> SCORE_ZERO; }
</span></span></code></pre></div><p>This avoids:</p><ul><li>Runtime loops</li><li>Dynamic type checks</li><li>Virtual dispatch</li></ul><p>The recursion is unrolled at compile time.</p><h3 id=boolean-template-parameters-for-feature-stripping>Boolean Template Parameters for Feature Stripping<a hidden class=anchor aria-hidden=true href=#boolean-template-parameters-for-feature-stripping>#</a></h3><p>Stockfish often uses boolean template parameters like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span> DoTrace<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>Value evaluate(<span style=color:#66d9ef>const</span> Position<span style=color:#f92672>&amp;</span> pos);
</span></span></code></pre></div><p>This allows:</p><ul><li>Tracing logic to be completely removed when DoTrace == false</li><li>Zero overhead in production builds</li><li>Debug-only code without if checks</li></ul><h3 id=two-ways-templates-create-multiple-versions-of-a-function>Two Ways Templates Create Multiple Versions of a Function<a hidden class=anchor aria-hidden=true href=#two-ways-templates-create-multiple-versions-of-a-function>#</a></h3><p>In C++, templates can produce multiple concrete versions of a function in two distinct ways. Stockfish relies on both mechanisms to precisely control performance and code generation.</p><h4 id=a-implicit-instantiation-compiler-generated>A. Implicit Instantiation (Compiler-Generated)<a hidden class=anchor aria-hidden=true href=#a-implicit-instantiation-compiler-generated>#</a></h4><p>Implicit instantiation occurs when a template function is used with a specific set of template parameters, but no explicit specialization is provided by the programmer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>Bitboard attacks_bb(Square s, Bitboard occupied);
</span></span></code></pre></div><p>When the code calls:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>attacks_bb<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>(s, occupied);
</span></span><span style=display:flex><span>attacks_bb<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>(s, occupied);
</span></span></code></pre></div><p>the compiler automatically:</p><ul><li>Generates a separate concrete function for each template argument</li><li>Substitutes the template parameter (Pt) with a compile-time constant</li><li>Eliminates all code paths that depend on other values of Pt</li><li>Aggressively inlines the resulting function</li></ul><p>Each instantiation is fully specialized and optimized as if it had been written by hand for that specific piece type.</p><p>This is the most common form of template usage in Stockfish and forms the backbone of its compile-time polymorphism.</p><h4 id=b-explicit-specialization-programmer-defined>B. Explicit Specialization (Programmer-Defined)<a hidden class=anchor aria-hidden=true href=#b-explicit-specialization-programmer-defined>#</a></h4><p>In some cases, Stockfish explicitly defines a custom implementation for a specific set of template parameters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span>Score evaluate_pieces<span style=color:#f92672>&lt;</span>false, WHITE, KING<span style=color:#f92672>&gt;</span>(...) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> SCORE_ZERO;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This tells the compiler:</p><ul><li>Do not generate a default implementation for this parameter combination</li><li>Use this explicitly defined version instead</li></ul><p>Explicit specialization is used to:</p><ul><li>Terminate compile-time recursion</li><li>Handle special cases cleanly</li><li>Avoid runtime conditionals</li><li>Keep performance-critical paths minimal</li></ul><h2 id=linkage-extern-and-the-one-definition-rule-odr>Linkage, extern, and the One Definition Rule (ODR)<a hidden class=anchor aria-hidden=true href=#linkage-extern-and-the-one-definition-rule-odr>#</a></h2><p>Stockfish is split across many translation units (.cpp files), but large parts of its logic depend on shared global data such as piece values, attack tables, and evaluation constants. To make this work efficiently and correctly, Stockfish relies on C++ linkage rules, especially extern.</p><h3 id=what-linkage-means-in-c>What Linkage Means in C++<a hidden class=anchor aria-hidden=true href=#what-linkage-means-in-c>#</a></h3><p>Linkage determines whether a symbol (variable or function) refers to the same entity across different source files.</p><ul><li>External linkage → the symbol is shared across translation units</li><li>Internal linkage → the symbol exists only within one translation unit</li></ul><p>By default:</p><ul><li>Functions have external linkage</li><li>Global variables have external linkage unless marked static</li></ul><h3 id=why-extern-is-used-in-stockfish>Why extern Is Used in Stockfish<a hidden class=anchor aria-hidden=true href=#why-extern-is-used-in-stockfish>#</a></h3><p>Consider this declaration in a header file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>extern</span> Value PieceValue[PHASE_NB][PIECE_NB];
</span></span></code></pre></div><p>This tells the compiler:</p><ul><li>“This variable exists somewhere”</li><li>“Do not allocate storage here”</li><li>“The definition will be provided in exactly one .cpp file”</li></ul><p>The actual definition appears in <code>psqt.cpp</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>Value PieceValue[PHASE_NB][PIECE_NB] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  { VALUE_ZERO, PawnValueMg, KnightValueMg, BishopValueMg, RookValueMg, QueenValueMg },
</span></span><span style=display:flex><span>  { VALUE_ZERO, PawnValueEg, KnightValueEg, BishopValueEg, RookValueEg, QueenValueEg }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This separation allows:</p><ul><li>The variable to be shared across the entire engine</li><li>Only one copy to exist in memory</li><li>Fast direct access without function calls</li><li>This is a global variable, one copy maintained across the entire program</li></ul><h3 id=internal-linkage>Internal Linkage<a hidden class=anchor aria-hidden=true href=#internal-linkage>#</a></h3><p>Consider this definition in <code>types.h</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>const</span> Piece Pieces[] <span style=color:#f92672>=</span> { W_PAWN, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
</span></span><span style=display:flex><span>                         B_PAWN, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING };
</span></span></code></pre></div><p><strong>Technically</strong>: This declares a global array.</p><p><strong>Practically</strong>: The <code>const</code> keyword gives it <strong>internal linkage</strong> in C++, meaning:</p><ul><li>Each translation unit (.cpp file) that includes <code>types.h</code> gets its <strong>own copy</strong></li><li>No linker errors about &ldquo;multiple definitions&rdquo;</li><li>Still problematic if you want a single shared instance</li></ul><p>If we remove <code>const</code>, then it will be considered as external linkage. The linker would see: multiple definition of <code>Pieces</code> and throws error.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/c++/>C++</a></li><li><a href=https://sankethbk.github.io/blog/tags/stockfish/>Stockfish</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>