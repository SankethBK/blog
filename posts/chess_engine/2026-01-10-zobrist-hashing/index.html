<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Zobrist Hashing | Sanketh's Blog</title><meta name=keywords content="zobrist hashing"><meta name=description content="Zobrist Hashing
What problem Zobrist hashing solves
In a chess engine, we constantly need to:

Identify identical positions reached via different move orders
Detect threefold repetition
Cache evaluations in a transposition table (TT)

But:

Comparing full board state is too slow
Copying board state is too expensive

The Core Idea
Goal: Convert a chess position into a single 64-bit number (the &ldquo;hash&rdquo; or &ldquo;key&rdquo;) that:

Uniquely identifies the position (with very high probability)
Can be incrementally updated when making moves
Enables O(1) position comparison

What a Zobrist key represents
A Zobrist key is a 64-bit integer (Key in Stockfish) representing:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Zobrist Hashing"><meta property="og:description" content="Zobrist Hashing What problem Zobrist hashing solves In a chess engine, we constantly need to:
Identify identical positions reached via different move orders Detect threefold repetition Cache evaluations in a transposition table (TT) But:
Comparing full board state is too slow Copying board state is too expensive The Core Idea Goal: Convert a chess position into a single 64-bit number (the “hash” or “key”) that:
Uniquely identifies the position (with very high probability) Can be incrementally updated when making moves Enables O(1) position comparison What a Zobrist key represents A Zobrist key is a 64-bit integer (Key in Stockfish) representing:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-10T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-10T00:00:00+00:00"><meta property="article:tag" content="Zobrist Hashing"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zobrist Hashing"><meta name=twitter:description content="Zobrist Hashing
What problem Zobrist hashing solves
In a chess engine, we constantly need to:

Identify identical positions reached via different move orders
Detect threefold repetition
Cache evaluations in a transposition table (TT)

But:

Comparing full board state is too slow
Copying board state is too expensive

The Core Idea
Goal: Convert a chess position into a single 64-bit number (the &ldquo;hash&rdquo; or &ldquo;key&rdquo;) that:

Uniquely identifies the position (with very high probability)
Can be incrementally updated when making moves
Enables O(1) position comparison

What a Zobrist key represents
A Zobrist key is a 64-bit integer (Key in Stockfish) representing:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Zobrist Hashing","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zobrist Hashing","name":"Zobrist Hashing","description":"Zobrist Hashing What problem Zobrist hashing solves In a chess engine, we constantly need to:\nIdentify identical positions reached via different move orders Detect threefold repetition Cache evaluations in a transposition table (TT) But:\nComparing full board state is too slow Copying board state is too expensive The Core Idea Goal: Convert a chess position into a single 64-bit number (the \u0026ldquo;hash\u0026rdquo; or \u0026ldquo;key\u0026rdquo;) that:\nUniquely identifies the position (with very high probability) Can be incrementally updated when making moves Enables O(1) position comparison What a Zobrist key represents A Zobrist key is a 64-bit integer (Key in Stockfish) representing:\n","keywords":["zobrist hashing"],"articleBody":"Zobrist Hashing What problem Zobrist hashing solves In a chess engine, we constantly need to:\nIdentify identical positions reached via different move orders Detect threefold repetition Cache evaluations in a transposition table (TT) But:\nComparing full board state is too slow Copying board state is too expensive The Core Idea Goal: Convert a chess position into a single 64-bit number (the “hash” or “key”) that:\nUniquely identifies the position (with very high probability) Can be incrementally updated when making moves Enables O(1) position comparison What a Zobrist key represents A Zobrist key is a 64-bit integer (Key in Stockfish) representing:\nWhich pieces are on which squares Side to move Castling rights En-passant file (if any) namespace Zobrist { Key psq[PIECE_NB][SQUARE_NB]; Key enpassant[FILE_NB]; Key castling[CASTLING_RIGHT_NB]; Key side; } Key is 64 bit unsigned integer\ntypedef uint64_t Key; Formally:\nkey = XOR(piece-square keys) ^ XOR(side-to-move key) ^ XOR(castling-rights key) ^ XOR(en-passant-file key) Two positions that are identical under chess rules will have the same Zobrist key.\nCore idea: XOR as reversible edit Zobrist hashing relies on one crucial property:\nX ^ A ^ A == X This makes it perfect for move/unmove.\nExample\nIf a white knight moves from g1 → f3:\nkey ^= Zobrist::psq[W_KNIGHT][G1]; key ^= Zobrist::psq[W_KNIGHT][F3]; Undoing the move applies the same XORs, restoring the old key.\nKey Insight: Zobrist keys are not recomputed — they are edited.\nZobrist tables in Stockfish Initialization (At Program Startup) void Position::init() { PRNG rng(1070372); for (Piece pc : Pieces) for (Square s = SQ_A1; s \u003c= SQ_H8; ++s) Zobrist::psq[pc][s] = rng.rand\u003cKey\u003e(); for (File f = FILE_A; f \u003c= FILE_H; ++f) Zobrist::enpassant[f] = rng.rand\u003cKey\u003e(); for (int cr = NO_CASTLING; cr \u003c= ANY_CASTLING; ++cr) { Zobrist::castling[cr] = 0; Bitboard b = cr; while (b) { Key k = Zobrist::castling[1ULL \u003c\u003c pop_lsb(\u0026b)]; Zobrist::castling[cr] ^= k ? k : rng.rand\u003cKey\u003e(); } } Zobrist::side = rng.rand\u003cKey\u003e(); } Why a fixed seed?\nSame random numbers every time the program runs Makes debugging easier (hashes are reproducible) Different engines use different seeds (so they don’t share bugs) Avoid collision of random values Stockfish precomputes random 64-bit values for:\n1. Piece–square keys Zobrist::psq[piece][square] One random number for every (piece, square) pair 12 pieces x 64 squares = 768 random values Covers all colors and piece types Used for:\nFull position key Pawn key Material key 2. Side to move Zobrist::side XORed once per move Ensures same board with different side ≠ same key 3. Castling rights Zobrist::castling[rights_mask] Indexed by castling-rights bitmask Rights are removed incrementally 4. En-passant file Zobrist::enpassant[file] Only the file matters (rank is implicit) Only added if EP capture is legal Prevents false repetition detection Incremental Updates (The Magic!) Moving a Piece (e.g., Nf3-e5) // Starting hash Key hash = current_position_hash; // Remove knight from f3 hash ^= Zobrist::psq[W_KNIGHT][f3]; // Add knight to e5 hash ^= Zobrist::psq[W_KNIGHT][e5]; // Flip side to move hash ^= Zobrist::side; // Done! New hash computed in O(1) Capturing (e.g., Nxe5, capturing black pawn) Key hash = current_position_hash; // Remove white knight from f3 hash ^= Zobrist::psq[W_KNIGHT][f3]; // Remove black pawn from e5 (captured) hash ^= Zobrist::psq[B_PAWN][e5]; // Add white knight to e5 hash ^= Zobrist::psq[W_KNIGHT][e5]; // Flip side to move hash ^= Zobrist::side; Castling (e.g., White kingside O-O) Key hash = current_position_hash; // Remove king from e1 hash ^= Zobrist::psq[W_KING][e1]; // Add king to g1 hash ^= Zobrist::psq[W_KING][g1]; // Remove rook from h1 hash ^= Zobrist::psq[W_ROOK][h1]; // Add rook to f1 hash ^= Zobrist::psq[W_ROOK][f1]; // Update castling rights (white loses both) hash ^= Zobrist::castling[old_rights]; // Remove old hash ^= Zobrist::castling[new_rights]; // Add new // Flip side to move hash ^= Zobrist::side; Creating en passant opportunity (e.g., e2-e4): // Clear old en passant (if any) if (old_ep_square != SQ_NONE) hash ^= Zobrist::enpassant[file_of(old_ep_square)]; // Set new en passant hash ^= Zobrist::enpassant[FILE_E]; Keys used in StateInfo StateInfo class stores 3 zobrist hashing keys\nstruct StateInfo { // Copied when making a move Key pawnKey; Key materialKey; ... // Not copied when making a move (will be recomputed anyhow) Key key; }; Initialization Logic void Position::set_state(StateInfo* si) const { si-\u003ekey = si-\u003epawnKey = si-\u003ematerialKey = 0; si-\u003enonPawnMaterial[WHITE] = si-\u003enonPawnMaterial[BLACK] = VALUE_ZERO; si-\u003epsq = SCORE_ZERO; si-\u003echeckersBB = attackers_to(square\u003cKING\u003e(sideToMove)) \u0026 pieces(~sideToMove); set_check_info(si); for (Bitboard b = pieces(); b; ) { Square s = pop_lsb(\u0026b); Piece pc = piece_on(s); si-\u003ekey ^= Zobrist::psq[pc][s]; si-\u003epsq += PSQT::psq[pc][s]; } if (si-\u003eepSquare != SQ_NONE) si-\u003ekey ^= Zobrist::enpassant[file_of(si-\u003eepSquare)]; if (sideToMove == BLACK) si-\u003ekey ^= Zobrist::side; si-\u003ekey ^= Zobrist::castling[si-\u003ecastlingRights]; for (Bitboard b = pieces(PAWN); b; ) { Square s = pop_lsb(\u0026b); si-\u003epawnKey ^= Zobrist::psq[piece_on(s)][s]; } for (Piece pc : Pieces) { if (type_of(pc) != PAWN \u0026\u0026 type_of(pc) != KING) si-\u003enonPawnMaterial[color_of(pc)] += pieceCount[pc] * PieceValue[MG][pc]; for (int cnt = 0; cnt \u003c pieceCount[pc]; ++cnt) si-\u003ematerialKey ^= Zobrist::psq[pc][cnt]; } } 1. Full position key st-\u003ekey Used for:\nTransposition table Repetition detection 2. Pawn hash st-\u003epawnKey Only includes:\nPawn piece-square keys Used for:\nPawn structure evaluation cache -\u003e Pawn structure changes rarely → huge speed win\n3 Material hash st-\u003ematerialKey Includes:\nPiece counts only (not squares) Used for:\nMaterial evaluation Endgame detection Clever bit operation to unset LSB In this code\nfor (Bitboard b = pieces(PAWN); b; ) { Square s = pop_lsb(\u0026b); si-\u003epawnKey ^= Zobrist::psq[piece_on(s)][s]; } pieces(PAWN) is just one bitboard, we are repeadly iterating through it until it becomes 0. b; breaks the loop when b is 0.\npop_lsb is responsible for unsetting LSB of b.\ninline Square pop_lsb(Bitboard* b) { const Square s = lsb(*b); *b \u0026= *b - 1; return s; } inline Square lsb(Bitboard b) { assert(b); return Square(__builtin_ctzll(b)); } x = x \u0026 (x - 1) is a clever way of unsetting the LSB.\nIt works because, any positive numbers can be assumed as of he form\nxxxxx1000...000 ^ lowest set bit (LSB) That is:\nSome prefix of bits (x) Then one 1 Then only zeros to the right Example\nx = 40 = 0b00101000 ^ LSB What does x - 1 do in binary?\nSubtracting 1:\nTurns the rightmost 1 into 0 Turns all trailing zeros into 1s Example\nx = 00101000 x - 1 = 00100111 So:\nThe lowest 1 flips to 0 Everything to the right becomes 1 Now apply x \u0026 (x - 1)\nLet’s AND them:\nx = 00101000 x - 1 = 00100111 ---------------- \u0026 result= 00100000 What happened?\nAll higher bits stay the same The lowest set bit is cleared Nothing else changes __builtin_ctzll __builtin_ctzll is a compiler intrinsic that usually compiles down to a single CPU instruction.\nctz = count trailing zeros ll = long long (64-bit) Returns: number of consecutive 0 bits starting from the least significant bit On x86-64, this usually becomes:\nTZCNT (newer CPUs) or BSF (older CPUs) Both are single instructions.\nOn ARM64 (Apple Silicon), it becomes:\nRBIT + CLZ or native CTZ instruction Still 1–2 instructions max.\n","wordCount":"1126","inLanguage":"en","datePublished":"2026-01-10T00:00:00Z","dateModified":"2026-01-10T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-10-zobrist-hashing/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Zobrist Hashing</h1><div class=post-meta><span title='2026-01-10 00:00:00 +0000 UTC'>January 10, 2026</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-10-zobrist-hashing.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#zobrist-hashing aria-label="Zobrist Hashing">Zobrist Hashing</a><ul><li><a href=#what-problem-zobrist-hashing-solves aria-label="What problem Zobrist hashing solves">What problem Zobrist hashing solves</a></li><li><a href=#the-core-idea aria-label="The Core Idea">The Core Idea</a></li><li><a href=#what-a-zobrist-key-represents aria-label="What a Zobrist key represents">What a Zobrist key represents</a></li><li><a href=#core-idea-xor-as-reversible-edit aria-label="Core idea: XOR as reversible edit">Core idea: XOR as reversible edit</a></li><li><a href=#zobrist-tables-in-stockfish aria-label="Zobrist tables in Stockfish">Zobrist tables in Stockfish</a><ul><li><a href=#initialization-at-program-startup aria-label="Initialization (At Program Startup)">Initialization (At Program Startup)</a></li><li><a href=#1-piecesquare-keys aria-label="1. Piece–square keys">1. Piece–square keys</a></li><li><a href=#2-side-to-move aria-label="2. Side to move">2. Side to move</a></li><li><a href=#3-castling-rights aria-label="3. Castling rights">3. Castling rights</a></li><li><a href=#4-en-passant-file aria-label="4. En-passant file">4. En-passant file</a></li></ul></li><li><a href=#incremental-updates-the-magic aria-label="Incremental Updates (The Magic!)">Incremental Updates (The Magic!)</a><ul><li><a href=#moving-a-piece-eg-nf3-e5 aria-label="Moving a Piece (e.g., Nf3-e5)">Moving a Piece (e.g., Nf3-e5)</a></li><li><a href=#capturing-eg-nxe5-capturing-black-pawn aria-label="Capturing (e.g., Nxe5, capturing black pawn)">Capturing (e.g., Nxe5, capturing black pawn)</a></li><li><a href=#castling-eg-white-kingside-o-o aria-label="Castling (e.g., White kingside O-O)">Castling (e.g., White kingside O-O)</a></li><li><a href=#creating-en-passant-opportunity-eg-e2-e4 aria-label="Creating en passant opportunity (e.g., e2-e4):">Creating en passant opportunity (e.g., e2-e4):</a></li></ul></li><li><a href=#keys-used-in-stateinfo aria-label="Keys used in StateInfo">Keys used in StateInfo</a><ul><li><a href=#initialization-logic aria-label="Initialization Logic">Initialization Logic</a></li><li><a href=#1-full-position-key aria-label="1. Full position key">1. Full position key</a></li><li><a href=#2-pawn-hash aria-label="2. Pawn hash">2. Pawn hash</a></li><li><a href=#3-material-hash aria-label="3 Material hash">3 Material hash</a></li></ul></li><li><a href=#clever-bit-operation-to-unset-lsb aria-label="Clever bit operation to unset LSB">Clever bit operation to unset LSB</a><ul><li><a href=#__builtin_ctzll aria-label=__builtin_ctzll>__builtin_ctzll</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=zobrist-hashing>Zobrist Hashing<a hidden class=anchor aria-hidden=true href=#zobrist-hashing>#</a></h1><h2 id=what-problem-zobrist-hashing-solves>What problem Zobrist hashing solves<a hidden class=anchor aria-hidden=true href=#what-problem-zobrist-hashing-solves>#</a></h2><p>In a chess engine, we constantly need to:</p><ul><li>Identify identical positions reached via different move orders</li><li>Detect threefold repetition</li><li>Cache evaluations in a transposition table (TT)</li></ul><p>But:</p><ul><li>Comparing full board state is too slow</li><li>Copying board state is too expensive</li></ul><h2 id=the-core-idea>The Core Idea<a hidden class=anchor aria-hidden=true href=#the-core-idea>#</a></h2><p><strong>Goal:</strong> Convert a chess position into a single 64-bit number (the &ldquo;hash&rdquo; or &ldquo;key&rdquo;) that:</p><ol><li>Uniquely identifies the position (with very high probability)</li><li>Can be incrementally updated when making moves</li><li>Enables O(1) position comparison</li></ol><h2 id=what-a-zobrist-key-represents>What a Zobrist key represents<a hidden class=anchor aria-hidden=true href=#what-a-zobrist-key-represents>#</a></h2><p>A Zobrist key is a 64-bit integer (Key in Stockfish) representing:</p><ul><li>Which pieces are on which squares</li><li>Side to move</li><li>Castling rights</li><li>En-passant file (if any)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>namespace</span> Zobrist {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Key psq[PIECE_NB][SQUARE_NB];
</span></span><span style=display:flex><span>  Key enpassant[FILE_NB];
</span></span><span style=display:flex><span>  Key castling[CASTLING_RIGHT_NB];
</span></span><span style=display:flex><span>  Key side;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Key is 64 bit unsigned integer</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>uint64_t</span> Key;
</span></span></code></pre></div><p>Formally:</p><pre tabindex=0><code>key =
  XOR(piece-square keys)
^ XOR(side-to-move key)
^ XOR(castling-rights key)
^ XOR(en-passant-file key)
</code></pre><p>Two positions that are identical under chess rules will have the same Zobrist key.</p><h2 id=core-idea-xor-as-reversible-edit>Core idea: XOR as reversible edit<a hidden class=anchor aria-hidden=true href=#core-idea-xor-as-reversible-edit>#</a></h2><p>Zobrist hashing relies on one crucial property:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>X <span style=color:#f92672>^</span> A <span style=color:#f92672>^</span> A <span style=color:#f92672>==</span> X
</span></span></code></pre></div><p>This makes it perfect for move/unmove.</p><p>Example</p><p>If a white knight moves from g1 → f3:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>key <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KNIGHT][G1];
</span></span><span style=display:flex><span>key <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KNIGHT][F3];
</span></span></code></pre></div><p>Undoing the move applies the same XORs, restoring the old key.</p><p>Key Insight: Zobrist keys are not recomputed — they are edited.</p><h2 id=zobrist-tables-in-stockfish>Zobrist tables in Stockfish<a hidden class=anchor aria-hidden=true href=#zobrist-tables-in-stockfish>#</a></h2><h3 id=initialization-at-program-startup>Initialization (At Program Startup)<a hidden class=anchor aria-hidden=true href=#initialization-at-program-startup>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Position<span style=color:#f92672>::</span>init() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  PRNG <span style=color:#a6e22e>rng</span>(<span style=color:#ae81ff>1070372</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (Piece pc : Pieces)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (Square s <span style=color:#f92672>=</span> SQ_A1; s <span style=color:#f92672>&lt;=</span> SQ_H8; <span style=color:#f92672>++</span>s)
</span></span><span style=display:flex><span>          Zobrist<span style=color:#f92672>::</span>psq[pc][s] <span style=color:#f92672>=</span> rng.rand<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (File f <span style=color:#f92672>=</span> FILE_A; f <span style=color:#f92672>&lt;=</span> FILE_H; <span style=color:#f92672>++</span>f)
</span></span><span style=display:flex><span>      Zobrist<span style=color:#f92672>::</span>enpassant[f] <span style=color:#f92672>=</span> rng.rand<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> cr <span style=color:#f92672>=</span> NO_CASTLING; cr <span style=color:#f92672>&lt;=</span> ANY_CASTLING; <span style=color:#f92672>++</span>cr)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Zobrist<span style=color:#f92672>::</span>castling[cr] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      Bitboard b <span style=color:#f92672>=</span> cr;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> (b)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          Key k <span style=color:#f92672>=</span> Zobrist<span style=color:#f92672>::</span>castling[<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> pop_lsb(<span style=color:#f92672>&amp;</span>b)];
</span></span><span style=display:flex><span>          Zobrist<span style=color:#f92672>::</span>castling[cr] <span style=color:#f92672>^=</span> k <span style=color:#f92672>?</span> k : rng.rand<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Zobrist<span style=color:#f92672>::</span>side <span style=color:#f92672>=</span> rng.rand<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Why a fixed seed?</strong></p><ul><li>Same random numbers every time the program runs</li><li>Makes debugging easier (hashes are reproducible)</li><li>Different engines use different seeds (so they don&rsquo;t share bugs)</li><li>Avoid collision of random values</li></ul><p>Stockfish precomputes random 64-bit values for:</p><h3 id=1-piecesquare-keys>1. Piece–square keys<a hidden class=anchor aria-hidden=true href=#1-piecesquare-keys>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Zobrist<span style=color:#f92672>::</span>psq[piece][square]
</span></span></code></pre></div><ul><li>One random number for every (piece, square) pair</li><li>12 pieces x 64 squares = 768 random values</li><li>Covers all colors and piece types</li></ul><p>Used for:</p><ul><li>Full position key</li><li>Pawn key</li><li>Material key</li></ul><h3 id=2-side-to-move>2. Side to move<a hidden class=anchor aria-hidden=true href=#2-side-to-move>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Zobrist<span style=color:#f92672>::</span>side
</span></span></code></pre></div><ul><li>XORed once per move</li><li>Ensures same board with different side ≠ same key</li></ul><h3 id=3-castling-rights>3. Castling rights<a hidden class=anchor aria-hidden=true href=#3-castling-rights>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Zobrist<span style=color:#f92672>::</span>castling[rights_mask]
</span></span></code></pre></div><ul><li>Indexed by castling-rights bitmask</li><li>Rights are removed incrementally</li></ul><h3 id=4-en-passant-file>4. En-passant file<a hidden class=anchor aria-hidden=true href=#4-en-passant-file>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Zobrist<span style=color:#f92672>::</span>enpassant[file]
</span></span></code></pre></div><ul><li>Only the file matters (rank is implicit)</li><li>Only added if EP capture is legal</li><li>Prevents false repetition detection</li></ul><h2 id=incremental-updates-the-magic>Incremental Updates (The Magic!)<a hidden class=anchor aria-hidden=true href=#incremental-updates-the-magic>#</a></h2><h3 id=moving-a-piece-eg-nf3-e5>Moving a Piece (e.g., Nf3-e5)<a hidden class=anchor aria-hidden=true href=#moving-a-piece-eg-nf3-e5>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Starting hash
</span></span></span><span style=display:flex><span>Key hash <span style=color:#f92672>=</span> current_position_hash;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Remove knight from f3
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KNIGHT][f3];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add knight to e5
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KNIGHT][e5];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Flip side to move
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>side;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Done! New hash computed in O(1)
</span></span></span></code></pre></div><h3 id=capturing-eg-nxe5-capturing-black-pawn>Capturing (e.g., Nxe5, capturing black pawn)<a hidden class=anchor aria-hidden=true href=#capturing-eg-nxe5-capturing-black-pawn>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Key hash <span style=color:#f92672>=</span> current_position_hash;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Remove white knight from f3
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KNIGHT][f3];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Remove black pawn from e5 (captured)
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[B_PAWN][e5];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add white knight to e5
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KNIGHT][e5];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Flip side to move
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>side;
</span></span></code></pre></div><h3 id=castling-eg-white-kingside-o-o>Castling (e.g., White kingside O-O)<a hidden class=anchor aria-hidden=true href=#castling-eg-white-kingside-o-o>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Key hash <span style=color:#f92672>=</span> current_position_hash;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Remove king from e1
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KING][e1];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add king to g1
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_KING][g1];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Remove rook from h1
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_ROOK][h1];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add rook to f1
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[W_ROOK][f1];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Update castling rights (white loses both)
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>castling[old_rights];  <span style=color:#75715e>// Remove old
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>castling[new_rights];  <span style=color:#75715e>// Add new
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Flip side to move
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>side;
</span></span></code></pre></div><h3 id=creating-en-passant-opportunity-eg-e2-e4>Creating en passant opportunity (e.g., e2-e4):<a hidden class=anchor aria-hidden=true href=#creating-en-passant-opportunity-eg-e2-e4>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Clear old en passant (if any)
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (old_ep_square <span style=color:#f92672>!=</span> SQ_NONE)
</span></span><span style=display:flex><span>    hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(old_ep_square)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Set new en passant
</span></span></span><span style=display:flex><span>hash <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[FILE_E];
</span></span></code></pre></div><h2 id=keys-used-in-stateinfo>Keys used in StateInfo<a hidden class=anchor aria-hidden=true href=#keys-used-in-stateinfo>#</a></h2><p><code>StateInfo</code> class stores 3 zobrist hashing keys</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StateInfo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Copied when making a move
</span></span></span><span style=display:flex><span>  Key    pawnKey;
</span></span><span style=display:flex><span>  Key    materialKey;
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Not copied when making a move (will be recomputed anyhow)
</span></span></span><span style=display:flex><span>  Key        key;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=initialization-logic>Initialization Logic<a hidden class=anchor aria-hidden=true href=#initialization-logic>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> Position<span style=color:#f92672>::</span>set_state(StateInfo<span style=color:#f92672>*</span> si) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  si<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>=</span> si<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>=</span> si<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  si<span style=color:#f92672>-&gt;</span>nonPawnMaterial[WHITE] <span style=color:#f92672>=</span> si<span style=color:#f92672>-&gt;</span>nonPawnMaterial[BLACK] <span style=color:#f92672>=</span> VALUE_ZERO;
</span></span><span style=display:flex><span>  si<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>=</span> SCORE_ZERO;
</span></span><span style=display:flex><span>  si<span style=color:#f92672>-&gt;</span>checkersBB <span style=color:#f92672>=</span> attackers_to(square<span style=color:#f92672>&lt;</span>KING<span style=color:#f92672>&gt;</span>(sideToMove)) <span style=color:#f92672>&amp;</span> pieces(<span style=color:#f92672>~</span>sideToMove);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  set_check_info(si);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (Bitboard b <span style=color:#f92672>=</span> pieces(); b; )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square s <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>      Piece pc <span style=color:#f92672>=</span> piece_on(s);
</span></span><span style=display:flex><span>      si<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][s];
</span></span><span style=display:flex><span>      si<span style=color:#f92672>-&gt;</span>psq <span style=color:#f92672>+=</span> PSQT<span style=color:#f92672>::</span>psq[pc][s];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (si<span style=color:#f92672>-&gt;</span>epSquare <span style=color:#f92672>!=</span> SQ_NONE)
</span></span><span style=display:flex><span>      si<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>enpassant[file_of(si<span style=color:#f92672>-&gt;</span>epSquare)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (sideToMove <span style=color:#f92672>==</span> BLACK)
</span></span><span style=display:flex><span>      si<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>side;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  si<span style=color:#f92672>-&gt;</span>key <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>castling[si<span style=color:#f92672>-&gt;</span>castlingRights];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (Bitboard b <span style=color:#f92672>=</span> pieces(PAWN); b; )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square s <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>      si<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[piece_on(s)][s];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (Piece pc : Pieces)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (type_of(pc) <span style=color:#f92672>!=</span> PAWN <span style=color:#f92672>&amp;&amp;</span> type_of(pc) <span style=color:#f92672>!=</span> KING)
</span></span><span style=display:flex><span>          si<span style=color:#f92672>-&gt;</span>nonPawnMaterial[color_of(pc)] <span style=color:#f92672>+=</span> pieceCount[pc] <span style=color:#f92672>*</span> PieceValue[MG][pc];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; cnt <span style=color:#f92672>&lt;</span> pieceCount[pc]; <span style=color:#f92672>++</span>cnt)
</span></span><span style=display:flex><span>          si<span style=color:#f92672>-&gt;</span>materialKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[pc][cnt];
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=1-full-position-key>1. Full position key<a hidden class=anchor aria-hidden=true href=#1-full-position-key>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>key
</span></span></code></pre></div><p>Used for:</p><ul><li>Transposition table</li><li>Repetition detection</li></ul><h3 id=2-pawn-hash>2. Pawn hash<a hidden class=anchor aria-hidden=true href=#2-pawn-hash>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>pawnKey
</span></span></code></pre></div><p>Only includes:</p><ul><li>Pawn piece-square keys</li></ul><p>Used for:</p><ul><li>Pawn structure evaluation cache</li></ul><p>-> Pawn structure changes rarely → huge speed win</p><h3 id=3-material-hash>3 Material hash<a hidden class=anchor aria-hidden=true href=#3-material-hash>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>st<span style=color:#f92672>-&gt;</span>materialKey
</span></span></code></pre></div><p>Includes:</p><ul><li>Piece counts only (not squares)</li></ul><p>Used for:</p><ul><li>Material evaluation</li><li>Endgame detection</li></ul><h2 id=clever-bit-operation-to-unset-lsb>Clever bit operation to unset LSB<a hidden class=anchor aria-hidden=true href=#clever-bit-operation-to-unset-lsb>#</a></h2><p>In this code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (Bitboard b <span style=color:#f92672>=</span> pieces(PAWN); b; )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      Square s <span style=color:#f92672>=</span> pop_lsb(<span style=color:#f92672>&amp;</span>b);
</span></span><span style=display:flex><span>      si<span style=color:#f92672>-&gt;</span>pawnKey <span style=color:#f92672>^=</span> Zobrist<span style=color:#f92672>::</span>psq[piece_on(s)][s];
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><code>pieces(PAWN)</code> is just one bitboard, we are repeadly iterating through it until it becomes 0. <code>b;</code> breaks the loop when b is 0.</p><p><code>pop_lsb</code> is responsible for unsetting LSB of <code>b</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Square <span style=color:#a6e22e>pop_lsb</span>(Bitboard<span style=color:#f92672>*</span> b) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> Square s <span style=color:#f92672>=</span> lsb(<span style=color:#f92672>*</span>b);
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>b <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>*</span>b <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Square <span style=color:#a6e22e>lsb</span>(Bitboard b) {
</span></span><span style=display:flex><span>  assert(b);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Square(__builtin_ctzll(b));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>x = x & (x - 1)</code> is a clever way of unsetting the LSB.</p><p>It works because, any positive numbers can be assumed as of he form</p><pre tabindex=0><code>xxxxx1000...000
     ^
     lowest set bit (LSB)
</code></pre><p>That is:</p><ul><li>Some prefix of bits (x)</li><li>Then one 1</li><li>Then only zeros to the right</li></ul><p>Example</p><pre tabindex=0><code>x = 40 = 0b00101000
              ^
              LSB
</code></pre><p><strong>What does x - 1 do in binary?</strong></p><p>Subtracting 1:</p><ul><li>Turns the rightmost 1 into 0</li><li>Turns all trailing zeros into 1s</li></ul><p>Example</p><pre tabindex=0><code>x     = 00101000
x - 1 = 00100111
</code></pre><p>So:</p><ul><li>The lowest 1 flips to 0</li><li>Everything to the right becomes 1</li></ul><p>Now apply x & (x - 1)</p><p>Let’s AND them:</p><pre tabindex=0><code>x     = 00101000
x - 1 = 00100111
---------------- &amp;
result= 00100000
</code></pre><p>What happened?</p><ul><li>All higher bits stay the same</li><li>The lowest set bit is cleared</li><li>Nothing else changes</li></ul><h3 id=__builtin_ctzll>__builtin_ctzll<a hidden class=anchor aria-hidden=true href=#__builtin_ctzll>#</a></h3><p><code>__builtin_ctzll</code> is a compiler intrinsic that usually compiles down to a single CPU instruction.</p><ul><li>ctz = count trailing zeros</li><li>ll = long long (64-bit)</li><li>Returns: number of consecutive 0 bits starting from the least significant bit</li></ul><p>On x86-64, this usually becomes:</p><ul><li><code>TZCNT</code> (newer CPUs)</li><li>or <code>BSF</code> (older CPUs)</li></ul><p>Both are single instructions.</p><p>On ARM64 (Apple Silicon), it becomes:</p><ul><li><code>RBIT</code> + <code>CLZ</code>
or</li><li>native <code>CTZ</code> instruction</li></ul><p>Still 1–2 instructions max.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/zobrist-hashing/>Zobrist Hashing</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>