<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bitboard representation of Chess Board | Sanketh's Blog</title><meta name=keywords content="bitboard"><meta name=description content="Bitboard-Based Game Representation in Stockfish
Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.
typedef uint64_t Bitboard;

Bit 0 (LSB) → A1
Bit 63 (MSB) → H8

This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.

Piece Encoding
enum Piece {
  NO_PIECE,
  W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
  B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
  PIECE_NB = 16
};
Numeric Structure

  
      
          Piece
          Value
          Binary
      
  
  
      
          W_PAWN
          1
          0001
      
      
          W_KING
          6
          0110
      
      
          B_PAWN
          9
          1001
      
      
          B_KING
          14
          1110
      
  

Key observations:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Bitboard representation of Chess Board"><meta property="og:description" content="Bitboard-Based Game Representation in Stockfish Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.
typedef uint64_t Bitboard; Bit 0 (LSB) → A1 Bit 63 (MSB) → H8 This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.
Piece Encoding enum Piece { NO_PIECE, W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING, PIECE_NB = 16 }; Numeric Structure Piece Value Binary W_PAWN 1 0001 W_KING 6 0110 B_PAWN 9 1001 B_KING 14 1110 Key observations:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-04T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-04T00:00:00+00:00"><meta property="article:tag" content="Bitboard"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bitboard representation of Chess Board"><meta name=twitter:description content="Bitboard-Based Game Representation in Stockfish
Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.
typedef uint64_t Bitboard;

Bit 0 (LSB) → A1
Bit 63 (MSB) → H8

This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.

Piece Encoding
enum Piece {
  NO_PIECE,
  W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
  B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
  PIECE_NB = 16
};
Numeric Structure

  
      
          Piece
          Value
          Binary
      
  
  
      
          W_PAWN
          1
          0001
      
      
          W_KING
          6
          0110
      
      
          B_PAWN
          9
          1001
      
      
          B_KING
          14
          1110
      
  

Key observations:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Bitboard representation of Chess Board","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bitboard representation of Chess Board","name":"Bitboard representation of Chess Board","description":"Bitboard-Based Game Representation in Stockfish Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.\ntypedef uint64_t Bitboard; Bit 0 (LSB) → A1 Bit 63 (MSB) → H8 This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.\nPiece Encoding enum Piece { NO_PIECE, W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING, PIECE_NB = 16 }; Numeric Structure Piece Value Binary W_PAWN 1 0001 W_KING 6 0110 B_PAWN 9 1001 B_KING 14 1110 Key observations:\n","keywords":["bitboard"],"articleBody":"Bitboard-Based Game Representation in Stockfish Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.\ntypedef uint64_t Bitboard; Bit 0 (LSB) → A1 Bit 63 (MSB) → H8 This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.\nPiece Encoding enum Piece { NO_PIECE, W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING, PIECE_NB = 16 }; Numeric Structure Piece Value Binary W_PAWN 1 0001 W_KING 6 0110 B_PAWN 9 1001 B_KING 14 1110 Key observations:\nWhite pieces occupy values 1–6 Black pieces occupy values 9–14 The 4th bit distinguishes color This enables a compact and efficient encoding:\nPiece = (Color \u003c\u003c 3) | PieceType Extracting Type and Color inline PieceType type_of(Piece pc) { return PieceType(pc \u0026 7); } inline Color color_of(Piece pc) { return Color(pc \u003e\u003e 3); } pc \u0026 7 strips color → piece type pc \u003e\u003e 3 extracts color Flipping Color ~pc == pc ^ 8 Toggles the color bit while keeping the piece type unchanged.\nPIECE_NB PIECE_NB = 16 Used for array sizing and indexing. It is not the number of actual chess pieces, but the size of the encoding space.\nPieceType: Color-Independent Identity enum PieceType { NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, ALL_PIECES = 0, PIECE_TYPE_NB = 8 }; Purpose Represents kind of piece, independent of color\nUsed for:\nMove generation Attack generation Evaluation Bitboard indexing This enum deliberately excludes color, which is handled separately.\nThe encoding aligns perfectly with Piece:\nPiece = (Color \u003c\u003c 3) | PieceType Special Values ALL_PIECES = 0 Used as a generic index when aggregating attacks. PIECE_TYPE_NB = 8 Total number of piece types including sentinel values. Square Representation enum Square { SQ_A1, SQ_B1, ..., SQ_H8, SQ_NONE, SQUARE_NB = 64, NORTH = 8, EAST = 1, SOUTH = -8, WEST = -1, NORTH_EAST = NORTH + EAST, SOUTH_EAST = SOUTH + EAST, SOUTH_WEST = SOUTH + WEST, NORTH_WEST = NORTH + WEST }; Numeric Layout Squares are encoded in rank-major order:\nA1 = 0 B1 = 1 ... H1 = 7 A2 = 8 B2 = 9 ... H2 = 15 ... A8 = 56 B8 = 57 ... H8 = 63 Example:\nint(SQ_E4) == 4 + 3 * 8 == 28 Why This Layout? Files increment by +1 Ranks increment by +8 Board geometry becomes simple integer arithmetic Directions as Integer Offsets NORTH = 8 EAST = 1 SOUTH = -8 WEST = -1 This allows simple move computation:\nSQ_E2 + NORTH == SQ_E3 SQ_E2 + NORTH_EAST == SQ_F3 Diagonal directions are composed, not duplicated:\nNORTH_EAST = NORTH + EAST File and Rank Enums enum File : int { FILE_A, FILE_B, ..., FILE_H, FILE_NB }; enum Rank : int { RANK_1, RANK_2, ..., RANK_8, RANK_NB }; These are semantic types, not just integers.\nThey improve:\nReadability Type safety Template specialization Extraction helpers:\ninline File file_of(Square s) { return File(s \u0026 7); } inline Rank rank_of(Square s) { return Rank(s \u003e\u003e 3); } Construction:\ninline Square make_square(File f, Rank r) { return Square((r \u003c\u003c 3) + f); } Everything reduces to:\nsquare = rank * 8 + file Color-Relative Squares inline Square relative_square(Color c, Square s) { return Square(s ^ (c * 56)); } For WHITE (c = 0): square unchanged For BLACK (c = 1): square vertically flipped Why 56?\n56 = 7 * 8 = A8 Examples:\nA1 ^ 56 = A8 C1 ^ 56 = C8 This allows writing color-independent evaluation logic.\nCastling Representation CastlingSide enum CastlingSide { KING_SIDE, QUEEN_SIDE, CASTLING_SIDE_NB = 2 }; Simple selector enum Not a bitmask Used in templates and branching logic CastlingRight: Bitmask Encoding enum CastlingRight { NO_CASTLING, WHITE_OO, WHITE_OOO = WHITE_OO \u003c\u003c 1, BLACK_OO = WHITE_OO \u003c\u003c 2, BLACK_OOO = WHITE_OO \u003c\u003c 3, ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO, CASTLING_RIGHT_NB = 16 }; Numeric Values WHITE_OO = 1 // 0001 WHITE_OOO = 2 // 0010 BLACK_OO = 4 // 0100 BLACK_OOO = 8 // 1000 Why Bitmasks? Castling rights are independent flags:\nA position may have:\nOnly king-side rights Only queen-side rights Both None Bitmasks allow all combinations efficiently:\nWHITE_OO | WHITE_OOO // White can castle both sides BLACK_OO | BLACK_OOO // Black can castle both sides WHITE_OO | BLACK_OO // Both can castle king-side ANY_CASTLING // All rights available Score: Middlegame and Endgame Packed Together Stockfish does not evaluate a position with a single number. Instead, it evaluates two positions in parallel:\nMiddlegame (MG) score Endgame (EG) score These two values are packed into a single 32-bit integer called Score.\n/// Score enum stores a middlegame and an endgame value in a single integer /// The upper 16 bits store the middlegame value /// The lower 16 bits store the endgame value enum Score : int { SCORE_ZERO }; Bit Layout 32-bit Score integer | MG (signed 16 bits) | EG (signed 16 bits) | |----------------------|----------------------| | bits 31 ........ 16 | bits 15 ........ 0 | This allows Stockfish to accumulate middlegame and endgame evaluations simultaneously, without branching on game phase.\nCreating a Score inline Score make_score(int mg, int eg) { return Score((int)((unsigned int)eg \u003c\u003c 16) + mg); } Conceptually:\nScore = (EG \u003c\u003c 16) | MG The implementation uses unsigned arithmetic to avoid undefined behavior when shifting signed integers.\nExtracting Values Endgame value:\ninline Value eg_value(Score s) { union { uint16_t u; int16_t s; } eg = { uint16_t(unsigned(s + 0x8000) \u003e\u003e 16) }; return Value(eg.s); } Middlegame value:\ninline Value mg_value(Score s) { union { uint16_t u; int16_t s; } mg = { uint16_t(unsigned(s)) }; return Value(mg.s); } These functions carefully preserve sign and avoid implementation-defined behavior in C++.\nWhy Stockfish Uses Score This design enables:\nContinuous transition between middlegame and endgame No runtime branching on game phase Extremely cache-friendly evaluation Simple accumulation of evaluation terms Throughout evaluation, Stockfish accumulates Score values:\nScore score = SCORE_ZERO; score += MobilityBonus; score += PawnStructure; score += KingSafety; Only at the very end is the final value computed by interpolating between MG and EG using the game phase.\nMental Model Think of Score as a 2-component vector:\nScore = ⟨middlegame, endgame⟩ Evaluation is vector addition, and the final numeric score is a weighted projection based on how far the game has progressed.\nMove Representation /// A move needs 16 bits to be stored /// /// bit 0- 5: destination square (from 0 to 63) /// bit 6-11: origin square (from 0 to 63) /// bit 12-13: promotion piece type - 2 (from KNIGHT-2 to QUEEN-2) /// bit 14-15: special move flag: promotion (1), en passant (2), castling (3) /// NOTE: EN-PASSANT bit is set only when a pawn can be captured /// /// Special cases are MOVE_NONE and MOVE_NULL. We can sneak these in because in /// any normal move destination square is always different from origin square /// while MOVE_NONE and MOVE_NULL have the same origin and destination square. enum Move : int { MOVE_NONE, MOVE_NULL = 65 }; Stockfish represents every chess move in just 16 bits for speed and cache efficiency.\nBit Layout (16 bits) 15 14 | 13 12 | 11 ...... 6 | 5 ...... 0 ---------------------------------------- flags | promo | from | to | Bits | Meaning | | ------- | ----------------------------- | | 0–5 | Destination square (0–63) | | 6–11 | Origin square (0–63) | | 12–13 | Promotion piece − 2 | | 14–15 | Special move flag | Squares (6 bits each) Squares are encoded as integers:\nA1 = 0, B1 = 1, ..., H8 = 63 So:\nfrom_sq(m) → bits 6–11 to_sq(m) → bits 0–5 Special Move Flags (bits 14–15) | Value | Meaning | | ----: | ----------- | | `00` | Normal move | | `01` | Promotion | | `10` | En passant | | `11` | Castling | Promotion Encoding (bits 12–13) Promotion piece type is encoded as:\npromotion_piece = (promotion_type + 2) | Promotion | Encoded | | --------- | ------- | | Knight | 0 | | Bishop | 1 | | Rook | 2 | | Queen | 3 | Because as per Stockfish representation, NO_PIECE_TYPE and PAWN are not useful for promotion, so we can save bits.\nenum PieceType { NO_PIECE_TYPE = 0, PAWN = 1, KNIGHT = 2, BISHOP = 3, ROOK = 4, QUEEN = 5, KING = 6 }; MOVE_NONE and MOVE_NULL enum Move : int { MOVE_NONE, MOVE_NULL = 65 }; Why this works\nA legal move always has from != to These special moves violate that rule MOVE_NONE from = 0 to = 0 Used to mean:\n“no move” invalid move search sentinel MOVE_NULL from = 1 to = 1 // 1 | (1 \u003c\u003c 6) = 65 Used for:\nnull move pruning represents “pass move” (side switches, no piece moved) Accessor Macros Internally Stockfish uses helpers like:\nto_sq(m) = m \u0026 0x3F from_sq(m) = (m \u003e\u003e 6) \u0026 0x3F type_of(m) = m \u0026 0xC000 promo_type(m) = ((m \u003e\u003e 12) \u0026 3) + KNIGHT StepAttacksBB - Pre-computed Attack Tables StepAttacksBB is a lookup table that stores pre-computed attack patterns for pieces that move in fixed steps (not sliding pieces).\nBitboard StepAttacksBB[PIECE_NB][SQUARE_NB]; // [16 piece types][64 squares] = 1024 bitboards “Step attacks” = pieces that attack a fixed pattern of squares:\nPawns (different for white/black) Knights Kings NOT bishops, rooks, queens (these are “sliding” pieces) What’s Stored // For each piece type and square, store which squares it attacks StepAttacksBB[piece][from_square] → Bitboard of attacked squares Examples:\nStepAttacksBB[W_PAWN][e4] → Bitboard with d5, f5 set (white pawn attacks) StepAttacksBB[B_PAWN][e5] → Bitboard with d4, f4 set (black pawn attacks) StepAttacksBB[W_KNIGHT][e4] → Bitboard with d2, f2, c3, g3, c5, g5, d6, f6 StepAttacksBB[W_KING][e1] → Bitboard with d1, f1, d2, e2, f2 LineBB Bitboard LineBB[SQUARE_NB][SQUARE_NB]; LineBB is a precomputed bitboard table that represents:\nThe entire straight line passing through two squares if they are aligned (same rank/file/diagonal)\nOtherwise:\nLineBB[a][b] = 0 Intuition\nIf you pick two squares:\ne1 and e8 → same file c1 and h6 → same diagonal a1 and h1 → same rank Then the squares between them lie on a straight line.\nSo LineBB[s1][s2] is a bitboard answers:\nWhich squares belong to the line containing both s1 and s2?\nExample:\nSquares: e1 and e8\nThey are aligned vertically.\nSo LineBB[e1][e8] returns bitboard containing e1 e2 e3 e4 e5 e6 e7 e8.\nSquares: c1 and h6\nDiagonal alignment: So LineBB[c1][h6] returns c1 d2 e3 f4 g5 h6.\nSquares: a1 and c2\nNot aligned (not same file/rank/diagonal). So LineBB[a1][c2] == 0.\nUsed in aligned() aligned(from, to, kingSquare) This is implemented as:\ninline bool aligned(Square a, Square b, Square c) { return LineBB[a][b] \u0026 c; } Meaning:\nIs square c on the line through a and b?\nBetweenBB Bitboard BetweenBB[SQUARE_NB][SQUARE_NB]; This is a precomputed lookup table:\nBetweenBB[a][b] gives the bitboard of all squares strictly between square a and square b, if they are aligned.\nWhat does “between” mean?\nIf two squares lie on the same:\nrank (horizontal) file (vertical) diagonal Why is this useful?\nBecause chess is full of “line relationships”:\npinned pieces blocking checks sliding attacks (rook/bishop/queen) discovering check legality testing Example BetweenBB[a1][a8] returns a bitboard of these squares {a2, a3, a4, a5, a6, a7}\nIf squares are not aligned → empty bitboard\nKey usage: Blocking a check Suppose black queen gives check:\nBlack queen: e7 White king: e1 BetweenBB[E7][E1] = {E6,E5,E4,E3,E2}\nNow, if white is in check, legal responses include:\ncapture attacker move king block the line Stockfish uses this here:\nif (!((between_bb(checkerSq, kingSq) | checkers()) \u0026 to)) return false; Means you must do either\ncapture the checker, or land on a square between checker and king BetweenBB is precomputed for speed\n","wordCount":"1952","inLanguage":"en","datePublished":"2026-01-04T00:00:00Z","dateModified":"2026-01-04T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Bitboard representation of Chess Board</h1><div class=post-meta><span title='2026-01-04 00:00:00 +0000 UTC'>January 4, 2026</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-04-bitboard-representation.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#bitboard-based-game-representation-in-stockfish aria-label="Bitboard-Based Game Representation in Stockfish">Bitboard-Based Game Representation in Stockfish</a></li><li><a href=#piece-encoding aria-label="Piece Encoding">Piece Encoding</a><ul><li><a href=#numeric-structure aria-label="Numeric Structure">Numeric Structure</a></li><li><a href=#extracting-type-and-color aria-label="Extracting Type and Color">Extracting Type and Color</a></li><li><a href=#flipping-color aria-label="Flipping Color">Flipping Color</a></li><li><a href=#piece_nb aria-label=PIECE_NB>PIECE_NB</a></li></ul></li><li><a href=#piecetype-color-independent-identity aria-label="PieceType: Color-Independent Identity">PieceType: Color-Independent Identity</a><ul><li><a href=#purpose aria-label=Purpose>Purpose</a></li><li><a href=#special-values aria-label="Special Values">Special Values</a></li></ul></li><li><a href=#square-representation aria-label="Square Representation">Square Representation</a><ul><li><a href=#numeric-layout aria-label="Numeric Layout">Numeric Layout</a></li><li><a href=#why-this-layout aria-label="Why This Layout?">Why This Layout?</a></li></ul></li><li><a href=#directions-as-integer-offsets aria-label="Directions as Integer Offsets">Directions as Integer Offsets</a></li><li><a href=#file-and-rank-enums aria-label="File and Rank Enums">File and Rank Enums</a></li><li><a href=#color-relative-squares aria-label="Color-Relative Squares">Color-Relative Squares</a></li><li><a href=#castling-representation aria-label="Castling Representation">Castling Representation</a><ul><li><a href=#castlingside aria-label=CastlingSide>CastlingSide</a></li><li><a href=#castlingright-bitmask-encoding aria-label="CastlingRight: Bitmask Encoding">CastlingRight: Bitmask Encoding</a></li><li><a href=#numeric-values aria-label="Numeric Values">Numeric Values</a></li><li><a href=#why-bitmasks aria-label="Why Bitmasks?">Why Bitmasks?</a></li></ul></li><li><a href=#score-middlegame-and-endgame-packed-together aria-label="Score: Middlegame and Endgame Packed Together">Score: Middlegame and Endgame Packed Together</a><ul><li><a href=#bit-layout aria-label="Bit Layout">Bit Layout</a></li><li><a href=#creating-a-score aria-label="Creating a Score">Creating a Score</a></li><li><a href=#extracting-values aria-label="Extracting Values">Extracting Values</a></li><li><a href=#why-stockfish-uses-score aria-label="Why Stockfish Uses Score">Why Stockfish Uses Score</a></li><li><a href=#mental-model aria-label="Mental Model">Mental Model</a></li></ul></li><li><a href=#move-representation aria-label="Move Representation">Move Representation</a><ul><li><a href=#bit-layout-16-bits aria-label="Bit Layout (16 bits)">Bit Layout (16 bits)</a></li><li><a href=#squares-6-bits-each aria-label="Squares (6 bits each)">Squares (6 bits each)</a></li><li><a href=#special-move-flags-bits-1415 aria-label="Special Move Flags (bits 14–15)">Special Move Flags (bits 14–15)</a></li><li><a href=#promotion-encoding-bits-1213 aria-label="Promotion Encoding (bits 12–13)">Promotion Encoding (bits 12–13)</a></li><li><a href=#move_none-and-move_null aria-label="MOVE_NONE and MOVE_NULL">MOVE_NONE and MOVE_NULL</a><ul><li><a href=#move_none aria-label=MOVE_NONE>MOVE_NONE</a></li><li><a href=#move_null aria-label=MOVE_NULL>MOVE_NULL</a></li></ul></li><li><a href=#accessor-macros aria-label="Accessor Macros">Accessor Macros</a></li></ul></li><li><a href=#stepattacksbb---pre-computed-attack-tables aria-label="StepAttacksBB - Pre-computed Attack Tables">StepAttacksBB - Pre-computed Attack Tables</a><ul><li><a href=#whats-stored aria-label="What&rsquo;s Stored">What&rsquo;s Stored</a></li></ul></li><li><a href=#linebb aria-label=LineBB>LineBB</a><ul><li><a href=#used-in-aligned aria-label="Used in aligned()">Used in aligned()</a></li></ul></li><li><a href=#betweenbb aria-label=BetweenBB>BetweenBB</a><ul><li><a href=#key-usage-blocking-a-check aria-label="Key usage: Blocking a check">Key usage: Blocking a check</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=bitboard-based-game-representation-in-stockfish>Bitboard-Based Game Representation in Stockfish<a hidden class=anchor aria-hidden=true href=#bitboard-based-game-representation-in-stockfish>#</a></h2><p>Stockfish represents the chessboard using <strong>bitboards</strong>: 64-bit unsigned integers where each bit corresponds to a square on the board.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>uint64_t</span> Bitboard;
</span></span></code></pre></div><ul><li>Bit 0 (LSB) → <strong>A1</strong></li><li>Bit 63 (MSB) → <strong>H8</strong></li></ul><p>This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.</p><hr><h2 id=piece-encoding>Piece Encoding<a hidden class=anchor aria-hidden=true href=#piece-encoding>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Piece</span> {
</span></span><span style=display:flex><span>  NO_PIECE,
</span></span><span style=display:flex><span>  W_PAWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
</span></span><span style=display:flex><span>  B_PAWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
</span></span><span style=display:flex><span>  PIECE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=numeric-structure>Numeric Structure<a hidden class=anchor aria-hidden=true href=#numeric-structure>#</a></h3><table><thead><tr><th>Piece</th><th>Value</th><th>Binary</th></tr></thead><tbody><tr><td>W_PAWN</td><td>1</td><td>0001</td></tr><tr><td>W_KING</td><td>6</td><td>0110</td></tr><tr><td>B_PAWN</td><td>9</td><td>1001</td></tr><tr><td>B_KING</td><td>14</td><td>1110</td></tr></tbody></table><p>Key observations:</p><ul><li>White pieces occupy values <strong>1–6</strong></li><li>Black pieces occupy values <strong>9–14</strong></li><li>The <strong>4th bit</strong> distinguishes color</li></ul><p>This enables a compact and efficient encoding:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Piece <span style=color:#f92672>=</span> (Color <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>|</span> PieceType
</span></span></code></pre></div><h3 id=extracting-type-and-color>Extracting Type and Color<a hidden class=anchor aria-hidden=true href=#extracting-type-and-color>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> PieceType <span style=color:#a6e22e>type_of</span>(Piece pc) { <span style=color:#66d9ef>return</span> PieceType(pc <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Color <span style=color:#a6e22e>color_of</span>(Piece pc)    { <span style=color:#66d9ef>return</span> Color(pc <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>); }
</span></span></code></pre></div><ul><li><code>pc & 7</code> strips color → piece type</li><li><code>pc >> 3</code> extracts color</li></ul><h3 id=flipping-color>Flipping Color<a hidden class=anchor aria-hidden=true href=#flipping-color>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>~</span>pc <span style=color:#f92672>==</span> pc <span style=color:#f92672>^</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>Toggles the color bit while keeping the piece type unchanged.</p><h3 id=piece_nb><code>PIECE_NB</code><a hidden class=anchor aria-hidden=true href=#piece_nb>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>PIECE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>Used for array sizing and indexing. It is <strong>not</strong> the number of actual chess pieces, but the size of the encoding space.</p><hr><h2 id=piecetype-color-independent-identity>PieceType: Color-Independent Identity<a hidden class=anchor aria-hidden=true href=#piecetype-color-independent-identity>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>PieceType</span> {
</span></span><span style=display:flex><span>  NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
</span></span><span style=display:flex><span>  ALL_PIECES <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  PIECE_TYPE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=purpose>Purpose<a hidden class=anchor aria-hidden=true href=#purpose>#</a></h3><ul><li><p>Represents <strong>kind of piece</strong>, independent of color</p></li><li><p>Used for:</p><ul><li>Move generation</li><li>Attack generation</li><li>Evaluation</li><li>Bitboard indexing</li></ul></li></ul><p>This enum deliberately excludes color, which is handled separately.</p><p>The encoding aligns perfectly with <code>Piece</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Piece <span style=color:#f92672>=</span> (Color <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>|</span> PieceType
</span></span></code></pre></div><h3 id=special-values>Special Values<a hidden class=anchor aria-hidden=true href=#special-values>#</a></h3><ul><li><code>ALL_PIECES = 0</code>
Used as a generic index when aggregating attacks.</li><li><code>PIECE_TYPE_NB = 8</code>
Total number of piece types including sentinel values.</li></ul><hr><h2 id=square-representation>Square Representation<a hidden class=anchor aria-hidden=true href=#square-representation>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Square</span> {
</span></span><span style=display:flex><span>  SQ_A1, SQ_B1, ..., SQ_H8,
</span></span><span style=display:flex><span>  SQ_NONE,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  SQUARE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  NORTH <span style=color:#f92672>=</span>  <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>  EAST  <span style=color:#f92672>=</span>  <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  SOUTH <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>  WEST  <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  NORTH_EAST <span style=color:#f92672>=</span> NORTH <span style=color:#f92672>+</span> EAST,
</span></span><span style=display:flex><span>  SOUTH_EAST <span style=color:#f92672>=</span> SOUTH <span style=color:#f92672>+</span> EAST,
</span></span><span style=display:flex><span>  SOUTH_WEST <span style=color:#f92672>=</span> SOUTH <span style=color:#f92672>+</span> WEST,
</span></span><span style=display:flex><span>  NORTH_WEST <span style=color:#f92672>=</span> NORTH <span style=color:#f92672>+</span> WEST
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=numeric-layout>Numeric Layout<a hidden class=anchor aria-hidden=true href=#numeric-layout>#</a></h3><p>Squares are encoded in <strong>rank-major order</strong>:</p><pre tabindex=0><code>A1 = 0   B1 = 1   ... H1 = 7
A2 = 8   B2 = 9   ... H2 = 15
...
A8 = 56  B8 = 57  ... H8 = 63
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span>(SQ_E4) <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>28</span>
</span></span></code></pre></div><h3 id=why-this-layout>Why This Layout?<a hidden class=anchor aria-hidden=true href=#why-this-layout>#</a></h3><ul><li>Files increment by <code>+1</code></li><li>Ranks increment by <code>+8</code></li><li>Board geometry becomes simple integer arithmetic</li></ul><hr><h2 id=directions-as-integer-offsets>Directions as Integer Offsets<a hidden class=anchor aria-hidden=true href=#directions-as-integer-offsets>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>NORTH <span style=color:#f92672>=</span>  <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>EAST  <span style=color:#f92672>=</span>  <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>SOUTH <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>WEST  <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>This allows simple move computation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>SQ_E2 <span style=color:#f92672>+</span> NORTH        <span style=color:#f92672>==</span> SQ_E3
</span></span><span style=display:flex><span>SQ_E2 <span style=color:#f92672>+</span> NORTH_EAST   <span style=color:#f92672>==</span> SQ_F3
</span></span></code></pre></div><p>Diagonal directions are composed, not duplicated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>NORTH_EAST <span style=color:#f92672>=</span> NORTH <span style=color:#f92672>+</span> EAST
</span></span></code></pre></div><hr><h2 id=file-and-rank-enums>File and Rank Enums<a hidden class=anchor aria-hidden=true href=#file-and-rank-enums>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>File</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> { FILE_A, FILE_B, ..., FILE_H, FILE_NB };
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Rank</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> { RANK_1, RANK_2, ..., RANK_8, RANK_NB };
</span></span></code></pre></div><p>These are <strong>semantic types</strong>, not just integers.</p><p>They improve:</p><ul><li>Readability</li><li>Type safety</li><li>Template specialization</li></ul><p>Extraction helpers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> File <span style=color:#a6e22e>file_of</span>(Square s) { <span style=color:#66d9ef>return</span> File(s <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Rank <span style=color:#a6e22e>rank_of</span>(Square s) { <span style=color:#66d9ef>return</span> Rank(s <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>); }
</span></span></code></pre></div><p>Construction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Square <span style=color:#a6e22e>make_square</span>(File f, Rank r) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Square((r <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>+</span> f);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Everything reduces to:</p><pre tabindex=0><code>square = rank * 8 + file
</code></pre><hr><h2 id=color-relative-squares>Color-Relative Squares<a hidden class=anchor aria-hidden=true href=#color-relative-squares>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Square <span style=color:#a6e22e>relative_square</span>(Color c, Square s) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Square(s <span style=color:#f92672>^</span> (c <span style=color:#f92672>*</span> <span style=color:#ae81ff>56</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>For <strong>WHITE (c = 0)</strong>: square unchanged</li><li>For <strong>BLACK (c = 1)</strong>: square vertically flipped</li></ul><p>Why <code>56</code>?</p><pre tabindex=0><code>56 = 7 * 8 = A8
</code></pre><p>Examples:</p><pre tabindex=0><code>A1 ^ 56 = A8
C1 ^ 56 = C8
</code></pre><p>This allows writing <strong>color-independent evaluation logic</strong>.</p><hr><h2 id=castling-representation>Castling Representation<a hidden class=anchor aria-hidden=true href=#castling-representation>#</a></h2><h3 id=castlingside>CastlingSide<a hidden class=anchor aria-hidden=true href=#castlingside>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CastlingSide</span> {
</span></span><span style=display:flex><span>  KING_SIDE,
</span></span><span style=display:flex><span>  QUEEN_SIDE,
</span></span><span style=display:flex><span>  CASTLING_SIDE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>Simple selector enum</li><li>Not a bitmask</li><li>Used in templates and branching logic</li></ul><hr><h3 id=castlingright-bitmask-encoding>CastlingRight: Bitmask Encoding<a hidden class=anchor aria-hidden=true href=#castlingright-bitmask-encoding>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CastlingRight</span> {
</span></span><span style=display:flex><span>  NO_CASTLING,
</span></span><span style=display:flex><span>  WHITE_OO,
</span></span><span style=display:flex><span>  WHITE_OOO <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  BLACK_OO  <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  BLACK_OOO <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  ANY_CASTLING <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>|</span> WHITE_OOO <span style=color:#f92672>|</span> BLACK_OO <span style=color:#f92672>|</span> BLACK_OOO,
</span></span><span style=display:flex><span>  CASTLING_RIGHT_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=numeric-values>Numeric Values<a hidden class=anchor aria-hidden=true href=#numeric-values>#</a></h3><pre tabindex=0><code>WHITE_OO    = 1  // 0001
WHITE_OOO   = 2  // 0010
BLACK_OO    = 4  // 0100
BLACK_OOO   = 8  // 1000
</code></pre><h3 id=why-bitmasks>Why Bitmasks?<a hidden class=anchor aria-hidden=true href=#why-bitmasks>#</a></h3><p>Castling rights are <strong>independent flags</strong>:</p><ul><li><p>A position may have:</p><ul><li>Only king-side rights</li><li>Only queen-side rights</li><li>Both</li><li>None</li></ul></li></ul><p>Bitmasks allow all combinations efficiently:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>WHITE_OO <span style=color:#f92672>|</span> WHITE_OOO   <span style=color:#75715e>// White can castle both sides
</span></span></span><span style=display:flex><span>BLACK_OO <span style=color:#f92672>|</span> BLACK_OOO   <span style=color:#75715e>// Black can castle both sides
</span></span></span><span style=display:flex><span>WHITE_OO <span style=color:#f92672>|</span> BLACK_OO    <span style=color:#75715e>// Both can castle king-side
</span></span></span><span style=display:flex><span>ANY_CASTLING           <span style=color:#75715e>// All rights available
</span></span></span></code></pre></div><h2 id=score-middlegame-and-endgame-packed-together>Score: Middlegame and Endgame Packed Together<a hidden class=anchor aria-hidden=true href=#score-middlegame-and-endgame-packed-together>#</a></h2><p>Stockfish does not evaluate a position with a single number. Instead, it evaluates <strong>two positions in parallel</strong>:</p><ul><li><strong>Middlegame (MG) score</strong></li><li><strong>Endgame (EG) score</strong></li></ul><p>These two values are packed into a single 32-bit integer called <code>Score</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Score enum stores a middlegame and an endgame value in a single integer
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// The upper 16 bits store the middlegame value
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// The lower 16 bits store the endgame value
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Score</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> { SCORE_ZERO };
</span></span></code></pre></div><h3 id=bit-layout>Bit Layout<a hidden class=anchor aria-hidden=true href=#bit-layout>#</a></h3><pre tabindex=0><code>32-bit Score integer

|  MG (signed 16 bits) |  EG (signed 16 bits) |
|----------------------|----------------------|
| bits 31 ........ 16 | bits 15 ........ 0  |
</code></pre><p>This allows Stockfish to accumulate middlegame and endgame evaluations <strong>simultaneously</strong>, without branching on game phase.</p><hr><h3 id=creating-a-score>Creating a Score<a hidden class=anchor aria-hidden=true href=#creating-a-score>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Score <span style=color:#a6e22e>make_score</span>(<span style=color:#66d9ef>int</span> mg, <span style=color:#66d9ef>int</span> eg) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Score((<span style=color:#66d9ef>int</span>)((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)eg <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>) <span style=color:#f92672>+</span> mg);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Conceptually:</p><pre tabindex=0><code>Score = (EG &lt;&lt; 16) | MG
</code></pre><p>The implementation uses unsigned arithmetic to avoid undefined behavior when shifting signed integers.</p><hr><h3 id=extracting-values>Extracting Values<a hidden class=anchor aria-hidden=true href=#extracting-values>#</a></h3><p><strong>Endgame value:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Value <span style=color:#a6e22e>eg_value</span>(Score s) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> { <span style=color:#66d9ef>uint16_t</span> u; <span style=color:#66d9ef>int16_t</span> s; } eg <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span>(<span style=color:#66d9ef>unsigned</span>(s <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x8000</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Value(eg.s);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Middlegame value:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Value <span style=color:#a6e22e>mg_value</span>(Score s) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> { <span style=color:#66d9ef>uint16_t</span> u; <span style=color:#66d9ef>int16_t</span> s; } mg <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span>(<span style=color:#66d9ef>unsigned</span>(s))
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Value(mg.s);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>These functions carefully preserve sign and avoid implementation-defined behavior in C++.</p><hr><h3 id=why-stockfish-uses-score>Why Stockfish Uses <code>Score</code><a hidden class=anchor aria-hidden=true href=#why-stockfish-uses-score>#</a></h3><p>This design enables:</p><ul><li>Continuous transition between middlegame and endgame</li><li>No runtime branching on game phase</li><li>Extremely cache-friendly evaluation</li><li>Simple accumulation of evaluation terms</li></ul><p>Throughout evaluation, Stockfish accumulates <code>Score</code> values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Score score <span style=color:#f92672>=</span> SCORE_ZERO;
</span></span><span style=display:flex><span>score <span style=color:#f92672>+=</span> MobilityBonus;
</span></span><span style=display:flex><span>score <span style=color:#f92672>+=</span> PawnStructure;
</span></span><span style=display:flex><span>score <span style=color:#f92672>+=</span> KingSafety;
</span></span></code></pre></div><p>Only at the very end is the final value computed by interpolating between MG and EG using the game phase.</p><hr><h3 id=mental-model>Mental Model<a hidden class=anchor aria-hidden=true href=#mental-model>#</a></h3><p>Think of <code>Score</code> as a <strong>2-component vector</strong>:</p><pre tabindex=0><code>Score = ⟨middlegame, endgame⟩
</code></pre><p>Evaluation is vector addition, and the final numeric score is a weighted projection based on how far the game has progressed.</p><h2 id=move-representation>Move Representation<a hidden class=anchor aria-hidden=true href=#move-representation>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// A move needs 16 bits to be stored
</span></span></span><span style=display:flex><span><span style=color:#75715e>///
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// bit  0- 5: destination square (from 0 to 63)
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// bit  6-11: origin square (from 0 to 63)
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// bit 12-13: promotion piece type - 2 (from KNIGHT-2 to QUEEN-2)
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// bit 14-15: special move flag: promotion (1), en passant (2), castling (3)
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// NOTE: EN-PASSANT bit is set only when a pawn can be captured
</span></span></span><span style=display:flex><span><span style=color:#75715e>///
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// Special cases are MOVE_NONE and MOVE_NULL. We can sneak these in because in
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// any normal move destination square is always different from origin square
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// while MOVE_NONE and MOVE_NULL have the same origin and destination square.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Move</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  MOVE_NONE,
</span></span><span style=display:flex><span>  MOVE_NULL <span style=color:#f92672>=</span> <span style=color:#ae81ff>65</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Stockfish represents every chess move in just 16 bits for speed and cache efficiency.</p><h3 id=bit-layout-16-bits>Bit Layout (16 bits)<a hidden class=anchor aria-hidden=true href=#bit-layout-16-bits>#</a></h3><pre tabindex=0><code>15 14 | 13 12 | 11 ...... 6 | 5 ...... 0
----------------------------------------
flags | promo |   from      |   to
</code></pre><pre tabindex=0><code>| Bits    | Meaning                       |
| ------- | ----------------------------- |
| 0–5     | Destination square (0–63)     |
| 6–11    | Origin square (0–63)          |
| 12–13   | Promotion piece − 2           |
| 14–15   | Special move flag             |
</code></pre><h3 id=squares-6-bits-each>Squares (6 bits each)<a hidden class=anchor aria-hidden=true href=#squares-6-bits-each>#</a></h3><p>Squares are encoded as integers:</p><pre tabindex=0><code>A1 = 0, B1 = 1, ..., H8 = 63
</code></pre><p>So:</p><ul><li><code>from_sq(m)</code> → bits 6–11</li><li><code>to_sq(m)</code> → bits 0–5</li></ul><h3 id=special-move-flags-bits-1415>Special Move Flags (bits 14–15)<a hidden class=anchor aria-hidden=true href=#special-move-flags-bits-1415>#</a></h3><pre tabindex=0><code>| Value | Meaning     |
| ----: | ----------- |
|  `00` | Normal move |
|  `01` | Promotion   |
|  `10` | En passant  |
|  `11` | Castling    |
</code></pre><h3 id=promotion-encoding-bits-1213>Promotion Encoding (bits 12–13)<a hidden class=anchor aria-hidden=true href=#promotion-encoding-bits-1213>#</a></h3><p>Promotion piece type is encoded as:</p><pre tabindex=0><code>promotion_piece = (promotion_type + 2)
</code></pre><pre tabindex=0><code>| Promotion | Encoded |
| --------- | ------- |
| Knight    | 0       |
| Bishop    | 1       |
| Rook      | 2       |
| Queen     | 3       |
</code></pre><p>Because as per Stockfish representation, <code>NO_PIECE_TYPE</code> and <code>PAWN</code> are not useful for promotion, so we can save bits.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>PieceType</span> {
</span></span><span style=display:flex><span>  NO_PIECE_TYPE <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  PAWN          <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  KNIGHT        <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  BISHOP        <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  ROOK          <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>  QUEEN         <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  KING          <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=move_none-and-move_null>MOVE_NONE and MOVE_NULL<a hidden class=anchor aria-hidden=true href=#move_none-and-move_null>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Move</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  MOVE_NONE,
</span></span><span style=display:flex><span>  MOVE_NULL <span style=color:#f92672>=</span> <span style=color:#ae81ff>65</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Why this works</p><ul><li>A legal move always has from != to</li><li>These special moves violate that rule</li></ul><h4 id=move_none>MOVE_NONE<a hidden class=anchor aria-hidden=true href=#move_none>#</a></h4><pre tabindex=0><code>from = 0
to   = 0
</code></pre><p>Used to mean:</p><ul><li>“no move”</li><li>invalid move</li><li>search sentinel</li></ul><h4 id=move_null>MOVE_NULL<a hidden class=anchor aria-hidden=true href=#move_null>#</a></h4><pre tabindex=0><code>from = 1
to   = 1   // 1 | (1 &lt;&lt; 6) = 65
</code></pre><p>Used for:</p><ul><li>null move pruning</li><li>represents “pass move” (side switches, no piece moved)</li></ul><h3 id=accessor-macros>Accessor Macros<a hidden class=anchor aria-hidden=true href=#accessor-macros>#</a></h3><p>Internally Stockfish uses helpers like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>to_sq(m)      <span style=color:#f92672>=</span> m <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3F</span>
</span></span><span style=display:flex><span>from_sq(m)    <span style=color:#f92672>=</span> (m <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>6</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3F</span>
</span></span><span style=display:flex><span>type_of(m)    <span style=color:#f92672>=</span> m <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xC000</span>
</span></span><span style=display:flex><span>promo_type(m) <span style=color:#f92672>=</span> ((m <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>12</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>+</span> KNIGHT
</span></span></code></pre></div><h2 id=stepattacksbb---pre-computed-attack-tables>StepAttacksBB - Pre-computed Attack Tables<a hidden class=anchor aria-hidden=true href=#stepattacksbb---pre-computed-attack-tables>#</a></h2><p><code>StepAttacksBB</code> is a lookup table that stores pre-computed attack patterns for pieces that move in fixed steps (not sliding pieces).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard StepAttacksBB[PIECE_NB][SQUARE_NB];
</span></span><span style=display:flex><span><span style=color:#75715e>// [16 piece types][64 squares] = 1024 bitboards
</span></span></span></code></pre></div><p>&ldquo;Step attacks&rdquo; = pieces that attack a fixed pattern of squares:</p><ul><li>Pawns (different for white/black)</li><li>Knights</li><li>Kings</li><li>NOT bishops, rooks, queens (these are &ldquo;sliding&rdquo; pieces)</li></ul><h3 id=whats-stored>What&rsquo;s Stored<a hidden class=anchor aria-hidden=true href=#whats-stored>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// For each piece type and square, store which squares it attacks
</span></span></span><span style=display:flex><span>StepAttacksBB[piece][from_square] <span style=color:#960050;background-color:#1e0010>→</span> Bitboard of attacked squares
</span></span></code></pre></div><p><strong>Examples:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>StepAttacksBB[W_PAWN][e4]  <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d5, f5 set (white pawn attacks)
</span></span><span style=display:flex><span>StepAttacksBB[B_PAWN][e5]  <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d4, f4 set (black pawn attacks)
</span></span><span style=display:flex><span>StepAttacksBB[W_KNIGHT][e4] <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d2, f2, c3, g3, c5, g5, d6, f6
</span></span><span style=display:flex><span>StepAttacksBB[W_KING][e1]  <span style=color:#960050;background-color:#1e0010>→</span> Bitboard with d1, f1, d2, e2, f2
</span></span></code></pre></div><h2 id=linebb>LineBB<a hidden class=anchor aria-hidden=true href=#linebb>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard LineBB[SQUARE_NB][SQUARE_NB];
</span></span></code></pre></div><p>LineBB is a precomputed bitboard table that represents:</p><blockquote><p>The entire straight line passing through two squares
if they are aligned (same rank/file/diagonal)</p></blockquote><p>Otherwise:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>LineBB[a][b] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Intuition</p><p>If you pick two squares:</p><ul><li>e1 and e8 → same file</li><li>c1 and h6 → same diagonal</li><li>a1 and h1 → same rank</li></ul><p>Then the squares between them lie on a straight line.</p><p>So <code>LineBB[s1][s2] </code>is a bitboard answers:</p><blockquote><p>Which squares belong to the line containing both s1 and s2?</p></blockquote><p>Example:</p><p>Squares: e1 and e8</p><p>They are aligned vertically.</p><p>So <code>LineBB[e1][e8]</code> returns bitboard containing <code>e1 e2 e3 e4 e5 e6 e7 e8</code>.</p><p>Squares: c1 and h6</p><p>Diagonal alignment: So <code>LineBB[c1][h6]</code> returns <code>c1 d2 e3 f4 g5 h6</code>.</p><p>Squares: a1 and c2</p><p>Not aligned (not same file/rank/diagonal). So <code>LineBB[a1][c2] == 0</code>.</p><h3 id=used-in-aligned>Used in aligned()<a hidden class=anchor aria-hidden=true href=#used-in-aligned>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>aligned(from, to, kingSquare)
</span></span></code></pre></div><p>This is implemented as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>aligned</span>(Square a, Square b, Square c) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> LineBB[a][b] <span style=color:#f92672>&amp;</span> c;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Meaning:</p><blockquote><p>Is square c on the line through a and b?</p></blockquote><h2 id=betweenbb>BetweenBB<a hidden class=anchor aria-hidden=true href=#betweenbb>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard BetweenBB[SQUARE_NB][SQUARE_NB];
</span></span></code></pre></div><p>This is a precomputed lookup table:</p><p>BetweenBB[a][b] gives the bitboard of all squares strictly between square a and square b, if they are aligned.</p><p>What does “between” mean?</p><p>If two squares lie on the same:</p><ul><li>rank (horizontal)</li><li>file (vertical)</li><li>diagonal</li></ul><p><strong>Why is this useful?</strong></p><p>Because chess is full of “line relationships”:</p><ul><li>pinned pieces</li><li>blocking checks</li><li>sliding attacks (rook/bishop/queen)</li><li>discovering check</li><li>legality testing</li></ul><p>Example BetweenBB[a1][a8] returns a bitboard of these squares {a2, a3, a4, a5, a6, a7}</p><p>If squares are not aligned → empty bitboard</p><h3 id=key-usage-blocking-a-check>Key usage: Blocking a check<a hidden class=anchor aria-hidden=true href=#key-usage-blocking-a-check>#</a></h3><p>Suppose black queen gives check:</p><pre tabindex=0><code>Black queen: e7
White king:  e1
</code></pre><p>BetweenBB[E7][E1] = {E6,E5,E4,E3,E2}</p><p>Now, if white is in check, legal responses include:</p><ul><li>capture attacker</li><li>move king</li><li>block the line</li></ul><p>Stockfish uses this here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>((between_bb(checkerSq, kingSq) <span style=color:#f92672>|</span> checkers()) <span style=color:#f92672>&amp;</span> to))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span></code></pre></div><p>Means you must do either</p><ul><li>capture the checker, or</li><li>land on a square between checker and king</li></ul><p>BetweenBB is precomputed for speed</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/bitboard/>Bitboard</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>