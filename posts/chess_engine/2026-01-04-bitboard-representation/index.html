<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bitboard representation of Chess Board | Sanketh's Blog</title><meta name=keywords content="bitboard"><meta name=description content="Bitboard-Based Game Representation in Stockfish
Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.
typedef uint64_t Bitboard;

Bit 0 (LSB) → A1
Bit 63 (MSB) → H8

This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.

Piece Encoding
enum Piece {
  NO_PIECE,
  W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
  B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
  PIECE_NB = 16
};
Numeric Structure

  
      
          Piece
          Value
          Binary
      
  
  
      
          W_PAWN
          1
          0001
      
      
          W_KING
          6
          0110
      
      
          B_PAWN
          9
          1001
      
      
          B_KING
          14
          1110
      
  

Key observations:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Bitboard representation of Chess Board"><meta property="og:description" content="Bitboard-Based Game Representation in Stockfish Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.
typedef uint64_t Bitboard; Bit 0 (LSB) → A1 Bit 63 (MSB) → H8 This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.
Piece Encoding enum Piece { NO_PIECE, W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING, PIECE_NB = 16 }; Numeric Structure Piece Value Binary W_PAWN 1 0001 W_KING 6 0110 B_PAWN 9 1001 B_KING 14 1110 Key observations:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-04T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-04T00:00:00+00:00"><meta property="article:tag" content="Bitboard"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bitboard representation of Chess Board"><meta name=twitter:description content="Bitboard-Based Game Representation in Stockfish
Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.
typedef uint64_t Bitboard;

Bit 0 (LSB) → A1
Bit 63 (MSB) → H8

This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.

Piece Encoding
enum Piece {
  NO_PIECE,
  W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
  B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
  PIECE_NB = 16
};
Numeric Structure

  
      
          Piece
          Value
          Binary
      
  
  
      
          W_PAWN
          1
          0001
      
      
          W_KING
          6
          0110
      
      
          B_PAWN
          9
          1001
      
      
          B_KING
          14
          1110
      
  

Key observations:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Bitboard representation of Chess Board","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bitboard representation of Chess Board","name":"Bitboard representation of Chess Board","description":"Bitboard-Based Game Representation in Stockfish Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.\ntypedef uint64_t Bitboard; Bit 0 (LSB) → A1 Bit 63 (MSB) → H8 This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.\nPiece Encoding enum Piece { NO_PIECE, W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING, PIECE_NB = 16 }; Numeric Structure Piece Value Binary W_PAWN 1 0001 W_KING 6 0110 B_PAWN 9 1001 B_KING 14 1110 Key observations:\n","keywords":["bitboard"],"articleBody":"Bitboard-Based Game Representation in Stockfish Stockfish represents the chessboard using bitboards: 64-bit unsigned integers where each bit corresponds to a square on the board.\ntypedef uint64_t Bitboard; Bit 0 (LSB) → A1 Bit 63 (MSB) → H8 This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.\nPiece Encoding enum Piece { NO_PIECE, W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING, B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING, PIECE_NB = 16 }; Numeric Structure Piece Value Binary W_PAWN 1 0001 W_KING 6 0110 B_PAWN 9 1001 B_KING 14 1110 Key observations:\nWhite pieces occupy values 1–6 Black pieces occupy values 9–14 The 4th bit distinguishes color This enables a compact and efficient encoding:\nPiece = (Color \u003c\u003c 3) | PieceType Extracting Type and Color inline PieceType type_of(Piece pc) { return PieceType(pc \u0026 7); } inline Color color_of(Piece pc) { return Color(pc \u003e\u003e 3); } pc \u0026 7 strips color → piece type pc \u003e\u003e 3 extracts color Flipping Color ~pc == pc ^ 8 Toggles the color bit while keeping the piece type unchanged.\nPIECE_NB PIECE_NB = 16 Used for array sizing and indexing. It is not the number of actual chess pieces, but the size of the encoding space.\nPieceType: Color-Independent Identity enum PieceType { NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING, ALL_PIECES = 0, PIECE_TYPE_NB = 8 }; Purpose Represents kind of piece, independent of color\nUsed for:\nMove generation Attack generation Evaluation Bitboard indexing This enum deliberately excludes color, which is handled separately.\nThe encoding aligns perfectly with Piece:\nPiece = (Color \u003c\u003c 3) | PieceType Special Values ALL_PIECES = 0 Used as a generic index when aggregating attacks. PIECE_TYPE_NB = 8 Total number of piece types including sentinel values. Square Representation enum Square { SQ_A1, SQ_B1, ..., SQ_H8, SQ_NONE, SQUARE_NB = 64, NORTH = 8, EAST = 1, SOUTH = -8, WEST = -1, NORTH_EAST = NORTH + EAST, SOUTH_EAST = SOUTH + EAST, SOUTH_WEST = SOUTH + WEST, NORTH_WEST = NORTH + WEST }; Numeric Layout Squares are encoded in rank-major order:\nA1 = 0 B1 = 1 ... H1 = 7 A2 = 8 B2 = 9 ... H2 = 15 ... A8 = 56 B8 = 57 ... H8 = 63 Example:\nint(SQ_E4) == 4 + 3 * 8 == 28 Why This Layout? Files increment by +1 Ranks increment by +8 Board geometry becomes simple integer arithmetic Directions as Integer Offsets NORTH = 8 EAST = 1 SOUTH = -8 WEST = -1 This allows simple move computation:\nSQ_E2 + NORTH == SQ_E3 SQ_E2 + NORTH_EAST == SQ_F3 Diagonal directions are composed, not duplicated:\nNORTH_EAST = NORTH + EAST File and Rank Enums enum File : int { FILE_A, FILE_B, ..., FILE_H, FILE_NB }; enum Rank : int { RANK_1, RANK_2, ..., RANK_8, RANK_NB }; These are semantic types, not just integers.\nThey improve:\nReadability Type safety Template specialization Extraction helpers:\ninline File file_of(Square s) { return File(s \u0026 7); } inline Rank rank_of(Square s) { return Rank(s \u003e\u003e 3); } Construction:\ninline Square make_square(File f, Rank r) { return Square((r \u003c\u003c 3) + f); } Everything reduces to:\nsquare = rank * 8 + file Color-Relative Squares inline Square relative_square(Color c, Square s) { return Square(s ^ (c * 56)); } For WHITE (c = 0): square unchanged For BLACK (c = 1): square vertically flipped Why 56?\n56 = 7 * 8 = A8 Examples:\nA1 ^ 56 = A8 C1 ^ 56 = C8 This allows writing color-independent evaluation logic.\nCastling Representation CastlingSide enum CastlingSide { KING_SIDE, QUEEN_SIDE, CASTLING_SIDE_NB = 2 }; Simple selector enum Not a bitmask Used in templates and branching logic CastlingRight: Bitmask Encoding enum CastlingRight { NO_CASTLING, WHITE_OO, WHITE_OOO = WHITE_OO \u003c\u003c 1, BLACK_OO = WHITE_OO \u003c\u003c 2, BLACK_OOO = WHITE_OO \u003c\u003c 3, ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO, CASTLING_RIGHT_NB = 16 }; Numeric Values WHITE_OO = 1 // 0001 WHITE_OOO = 2 // 0010 BLACK_OO = 4 // 0100 BLACK_OOO = 8 // 1000 Why Bitmasks? Castling rights are independent flags:\nA position may have:\nOnly king-side rights Only queen-side rights Both None Bitmasks allow all combinations efficiently:\nWHITE_OO | WHITE_OOO // White can castle both sides BLACK_OO | BLACK_OOO // Black can castle both sides WHITE_OO | BLACK_OO // Both can castle king-side ANY_CASTLING // All rights available Score: Middlegame and Endgame Packed Together Stockfish does not evaluate a position with a single number. Instead, it evaluates two positions in parallel:\nMiddlegame (MG) score Endgame (EG) score These two values are packed into a single 32-bit integer called Score.\n/// Score enum stores a middlegame and an endgame value in a single integer /// The upper 16 bits store the middlegame value /// The lower 16 bits store the endgame value enum Score : int { SCORE_ZERO }; Bit Layout 32-bit Score integer | MG (signed 16 bits) | EG (signed 16 bits) | |----------------------|----------------------| | bits 31 ........ 16 | bits 15 ........ 0 | This allows Stockfish to accumulate middlegame and endgame evaluations simultaneously, without branching on game phase.\nCreating a Score inline Score make_score(int mg, int eg) { return Score((int)((unsigned int)eg \u003c\u003c 16) + mg); } Conceptually:\nScore = (EG \u003c\u003c 16) | MG The implementation uses unsigned arithmetic to avoid undefined behavior when shifting signed integers.\nExtracting Values Endgame value:\ninline Value eg_value(Score s) { union { uint16_t u; int16_t s; } eg = { uint16_t(unsigned(s + 0x8000) \u003e\u003e 16) }; return Value(eg.s); } Middlegame value:\ninline Value mg_value(Score s) { union { uint16_t u; int16_t s; } mg = { uint16_t(unsigned(s)) }; return Value(mg.s); } These functions carefully preserve sign and avoid implementation-defined behavior in C++.\nWhy Stockfish Uses Score This design enables:\nContinuous transition between middlegame and endgame No runtime branching on game phase Extremely cache-friendly evaluation Simple accumulation of evaluation terms Throughout evaluation, Stockfish accumulates Score values:\nScore score = SCORE_ZERO; score += MobilityBonus; score += PawnStructure; score += KingSafety; Only at the very end is the final value computed by interpolating between MG and EG using the game phase.\nMental Model Think of Score as a 2-component vector:\nScore = ⟨middlegame, endgame⟩ Evaluation is vector addition, and the final numeric score is a weighted projection based on how far the game has progressed.\n","wordCount":"1052","inLanguage":"en","datePublished":"2026-01-04T00:00:00Z","dateModified":"2026-01-04T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-04-bitboard-representation/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Bitboard representation of Chess Board</h1><div class=post-meta><span title='2026-01-04 00:00:00 +0000 UTC'>January 4, 2026</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-04-bitboard-representation.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#bitboard-based-game-representation-in-stockfish aria-label="Bitboard-Based Game Representation in Stockfish">Bitboard-Based Game Representation in Stockfish</a></li><li><a href=#piece-encoding aria-label="Piece Encoding">Piece Encoding</a><ul><li><a href=#numeric-structure aria-label="Numeric Structure">Numeric Structure</a></li><li><a href=#extracting-type-and-color aria-label="Extracting Type and Color">Extracting Type and Color</a></li><li><a href=#flipping-color aria-label="Flipping Color">Flipping Color</a></li><li><a href=#piece_nb aria-label=PIECE_NB>PIECE_NB</a></li></ul></li><li><a href=#piecetype-color-independent-identity aria-label="PieceType: Color-Independent Identity">PieceType: Color-Independent Identity</a><ul><li><a href=#purpose aria-label=Purpose>Purpose</a></li><li><a href=#special-values aria-label="Special Values">Special Values</a></li></ul></li><li><a href=#square-representation aria-label="Square Representation">Square Representation</a><ul><li><a href=#numeric-layout aria-label="Numeric Layout">Numeric Layout</a></li><li><a href=#why-this-layout aria-label="Why This Layout?">Why This Layout?</a></li></ul></li><li><a href=#directions-as-integer-offsets aria-label="Directions as Integer Offsets">Directions as Integer Offsets</a></li><li><a href=#file-and-rank-enums aria-label="File and Rank Enums">File and Rank Enums</a></li><li><a href=#color-relative-squares aria-label="Color-Relative Squares">Color-Relative Squares</a></li><li><a href=#castling-representation aria-label="Castling Representation">Castling Representation</a><ul><li><a href=#castlingside aria-label=CastlingSide>CastlingSide</a></li><li><a href=#castlingright-bitmask-encoding aria-label="CastlingRight: Bitmask Encoding">CastlingRight: Bitmask Encoding</a></li><li><a href=#numeric-values aria-label="Numeric Values">Numeric Values</a></li><li><a href=#why-bitmasks aria-label="Why Bitmasks?">Why Bitmasks?</a></li></ul></li><li><a href=#score-middlegame-and-endgame-packed-together aria-label="Score: Middlegame and Endgame Packed Together">Score: Middlegame and Endgame Packed Together</a><ul><li><a href=#bit-layout aria-label="Bit Layout">Bit Layout</a></li><li><a href=#creating-a-score aria-label="Creating a Score">Creating a Score</a></li><li><a href=#extracting-values aria-label="Extracting Values">Extracting Values</a></li><li><a href=#why-stockfish-uses-score aria-label="Why Stockfish Uses Score">Why Stockfish Uses Score</a></li><li><a href=#mental-model aria-label="Mental Model">Mental Model</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=bitboard-based-game-representation-in-stockfish>Bitboard-Based Game Representation in Stockfish<a hidden class=anchor aria-hidden=true href=#bitboard-based-game-representation-in-stockfish>#</a></h2><p>Stockfish represents the chessboard using <strong>bitboards</strong>: 64-bit unsigned integers where each bit corresponds to a square on the board.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>uint64_t</span> Bitboard;
</span></span></code></pre></div><ul><li>Bit 0 (LSB) → <strong>A1</strong></li><li>Bit 63 (MSB) → <strong>H8</strong></li></ul><p>This representation allows the engine to manipulate entire sets of squares using fast bitwise operations, which is critical for performance.</p><hr><h2 id=piece-encoding>Piece Encoding<a hidden class=anchor aria-hidden=true href=#piece-encoding>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Piece</span> {
</span></span><span style=display:flex><span>  NO_PIECE,
</span></span><span style=display:flex><span>  W_PAWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
</span></span><span style=display:flex><span>  B_PAWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
</span></span><span style=display:flex><span>  PIECE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=numeric-structure>Numeric Structure<a hidden class=anchor aria-hidden=true href=#numeric-structure>#</a></h3><table><thead><tr><th>Piece</th><th>Value</th><th>Binary</th></tr></thead><tbody><tr><td>W_PAWN</td><td>1</td><td>0001</td></tr><tr><td>W_KING</td><td>6</td><td>0110</td></tr><tr><td>B_PAWN</td><td>9</td><td>1001</td></tr><tr><td>B_KING</td><td>14</td><td>1110</td></tr></tbody></table><p>Key observations:</p><ul><li>White pieces occupy values <strong>1–6</strong></li><li>Black pieces occupy values <strong>9–14</strong></li><li>The <strong>4th bit</strong> distinguishes color</li></ul><p>This enables a compact and efficient encoding:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Piece <span style=color:#f92672>=</span> (Color <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>|</span> PieceType
</span></span></code></pre></div><h3 id=extracting-type-and-color>Extracting Type and Color<a hidden class=anchor aria-hidden=true href=#extracting-type-and-color>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> PieceType <span style=color:#a6e22e>type_of</span>(Piece pc) { <span style=color:#66d9ef>return</span> PieceType(pc <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Color <span style=color:#a6e22e>color_of</span>(Piece pc)    { <span style=color:#66d9ef>return</span> Color(pc <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>); }
</span></span></code></pre></div><ul><li><code>pc & 7</code> strips color → piece type</li><li><code>pc >> 3</code> extracts color</li></ul><h3 id=flipping-color>Flipping Color<a hidden class=anchor aria-hidden=true href=#flipping-color>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#f92672>~</span>pc <span style=color:#f92672>==</span> pc <span style=color:#f92672>^</span> <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>Toggles the color bit while keeping the piece type unchanged.</p><h3 id=piece_nb><code>PIECE_NB</code><a hidden class=anchor aria-hidden=true href=#piece_nb>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>PIECE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>Used for array sizing and indexing. It is <strong>not</strong> the number of actual chess pieces, but the size of the encoding space.</p><hr><h2 id=piecetype-color-independent-identity>PieceType: Color-Independent Identity<a hidden class=anchor aria-hidden=true href=#piecetype-color-independent-identity>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>PieceType</span> {
</span></span><span style=display:flex><span>  NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
</span></span><span style=display:flex><span>  ALL_PIECES <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  PIECE_TYPE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=purpose>Purpose<a hidden class=anchor aria-hidden=true href=#purpose>#</a></h3><ul><li><p>Represents <strong>kind of piece</strong>, independent of color</p></li><li><p>Used for:</p><ul><li>Move generation</li><li>Attack generation</li><li>Evaluation</li><li>Bitboard indexing</li></ul></li></ul><p>This enum deliberately excludes color, which is handled separately.</p><p>The encoding aligns perfectly with <code>Piece</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Piece <span style=color:#f92672>=</span> (Color <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>|</span> PieceType
</span></span></code></pre></div><h3 id=special-values>Special Values<a hidden class=anchor aria-hidden=true href=#special-values>#</a></h3><ul><li><code>ALL_PIECES = 0</code>
Used as a generic index when aggregating attacks.</li><li><code>PIECE_TYPE_NB = 8</code>
Total number of piece types including sentinel values.</li></ul><hr><h2 id=square-representation>Square Representation<a hidden class=anchor aria-hidden=true href=#square-representation>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Square</span> {
</span></span><span style=display:flex><span>  SQ_A1, SQ_B1, ..., SQ_H8,
</span></span><span style=display:flex><span>  SQ_NONE,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  SQUARE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  NORTH <span style=color:#f92672>=</span>  <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>  EAST  <span style=color:#f92672>=</span>  <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  SOUTH <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>  WEST  <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  NORTH_EAST <span style=color:#f92672>=</span> NORTH <span style=color:#f92672>+</span> EAST,
</span></span><span style=display:flex><span>  SOUTH_EAST <span style=color:#f92672>=</span> SOUTH <span style=color:#f92672>+</span> EAST,
</span></span><span style=display:flex><span>  SOUTH_WEST <span style=color:#f92672>=</span> SOUTH <span style=color:#f92672>+</span> WEST,
</span></span><span style=display:flex><span>  NORTH_WEST <span style=color:#f92672>=</span> NORTH <span style=color:#f92672>+</span> WEST
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=numeric-layout>Numeric Layout<a hidden class=anchor aria-hidden=true href=#numeric-layout>#</a></h3><p>Squares are encoded in <strong>rank-major order</strong>:</p><pre tabindex=0><code>A1 = 0   B1 = 1   ... H1 = 7
A2 = 8   B2 = 9   ... H2 = 15
...
A8 = 56  B8 = 57  ... H8 = 63
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span>(SQ_E4) <span style=color:#f92672>==</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>28</span>
</span></span></code></pre></div><h3 id=why-this-layout>Why This Layout?<a hidden class=anchor aria-hidden=true href=#why-this-layout>#</a></h3><ul><li>Files increment by <code>+1</code></li><li>Ranks increment by <code>+8</code></li><li>Board geometry becomes simple integer arithmetic</li></ul><hr><h2 id=directions-as-integer-offsets>Directions as Integer Offsets<a hidden class=anchor aria-hidden=true href=#directions-as-integer-offsets>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>NORTH <span style=color:#f92672>=</span>  <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>EAST  <span style=color:#f92672>=</span>  <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>SOUTH <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>WEST  <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>This allows simple move computation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SQ_E2 <span style=color:#f92672>+</span> NORTH        <span style=color:#f92672>==</span> SQ_E3
</span></span><span style=display:flex><span>SQ_E2 <span style=color:#f92672>+</span> NORTH_EAST   <span style=color:#f92672>==</span> SQ_F3
</span></span></code></pre></div><p>Diagonal directions are composed, not duplicated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>NORTH_EAST <span style=color:#f92672>=</span> NORTH <span style=color:#f92672>+</span> EAST
</span></span></code></pre></div><hr><h2 id=file-and-rank-enums>File and Rank Enums<a hidden class=anchor aria-hidden=true href=#file-and-rank-enums>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>File</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> { FILE_A, FILE_B, ..., FILE_H, FILE_NB };
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Rank</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> { RANK_1, RANK_2, ..., RANK_8, RANK_NB };
</span></span></code></pre></div><p>These are <strong>semantic types</strong>, not just integers.</p><p>They improve:</p><ul><li>Readability</li><li>Type safety</li><li>Template specialization</li></ul><p>Extraction helpers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> File <span style=color:#a6e22e>file_of</span>(Square s) { <span style=color:#66d9ef>return</span> File(s <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>7</span>); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> Rank <span style=color:#a6e22e>rank_of</span>(Square s) { <span style=color:#66d9ef>return</span> Rank(s <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>); }
</span></span></code></pre></div><p>Construction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Square <span style=color:#a6e22e>make_square</span>(File f, Rank r) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Square((r <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>+</span> f);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Everything reduces to:</p><pre tabindex=0><code>square = rank * 8 + file
</code></pre><hr><h2 id=color-relative-squares>Color-Relative Squares<a hidden class=anchor aria-hidden=true href=#color-relative-squares>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Square <span style=color:#a6e22e>relative_square</span>(Color c, Square s) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Square(s <span style=color:#f92672>^</span> (c <span style=color:#f92672>*</span> <span style=color:#ae81ff>56</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>For <strong>WHITE (c = 0)</strong>: square unchanged</li><li>For <strong>BLACK (c = 1)</strong>: square vertically flipped</li></ul><p>Why <code>56</code>?</p><pre tabindex=0><code>56 = 7 * 8 = A8
</code></pre><p>Examples:</p><pre tabindex=0><code>A1 ^ 56 = A8
C1 ^ 56 = C8
</code></pre><p>This allows writing <strong>color-independent evaluation logic</strong>.</p><hr><h2 id=castling-representation>Castling Representation<a hidden class=anchor aria-hidden=true href=#castling-representation>#</a></h2><h3 id=castlingside>CastlingSide<a hidden class=anchor aria-hidden=true href=#castlingside>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CastlingSide</span> {
</span></span><span style=display:flex><span>  KING_SIDE,
</span></span><span style=display:flex><span>  QUEEN_SIDE,
</span></span><span style=display:flex><span>  CASTLING_SIDE_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>Simple selector enum</li><li>Not a bitmask</li><li>Used in templates and branching logic</li></ul><hr><h3 id=castlingright-bitmask-encoding>CastlingRight: Bitmask Encoding<a hidden class=anchor aria-hidden=true href=#castlingright-bitmask-encoding>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CastlingRight</span> {
</span></span><span style=display:flex><span>  NO_CASTLING,
</span></span><span style=display:flex><span>  WHITE_OO,
</span></span><span style=display:flex><span>  WHITE_OOO <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  BLACK_OO  <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>  BLACK_OOO <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>  ANY_CASTLING <span style=color:#f92672>=</span> WHITE_OO <span style=color:#f92672>|</span> WHITE_OOO <span style=color:#f92672>|</span> BLACK_OO <span style=color:#f92672>|</span> BLACK_OOO,
</span></span><span style=display:flex><span>  CASTLING_RIGHT_NB <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=numeric-values>Numeric Values<a hidden class=anchor aria-hidden=true href=#numeric-values>#</a></h3><pre tabindex=0><code>WHITE_OO    = 1  // 0001
WHITE_OOO   = 2  // 0010
BLACK_OO    = 4  // 0100
BLACK_OOO   = 8  // 1000
</code></pre><h3 id=why-bitmasks>Why Bitmasks?<a hidden class=anchor aria-hidden=true href=#why-bitmasks>#</a></h3><p>Castling rights are <strong>independent flags</strong>:</p><ul><li><p>A position may have:</p><ul><li>Only king-side rights</li><li>Only queen-side rights</li><li>Both</li><li>None</li></ul></li></ul><p>Bitmasks allow all combinations efficiently:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>WHITE_OO <span style=color:#f92672>|</span> WHITE_OOO   <span style=color:#75715e>// White can castle both sides
</span></span></span><span style=display:flex><span>BLACK_OO <span style=color:#f92672>|</span> BLACK_OOO   <span style=color:#75715e>// Black can castle both sides
</span></span></span><span style=display:flex><span>WHITE_OO <span style=color:#f92672>|</span> BLACK_OO    <span style=color:#75715e>// Both can castle king-side
</span></span></span><span style=display:flex><span>ANY_CASTLING           <span style=color:#75715e>// All rights available
</span></span></span></code></pre></div><h2 id=score-middlegame-and-endgame-packed-together>Score: Middlegame and Endgame Packed Together<a hidden class=anchor aria-hidden=true href=#score-middlegame-and-endgame-packed-together>#</a></h2><p>Stockfish does not evaluate a position with a single number. Instead, it evaluates <strong>two positions in parallel</strong>:</p><ul><li><strong>Middlegame (MG) score</strong></li><li><strong>Endgame (EG) score</strong></li></ul><p>These two values are packed into a single 32-bit integer called <code>Score</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// Score enum stores a middlegame and an endgame value in a single integer
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// The upper 16 bits store the middlegame value
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// The lower 16 bits store the endgame value
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Score</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> { SCORE_ZERO };
</span></span></code></pre></div><h3 id=bit-layout>Bit Layout<a hidden class=anchor aria-hidden=true href=#bit-layout>#</a></h3><pre tabindex=0><code>32-bit Score integer

|  MG (signed 16 bits) |  EG (signed 16 bits) |
|----------------------|----------------------|
| bits 31 ........ 16 | bits 15 ........ 0  |
</code></pre><p>This allows Stockfish to accumulate middlegame and endgame evaluations <strong>simultaneously</strong>, without branching on game phase.</p><hr><h3 id=creating-a-score>Creating a Score<a hidden class=anchor aria-hidden=true href=#creating-a-score>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Score <span style=color:#a6e22e>make_score</span>(<span style=color:#66d9ef>int</span> mg, <span style=color:#66d9ef>int</span> eg) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Score((<span style=color:#66d9ef>int</span>)((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)eg <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>) <span style=color:#f92672>+</span> mg);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Conceptually:</p><pre tabindex=0><code>Score = (EG &lt;&lt; 16) | MG
</code></pre><p>The implementation uses unsigned arithmetic to avoid undefined behavior when shifting signed integers.</p><hr><h3 id=extracting-values>Extracting Values<a hidden class=anchor aria-hidden=true href=#extracting-values>#</a></h3><p><strong>Endgame value:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Value <span style=color:#a6e22e>eg_value</span>(Score s) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> { <span style=color:#66d9ef>uint16_t</span> u; <span style=color:#66d9ef>int16_t</span> s; } eg <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span>(<span style=color:#66d9ef>unsigned</span>(s <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x8000</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Value(eg.s);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Middlegame value:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>inline</span> Value <span style=color:#a6e22e>mg_value</span>(Score s) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>union</span> { <span style=color:#66d9ef>uint16_t</span> u; <span style=color:#66d9ef>int16_t</span> s; } mg <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span>(<span style=color:#66d9ef>unsigned</span>(s))
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Value(mg.s);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>These functions carefully preserve sign and avoid implementation-defined behavior in C++.</p><hr><h3 id=why-stockfish-uses-score>Why Stockfish Uses <code>Score</code><a hidden class=anchor aria-hidden=true href=#why-stockfish-uses-score>#</a></h3><p>This design enables:</p><ul><li>Continuous transition between middlegame and endgame</li><li>No runtime branching on game phase</li><li>Extremely cache-friendly evaluation</li><li>Simple accumulation of evaluation terms</li></ul><p>Throughout evaluation, Stockfish accumulates <code>Score</code> values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Score score <span style=color:#f92672>=</span> SCORE_ZERO;
</span></span><span style=display:flex><span>score <span style=color:#f92672>+=</span> MobilityBonus;
</span></span><span style=display:flex><span>score <span style=color:#f92672>+=</span> PawnStructure;
</span></span><span style=display:flex><span>score <span style=color:#f92672>+=</span> KingSafety;
</span></span></code></pre></div><p>Only at the very end is the final value computed by interpolating between MG and EG using the game phase.</p><hr><h3 id=mental-model>Mental Model<a hidden class=anchor aria-hidden=true href=#mental-model>#</a></h3><p>Think of <code>Score</code> as a <strong>2-component vector</strong>:</p><pre tabindex=0><code>Score = ⟨middlegame, endgame⟩
</code></pre><p>Evaluation is vector addition, and the final numeric score is a weighted projection based on how far the game has progressed.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/bitboard/>Bitboard</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>