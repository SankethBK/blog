<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Magic Bitboards and PEXT | Sanketh's Blog</title><meta name=keywords content="magic bitboards,pext"><meta name=description content="Magic Bitboards and PEXT
The Problem: Sliding Piece Attacks
Why Sliding Pieces Are Hard
Non-sliding pieces (knight, king, pawn):

Fixed attack pattern regardless of board state
Can pre-compute all attacks at startup
Simple lookup: StepAttacksBB[piece][square]

Sliding pieces (rook, bishop, queen):

Attack pattern depends on blocking pieces
Can&rsquo;t pre-compute all possibilities (too many combinations)

The Challenge
Rook on e4 - different scenarios:

Scenario 1: Empty board
  8  . . . . X . . .
  7  . . . . X . . .
  6  . . . . X . . .
  5  . . . . X . . .
  4  X X X X R X X X  ← Attacks entire rank and file
  3  . . . . X . . .
  2  . . . . X . . .
  1  . . . . X . . .
     a b c d e f g h

Scenario 2: Blocked by pieces
  8  . . . . . . . .
  7  . . . . . . . .
  6  . . . . X . . .
  5  . . . . X . . .
  4  . . X X R X . .  ← Blocked at c4 and f4
  3  . . . . X . . .
  2  . . . . . . . .
  1  . . . . . . . .
     a b c d e f g h
     (Pieces at: c4, e2, e6, f4)
The question: How do we efficiently compute attacks for ANY occupancy pattern?"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Magic Bitboards and PEXT"><meta property="og:description" content="Magic Bitboards and PEXT The Problem: Sliding Piece Attacks Why Sliding Pieces Are Hard Non-sliding pieces (knight, king, pawn):
Fixed attack pattern regardless of board state Can pre-compute all attacks at startup Simple lookup: StepAttacksBB[piece][square] Sliding pieces (rook, bishop, queen):
Attack pattern depends on blocking pieces Can’t pre-compute all possibilities (too many combinations) The Challenge Rook on e4 - different scenarios: Scenario 1: Empty board 8 . . . . X . . . 7 . . . . X . . . 6 . . . . X . . . 5 . . . . X . . . 4 X X X X R X X X ← Attacks entire rank and file 3 . . . . X . . . 2 . . . . X . . . 1 . . . . X . . . a b c d e f g h Scenario 2: Blocked by pieces 8 . . . . . . . . 7 . . . . . . . . 6 . . . . X . . . 5 . . . . X . . . 4 . . X X R X . . ← Blocked at c4 and f4 3 . . . . X . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h (Pieces at: c4, e2, e6, f4) The question: How do we efficiently compute attacks for ANY occupancy pattern?"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-29T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-29T00:00:00+00:00"><meta property="article:tag" content="Magic Bitboards"><meta property="article:tag" content="Pext"><meta name=twitter:card content="summary"><meta name=twitter:title content="Magic Bitboards and PEXT"><meta name=twitter:description content="Magic Bitboards and PEXT
The Problem: Sliding Piece Attacks
Why Sliding Pieces Are Hard
Non-sliding pieces (knight, king, pawn):

Fixed attack pattern regardless of board state
Can pre-compute all attacks at startup
Simple lookup: StepAttacksBB[piece][square]

Sliding pieces (rook, bishop, queen):

Attack pattern depends on blocking pieces
Can&rsquo;t pre-compute all possibilities (too many combinations)

The Challenge
Rook on e4 - different scenarios:

Scenario 1: Empty board
  8  . . . . X . . .
  7  . . . . X . . .
  6  . . . . X . . .
  5  . . . . X . . .
  4  X X X X R X X X  ← Attacks entire rank and file
  3  . . . . X . . .
  2  . . . . X . . .
  1  . . . . X . . .
     a b c d e f g h

Scenario 2: Blocked by pieces
  8  . . . . . . . .
  7  . . . . . . . .
  6  . . . . X . . .
  5  . . . . X . . .
  4  . . X X R X . .  ← Blocked at c4 and f4
  3  . . . . X . . .
  2  . . . . . . . .
  1  . . . . . . . .
     a b c d e f g h
     (Pieces at: c4, e2, e6, f4)
The question: How do we efficiently compute attacks for ANY occupancy pattern?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Magic Bitboards and PEXT","item":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Magic Bitboards and PEXT","name":"Magic Bitboards and PEXT","description":"Magic Bitboards and PEXT The Problem: Sliding Piece Attacks Why Sliding Pieces Are Hard Non-sliding pieces (knight, king, pawn):\nFixed attack pattern regardless of board state Can pre-compute all attacks at startup Simple lookup: StepAttacksBB[piece][square] Sliding pieces (rook, bishop, queen):\nAttack pattern depends on blocking pieces Can\u0026rsquo;t pre-compute all possibilities (too many combinations) The Challenge Rook on e4 - different scenarios: Scenario 1: Empty board 8 . . . . X . . . 7 . . . . X . . . 6 . . . . X . . . 5 . . . . X . . . 4 X X X X R X X X ← Attacks entire rank and file 3 . . . . X . . . 2 . . . . X . . . 1 . . . . X . . . a b c d e f g h Scenario 2: Blocked by pieces 8 . . . . . . . . 7 . . . . . . . . 6 . . . . X . . . 5 . . . . X . . . 4 . . X X R X . . ← Blocked at c4 and f4 3 . . . . X . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h (Pieces at: c4, e2, e6, f4) The question: How do we efficiently compute attacks for ANY occupancy pattern?\n","keywords":["magic bitboards","pext"],"articleBody":"Magic Bitboards and PEXT The Problem: Sliding Piece Attacks Why Sliding Pieces Are Hard Non-sliding pieces (knight, king, pawn):\nFixed attack pattern regardless of board state Can pre-compute all attacks at startup Simple lookup: StepAttacksBB[piece][square] Sliding pieces (rook, bishop, queen):\nAttack pattern depends on blocking pieces Can’t pre-compute all possibilities (too many combinations) The Challenge Rook on e4 - different scenarios: Scenario 1: Empty board 8 . . . . X . . . 7 . . . . X . . . 6 . . . . X . . . 5 . . . . X . . . 4 X X X X R X X X ← Attacks entire rank and file 3 . . . . X . . . 2 . . . . X . . . 1 . . . . X . . . a b c d e f g h Scenario 2: Blocked by pieces 8 . . . . . . . . 7 . . . . . . . . 6 . . . . X . . . 5 . . . . X . . . 4 . . X X R X . . ← Blocked at c4 and f4 3 . . . . X . . . 2 . . . . . . . . 1 . . . . . . . . a b c d e f g h (Pieces at: c4, e2, e6, f4) The question: How do we efficiently compute attacks for ANY occupancy pattern?\nNaive Solutions (Too Slow) Solution 1: Compute On-Demand Bitboard rook_attacks(Square sq, Bitboard occupied) { Bitboard attacks = 0; // North for (Square s = sq + 8; s \u003c= SQ_H8; s += 8) { attacks |= s; if (occupied \u0026 s) break; // Hit a piece, stop } // South for (Square s = sq - 8; s \u003e= SQ_A1; s -= 8) { attacks |= s; if (occupied \u0026 s) break; } // East, West (similar) ... return attacks; } Cost: 4 loops, up to 7 iterations each = ~20-30 cycles Called: Millions of times per second Too slow!\nSolution 2: Pre-compute Everything // For EACH square (64) and EACH possible occupancy pattern Bitboard RookAttacks[64][2^64]; // Store all possibilities Problem:\n64 squares × 2^64 occupancies = impossibly large (10^19 entries!) Would need exabytes of RAM The Insight: Most Bits Don’t Matter Relevant Occupancy For a rook on e4, only these squares matter:\n8 . . . . . . . . 7 . . . . X . . . ← Only e7 matters (not e8 - edge) 6 . . . . X . . . 5 . . . . X . . . 4 . X X X R X X . ← Only b4-d4 and f4-g4 (not a4, h4 - edges) 3 . . . . X . . . 2 . . . . X . . . 1 . . . . . . . . ← Only e2 matters (not e1 - edge) a b c d e f g h Relevant squares: {b4, c4, d4, f4, g4, e2, e3, e5, e6, e7} = 10 squares\nSimilarly for a rook in a1\nFor a rook on e4, only these squares matter:\n8 . . . . . . . . 7 X . . . . . . . 6 X . . . . . . . 5 X . . . . . . . 4 X . . . . . . . 3 X . . . . . . . 2 X . . . . . . . 1 R X X X X X X . a b c d e f g h Relevant squares: {a2, a3, a4, a5, a6, a7, b1, c1, d1, e1, f1, g1} = 12 squares\nWhy ignore edges?\nAttacks always stop at or go past the edge Occupancy of edge squares doesn’t change the attack pattern This is the maximum number of squares we would ever need for a rook.\nThe Next Idea: Perfect Hashing The Problem We Still Have Even with only relevant squares, we still need efficient lookup:\nRook on e4: 10 relevant squares → 2^10 = 1,024 possible occupancy patterns Rook on a1: 12 relevant squares → 2^12 = 4,096 possible occupancy patterns We could create a table like:\nBitboard RookAttacks[64][4096]; // Much better than 2^64! Output would be a bitboard containing all the squares reachable by the piece.\nLet’s take a step back and understand what is the 4096 here, its 2^12. At worst, we might need to represent 12 squares whose occupancy affects rook reachability. Since each square can be occupied or empty, we take 2^12.\nThis means the second index is an encoded way to tell which of these relevant squares are occupied by any piece (blockers),\nConcrete Example: Rook on a1 (12 relevant squares)\n8 . . . . . . . . 7 X . . . . . . . ← a7 (relevant) 6 X . . . . . . . ← a6 (relevant) 5 X . . . . . . . ← a5 (relevant) 4 X . . . . . . . ← a4 (relevant) 3 X . . . . . . . ← a3 (relevant) 2 X . . . . . . . ← a2 (relevant) 1 R X X X X X X . ← b1,c1,d1,e1,f1,g1 (relevant) a b c d e f g h Relevant squares: {a2, a3, a4, a5, a6, a7, b1, c1, d1, e1, f1, g1} = 12 squares\nAll Possible Occupancy Patterns Pattern 0: All 12 squares empty Occupancy: [0,0,0,0,0,0,0,0,0,0,0,0] → Attacks go to edges Pattern 1: Only a2 occupied Occupancy: [1,0,0,0,0,0,0,0,0,0,0,0] → Attacks blocked at a2 vertically Pattern 2: Only a3 occupied Occupancy: [0,1,0,0,0,0,0,0,0,0,0,0] → Attacks blocked at a3 vertically Pattern 3: Both a2 and a3 occupied Occupancy: [1,1,0,0,0,0,0,0,0,0,0,0] → Attacks blocked at a2 (closer blocker) … continuing through …\nPattern 4095: All 12 squares occupied Occupancy: [1,1,1,1,1,1,1,1,1,1,1,1] → Attacks only to a2 and b1 Why We Need All Combinations Each combination produces a different attack pattern:\n// Example: Different occupancies → Different attacks // Empty board Occupancy: 000000000000 → Attacks: a2-a7, b1-g1 // Piece at a4 only Occupancy: 000100000000 → Attacks: a2-a4, b1-g1 // Piece at c1 only Occupancy: 000000010000 → Attacks: a2-a7, b1-c1 // Pieces at both a4 AND c1 Occupancy: 000100010000 → Attacks: a2-a4, b1-c1 (different from either alone!) The Table Structure So we build:\n// For rook on a1 with 12 relevant squares: Bitboard RookAttacks_a1[4096]; // One entry for each occupancy pattern RookAttacks_a1[0] = attacks when all relevant squares empty RookAttacks_a1[1] = attacks when only a2 occupied RookAttacks_a1[2] = attacks when only a3 occupied RookAttacks_a1[3] = attacks when a2 and a3 occupied ... RookAttacks_a1[4095] = attacks when all 12 squares occupied But in order to generate the second index, we must encode the information of pieces present on same rank and file into a integer.\nNaive Approach A naive way of building the second index would be to loop through the corresponding file and column and set the bits, but loops defeat the whole purpose here.\nFor a rook on a1\n// Extract relevant bits manually int index = 0; if (occupied \u0026 (1ULL \u003c\u003c 1)) index |= (1 \u003c\u003c 0); // Check a2 if (occupied \u0026 (1ULL \u003c\u003c 2)) index |= (1 \u003c\u003c 1); // Check b1 if (occupied \u0026 (1ULL \u003c\u003c 3)) index |= (1 \u003c\u003c 2); // Check c1 if (occupied \u0026 (1ULL \u003c\u003c 4)) index |= (1 \u003c\u003c 3); // Check d1 if (occupied \u0026 (1ULL \u003c\u003c 5)) index |= (1 \u003c\u003c 4); // Check e1 if (occupied \u0026 (1ULL \u003c\u003c 6)) index |= (1 \u003c\u003c 5); // Check f1 if (occupied \u0026 (1ULL \u003c\u003c 8)) index |= (1 \u003c\u003c 6); // Check a3 if (occupied \u0026 (1ULL \u003c\u003c 16)) index |= (1 \u003c\u003c 7); // Check a4 // ... 12 checks total! // Finally lookup: Bitboard attacks = RookAttacks_a1[index]; Cost: 12 conditional checks, 12 bit operations = ~30-40 CPU cycles\nThe Magic Bitboard Solution The Mask In order to quickly extract only the pieces on relevant rank and file, we can use pre-computed masks.\nFor eg: for a rook on a1, the mask will be\n8 . . . . . . . . 7 1 . . . . . . . ← a7 (relevant) 6 1 . . . . . . . ← a6 (relevant) 5 1 . . . . . . . ← a5 (relevant) 4 1 . . . . . . . ← a4 (relevant) 3 1 . . . . . . . ← a3 (relevant) 2 1 . . . . . . . ← a2 (relevant) 1 0 1 1 1 1 1 1 . ← b1,c1,d1,e1,f1,g1 (relevant) a b c d e f g h In hex it can be written as\nBitboard mask = 0x0001010101010126; // Relevant squares Similarly there are 64 squares, each square will have a mask for each type of sliding piece.\nThe Mapping Problem Once we have the mask, we can extract only the pieces on relevant rank/file/diagonal by using pre-computed mask.\noccupied \u0026 mask will give us the bitboard of only relevant pieces.\nNow for rook on a1, there can be 4096 such bitboards, we need a way to map each of them uniquely to a number between 0 and 4095.\nIt doesn’t matter which scenario corresponds to what number.\nFor eg: for rook on a1 scenario:\nindex 0 could be the case where there are no blockers index 1 could be the case where there is a blocker on c1 index 2 could be the case where there is a blocker on a6, a3. … index 4095 could be the case where are blockers on d1, g1, a4, a6 We need a function which consumes occupied \u0026 mask and outputs a unique index between 0 and 4095. Since the input space is finite and bounded, ensuring collision free output space is possible.\nHow multiplication helps The key insight: A single multiplication can rearrange bits!\nWhen you multiply two numbers, bits from the multiplicand appear at different positions in the result:\nExample: x = 0b00001010 (bits at positions 1 and 3) m = 0b00000011 (magic multiplier) x * m = ? In binary multiplication: 00001010 × 00000011 ────────── 00001010 (x × 1) 00001010 (x × 2, shifted left 1) ────────── 000011110 Notice: The bits from x appeared at new positions in the result!\nMultiplication causes the relevant occupancy bits to interact and spread into the upper bits. With the right magic constant, every different occupancy produces a unique high-bit pattern.\nThe Magic Bitboard For each scenario, eg: rook on a1, we choose a seemingly random magic bitboard\nBitboard magic = 0x0080001020400080; Magic bitboards work like a hash function:\nhash(occupancy_pattern) = ((occupancy \u0026 mask) * magic) \u003e\u003e shift Requirements:\nDifferent patterns → Different indices (no collisions) Same pattern → Same index (deterministic) Index range: 0 to 2^N - 1 (where N = number of relevant squares) For our case of rook on a1, N = 12\nBitboard magic = 0x0080001020400080; hash(occupancy_pattern) = ((occupancy \u0026 mask) * magic) \u003e\u003e 52 Reason for right shifting by 52 is:\nRight shifting by 52 ensures the range is within 0 to 4095 because 2^64 / 2^52 = 2^12. After multiplication, the useful information ends up in the top bits We discard the lower noisy bits The magic mask is not randomly selected, it is carefully found via search such that it scatters the patterns so that there is no collision in the end result of 0 to 4095.\nEach square will have its own unique magic mask for each type of sliding piece.\nAt runtime, Stockfish computes rook attacks in 3 steps:\nExtract only relevant blockers: occ = occupied \u0026 mask Compress this occupancy into an index: index = (occ * magic) \u003e\u003e (64 - N) Lookup the precomputed attack bitboard: attacks = RookAttacks[square][index] The magic number is chosen offline so that all 2^N occupancies map to unique indices (no collisions).\nHow are magic numbers calculated? Magic numbers are found offline using brute force search with heuristics, and then hardcoded into Stockfish.\nThere is no known direct mathematical formula They are computed once (during development or build tooling) The engine does not search for them at runtime Stockfish just ships with a precomputed array like:\nMagic RookMagics[64]; Magic BishopMagics[64]; But the search is not purely random, there are some heuristics which help is to reduce the search space. For eg: for rook we need only higher 12 bits, so first 52 btits of mask don’t contribute anything and they can all be 0. Brute forcing 12 bit number is a solvable problem.\nCode Walkthrough 1. The Magic Bitboard Data Structures Bitboard RookMasks [SQUARE_NB]; Bitboard RookMagics [SQUARE_NB]; Bitboard* RookAttacks[SQUARE_NB]; unsigned RookShifts [SQUARE_NB]; Bitboard BishopMasks [SQUARE_NB]; Bitboard BishopMagics [SQUARE_NB]; Bitboard* BishopAttacks[SQUARE_NB]; unsigned BishopShifts [SQUARE_NB]; These arrays store the pre-computed magic bitboard data for all 64 squares, separately for rooks and bishops.\n1. RookMasks[SQUARE_NB] Type: Array of 64 bitboards Purpose: Stores the relevant occupancy mask for each square Content: For square sq, RookMasks[sq] is a bitboard with 1’s at all relevant squares (excluding edges) 2. RookMagics[SQUARE_NB] Type: Array of 64 bitboards (used as 64-bit magic numbers) Purpose: Stores the magic constant for each square Content: For square sq, RookMagics[sq] is the magic number found through search that creates a perfect hash 3. RookAttacks[SQUARE_NB] Type: Array of 64 pointers to bitboards Purpose: Each pointer points to the attack lookup table for that square Content: RookAttacks[sq] is a pointer to an array of attack bitboards The array size depends on the number of relevant bits for that square Memory layout:\n// Conceptually: RookAttacks[A1] → points to array of 4096 bitboards (2^12 for corner) RookAttacks[E4] → points to array of 1024 bitboards (2^10 for center) RookAttacks[A8] → points to array of 4096 bitboards (2^12 for corner) // etc. // Example of what RookAttacks[A1] points to: Bitboard rook_a1_table[4096] = { 0x01010101010101FE, // [0] All relevant squares empty 0x000000000000017E, // [1] Blocked by piece at a2 0x0101010101010102, // [2] Blocked by piece at a3 0x0000000000000102, // [3] Blocked by pieces at a2 and a3 // ... 4092 more entries }; RookAttacks[A1] = rook_a1_table; // Pointer assignment Usage:\nint index = (relevant_occupancy * RookMagics[sq]) \u003e\u003e shift; Bitboard attacks = RookAttacks[sq][index]; Its pointer instead of hardcoding 4096, because only corner squares need 4096, center squares need only 1024.\nSame logic is applied for bishops.\n4. RookShifts[SQUARE_NB] It stores the amount of shift required for each square as per this formula\nint index = (relevant_occupancy * RookMagics[sq]) \u003e\u003e shift; for corner square its 4096, for center its 1024, …\n2. magic_index /// attacks_bb() returns a bitboard representing all the squares attacked by a /// piece of type Pt (bishop or rook) placed on 's'. The helper magic_index() /// looks up the index using the 'magic bitboards' approach. template\u003cPieceType Pt\u003e inline unsigned magic_index(Square s, Bitboard occupied) { extern Bitboard RookMasks[SQUARE_NB]; extern Bitboard RookMagics[SQUARE_NB]; extern unsigned RookShifts[SQUARE_NB]; extern Bitboard BishopMasks[SQUARE_NB]; extern Bitboard BishopMagics[SQUARE_NB]; extern unsigned BishopShifts[SQUARE_NB]; Bitboard* const Masks = Pt == ROOK ? RookMasks : BishopMasks; Bitboard* const Magics = Pt == ROOK ? RookMagics : BishopMagics; unsigned* const Shifts = Pt == ROOK ? RookShifts : BishopShifts; if (HasPext) return unsigned(pext(occupied, Masks[s])); if (Is64Bit) return unsigned(((occupied \u0026 Masks[s]) * Magics[s]) \u003e\u003e Shifts[s]); unsigned lo = unsigned(occupied) \u0026 unsigned(Masks[s]); unsigned hi = unsigned(occupied \u003e\u003e 32) \u0026 unsigned(Masks[s] \u003e\u003e 32); return (lo * unsigned(Magics[s]) ^ hi * unsigned(Magics[s] \u003e\u003e 32)) \u003e\u003e Shifts[s]; } This is a sophisticated, optimized version of the basic magic index calculation.\nint index = (relevant_occupancy * RookMagics[sq]) \u003e\u003e shift; Template parameter Pt: Either ROOK or BISHOP\nAllows one function to work for both piece types Compiler generates two versions at compile time Step 1: Compile time branching selects the corresponding masks, magics and shifts. What’s happening:\nUses compile-time selection to pick rook or bishop arrays Masks, Magics, Shifts are pointers to the appropriate arrays Since Pt is a template parameter, this is resolved at compile time (zero runtime cost!) Step 2: Three Different Implementations The function has three code paths for different CPU capabilities:\nPath 1: PEXT Instruction (Modern CPUs) if (HasPext) return unsigned(pext(occupied, Masks[s])); PEXT (Parallel Bits Extract): A single CPU instruction (BMI2 instruction set) that does exactly what we need!\npext(source, mask) → extracts bits where mask=1, compacts them Take some bits from a number (source), but only at positions where mask has 1s, and pack them tightly into the low bits.\nIn magic bitboards, we want this:\nocc = occupied \u0026 mask; index = encode(occ); Where encode() means:\nTake the bits on relevant squares Convert them into a compact number from 0 .. 2^N - 1 That encoding step is exactly what PEXT does instantly.\nMask tells which squares matter\nExample: rook on A1 has 12 relevant blocker squares:\na2 a3 a4 a5 a6 a7 b1 c1 d1 e1 f1 g1 So the mask has 1s in those bit positions.\nWhat PEXT does\npext(occupied, mask) It does:\nLook at every bit where mask has a 1 Copy that bit from occupied Pack them into a small integer Example\nbit: 7 6 5 4 3 2 1 0 occupied = 1 0 1 1 0 1 0 1 mask = 0 1 1 0 1 0 0 0 Mask selects bits:\nbit 6 bit 5 bit 3 bit6 = 0 bit5 = 1 bit3 = 1 Now PEXT packs them into low bits:\nresult = 0b011 So\npext(occupied, mask) = 3 We can clearly see why this generates a unique number between 0 to 2^N - 1 (4096 for rook on a1). Because each mask is unique, depending on occupancy some bits of mask might be turned to 0, but the result will always be unique.\nThis entirely skips the use of magics.\nThis is the fastest method!\nPath 2: 64-bit Magic Bitboards (Standard Case) if (Is64Bit) return unsigned(((occupied \u0026 Masks[s]) * Magics[s]) \u003e\u003e Shifts[s]); This is our familiar version:\nint index = (relevant_occupancy * RookMagics[sq]) \u003e\u003e shift; When used: On 64-bit CPUs without PEXT (most common case until ~2013)\nPath 3: 32-bit Magic Bitboards (Legacy) unsigned lo = unsigned(occupied) \u0026 unsigned(Masks[s]); unsigned hi = unsigned(occupied \u003e\u003e 32) \u0026 unsigned(Masks[s] \u003e\u003e 32); return (lo * unsigned(Magics[s]) ^ hi * unsigned(Magics[s] \u003e\u003e 32)) \u003e\u003e Shifts[s]; Why this is needed: On 32-bit CPUs, multiplying two 64-bit numbers is expensive!\nThe trick: Split 64-bit numbers into two 32-bit halves\noccupied (64-bit) = [hi 32 bits | lo 32 bits] Masks[s] (64-bit) = [hi 32 bits | lo 32 bits] Step 1: Extract relevant bits in each half lo = (occupied \u0026 0xFFFFFFFF) \u0026 (Masks[s] \u0026 0xFFFFFFFF) hi = (occupied \u003e\u003e 32) \u0026 (Masks[s] \u003e\u003e 32) Step 2: Hash each half separately lo_hash = lo * (lower 32 bits of Magics[s]) hi_hash = hi * (upper 32 bits of Magics[s]) Step 3: Combine with XOR and shift index = (lo_hash ^ hi_hash) \u003e\u003e Shifts[s] Why XOR? It mixes the two 32-bit hashes into one hash value\nWhen used: On 32-bit CPUs (rare nowadays, but important for embedded systems)\nThe underlying tables are different for PEXT and magic bitboard version, so we don’t need to worry about producing same index in both versions.\nBut this also means the type of implementation is decided at compile time, a binary compiled with PEXT implementation can’t be used on 64 bit CPU without BMI2.\n3. init_magics // init_magics() computes all rook and bishop attacks at startup. Magic // bitboards are used to look up attacks of sliding pieces. As a reference see // chessprogramming.wikispaces.com/Magic+Bitboards. In particular, here we // use the so called \"fancy\" approach. void init_magics(Bitboard table[], Bitboard* attacks[], Bitboard magics[], Bitboard masks[], unsigned shifts[], Square deltas[], Fn index) { int seeds[][RANK_NB] = { { 8977, 44560, 54343, 38998, 5731, 95205, 104912, 17020 }, { 728, 10316, 55013, 32803, 12281, 15100, 16645, 255 } }; Bitboard occupancy[4096], reference[4096], edges, b; int age[4096] = {0}, current = 0, i, size; // attacks[s] is a pointer to the beginning of the attacks table for square 's' attacks[SQ_A1] = table; for (Square s = SQ_A1; s \u003c= SQ_H8; ++s) { // Board edges are not considered in the relevant occupancies edges = ((Rank1BB | Rank8BB) \u0026 ~rank_bb(s)) | ((FileABB | FileHBB) \u0026 ~file_bb(s)); // Given a square 's', the mask is the bitboard of sliding attacks from // 's' computed on an empty board. The index must be big enough to contain // all the attacks for each possible subset of the mask and so is 2 power // the number of 1s of the mask. Hence we deduce the size of the shift to // apply to the 64 or 32 bits word to get the index. masks[s] = sliding_attack(deltas, s, 0) \u0026 ~edges; shifts[s] = (Is64Bit ? 64 : 32) - popcount(masks[s]); // Use Carry-Rippler trick to enumerate all subsets of masks[s] and // store the corresponding sliding attack bitboard in reference[]. b = size = 0; do { occupancy[size] = b; reference[size] = sliding_attack(deltas, s, b); if (HasPext) attacks[s][pext(b, masks[s])] = reference[size]; size++; b = (b - masks[s]) \u0026 masks[s]; } while (b); // Set the offset for the table of the next square. We have individual // table sizes for each square with \"Fancy Magic Bitboards\". if (s \u003c SQ_H8) attacks[s + 1] = attacks[s] + size; if (HasPext) continue; PRNG rng(seeds[Is64Bit][rank_of(s)]); // Find a magic for square 's' picking up an (almost) random number // until we find the one that passes the verification test. do { do magics[s] = rng.sparse_rand\u003cBitboard\u003e(); while (popcount((magics[s] * masks[s]) \u003e\u003e 56) \u003c 6); // A good magic must map every possible occupancy to an index that // looks up the correct sliding attack in the attacks[s] database. // Note that we build up the database for square 's' as a side // effect of verifying the magic. for (++current, i = 0; i \u003c size; ++i) { unsigned idx = index(s, occupancy[i]); if (age[idx] \u003c current) { age[idx] = current; attacks[s][idx] = reference[i]; } else if (attacks[s][idx] != reference[i]) break; } } while (i \u003c size); } } Parameters:\ntable[] - Large pre-allocated array to hold all attack bitboards attacks[] - Array of 64 pointers, will point into table[] magics[] - Will be filled with magic numbers for each square masks[] - Will be filled with relevant occupancy masks shifts[] - Will be filled with shift amounts deltas[] - Movement directions (e.g., {+8, -8, +1, -1} for rook) index - Function pointer to calculate index (64-bit or 32-bit version) Called twice at startup:\ninit_magics(RookTable, RookAttacks, RookMagics, RookMasks, RookShifts, RookDeltas, magic_index\u003cROOK\u003e); init_magics(BishopTable, BishopAttacks, BishopMagics, BishopMasks, BishopShifts, BishopDeltas, magic_index\u003cBISHOP\u003e); Part 1: Random Seeds int seeds[][RANK_NB] = { { 8977, 44560, 54343, 38998, 5731, 95205, 104912, 17020 }, // 64-bit { 728, 10316, 55013, 32803, 12281, 15100, 16645, 255 } // 32-bit }; Purpose: Seeds for random number generator, one per rank Why different seeds per rank?\nSquares on different ranks have different numbers of relevant bits Different seeds help find magic numbers faster These specific values were found empirically to work well attacks[SQ_A1] = table; for (Square s = SQ_A1; s \u003c= SQ_H8; ++s) { // ... (work for square s) if (s \u003c SQ_H8) attacks[s + 1] = attacks[s] + size; } What’s happening: Building variable-sized tables in one contiguous array\ntable[] (one big array): ┌────────────────────────────────────────────────────┐ │ A1 attacks | A2 attacks | A3 attacks | ... | H8 │ │ (4096) | (2048) | (2048) | | (4096)│ └────────────────────────────────────────────────────┘ ↑ ↑ ↑ ↑ attacks[A1] attacks[A2] attacks[A3] attacks[H8] Each square gets a pointer to its portion of the table:\nattacks[A1] = \u0026table[0]; attacks[A2] = \u0026table[4096]; // A1 used 4096 entries attacks[A3] = \u0026table[4096+2048]; // A2 used 2048 entries // etc. This is the “Fancy Magic Bitboards” approach - variable-sized tables to save memory!\nPart 3: Compute Mask for Each Square for (Square s = SQ_A1; s \u003c= SQ_H8; ++s) { // Board edges are not considered in the relevant occupancies edges = ((Rank1BB | Rank8BB) \u0026 ~rank_bb(s)) | ((FileABB | FileHBB) \u0026 ~file_bb(s)); masks[s] = sliding_attack(deltas, s, 0) \u0026 ~edges; shifts[s] = (Is64Bit ? 64 : 32) - popcount(masks[s]); edges contains a bitboard where 1 means we can ignore that square for occupancy calculation. Its calculated for each square\nStep 1: Calculate edge squares to exclude // For rook on e4: edges = ((Rank1BB | Rank8BB) \u0026 ~rank_bb(E4)) // Ranks 1 and 8, but NOT rank 4 | ((FileABB | FileHBB) \u0026 ~file_bb(E4)); // Files a and h, but NOT file e // Result: edges excludes e1, e8, a4, h4 Step 2: Compute sliding attacks on empty board, then remove edges masks[s] = sliding_attack(deltas, s, 0) // Attacks on empty board \u0026 ~edges; // Remove edge squares // For rook on a1: // sliding_attack gives: a1-a8, a1-h1 (full rank and file) // Remove edges: a8, h1 // Result: {a2, a3, a4, a5, a6, a7, b1, c1, d1, e1, f1, g1} Step 3: Calculate shift amount shifts[s] = (Is64Bit ? 64 : 32) - popcount(masks[s]); // For rook on a1: 12 relevant bits // shifts[A1] = 64 - 12 = 52 (for 64-bit) Part 4: Enumerate All Occupancy Patterns (Carry-Rippler) b = size = 0; do { occupancy[size] = b; reference[size] = sliding_attack(deltas, s, b); if (HasPext) attacks[s][pext(b, masks[s])] = reference[size]; size++; b = (b - masks[s]) \u0026 masks[s]; // Carry-Rippler trick! } while (b); For this square s, generate every possible blocker configuration on the relevant squares.\nFor a rook square, you may have:\n12 relevant squares so 2¹² = 4096 possible occupancies Stockfish must generate all of them at startup:\nblocker pattern → correct attack bitboard So we need:\nfor every subset b of mask: attacks[b] = sliding_attack(...) Carry-Rippler Trick: Enumerating all subsets\nThe trick is:\nb = (b - mask) \u0026 mask; This generates all subsets of mask in a cycle.\nWhat does “subset” mean?\nIf:\nmask = 0b10110 The subset bitboards are:\n00000 00010 00100 00110 10000 10010 10100 10110 Note: how 1st and 4th bit remain 0 in all subsets. Every subset contains only bits that exist in mask.\nWhy is this called Carry-Rippler?\nBecause subtraction causes a binary carry ripple through bits.\nWhen you subtract mask, the borrow propagates through the bit pattern, flipping bits in exactly the right way to produce the next subset.\nThe Carry-Rippler Trick: Enumerates all subsets of masks[s]\nHow it works:\n// Example: mask = 0b00010110 (bits at positions 1, 2, 4) // We want to generate: 0b00000000, 0b00000010, 0b00000100, 0b00000110, // 0b00010000, 0b00010010, 0b00010100, 0b00010110 b = 0; Iteration 0: b = 0b00000000 // Subset: {} Iteration 1: b = 0b00000010 // Subset: {1} Iteration 2: b = 0b00000100 // Subset: {2} Iteration 3: b = 0b00000110 // Subset: {1, 2} Iteration 4: b = 0b00010000 // Subset: {4} Iteration 5: b = 0b00010010 // Subset: {1, 4} Iteration 6: b = 0b00010100 // Subset: {2, 4} Iteration 7: b = 0b00010110 // Subset: {1, 2, 4} Iteration 8: b = 0b00000000 // Wraps around, exit Why b = (b - masks[s]) \u0026 masks[s] works:\nSubtracting flips bits in a clever way AND with mask keeps only relevant bits Magically iterates through all 2^N subsets! If PEXT available: Fill table immediately\nif (HasPext) attacks[s][pext(b, masks[s])] = reference[size]; // PEXT gives us the index directly, so populate table now Part 5: Find Magic Numbers (The Hard Part!) if (HasPext) continue; // Skip magic finding if we have PEXT PRNG rng(seeds[Is64Bit][rank_of(s)]); do { // Generate random magic candidate do magics[s] = rng.sparse_rand\u003cBitboard\u003e(); while (popcount((magics[s] * masks[s]) \u003e\u003e 56) \u003c 6); // Test if this magic works for (++current, i = 0; i \u003c size; ++i) { unsigned idx = index(s, occupancy[i]); if (age[idx] \u003c current) { age[idx] = current; attacks[s][idx] = reference[i]; } else if (attacks[s][idx] != reference[i]) break; // Collision! Try next magic } } while (i \u003c size); Step 5a: Generate Magic Candidate\ndo magics[s] = rng.sparse_rand\u003cBitboard\u003e(); while (popcount((magics[s] * masks[s]) \u003e\u003e 56) \u003c 6); sparse_rand(): Generates numbers with few bits set (sparse bitboards)\nMagic numbers work better when sparse Fewer bits = less chance of unwanted carries Filter: popcount((magics[s] * masks[s]) \u003e\u003e 56) \u003c 6\nQuick rejection test Multiplying magic by mask should produce at least 6 bits in top byte If not enough bits at top, magic won’t spread occupancy well Step 5b: Test the Magic\nfor (++current, i = 0; i \u003c size; ++i) { unsigned idx = index(s, occupancy[i]); if (age[idx] \u003c current) { age[idx] = current; attacks[s][idx] = reference[i]; } else if (attacks[s][idx] != reference[i]) break; // Collision! } The age[] array trick: Detects collisions efficiently\nint age[4096] = {0}; // Tracks which \"attempt\" last wrote to each index int current = 0; // Current attempt number // For each new magic candidate: ++current; // New attempt number for each occupancy pattern i: idx = hash(occupancy[i]) using candidate magic if (age[idx] \u003c current): // This index hasn't been used in this attempt yet age[idx] = current; attacks[s][idx] = reference[i]; // Store the correct attacks else: // This index was already used in this attempt! if (attacks[s][idx] != reference[i]): // COLLISION! Different occupancies map to same index // but have different attacks break; // Reject this magic Why this works:\nIf two occupancies hash to the same index but have the same attacks, it’s OK (constructive collision) If they have different attacks, the magic is invalid (destructive collision) age[] lets us detect this without clearing the array each attempt ","wordCount":"4931","inLanguage":"en","datePublished":"2026-01-29T00:00:00Z","dateModified":"2026-01-29T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/chess_engine/2026-01-29-magic-bitboards-and-pext/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Magic Bitboards and PEXT</h1><div class=post-meta><span title='2026-01-29 00:00:00 +0000 UTC'>January 29, 2026</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/chess_engine/2026-01-29-magic-bitboards-and-pext.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#magic-bitboards-and-pext aria-label="Magic Bitboards and PEXT">Magic Bitboards and PEXT</a><ul><li><a href=#the-problem-sliding-piece-attacks aria-label="The Problem: Sliding Piece Attacks">The Problem: Sliding Piece Attacks</a><ul><li><a href=#why-sliding-pieces-are-hard aria-label="Why Sliding Pieces Are Hard">Why Sliding Pieces Are Hard</a></li><li><a href=#the-challenge aria-label="The Challenge">The Challenge</a></li></ul></li><li><a href=#naive-solutions-too-slow aria-label="Naive Solutions (Too Slow)">Naive Solutions (Too Slow)</a><ul><li><a href=#solution-1-compute-on-demand aria-label="Solution 1: Compute On-Demand">Solution 1: Compute On-Demand</a></li><li><a href=#solution-2-pre-compute-everything aria-label="Solution 2: Pre-compute Everything">Solution 2: Pre-compute Everything</a></li></ul></li><li><a href=#the-insight-most-bits-dont-matter aria-label="The Insight: Most Bits Don&rsquo;t Matter">The Insight: Most Bits Don&rsquo;t Matter</a><ul><li><a href=#relevant-occupancy aria-label="Relevant Occupancy">Relevant Occupancy</a></li></ul></li><li><a href=#the-next-idea-perfect-hashing aria-label="The Next Idea: Perfect Hashing">The Next Idea: Perfect Hashing</a><ul><li><a href=#the-problem-we-still-have aria-label="The Problem We Still Have">The Problem We Still Have</a><ul><li><a href=#all-possible-occupancy-patterns aria-label="All Possible Occupancy Patterns">All Possible Occupancy Patterns</a></li><li><a href=#why-we-need-all-combinations aria-label="Why We Need All Combinations">Why We Need All Combinations</a></li><li><a href=#the-table-structure aria-label="The Table Structure">The Table Structure</a></li></ul></li><li><a href=#naive-approach aria-label="Naive Approach">Naive Approach</a></li></ul></li><li><a href=#the-magic-bitboard-solution aria-label="The Magic Bitboard Solution">The Magic Bitboard Solution</a><ul><li><a href=#the-mask aria-label="The Mask">The Mask</a></li><li><a href=#the-mapping-problem aria-label="The Mapping Problem">The Mapping Problem</a></li><li><a href=#how-multiplication-helps aria-label="How multiplication helps">How multiplication helps</a></li><li><a href=#the-magic-bitboard aria-label="The Magic Bitboard">The Magic Bitboard</a><ul><li><a href=#how-are-magic-numbers-calculated aria-label="How are magic numbers calculated?">How are magic numbers calculated?</a></li></ul></li><li><a href=#code-walkthrough aria-label="Code Walkthrough">Code Walkthrough</a><ul><li><a href=#1-the-magic-bitboard-data-structures aria-label="1. The Magic Bitboard Data Structures">1. The Magic Bitboard Data Structures</a><ul><li><a href=#1-rookmaskssquare_nb aria-label="1. RookMasks[SQUARE_NB]">1. RookMasks[SQUARE_NB]</a></li><li><a href=#2-rookmagicssquare_nb aria-label="2. RookMagics[SQUARE_NB]">2. RookMagics[SQUARE_NB]</a></li><li><a href=#3-rookattackssquare_nb aria-label="3. RookAttacks[SQUARE_NB]">3. RookAttacks[SQUARE_NB]</a></li><li><a href=#4-rookshiftssquare_nb aria-label="4. RookShifts[SQUARE_NB]">4. RookShifts[SQUARE_NB]</a></li></ul></li><li><a href=#2-magic_index aria-label="2. magic_index">2. magic_index</a><ul><li><a href=#step-1-compile-time-branching-selects-the-corresponding-masks-magics-and-shifts aria-label="Step 1: Compile time branching selects the corresponding masks, magics and shifts.">Step 1: Compile time branching selects the corresponding masks, magics and shifts.</a></li><li><a href=#step-2-three-different-implementations aria-label="Step 2: Three Different Implementations">Step 2: Three Different Implementations</a><ul><li><a href=#path-1-pext-instruction-modern-cpus aria-label="Path 1: PEXT Instruction (Modern CPUs)">Path 1: PEXT Instruction (Modern CPUs)</a></li><li><a href=#path-2-64-bit-magic-bitboards-standard-case aria-label="Path 2: 64-bit Magic Bitboards (Standard Case)">Path 2: 64-bit Magic Bitboards (Standard Case)</a></li><li><a href=#path-3-32-bit-magic-bitboards-legacy aria-label="Path 3: 32-bit Magic Bitboards (Legacy)">Path 3: 32-bit Magic Bitboards (Legacy)</a></li></ul></li></ul></li><li><a href=#3-init_magics aria-label="3. init_magics">3. init_magics</a><ul><li><a href=#part-1-random-seeds aria-label="Part 1: Random Seeds">Part 1: Random Seeds</a></li><li><a href=#part-3-compute-mask-for-each-square aria-label="Part 3: Compute Mask for Each Square">Part 3: Compute Mask for Each Square</a><ul><li><a href=#step-1-calculate-edge-squares-to-exclude aria-label="Step 1: Calculate edge squares to exclude">Step 1: Calculate edge squares to exclude</a></li><li><a href=#step-2-compute-sliding-attacks-on-empty-board-then-remove-edges aria-label="Step 2: Compute sliding attacks on empty board, then remove edges">Step 2: Compute sliding attacks on empty board, then remove edges</a></li><li><a href=#step-3-calculate-shift-amount aria-label="Step 3: Calculate shift amount">Step 3: Calculate shift amount</a></li></ul></li><li><a href=#part-4-enumerate-all-occupancy-patterns-carry-rippler aria-label="Part 4: Enumerate All Occupancy Patterns (Carry-Rippler)">Part 4: Enumerate All Occupancy Patterns (Carry-Rippler)</a></li><li><a href=#part-5-find-magic-numbers-the-hard-part aria-label="Part 5: Find Magic Numbers (The Hard Part!)">Part 5: Find Magic Numbers (The Hard Part!)</a></li></ul></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=magic-bitboards-and-pext>Magic Bitboards and PEXT<a hidden class=anchor aria-hidden=true href=#magic-bitboards-and-pext>#</a></h1><h2 id=the-problem-sliding-piece-attacks>The Problem: Sliding Piece Attacks<a hidden class=anchor aria-hidden=true href=#the-problem-sliding-piece-attacks>#</a></h2><h3 id=why-sliding-pieces-are-hard>Why Sliding Pieces Are Hard<a hidden class=anchor aria-hidden=true href=#why-sliding-pieces-are-hard>#</a></h3><p><strong>Non-sliding pieces (knight, king, pawn):</strong></p><ul><li>Fixed attack pattern regardless of board state</li><li>Can pre-compute all attacks at startup</li><li>Simple lookup: <code>StepAttacksBB[piece][square]</code></li></ul><p><strong>Sliding pieces (rook, bishop, queen):</strong></p><ul><li>Attack pattern depends on blocking pieces</li><li>Can&rsquo;t pre-compute all possibilities (too many combinations)</li></ul><h3 id=the-challenge>The Challenge<a hidden class=anchor aria-hidden=true href=#the-challenge>#</a></h3><pre tabindex=0><code>Rook on e4 - different scenarios:

Scenario 1: Empty board
  8  . . . . X . . .
  7  . . . . X . . .
  6  . . . . X . . .
  5  . . . . X . . .
  4  X X X X R X X X  ← Attacks entire rank and file
  3  . . . . X . . .
  2  . . . . X . . .
  1  . . . . X . . .
     a b c d e f g h

Scenario 2: Blocked by pieces
  8  . . . . . . . .
  7  . . . . . . . .
  6  . . . . X . . .
  5  . . . . X . . .
  4  . . X X R X . .  ← Blocked at c4 and f4
  3  . . . . X . . .
  2  . . . . . . . .
  1  . . . . . . . .
     a b c d e f g h
     (Pieces at: c4, e2, e6, f4)
</code></pre><p>The question: How do we efficiently compute attacks for ANY occupancy pattern?</p><h2 id=naive-solutions-too-slow>Naive Solutions (Too Slow)<a hidden class=anchor aria-hidden=true href=#naive-solutions-too-slow>#</a></h2><h3 id=solution-1-compute-on-demand>Solution 1: Compute On-Demand<a hidden class=anchor aria-hidden=true href=#solution-1-compute-on-demand>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard <span style=color:#a6e22e>rook_attacks</span>(Square sq, Bitboard occupied) {
</span></span><span style=display:flex><span>    Bitboard attacks <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// North
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Square s <span style=color:#f92672>=</span> sq <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>; s <span style=color:#f92672>&lt;=</span> SQ_H8; s <span style=color:#f92672>+=</span> <span style=color:#ae81ff>8</span>) {
</span></span><span style=display:flex><span>        attacks <span style=color:#f92672>|=</span> s;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> s) <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// Hit a piece, stop
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// South
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Square s <span style=color:#f92672>=</span> sq <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>; s <span style=color:#f92672>&gt;=</span> SQ_A1; s <span style=color:#f92672>-=</span> <span style=color:#ae81ff>8</span>) {
</span></span><span style=display:flex><span>        attacks <span style=color:#f92672>|=</span> s;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> s) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// East, West (similar)
</span></span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> attacks;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Cost: 4 loops, up to 7 iterations each = ~20-30 cycles
Called: Millions of times per second
Too slow!</p><h3 id=solution-2-pre-compute-everything>Solution 2: Pre-compute Everything<a hidden class=anchor aria-hidden=true href=#solution-2-pre-compute-everything>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// For EACH square (64) and EACH possible occupancy pattern
</span></span></span><span style=display:flex><span>Bitboard RookAttacks[<span style=color:#ae81ff>64</span>][<span style=color:#ae81ff>2</span><span style=color:#f92672>^</span><span style=color:#ae81ff>64</span>];  <span style=color:#75715e>// Store all possibilities
</span></span></span></code></pre></div><p><strong>Problem:</strong></p><ul><li>64 squares × 2^64 occupancies = impossibly large (10^19 entries!)</li><li>Would need exabytes of RAM</li></ul><h2 id=the-insight-most-bits-dont-matter>The Insight: Most Bits Don&rsquo;t Matter<a hidden class=anchor aria-hidden=true href=#the-insight-most-bits-dont-matter>#</a></h2><h3 id=relevant-occupancy>Relevant Occupancy<a hidden class=anchor aria-hidden=true href=#relevant-occupancy>#</a></h3><p>For a rook on e4, <strong>only these squares matter</strong>:</p><pre tabindex=0><code>  8  . . . . . . . .
  7  . . . . X . . .  ← Only e7 matters (not e8 - edge)
  6  . . . . X . . .
  5  . . . . X . . .
  4  . X X X R X X .  ← Only b4-d4 and f4-g4 (not a4, h4 - edges)
  3  . . . . X . . .
  2  . . . . X . . .
  1  . . . . . . . .  ← Only e2 matters (not e1 - edge)
     a b c d e f g h
</code></pre><p>Relevant squares: {b4, c4, d4, f4, g4, e2, e3, e5, e6, e7}
= 10 squares</p><p>Similarly for a rook in a1</p><p>For a rook on e4, <strong>only these squares matter</strong>:</p><pre tabindex=0><code>  8  . . . . . . . .
  7  X . . . . . . . 
  6  X . . . . . . .
  5  X . . . . . . .
  4  X . . . . . . .  
  3  X . . . . . . .
  2  X . . . . . . .
  1  R X X X X X X .  
     a b c d e f g h
</code></pre><p>Relevant squares: {a2, a3, a4, a5, a6, a7, b1, c1, d1, e1, f1, g1}
= 12 squares</p><p><strong>Why ignore edges?</strong></p><ul><li>Attacks always <strong>stop at</strong> or <strong>go past</strong> the edge</li><li>Occupancy of edge squares doesn&rsquo;t change the attack pattern</li></ul><p>This is the maximum number of squares we would ever need for a rook.</p><h2 id=the-next-idea-perfect-hashing>The Next Idea: Perfect Hashing<a hidden class=anchor aria-hidden=true href=#the-next-idea-perfect-hashing>#</a></h2><h3 id=the-problem-we-still-have>The Problem We Still Have<a hidden class=anchor aria-hidden=true href=#the-problem-we-still-have>#</a></h3><p>Even with only relevant squares, we still need efficient lookup:</p><ul><li>Rook on e4: 10 relevant squares → 2^10 = 1,024 possible occupancy patterns</li><li>Rook on a1: 12 relevant squares → 2^12 = 4,096 possible occupancy patterns</li></ul><p>We could create a table like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard RookAttacks[<span style=color:#ae81ff>64</span>][<span style=color:#ae81ff>4096</span>];  <span style=color:#75715e>// Much better than 2^64!
</span></span></span></code></pre></div><p>Output would be a bitboard containing all the squares reachable by the piece.</p><p>Let&rsquo;s take a step back and understand what is the 4096 here, its 2^12. At worst, we might need to represent 12 squares whose occupancy affects rook reachability. Since each square can be occupied or empty, we take 2^12.</p><p>This means the second index is an encoded way to tell which of these relevant squares are occupied by any piece (blockers),</p><p><strong>Concrete Example: Rook on a1 (12 relevant squares)</strong></p><pre tabindex=0><code>  8  . . . . . . . .
  7  X . . . . . . . ← a7 (relevant)
  6  X . . . . . . . ← a6 (relevant)
  5  X . . . . . . . ← a5 (relevant)
  4  X . . . . . . . ← a4 (relevant)
  3  X . . . . . . . ← a3 (relevant)
  2  X . . . . . . . ← a2 (relevant)
  1  R X X X X X X . ← b1,c1,d1,e1,f1,g1 (relevant)
     a b c d e f g h
</code></pre><p>Relevant squares: {a2, a3, a4, a5, a6, a7, b1, c1, d1, e1, f1, g1} = 12 squares</p><h4 id=all-possible-occupancy-patterns>All Possible Occupancy Patterns<a hidden class=anchor aria-hidden=true href=#all-possible-occupancy-patterns>#</a></h4><ul><li><strong>Pattern 0:</strong> All 12 squares empty</li></ul><pre tabindex=0><code>Occupancy: [0,0,0,0,0,0,0,0,0,0,0,0] → Attacks go to edges
</code></pre><ul><li><strong>Pattern 1:</strong> Only a2 occupied</li></ul><pre tabindex=0><code>Occupancy: [1,0,0,0,0,0,0,0,0,0,0,0] → Attacks blocked at a2 vertically
</code></pre><ul><li><strong>Pattern 2:</strong> Only a3 occupied</li></ul><pre tabindex=0><code>Occupancy: [0,1,0,0,0,0,0,0,0,0,0,0] → Attacks blocked at a3 vertically
</code></pre><ul><li><strong>Pattern 3:</strong> Both a2 and a3 occupied</li></ul><pre tabindex=0><code>Occupancy: [1,1,0,0,0,0,0,0,0,0,0,0] → Attacks blocked at a2 (closer blocker)
</code></pre><p>&mldr; continuing through &mldr;</p><ul><li><strong>Pattern 4095:</strong> All 12 squares occupied</li></ul><pre tabindex=0><code>Occupancy: [1,1,1,1,1,1,1,1,1,1,1,1] → Attacks only to a2 and b1
</code></pre><h4 id=why-we-need-all-combinations>Why We Need All Combinations<a hidden class=anchor aria-hidden=true href=#why-we-need-all-combinations>#</a></h4><p>Each combination produces a different attack pattern:</p><pre tabindex=0><code>// Example: Different occupancies → Different attacks

// Empty board
Occupancy: 000000000000 → Attacks: a2-a7, b1-g1

// Piece at a4 only  
Occupancy: 000100000000 → Attacks: a2-a4, b1-g1

// Piece at c1 only
Occupancy: 000000010000 → Attacks: a2-a7, b1-c1

// Pieces at both a4 AND c1
Occupancy: 000100010000 → Attacks: a2-a4, b1-c1 (different from either alone!)
</code></pre><h4 id=the-table-structure>The Table Structure<a hidden class=anchor aria-hidden=true href=#the-table-structure>#</a></h4><p>So we build:</p><pre tabindex=0><code>// For rook on a1 with 12 relevant squares:
Bitboard RookAttacks_a1[4096];  // One entry for each occupancy pattern

RookAttacks_a1[0]    = attacks when all relevant squares empty
RookAttacks_a1[1]    = attacks when only a2 occupied
RookAttacks_a1[2]    = attacks when only a3 occupied
RookAttacks_a1[3]    = attacks when a2 and a3 occupied
...
RookAttacks_a1[4095] = attacks when all 12 squares occupied
</code></pre><p>But in order to generate the second index, we must encode the information of pieces present on same rank and file into a integer.</p><h3 id=naive-approach>Naive Approach<a hidden class=anchor aria-hidden=true href=#naive-approach>#</a></h3><p>A naive way of building the second index would be to loop through the corresponding file and column and set the bits, but loops defeat the whole purpose here.</p><p>For a rook on a1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Extract relevant bits manually
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>0</span>);   <span style=color:#75715e>// Check a2
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>);   <span style=color:#75715e>// Check b1
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>);   <span style=color:#75715e>// Check c1
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>3</span>);   <span style=color:#75715e>// Check d1
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>);   <span style=color:#75715e>// Check e1
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>5</span>);   <span style=color:#75715e>// Check f1
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>))  index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>);   <span style=color:#75715e>// Check a3
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (occupied <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1ULL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span>)) index <span style=color:#f92672>|=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>7</span>);   <span style=color:#75715e>// Check a4
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ... 12 checks total!
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Finally lookup:
</span></span></span><span style=display:flex><span>Bitboard attacks <span style=color:#f92672>=</span> RookAttacks_a1[index];
</span></span></code></pre></div><p><strong>Cost:</strong> 12 conditional checks, 12 bit operations = <strong>~30-40 CPU cycles</strong></p><h2 id=the-magic-bitboard-solution>The Magic Bitboard Solution<a hidden class=anchor aria-hidden=true href=#the-magic-bitboard-solution>#</a></h2><h3 id=the-mask>The Mask<a hidden class=anchor aria-hidden=true href=#the-mask>#</a></h3><p>In order to quickly extract only the pieces on relevant rank and file, we can use pre-computed masks.</p><p>For eg: for a rook on a1, the mask will be</p><pre tabindex=0><code>  8  . . . . . . . .
  7  1 . . . . . . . ← a7 (relevant)
  6  1 . . . . . . . ← a6 (relevant)
  5  1 . . . . . . . ← a5 (relevant)
  4  1 . . . . . . . ← a4 (relevant)
  3  1 . . . . . . . ← a3 (relevant)
  2  1 . . . . . . . ← a2 (relevant)
  1  0 1 1 1 1 1 1 . ← b1,c1,d1,e1,f1,g1 (relevant)
     a b c d e f g h
</code></pre><p>In hex it can be written as</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard mask   <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0001010101010126</span>;  <span style=color:#75715e>// Relevant squares
</span></span></span></code></pre></div><p>Similarly there are 64 squares, each square will have a mask for each type of sliding piece.</p><h3 id=the-mapping-problem>The Mapping Problem<a hidden class=anchor aria-hidden=true href=#the-mapping-problem>#</a></h3><p>Once we have the mask, we can extract only the pieces on relevant rank/file/diagonal by using pre-computed mask.</p><p><code>occupied & mask</code> will give us the bitboard of only relevant pieces.</p><p>Now for rook on a1, there can be 4096 such bitboards, we need a way to map each of them uniquely to a number between 0 and 4095.</p><p>It doesn&rsquo;t matter which scenario corresponds to what number.</p><p>For eg: for rook on a1 scenario:</p><ul><li>index 0 could be the case where there are no blockers</li><li>index 1 could be the case where there is a blocker on c1</li><li>index 2 could be the case where there is a blocker on a6, a3.</li><li>&mldr;</li><li>index 4095 could be the case where are blockers on d1, g1, a4, a6</li></ul><p>We need a function which consumes <code>occupied & mask</code> and outputs a unique index between 0 and 4095. Since the input space is finite and bounded, ensuring collision free output space is possible.</p><h3 id=how-multiplication-helps>How multiplication helps<a hidden class=anchor aria-hidden=true href=#how-multiplication-helps>#</a></h3><p>The key insight: <strong>A single multiplication can rearrange bits!</strong></p><p>When you multiply two numbers, bits from the multiplicand appear at different positions in the result:</p><pre tabindex=0><code>Example:
  x = 0b00001010  (bits at positions 1 and 3)
  m = 0b00000011  (magic multiplier)
  
  x * m = ?
  
In binary multiplication:
      00001010
    × 00000011
    ──────────
      00001010  (x × 1)
     00001010   (x × 2, shifted left 1)
    ──────────
     000011110
</code></pre><p>Notice: The bits from <code>x</code> appeared at new positions in the result!</p><p>Multiplication causes the relevant occupancy bits to interact and spread into the upper bits. With the right magic constant, every different occupancy produces a unique high-bit pattern.</p><h3 id=the-magic-bitboard>The Magic Bitboard<a hidden class=anchor aria-hidden=true href=#the-magic-bitboard>#</a></h3><p>For each scenario, eg: rook on a1, we choose a seemingly random magic bitboard</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard magic  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0080001020400080</span>;
</span></span></code></pre></div><p>Magic bitboards work like a hash function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>hash(occupancy_pattern) <span style=color:#f92672>=</span> ((occupancy <span style=color:#f92672>&amp;</span> mask) <span style=color:#f92672>*</span> magic) <span style=color:#f92672>&gt;&gt;</span> shift
</span></span></code></pre></div><p>Requirements:</p><ul><li>Different patterns → Different indices (no collisions)</li><li>Same pattern → Same index (deterministic)</li><li>Index range: 0 to 2^N - 1 (where N = number of relevant squares)</li></ul><p>For our case of rook on a1, N = 12</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard magic  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0080001020400080</span>;
</span></span><span style=display:flex><span>hash(occupancy_pattern) <span style=color:#f92672>=</span> ((occupancy <span style=color:#f92672>&amp;</span> mask) <span style=color:#f92672>*</span> magic) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>52</span>
</span></span></code></pre></div><p>Reason for right shifting by 52 is:</p><ul><li>Right shifting by 52 ensures the range is within 0 to 4095 because 2^64 / 2^52 = 2^12.</li><li>After multiplication, the useful information ends up in the top bits</li><li>We discard the lower noisy bits</li></ul><p>The magic mask is not randomly selected, it is carefully found via search such that it scatters the patterns so that there is no collision in the end result of 0 to 4095.</p><p>Each square will have its own unique magic mask for each type of sliding piece.</p><p>At runtime, Stockfish computes rook attacks in 3 steps:</p><ol><li>Extract only relevant blockers:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    occ <span style=color:#f92672>=</span> occupied <span style=color:#f92672>&amp;</span> mask
</span></span></code></pre></div><ol start=2><li>Compress this occupancy into an index:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    index <span style=color:#f92672>=</span> (occ <span style=color:#f92672>*</span> magic) <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#ae81ff>64</span> <span style=color:#f92672>-</span> N)
</span></span></code></pre></div><ol start=3><li>Lookup the precomputed attack bitboard:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>    attacks <span style=color:#f92672>=</span> RookAttacks[square][index]
</span></span></code></pre></div><p>The magic number is chosen offline so that all 2^N occupancies map to unique indices (no collisions).</p><h4 id=how-are-magic-numbers-calculated>How are magic numbers calculated?<a hidden class=anchor aria-hidden=true href=#how-are-magic-numbers-calculated>#</a></h4><p>Magic numbers are found offline using brute force search with heuristics, and then hardcoded into Stockfish.</p><ul><li>There is no known direct mathematical formula</li><li>They are computed once (during development or build tooling)</li><li>The engine does not search for them at runtime</li></ul><p>Stockfish just ships with a precomputed array like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Magic RookMagics[<span style=color:#ae81ff>64</span>];
</span></span><span style=display:flex><span>Magic BishopMagics[<span style=color:#ae81ff>64</span>];
</span></span></code></pre></div><p>But the search is not purely random, there are some heuristics which help is to reduce the search space. For eg: for rook we need only higher 12 bits, so first 52 btits of mask don&rsquo;t contribute anything and they can all be 0. Brute forcing 12 bit number is a solvable problem.</p><h3 id=code-walkthrough>Code Walkthrough<a hidden class=anchor aria-hidden=true href=#code-walkthrough>#</a></h3><h4 id=1-the-magic-bitboard-data-structures>1. The Magic Bitboard Data Structures<a hidden class=anchor aria-hidden=true href=#1-the-magic-bitboard-data-structures>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>Bitboard  RookMasks  [SQUARE_NB];
</span></span><span style=display:flex><span>Bitboard  RookMagics [SQUARE_NB];
</span></span><span style=display:flex><span>Bitboard<span style=color:#f92672>*</span> RookAttacks[SQUARE_NB];
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span>  RookShifts [SQUARE_NB];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Bitboard  BishopMasks  [SQUARE_NB];
</span></span><span style=display:flex><span>Bitboard  BishopMagics [SQUARE_NB];
</span></span><span style=display:flex><span>Bitboard<span style=color:#f92672>*</span> BishopAttacks[SQUARE_NB];
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span>  BishopShifts [SQUARE_NB];
</span></span></code></pre></div><p>These arrays store the pre-computed magic bitboard data for all 64 squares, separately for rooks and bishops.</p><h5 id=1-rookmaskssquare_nb>1. RookMasks[SQUARE_NB]<a hidden class=anchor aria-hidden=true href=#1-rookmaskssquare_nb>#</a></h5><ul><li>Type: Array of 64 bitboards</li><li>Purpose: Stores the relevant occupancy mask for each square</li><li>Content: For square sq, RookMasks[sq] is a bitboard with 1&rsquo;s at all relevant squares (excluding edges)</li></ul><h5 id=2-rookmagicssquare_nb>2. RookMagics[SQUARE_NB]<a hidden class=anchor aria-hidden=true href=#2-rookmagicssquare_nb>#</a></h5><ul><li>Type: Array of 64 bitboards (used as 64-bit magic numbers)</li><li>Purpose: Stores the magic constant for each square</li><li>Content: For square sq, RookMagics[sq] is the magic number found through search that creates a perfect hash</li></ul><h5 id=3-rookattackssquare_nb>3. RookAttacks[SQUARE_NB]<a hidden class=anchor aria-hidden=true href=#3-rookattackssquare_nb>#</a></h5><ul><li>Type: Array of 64 pointers to bitboards</li><li>Purpose: Each pointer points to the attack lookup table for that square</li><li>Content:<ul><li>RookAttacks[sq] is a pointer to an array of attack bitboards</li><li>The array size depends on the number of relevant bits for that square</li></ul></li></ul><p><strong>Memory layout:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Conceptually:
</span></span></span><span style=display:flex><span>RookAttacks[A1]  <span style=color:#960050;background-color:#1e0010>→</span> points to array of <span style=color:#ae81ff>4096</span> bitboards (<span style=color:#ae81ff>2</span><span style=color:#f92672>^</span><span style=color:#ae81ff>12</span> <span style=color:#66d9ef>for</span> corner)
</span></span><span style=display:flex><span>RookAttacks[E4]  <span style=color:#960050;background-color:#1e0010>→</span> points to array of <span style=color:#ae81ff>1024</span> bitboards (<span style=color:#ae81ff>2</span><span style=color:#f92672>^</span><span style=color:#ae81ff>10</span> <span style=color:#66d9ef>for</span> center)
</span></span><span style=display:flex><span>RookAttacks[A8]  <span style=color:#960050;background-color:#1e0010>→</span> points to array of <span style=color:#ae81ff>4096</span> bitboards (<span style=color:#ae81ff>2</span><span style=color:#f92672>^</span><span style=color:#ae81ff>12</span> <span style=color:#66d9ef>for</span> corner)
</span></span><span style=display:flex><span><span style=color:#75715e>// etc.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Example of what RookAttacks[A1] points to:
</span></span></span><span style=display:flex><span>Bitboard rook_a1_table[<span style=color:#ae81ff>4096</span>] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x01010101010101FE</span>,  <span style=color:#75715e>// [0]    All relevant squares empty
</span></span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x000000000000017E</span>,  <span style=color:#75715e>// [1]    Blocked by piece at a2
</span></span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x0101010101010102</span>,  <span style=color:#75715e>// [2]    Blocked by piece at a3
</span></span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x0000000000000102</span>,  <span style=color:#75715e>// [3]    Blocked by pieces at a2 and a3
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 4092 more entries
</span></span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RookAttacks[A1] <span style=color:#f92672>=</span> rook_a1_table;  <span style=color:#75715e>// Pointer assignment
</span></span></span></code></pre></div><p><strong>Usage:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> (relevant_occupancy <span style=color:#f92672>*</span> RookMagics[sq]) <span style=color:#f92672>&gt;&gt;</span> shift;
</span></span><span style=display:flex><span>Bitboard attacks <span style=color:#f92672>=</span> RookAttacks[sq][index];
</span></span></code></pre></div><p>Its pointer instead of hardcoding 4096, because only corner squares need 4096, center squares need only 1024.</p><p>Same logic is applied for bishops.</p><h5 id=4-rookshiftssquare_nb>4. RookShifts[SQUARE_NB]<a hidden class=anchor aria-hidden=true href=#4-rookshiftssquare_nb>#</a></h5><p>It stores the amount of shift required for each square as per this formula</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> (relevant_occupancy <span style=color:#f92672>*</span> RookMagics[sq]) <span style=color:#f92672>&gt;&gt;</span> shift;
</span></span></code></pre></div><p>for corner square its 4096, for center its 1024, &mldr;</p><h4 id=2-magic_index>2. magic_index<a hidden class=anchor aria-hidden=true href=#2-magic_index>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/// attacks_bb() returns a bitboard representing all the squares attacked by a
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// piece of type Pt (bishop or rook) placed on &#39;s&#39;. The helper magic_index()
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// looks up the index using the &#39;magic bitboards&#39; approach.
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>PieceType Pt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>unsigned</span> magic_index(Square s, Bitboard occupied) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> Bitboard RookMasks[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> Bitboard RookMagics[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>unsigned</span> RookShifts[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> Bitboard BishopMasks[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> Bitboard BishopMagics[SQUARE_NB];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extern</span> <span style=color:#66d9ef>unsigned</span> BishopShifts[SQUARE_NB];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Bitboard<span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> Masks  <span style=color:#f92672>=</span> Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>?</span> RookMasks  : BishopMasks;
</span></span><span style=display:flex><span>  Bitboard<span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> Magics <span style=color:#f92672>=</span> Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>?</span> RookMagics : BishopMagics;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span><span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> Shifts <span style=color:#f92672>=</span> Pt <span style=color:#f92672>==</span> ROOK <span style=color:#f92672>?</span> RookShifts : BishopShifts;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>unsigned</span>(pext(occupied, Masks[s]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (Is64Bit)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>unsigned</span>(((occupied <span style=color:#f92672>&amp;</span> Masks[s]) <span style=color:#f92672>*</span> Magics[s]) <span style=color:#f92672>&gt;&gt;</span> Shifts[s]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> lo <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsigned</span>(occupied) <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>unsigned</span>(Masks[s]);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> hi <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsigned</span>(occupied <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>unsigned</span>(Masks[s] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (lo <span style=color:#f92672>*</span> <span style=color:#66d9ef>unsigned</span>(Magics[s]) <span style=color:#f92672>^</span> hi <span style=color:#f92672>*</span> <span style=color:#66d9ef>unsigned</span>(Magics[s] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>)) <span style=color:#f92672>&gt;&gt;</span> Shifts[s];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a sophisticated, optimized version of the basic magic index calculation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> (relevant_occupancy <span style=color:#f92672>*</span> RookMagics[sq]) <span style=color:#f92672>&gt;&gt;</span> shift;
</span></span></code></pre></div><p>Template parameter Pt: Either ROOK or BISHOP</p><ul><li>Allows one function to work for both piece types</li><li>Compiler generates two versions at compile time</li></ul><h5 id=step-1-compile-time-branching-selects-the-corresponding-masks-magics-and-shifts>Step 1: Compile time branching selects the corresponding masks, magics and shifts.<a hidden class=anchor aria-hidden=true href=#step-1-compile-time-branching-selects-the-corresponding-masks-magics-and-shifts>#</a></h5><p>What&rsquo;s happening:</p><ul><li>Uses compile-time selection to pick rook or bishop arrays</li><li>Masks, Magics, Shifts are pointers to the appropriate arrays</li><li>Since Pt is a template parameter, this is resolved at compile time (zero runtime cost!)</li></ul><h5 id=step-2-three-different-implementations>Step 2: Three Different Implementations<a hidden class=anchor aria-hidden=true href=#step-2-three-different-implementations>#</a></h5><p>The function has three code paths for different CPU capabilities:</p><h6 id=path-1-pext-instruction-modern-cpus>Path 1: PEXT Instruction (Modern CPUs)<a hidden class=anchor aria-hidden=true href=#path-1-pext-instruction-modern-cpus>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>unsigned</span>(pext(occupied, Masks[s]));
</span></span></code></pre></div><p><strong>PEXT (Parallel Bits Extract):</strong> A single CPU instruction (BMI2 instruction set) that does <strong>exactly</strong> what we need!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pext(source, mask) <span style=color:#960050;background-color:#1e0010>→</span> extracts bits where mask<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, compacts them
</span></span></code></pre></div><blockquote><p>Take some bits from a number (source),
but only at positions where mask has 1s,
and pack them tightly into the low bits.</p></blockquote><p>In magic bitboards, we want this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>occ <span style=color:#f92672>=</span> occupied <span style=color:#f92672>&amp;</span> mask;
</span></span><span style=display:flex><span>index <span style=color:#f92672>=</span> encode(occ);
</span></span></code></pre></div><p>Where encode() means:</p><ul><li>Take the bits on relevant squares</li><li>Convert them into a compact number from 0 .. 2^N - 1</li></ul><p>That encoding step is exactly what PEXT does instantly.</p><p><strong>Mask tells which squares matter</strong></p><p>Example: rook on A1 has 12 relevant blocker squares:</p><pre tabindex=0><code>a2 a3 a4 a5 a6 a7  b1 c1 d1 e1 f1 g1
</code></pre><p>So the mask has 1s in those bit positions.</p><p><strong>What PEXT does</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pext(occupied, mask)
</span></span></code></pre></div><p>It does:</p><ol><li>Look at every bit where mask has a 1</li><li>Copy that bit from occupied</li><li>Pack them into a small integer</li></ol><p>Example</p><pre tabindex=0><code>bit:       7 6 5 4 3 2 1 0
occupied = 1 0 1 1 0 1 0 1
mask     = 0 1 1 0 1 0 0 0
</code></pre><p>Mask selects bits:</p><ul><li>bit 6</li><li>bit 5</li><li>bit 3</li></ul><pre tabindex=0><code>bit6 = 0
bit5 = 1
bit3 = 1
</code></pre><p>Now PEXT packs them into low bits:</p><pre tabindex=0><code>result = 0b011
</code></pre><p>So</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>pext(occupied, mask) <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>We can clearly see why this generates a unique number between 0 to 2^N - 1 (4096 for rook on a1). Because each mask is unique, depending on occupancy some bits of mask might be turned to 0, but the result will always be unique.</p><p>This entirely skips the use of magics.</p><p>This is the fastest method!</p><h6 id=path-2-64-bit-magic-bitboards-standard-case>Path 2: 64-bit Magic Bitboards (Standard Case)<a hidden class=anchor aria-hidden=true href=#path-2-64-bit-magic-bitboards-standard-case>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (Is64Bit)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>unsigned</span>(((occupied <span style=color:#f92672>&amp;</span> Masks[s]) <span style=color:#f92672>*</span> Magics[s]) <span style=color:#f92672>&gt;&gt;</span> Shifts[s]);
</span></span></code></pre></div><p>This is our familiar version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> (relevant_occupancy <span style=color:#f92672>*</span> RookMagics[sq]) <span style=color:#f92672>&gt;&gt;</span> shift;
</span></span></code></pre></div><p>When used: On 64-bit CPUs without PEXT (most common case until ~2013)</p><h6 id=path-3-32-bit-magic-bitboards-legacy>Path 3: 32-bit Magic Bitboards (Legacy)<a hidden class=anchor aria-hidden=true href=#path-3-32-bit-magic-bitboards-legacy>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> lo <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsigned</span>(occupied) <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>unsigned</span>(Masks[s]);
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> hi <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsigned</span>(occupied <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>unsigned</span>(Masks[s] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> (lo <span style=color:#f92672>*</span> <span style=color:#66d9ef>unsigned</span>(Magics[s]) <span style=color:#f92672>^</span> hi <span style=color:#f92672>*</span> <span style=color:#66d9ef>unsigned</span>(Magics[s] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span>)) <span style=color:#f92672>&gt;&gt;</span> Shifts[s];
</span></span></code></pre></div><p><strong>Why this is needed:</strong> On 32-bit CPUs, multiplying two 64-bit numbers is expensive!</p><p><strong>The trick:</strong> Split 64-bit numbers into two 32-bit halves</p><pre tabindex=0><code>occupied (64-bit) = [hi 32 bits | lo 32 bits]
Masks[s] (64-bit) = [hi 32 bits | lo 32 bits]

Step 1: Extract relevant bits in each half
  lo = (occupied &amp; 0xFFFFFFFF) &amp; (Masks[s] &amp; 0xFFFFFFFF)
  hi = (occupied &gt;&gt; 32) &amp; (Masks[s] &gt;&gt; 32)

Step 2: Hash each half separately
  lo_hash = lo * (lower 32 bits of Magics[s])
  hi_hash = hi * (upper 32 bits of Magics[s])

Step 3: Combine with XOR and shift
  index = (lo_hash ^ hi_hash) &gt;&gt; Shifts[s]
</code></pre><p><strong>Why XOR?</strong> It mixes the two 32-bit hashes into one hash value</p><p><strong>When used:</strong> On 32-bit CPUs (rare nowadays, but important for embedded systems)</p><p>The underlying tables are different for PEXT and magic bitboard version, so we don&rsquo;t need to worry about producing same index in both versions.</p><p>But this also means the type of implementation is decided at compile time, a binary compiled with PEXT implementation can&rsquo;t be used on 64 bit CPU without BMI2.</p><h4 id=3-init_magics>3. init_magics<a hidden class=anchor aria-hidden=true href=#3-init_magics>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span> <span style=color:#75715e>// init_magics() computes all rook and bishop attacks at startup. Magic
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// bitboards are used to look up attacks of sliding pieces. As a reference see
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// chessprogramming.wikispaces.com/Magic+Bitboards. In particular, here we
</span></span></span><span style=display:flex><span>  <span style=color:#75715e>// use the so called &#34;fancy&#34; approach.
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_magics</span>(Bitboard table[], Bitboard<span style=color:#f92672>*</span> attacks[], Bitboard magics[],
</span></span><span style=display:flex><span>                   Bitboard masks[], <span style=color:#66d9ef>unsigned</span> shifts[], Square deltas[], Fn index) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> seeds[][RANK_NB] <span style=color:#f92672>=</span> { { <span style=color:#ae81ff>8977</span>, <span style=color:#ae81ff>44560</span>, <span style=color:#ae81ff>54343</span>, <span style=color:#ae81ff>38998</span>,  <span style=color:#ae81ff>5731</span>, <span style=color:#ae81ff>95205</span>, <span style=color:#ae81ff>104912</span>, <span style=color:#ae81ff>17020</span> },
</span></span><span style=display:flex><span>                             {  <span style=color:#ae81ff>728</span>, <span style=color:#ae81ff>10316</span>, <span style=color:#ae81ff>55013</span>, <span style=color:#ae81ff>32803</span>, <span style=color:#ae81ff>12281</span>, <span style=color:#ae81ff>15100</span>,  <span style=color:#ae81ff>16645</span>,   <span style=color:#ae81ff>255</span> } };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Bitboard occupancy[<span style=color:#ae81ff>4096</span>], reference[<span style=color:#ae81ff>4096</span>], edges, b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age[<span style=color:#ae81ff>4096</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>}, current <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, i, size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// attacks[s] is a pointer to the beginning of the attacks table for square &#39;s&#39;
</span></span></span><span style=display:flex><span>    attacks[SQ_A1] <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Square s <span style=color:#f92672>=</span> SQ_A1; s <span style=color:#f92672>&lt;=</span> SQ_H8; <span style=color:#f92672>++</span>s)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Board edges are not considered in the relevant occupancies
</span></span></span><span style=display:flex><span>        edges <span style=color:#f92672>=</span> ((Rank1BB <span style=color:#f92672>|</span> Rank8BB) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>rank_bb(s)) <span style=color:#f92672>|</span> ((FileABB <span style=color:#f92672>|</span> FileHBB) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>file_bb(s));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Given a square &#39;s&#39;, the mask is the bitboard of sliding attacks from
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// &#39;s&#39; computed on an empty board. The index must be big enough to contain
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// all the attacks for each possible subset of the mask and so is 2 power
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// the number of 1s of the mask. Hence we deduce the size of the shift to
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// apply to the 64 or 32 bits word to get the index.
</span></span></span><span style=display:flex><span>        masks[s]  <span style=color:#f92672>=</span> sliding_attack(deltas, s, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>edges;
</span></span><span style=display:flex><span>        shifts[s] <span style=color:#f92672>=</span> (Is64Bit <span style=color:#f92672>?</span> <span style=color:#ae81ff>64</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>-</span> popcount(masks[s]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Use Carry-Rippler trick to enumerate all subsets of masks[s] and
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// store the corresponding sliding attack bitboard in reference[].
</span></span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            occupancy[size] <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            reference[size] <span style=color:#f92672>=</span> sliding_attack(deltas, s, b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>                attacks[s][pext(b, masks[s])] <span style=color:#f92672>=</span> reference[size];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            b <span style=color:#f92672>=</span> (b <span style=color:#f92672>-</span> masks[s]) <span style=color:#f92672>&amp;</span> masks[s];
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Set the offset for the table of the next square. We have individual
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// table sizes for each square with &#34;Fancy Magic Bitboards&#34;.
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>&lt;</span> SQ_H8)
</span></span><span style=display:flex><span>            attacks[s <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> attacks[s] <span style=color:#f92672>+</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        PRNG rng(seeds[Is64Bit][rank_of(s)]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find a magic for square &#39;s&#39; picking up an (almost) random number
</span></span></span><span style=display:flex><span>        <span style=color:#75715e>// until we find the one that passes the verification test.
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>                magics[s] <span style=color:#f92672>=</span> rng.sparse_rand<span style=color:#f92672>&lt;</span>Bitboard<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (popcount((magics[s] <span style=color:#f92672>*</span> masks[s]) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>56</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A good magic must map every possible occupancy to an index that
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// looks up the correct sliding attack in the attacks[s] database.
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// Note that we build up the database for square &#39;s&#39; as a side
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// effect of verifying the magic.
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#f92672>++</span>current, i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; <span style=color:#f92672>++</span>i)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>unsigned</span> idx <span style=color:#f92672>=</span> index(s, occupancy[i]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (age[idx] <span style=color:#f92672>&lt;</span> current)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    age[idx] <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>                    attacks[s][idx] <span style=color:#f92672>=</span> reference[i];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (attacks[s][idx] <span style=color:#f92672>!=</span> reference[i])
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> size);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><strong>Parameters:</strong></p><ul><li>table[] - Large pre-allocated array to hold all attack bitboards</li><li>attacks[] - Array of 64 pointers, will point into table[]</li><li>magics[] - Will be filled with magic numbers for each square</li><li>masks[] - Will be filled with relevant occupancy masks</li><li>shifts[] - Will be filled with shift amounts</li><li>deltas[] - Movement directions (e.g., {+8, -8, +1, -1} for rook)</li><li>index - Function pointer to calculate index (64-bit or 32-bit version)</li></ul><p>Called twice at startup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>init_magics(RookTable, RookAttacks, RookMagics, RookMasks, RookShifts, 
</span></span><span style=display:flex><span>            RookDeltas, magic_index<span style=color:#f92672>&lt;</span>ROOK<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>init_magics(BishopTable, BishopAttacks, BishopMagics, BishopMasks, BishopShifts,
</span></span><span style=display:flex><span>            BishopDeltas, magic_index<span style=color:#f92672>&lt;</span>BISHOP<span style=color:#f92672>&gt;</span>);
</span></span></code></pre></div><h5 id=part-1-random-seeds>Part 1: Random Seeds<a hidden class=anchor aria-hidden=true href=#part-1-random-seeds>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> seeds[][RANK_NB] <span style=color:#f92672>=</span> { 
</span></span><span style=display:flex><span>    { <span style=color:#ae81ff>8977</span>, <span style=color:#ae81ff>44560</span>, <span style=color:#ae81ff>54343</span>, <span style=color:#ae81ff>38998</span>,  <span style=color:#ae81ff>5731</span>, <span style=color:#ae81ff>95205</span>, <span style=color:#ae81ff>104912</span>, <span style=color:#ae81ff>17020</span> },  <span style=color:#75715e>// 64-bit
</span></span></span><span style=display:flex><span>    {  <span style=color:#ae81ff>728</span>, <span style=color:#ae81ff>10316</span>, <span style=color:#ae81ff>55013</span>, <span style=color:#ae81ff>32803</span>, <span style=color:#ae81ff>12281</span>, <span style=color:#ae81ff>15100</span>,  <span style=color:#ae81ff>16645</span>,   <span style=color:#ae81ff>255</span> }   <span style=color:#75715e>// 32-bit
</span></span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Purpose: Seeds for random number generator, one per rank
Why different seeds per rank?</p><ul><li>Squares on different ranks have different numbers of relevant bits</li><li>Different seeds help find magic numbers faster</li><li>These specific values were found empirically to work well</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks[SQ_A1] <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (Square s <span style=color:#f92672>=</span> SQ_A1; s <span style=color:#f92672>&lt;=</span> SQ_H8; <span style=color:#f92672>++</span>s) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... (work for square s)
</span></span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>&lt;</span> SQ_H8)
</span></span><span style=display:flex><span>        attacks[s <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> attacks[s] <span style=color:#f92672>+</span> size;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>What&rsquo;s happening:</strong> Building <strong>variable-sized tables</strong> in one contiguous array</p><pre tabindex=0><code>table[] (one big array):
┌────────────────────────────────────────────────────┐
│ A1 attacks | A2 attacks | A3 attacks | ... | H8    │
│ (4096)     | (2048)     | (2048)     |     | (4096)│
└────────────────────────────────────────────────────┘
 ↑            ↑            ↑                  ↑
 attacks[A1]  attacks[A2]  attacks[A3]       attacks[H8]
</code></pre><p>Each square gets a pointer to its portion of the table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>attacks[A1] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>table[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>attacks[A2] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>table[<span style=color:#ae81ff>4096</span>];      <span style=color:#75715e>// A1 used 4096 entries
</span></span></span><span style=display:flex><span>attacks[A3] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>table[<span style=color:#ae81ff>4096</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2048</span>]; <span style=color:#75715e>// A2 used 2048 entries
</span></span></span><span style=display:flex><span><span style=color:#75715e>// etc.
</span></span></span></code></pre></div><p>This is the &ldquo;Fancy Magic Bitboards&rdquo; approach - variable-sized tables to save memory!</p><h5 id=part-3-compute-mask-for-each-square>Part 3: Compute Mask for Each Square<a hidden class=anchor aria-hidden=true href=#part-3-compute-mask-for-each-square>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (Square s <span style=color:#f92672>=</span> SQ_A1; s <span style=color:#f92672>&lt;=</span> SQ_H8; <span style=color:#f92672>++</span>s)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Board edges are not considered in the relevant occupancies
</span></span></span><span style=display:flex><span>    edges <span style=color:#f92672>=</span> ((Rank1BB <span style=color:#f92672>|</span> Rank8BB) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>rank_bb(s)) <span style=color:#f92672>|</span> ((FileABB <span style=color:#f92672>|</span> FileHBB) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>file_bb(s));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    masks[s] <span style=color:#f92672>=</span> sliding_attack(deltas, s, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>edges;
</span></span><span style=display:flex><span>    shifts[s] <span style=color:#f92672>=</span> (Is64Bit <span style=color:#f92672>?</span> <span style=color:#ae81ff>64</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>-</span> popcount(masks[s]);
</span></span></code></pre></div><p><code>edges</code> contains a bitboard where 1 means we can ignore that square for occupancy calculation. Its calculated for each square</p><h6 id=step-1-calculate-edge-squares-to-exclude>Step 1: Calculate edge squares to exclude<a hidden class=anchor aria-hidden=true href=#step-1-calculate-edge-squares-to-exclude>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// For rook on e4:
</span></span></span><span style=display:flex><span>edges <span style=color:#f92672>=</span> ((Rank1BB <span style=color:#f92672>|</span> Rank8BB) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>rank_bb(E4))  <span style=color:#75715e>// Ranks 1 and 8, but NOT rank 4
</span></span></span><span style=display:flex><span>      <span style=color:#f92672>|</span> ((FileABB <span style=color:#f92672>|</span> FileHBB) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>file_bb(E4)); <span style=color:#75715e>// Files a and h, but NOT file e
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Result: edges excludes e1, e8, a4, h4
</span></span></span></code></pre></div><h6 id=step-2-compute-sliding-attacks-on-empty-board-then-remove-edges>Step 2: Compute sliding attacks on empty board, then remove edges<a hidden class=anchor aria-hidden=true href=#step-2-compute-sliding-attacks-on-empty-board-then-remove-edges>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>masks[s] <span style=color:#f92672>=</span> sliding_attack(deltas, s, <span style=color:#ae81ff>0</span>)  <span style=color:#75715e>// Attacks on empty board
</span></span></span><span style=display:flex><span>         <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>edges;                        <span style=color:#75715e>// Remove edge squares
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For rook on a1:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// sliding_attack gives: a1-a8, a1-h1 (full rank and file)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Remove edges: a8, h1
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Result: {a2, a3, a4, a5, a6, a7, b1, c1, d1, e1, f1, g1}
</span></span></span></code></pre></div><h6 id=step-3-calculate-shift-amount>Step 3: Calculate shift amount<a hidden class=anchor aria-hidden=true href=#step-3-calculate-shift-amount>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>shifts[s] <span style=color:#f92672>=</span> (Is64Bit <span style=color:#f92672>?</span> <span style=color:#ae81ff>64</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>32</span>) <span style=color:#f92672>-</span> popcount(masks[s]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For rook on a1: 12 relevant bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>// shifts[A1] = 64 - 12 = 52 (for 64-bit)
</span></span></span></code></pre></div><h5 id=part-4-enumerate-all-occupancy-patterns-carry-rippler>Part 4: Enumerate All Occupancy Patterns (Carry-Rippler)<a hidden class=anchor aria-hidden=true href=#part-4-enumerate-all-occupancy-patterns-carry-rippler>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>b <span style=color:#f92672>=</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    occupancy[size] <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    reference[size] <span style=color:#f92672>=</span> sliding_attack(deltas, s, b);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>        attacks[s][pext(b, masks[s])] <span style=color:#f92672>=</span> reference[size];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> (b <span style=color:#f92672>-</span> masks[s]) <span style=color:#f92672>&amp;</span> masks[s];  <span style=color:#75715e>// Carry-Rippler trick!
</span></span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (b);
</span></span></code></pre></div><p>For this square s, generate every possible blocker configuration on the relevant squares.</p><p>For a rook square, you may have:</p><ul><li>12 relevant squares</li><li>so 2¹² = 4096 possible occupancies</li></ul><p>Stockfish must generate all of them at startup:</p><ul><li>blocker pattern → correct attack bitboard</li></ul><p>So we need:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> every subset b of mask:
</span></span><span style=display:flex><span>    attacks[b] <span style=color:#f92672>=</span> sliding_attack(...)
</span></span></code></pre></div><p><strong>Carry-Rippler Trick: Enumerating all subsets</strong></p><p>The trick is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>b <span style=color:#f92672>=</span> (b <span style=color:#f92672>-</span> mask) <span style=color:#f92672>&amp;</span> mask;
</span></span></code></pre></div><p>This generates all subsets of mask in a cycle.</p><p>What does “subset” mean?</p><p>If:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span>mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b10110</span>
</span></span></code></pre></div><p>The subset bitboards are:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ae81ff>00000</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>00010</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>00100</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>00110</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10010</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10100</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10110</span>
</span></span></code></pre></div><p>Note: how 1st and 4th bit remain 0 in all subsets. Every subset contains only bits that exist in mask.</p><p><strong>Why is this called Carry-Rippler?</strong></p><p>Because subtraction causes a binary carry ripple through bits.</p><p>When you subtract mask, the borrow propagates through the bit pattern, flipping bits in exactly the right way to produce the next subset.</p><p>The Carry-Rippler Trick: Enumerates all subsets of masks[s]</p><p>How it works:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Example: mask = 0b00010110 (bits at positions 1, 2, 4)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// We want to generate: 0b00000000, 0b00000010, 0b00000100, 0b00000110, 
</span></span></span><span style=display:flex><span><span style=color:#75715e>//                      0b00010000, 0b00010010, 0b00010100, 0b00010110
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000000</span>  <span style=color:#75715e>// Subset: {}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000010</span>  <span style=color:#75715e>// Subset: {1}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000100</span>  <span style=color:#75715e>// Subset: {2}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000110</span>  <span style=color:#75715e>// Subset: {1, 2}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>4</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00010000</span>  <span style=color:#75715e>// Subset: {4}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>5</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00010010</span>  <span style=color:#75715e>// Subset: {1, 4}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>6</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00010100</span>  <span style=color:#75715e>// Subset: {2, 4}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00010110</span>  <span style=color:#75715e>// Subset: {1, 2, 4}
</span></span></span><span style=display:flex><span>Iteration <span style=color:#ae81ff>8</span><span style=color:#f92672>:</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000000</span>  <span style=color:#75715e>// Wraps around, exit
</span></span></span></code></pre></div><p>Why <code>b = (b - masks[s]) & masks[s]</code> works:</p><ul><li>Subtracting flips bits in a clever way</li><li>AND with mask keeps only relevant bits</li><li>Magically iterates through all 2^N subsets!</li></ul><p>If PEXT available: Fill table immediately</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>    attacks[s][pext(b, masks[s])] <span style=color:#f92672>=</span> reference[size];
</span></span><span style=display:flex><span><span style=color:#75715e>// PEXT gives us the index directly, so populate table now
</span></span></span></code></pre></div><h5 id=part-5-find-magic-numbers-the-hard-part>Part 5: Find Magic Numbers (The Hard Part!)<a hidden class=anchor aria-hidden=true href=#part-5-find-magic-numbers-the-hard-part>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (HasPext)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;  <span style=color:#75715e>// Skip magic finding if we have PEXT
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PRNG <span style=color:#a6e22e>rng</span>(seeds[Is64Bit][rank_of(s)]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Generate random magic candidate
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        magics[s] <span style=color:#f92672>=</span> rng.sparse_rand<span style=color:#f92672>&lt;</span>Bitboard<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (popcount((magics[s] <span style=color:#f92672>*</span> masks[s]) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>56</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Test if this magic works
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#f92672>++</span>current, i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> idx <span style=color:#f92672>=</span> index(s, occupancy[i]);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (age[idx] <span style=color:#f92672>&lt;</span> current) {
</span></span><span style=display:flex><span>            age[idx] <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>            attacks[s][idx] <span style=color:#f92672>=</span> reference[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (attacks[s][idx] <span style=color:#f92672>!=</span> reference[i])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// Collision! Try next magic
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> size);
</span></span></code></pre></div><p><strong>Step 5a: Generate Magic Candidate</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    magics[s] <span style=color:#f92672>=</span> rng.sparse_rand<span style=color:#f92672>&lt;</span>Bitboard<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (popcount((magics[s] <span style=color:#f92672>*</span> masks[s]) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>56</span>) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>);
</span></span></code></pre></div><p><code>sparse_rand()</code>: Generates numbers with few bits set (sparse bitboards)</p><ul><li>Magic numbers work better when sparse</li><li>Fewer bits = less chance of unwanted carries</li></ul><p>Filter: <code>popcount((magics[s] * masks[s]) >> 56) &lt; 6</code></p><ul><li>Quick rejection test</li><li>Multiplying magic by mask should produce at least 6 bits in top byte</li><li>If not enough bits at top, magic won&rsquo;t spread occupancy well</li></ul><p><strong>Step 5b: Test the Magic</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#f92672>++</span>current, i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> idx <span style=color:#f92672>=</span> index(s, occupancy[i]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (age[idx] <span style=color:#f92672>&lt;</span> current) {
</span></span><span style=display:flex><span>        age[idx] <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>        attacks[s][idx] <span style=color:#f92672>=</span> reference[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (attacks[s][idx] <span style=color:#f92672>!=</span> reference[i])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// Collision!
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>The age[]</strong> array trick: Detects collisions efficiently</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> age[<span style=color:#ae81ff>4096</span>] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};  <span style=color:#75715e>// Tracks which &#34;attempt&#34; last wrote to each index
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> current <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;       <span style=color:#75715e>// Current attempt number
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// For each new magic candidate:
</span></span></span><span style=display:flex><span><span style=color:#f92672>++</span>current;  <span style=color:#75715e>// New attempt number
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> each occupancy pattern i:
</span></span><span style=display:flex><span>    idx <span style=color:#f92672>=</span> hash(occupancy[i]) <span style=color:#66d9ef>using</span> candidate magic
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (age[idx] <span style=color:#f92672>&lt;</span> current)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This index hasn&#39;t been used in this attempt yet
</span></span></span><span style=display:flex><span>        age[idx] <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>        attacks[s][idx] <span style=color:#f92672>=</span> reference[i];  <span style=color:#75715e>// Store the correct attacks
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This index was already used in this attempt!
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (attacks[s][idx] <span style=color:#f92672>!=</span> reference[i])<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// COLLISION! Different occupancies map to same index
</span></span></span><span style=display:flex><span>            <span style=color:#75715e>// but have different attacks
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// Reject this magic
</span></span></span></code></pre></div><p>Why this works:</p><ul><li>If two occupancies hash to the same index but have the same attacks, it&rsquo;s OK (constructive collision)</li><li>If they have different attacks, the magic is invalid (destructive collision)</li><li>age[] lets us detect this without clearing the array each attempt</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/magic-bitboards/>Magic Bitboards</a></li><li><a href=https://sankethbk.github.io/blog/tags/pext/>Pext</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://www.chessprogramming.org/Traversing_Subsets_of_a_Set target=_blank rel="noopener noreferrer">Carry Rippler</a></li></ul></section></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>