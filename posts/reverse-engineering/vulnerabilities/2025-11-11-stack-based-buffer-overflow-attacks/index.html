<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stack Based Buffer Overflow Attacks | Sanketh's Blog</title><meta name=keywords content="vulnerabilities,buffer overflow,reverse engineering"><meta name=description content="Stack Based Buffer Overflow Attacks
A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C
When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Stack Based Buffer Overflow Attacks"><meta property="og:description" content="Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-11T00:00:00+00:00"><meta property="article:tag" content="Vulnerabilities"><meta property="article:tag" content="Buffer Overflow"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stack Based Buffer Overflow Attacks"><meta name=twitter:description content="Stack Based Buffer Overflow Attacks
A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C
When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Stack Based Buffer Overflow Attacks","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stack Based Buffer Overflow Attacks","name":"Stack Based Buffer Overflow Attacks","description":"Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).\nCauses of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:\n","keywords":["vulnerabilities","buffer overflow","reverse engineering"],"articleBody":"Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).\nCauses of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:\n1. C allows writing beyond (and before) array bounds Arrays in C are just raw memory. The compiler does not perform runtime checks. If you write past buf[63], C simply writes into whatever memory comes next. char buf[64]; buf[100] = 'A'; // C happily writes here → overflow No warning, no crash, memory is overwritten silently.\n2. C strings rely on null termination C treats strings as a sequence of characters until it encounters a null termination character \\0\nProblems caused by this:\nFunctions like strcpy, gets, scanf(\"%s\") keep copying until they hit a null byte — not until the buffer ends. If input lacks a null terminator early enough, it will overflow. 3. Direct pointer arithmetic C allows writing to any address you compute.\n*(buf + 80) = 'X'; Since the memory layout of a program was quite predictable before the mitigations like ASLR arrived, attackers could easily calculate which address needs to be overwritten with what value.\nWhat is Stack? Stack is a segment of memory where the process stores function context: particularly function calls and its local variables.\nBefore Stack, programmers didn’t have a definite way of doing these things:\nWhere to store function arguments Where to store local variables Where to store the return address (so CPU knows where to go back) How to make function calls nested (A → B → C → D …) How to handle recursion (function calling itself multiple times) Some of the earlier assembly languages didn’t have the concept of stack, programmers had to simulate the stack on their own on a raw block of memory. Today all the mainstream CPU’s have support for stack at the hardware level.\nWhy a stack specifically (LIFO)? Function calls behave naturally like a Last-In-First-Out structure.\nExample:\nmain calls A A calls B B calls C Order of returning:\nC returns to B B returns to A A returns to main This is literally a LIFO pattern, a stack is the perfect structure.\nStructure of a Stack Frame A stack frame is a single entry in the call stack that contains all the local variables and metadata associated with a function invocation. In a nested function call chain, each function maintains its own distinct stack frame, creating a LIFO (Last-In-First-Out) structure.\nRegister Management in x86:\nThe EBP (Base Pointer) register marks the base of the currently active stack frame The ESP (Stack Pointer) register points to the top of the stack The Reality of Function Calls:\nWhile high-level languages like C use function call syntax, the underlying assembly implementation is fundamentally different. At the assembly level, there is no native concept of “functions”—each function call is simply a jump to a different memory location containing executable instructions.\nThis creates an important challenge: since function calls are just jumps, how do the caller and callee exchange information? How are parameters passed? Where should return values be placed?\nThe Application Binary Interface (ABI):\nThe solution is the ABI—a standardized calling convention that defines the contract between caller and callee. The ABI specifies:\nHow arguments are passed (registers vs. stack) Which registers are preserved across calls Where return values are stored How the stack frame is set up and torn down Without this agreement, function calls across separately compiled code would be impossible, as each piece of code would have different expectations about parameter passing and register usage.\nLet’s take an example\nint main() { A(5); } void A(int a) { B(3); } void B(int b) { int local_var1; char local_var2; } The stack for this code when C is called will look like this:\nHigher Memory Addresses (0xFFFFFFFF) ↑ | | STACK GROWTH DIRECTION | ↓↓↓ | +------------------+ | Arguments | ← Arguments for function A (if any) | for A | +------------------+ | Return Addr | ← Where to return after A finishes (e.g., main) | to main | +------------------+ | Saved EBP | ← main's base pointer | (main's frame) | +------------------+ ← EBP when A is executing (A's frame base) | A's Local | | Variables | | - local_var1 | | - local_var2 | +------------------+ | Arguments | ← Arguments pushed for B (right to left in C) | for B | e.g., arg2, arg1 +------------------+ | Return Addr | ← Where to return in A after B finishes | to A | +------------------+ | Saved EBP | ← A's base pointer saved | (A's frame) | +------------------+ ← EBP (Current frame base - B is executing) | B's Local | | Variables | | - local_var1 | | - local_var2 | +------------------+ ← ESP (Stack pointer - top of stack) | | | (Unused | | Stack | | Space) | | | ↓ Lower Memory Addresses (0x00000000) What Happens During a Function Call Now let’s look at thx86 assembly code for what happens when a function is called\n1. Caller’s Responsibilities (Before the Jump): First, the caller must save the return address—the location where execution should resume after the function completes. Let’s see what happens when function A calls function B.\npush arguments_to_function_B (pushed in reverse order) push next_instruction_address_of_function_A (the value in EIP register) jmp address_of_function_B Sometimes the Caller can also decide to save all the values of general purpose registers to avoid losing its values from being overwritten by the caller.\n; Function A calling Function B with register preservation function_A: ; ... A's code using registers ... mov eax, 100 ; EAX has important data mov ebx, 200 ; EBX has important data mov ecx, 300 ; ECX has important data ; Prepare to call B pusha ; Push all general-purpose registers onto stack ; Order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI push arguments_to_function_B ; (pushed in reverse order) push next_instruction_address_of_function_A ; (the value in EIP register) jmp address_of_function_B popa ; Restore all registers to their original values ; Now EAX=100, EBX=200, ECX=300 again ; Continue with A's logic, registers are preserved ; ... Most of the times callee’s ABI clearly defines what register values are preserved and what can be overwritten, we can only save those registers instead.\n2. Callee’s Responsibilities (Function Prologue): Once inside the function B, we need to set up a new stack frame:\naddress_of_function_B: push ebp ; Save the old base pointer (of function A) mov ebp, esp ; Set EBP to current stack top (new frame base) sub esp, N ; Allocate space for local variables (N bytes) This sequence accomplishes three things:\nPreserves the caller’s frame pointer (old EBP) so we can restore it late Establishes a new base pointer for the current function Allocates stack space for local variables by moving ESP downward 3. Function Execution: The function body executes, with local variables accessible via offsets from EBP:\n[ebp-4] accesses the first local variable [ebp-8] accesses the second, and so on Function parameters (if pushed by caller) are at [ebp+8], [ebp+12], etc. 4. Callee’s Responsibilities (Function Epilogue): Before returning, we must tear down the stack frame and restore state:\nmov esp, ebp ; Deallocate local variables (restore ESP) pop ebp ; Restore the old base pointer ret_address = pop() ; Get return address from stack jmp ret_address ; Jump back to caller This will:\nCollapses the function B’s stack frame by resetting ESP to EBP Restores the caller’s base pointer Retrieves the return address from the stack (saved by function A) Jumps back to continue execution after the original call site Simplified Function Call with CALL/RET/LEAVE The x86 instruction set provides three specialized instructions that automate this process:\nThe CALL Instruction: call function_address This single instruction replaces:\npush next_instruction_address jmp function_address It automatically pushes the return address (address of the instruction following call) onto the stack and jumps to the target function.\nThe LEAVE Instruction: leave This single instruction replaces:\nmov esp, ebp pop ebp It efficiently collapses the stack frame and restores the old base pointer in one operation.\nThe RET Instruction: ret This single instruction replaces:\npop eip ; Pop return address into instruction pointer jmp eip ; Jump to return address Complete Example with Simplified Instructions: ; Caller side: push argument2 push argument1 call my_function ; Pushes return address and jumps add esp, 8 ; Clean up arguments (caller cleanup) ; Callee side: my_function: push ebp ; Save old frame pointer mov ebp, esp ; Set up new frame sub esp, 16 ; Allocate local variables ; ... function body ... leave ; Equivalent to: mov esp, ebp; pop ebp ret ; Pop return address and jump to it ","wordCount":"1494","inLanguage":"en","datePublished":"2025-11-11T00:00:00Z","dateModified":"2025-11-11T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stack Based Buffer Overflow Attacks</h1><div class=post-meta><span title='2025-11-11 00:00:00 +0000 UTC'>November 11, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#stack-based-buffer-overflow-attacks aria-label="Stack Based Buffer Overflow Attacks">Stack Based Buffer Overflow Attacks</a><ul><li><a href=#causes-of-buffer-overflow-attacks-in-c aria-label="Causes of Buffer Overflow Attacks in C">Causes of Buffer Overflow Attacks in C</a><ul><li><a href=#1-c-allows-writing-beyond-and-before-array-bounds aria-label="1. C allows writing beyond (and before) array bounds">1. C allows writing beyond (and before) array bounds</a></li><li><a href=#2-c-strings-rely-on-null-termination aria-label="2. C strings rely on null termination">2. C strings rely on null termination</a></li><li><a href=#3-direct-pointer-arithmetic aria-label="3. Direct pointer arithmetic">3. Direct pointer arithmetic</a></li></ul></li><li><a href=#what-is-stack aria-label="What is Stack?">What is Stack?</a><ul><li><a href=#why-a-stack-specifically-lifo aria-label="Why a stack specifically (LIFO)?">Why a stack specifically (LIFO)?</a></li><li><a href=#structure-of-a-stack-frame aria-label="Structure of a Stack Frame">Structure of a Stack Frame</a></li><li><a href=#what-happens-during-a-function-call aria-label="What Happens During a Function Call">What Happens During a Function Call</a><ul><li><a href=#1-callers-responsibilities-before-the-jump aria-label="1. Caller&rsquo;s Responsibilities (Before the Jump):">1. Caller&rsquo;s Responsibilities (Before the Jump):</a></li><li><a href=#2-callees-responsibilities-function-prologue aria-label="2. Callee&rsquo;s Responsibilities (Function Prologue):">2. Callee&rsquo;s Responsibilities (Function Prologue):</a></li><li><a href=#3-function-execution aria-label="3. Function Execution:">3. Function Execution:</a></li><li><a href=#4-callees-responsibilities-function-epilogue aria-label="4. Callee&rsquo;s Responsibilities (Function Epilogue):">4. Callee&rsquo;s Responsibilities (Function Epilogue):</a></li></ul></li><li><a href=#simplified-function-call-with-callretleave aria-label="Simplified Function Call with CALL/RET/LEAVE">Simplified Function Call with CALL/RET/LEAVE</a><ul><li><a href=#the-call-instruction aria-label="The CALL Instruction:">The CALL Instruction:</a></li><li><a href=#the-leave-instruction aria-label="The LEAVE Instruction:">The LEAVE Instruction:</a></li><li><a href=#the-ret-instruction aria-label="The RET Instruction:">The RET Instruction:</a></li><li><a href=#complete-example-with-simplified-instructions aria-label="Complete Example with Simplified Instructions:">Complete Example with Simplified Instructions:</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=stack-based-buffer-overflow-attacks>Stack Based Buffer Overflow Attacks<a hidden class=anchor aria-hidden=true href=#stack-based-buffer-overflow-attacks>#</a></h1><p>A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).</p><h2 id=causes-of-buffer-overflow-attacks-in-c>Causes of Buffer Overflow Attacks in C<a hidden class=anchor aria-hidden=true href=#causes-of-buffer-overflow-attacks-in-c>#</a></h2><p>When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:</p><h3 id=1-c-allows-writing-beyond-and-before-array-bounds>1. C allows writing beyond (and before) array bounds<a hidden class=anchor aria-hidden=true href=#1-c-allows-writing-beyond-and-before-array-bounds>#</a></h3><ul><li>Arrays in C are just raw memory.</li><li>The compiler does not perform runtime checks.</li><li>If you write past <code>buf[63]</code>, C simply writes into whatever memory comes next.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>64</span>];
</span></span><span style=display:flex><span>buf[<span style=color:#ae81ff>100</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;   <span style=color:#75715e>// C happily writes here → overflow
</span></span></span></code></pre></div><p>No warning, no crash, memory is overwritten silently.</p><h3 id=2-c-strings-rely-on-null-termination>2. C strings rely on null termination<a hidden class=anchor aria-hidden=true href=#2-c-strings-rely-on-null-termination>#</a></h3><p>C treats strings as a sequence of characters until it encounters a null termination character <code>\0</code></p><p>Problems caused by this:</p><ul><li>Functions like <code>strcpy</code>, <code>gets</code>, <code>scanf("%s")</code> keep copying until they hit a null byte — not until the buffer ends.</li><li>If input lacks a null terminator early enough, it will overflow.</li></ul><h3 id=3-direct-pointer-arithmetic>3. Direct pointer arithmetic<a hidden class=anchor aria-hidden=true href=#3-direct-pointer-arithmetic>#</a></h3><p>C allows writing to any address you compute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>(buf <span style=color:#f92672>+</span> <span style=color:#ae81ff>80</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X&#39;</span>;
</span></span></code></pre></div><p>Since the memory layout of a program was quite predictable before the mitigations like ASLR arrived, attackers could easily calculate which address needs to be overwritten with what value.</p><h2 id=what-is-stack>What is Stack?<a hidden class=anchor aria-hidden=true href=#what-is-stack>#</a></h2><p>Stack is a segment of memory where the process stores function context: particularly function calls and its local variables.</p><p>Before Stack, programmers didn&rsquo;t have a definite way of doing these things:</p><ul><li>Where to store function arguments</li><li>Where to store local variables</li><li>Where to store the return address (so CPU knows where to go back)</li><li>How to make function calls nested (A → B → C → D …)</li><li>How to handle recursion (function calling itself multiple times)</li></ul><p>Some of the earlier assembly languages didn&rsquo;t have the concept of stack, programmers had to simulate the stack on their own on a raw block of memory. Today all the mainstream CPU&rsquo;s have support for stack at the hardware level.</p><h3 id=why-a-stack-specifically-lifo>Why a stack specifically (LIFO)?<a hidden class=anchor aria-hidden=true href=#why-a-stack-specifically-lifo>#</a></h3><p>Function calls behave naturally like a Last-In-First-Out structure.</p><p>Example:</p><pre tabindex=0><code>main calls A
A calls B
B calls C
</code></pre><p>Order of returning:</p><pre tabindex=0><code>C returns to B
B returns to A
A returns to main
</code></pre><p>This is literally a LIFO pattern, a stack is the perfect structure.</p><h3 id=structure-of-a-stack-frame>Structure of a Stack Frame<a hidden class=anchor aria-hidden=true href=#structure-of-a-stack-frame>#</a></h3><p>A stack frame is a single entry in the call stack that contains all the local variables and metadata associated with a function invocation. In a nested function call chain, each function maintains its own distinct stack frame, creating a LIFO (Last-In-First-Out) structure.</p><p><strong>Register Management in x86:</strong></p><ul><li>The <strong>EBP (Base Pointer)</strong> register marks the base of the currently active stack frame</li><li>The <strong>ESP (Stack Pointer)</strong> register points to the top of the stack</li></ul><p><strong>The Reality of Function Calls:</strong></p><p>While high-level languages like C use function call syntax, the underlying assembly implementation is fundamentally different. At the assembly level, there is no native concept of &ldquo;functions&rdquo;—each function call is simply a jump to a different memory location containing executable instructions.</p><p>This creates an important challenge: since function calls are just jumps, how do the caller and callee exchange information? How are parameters passed? Where should return values be placed?</p><p><strong>The Application Binary Interface (ABI):</strong></p><p>The solution is the ABI—a standardized calling convention that defines the contract between caller and callee. The ABI specifies:</p><ul><li>How arguments are passed (registers vs. stack)</li><li>Which registers are preserved across calls</li><li>Where return values are stored</li><li>How the stack frame is set up and torn down</li></ul><p>Without this agreement, function calls across separately compiled code would be impossible, as each piece of code would have different expectations about parameter passing and register usage.</p><p>Let&rsquo;s take an example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>A</span>(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>A</span>(<span style=color:#66d9ef>int</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span>(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>B</span>(<span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> local_var1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> local_var2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The stack for this code when C is called will look like this:</p><pre tabindex=0><code>Higher Memory Addresses (0xFFFFFFFF)
↑
|
|                    STACK GROWTH DIRECTION
|                           ↓↓↓
|
+------------------+
|   Arguments      |  ← Arguments for function A (if any)
|   for A          |
+------------------+
|   Return Addr    |  ← Where to return after A finishes (e.g., main)
|   to main        |
+------------------+
|   Saved EBP      |  ← main&#39;s base pointer
|   (main&#39;s frame) |
+------------------+ ← EBP when A is executing (A&#39;s frame base)
|   A&#39;s Local      |
|   Variables      |
|   - local_var1   |
|   - local_var2   |
+------------------+
|   Arguments      |  ← Arguments pushed for B (right to left in C)
|   for B          |    e.g., arg2, arg1
+------------------+
|   Return Addr    |  ← Where to return in A after B finishes
|   to A           |
+------------------+
|   Saved EBP      |  ← A&#39;s base pointer saved
|   (A&#39;s frame)    |
+------------------+ ← EBP (Current frame base - B is executing)
|   B&#39;s Local      |
|   Variables      |
|   - local_var1   |
|   - local_var2   |
+------------------+ ← ESP (Stack pointer - top of stack)
|                  |
|   (Unused        |
|    Stack         |
|    Space)        |
|                  |
↓
Lower Memory Addresses (0x00000000)
</code></pre><h3 id=what-happens-during-a-function-call>What Happens During a Function Call<a hidden class=anchor aria-hidden=true href=#what-happens-during-a-function-call>#</a></h3><p>Now let&rsquo;s look at thx86 assembly code for what happens when a function is called</p><h4 id=1-callers-responsibilities-before-the-jump>1. Caller&rsquo;s Responsibilities (Before the Jump):<a hidden class=anchor aria-hidden=true href=#1-callers-responsibilities-before-the-jump>#</a></h4><p>First, the caller must save the return address—the location where execution should resume after the function completes. Let&rsquo;s see what happens when function A calls function B.</p><pre tabindex=0><code>push arguments_to_function_B (pushed in reverse order)
push next_instruction_address_of_function_A (the value in EIP register)
jmp address_of_function_B 
</code></pre><p>Sometimes the Caller can also decide to save all the values of general purpose registers to avoid losing its values from being overwritten by the caller.</p><pre tabindex=0><code>; Function A calling Function B with register preservation

function_A:
    ; ... A&#39;s code using registers ...
    mov eax, 100        ; EAX has important data
    mov ebx, 200        ; EBX has important data
    mov ecx, 300        ; ECX has important data
    
    ; Prepare to call B
    pusha               ; Push all general-purpose registers onto stack
                        ; Order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
    
    push arguments_to_function_B    ; (pushed in reverse order)
    push next_instruction_address_of_function_A ; (the value in EIP register)
    jmp address_of_function_B

    popa                ; Restore all registers to their original values
                        ; Now EAX=100, EBX=200, ECX=300 again
    
    ; Continue with A&#39;s logic, registers are preserved
    ; ...
</code></pre><p>Most of the times callee&rsquo;s ABI clearly defines what register values are preserved and what can be overwritten, we can only save those registers instead.</p><h4 id=2-callees-responsibilities-function-prologue>2. Callee&rsquo;s Responsibilities (Function Prologue):<a hidden class=anchor aria-hidden=true href=#2-callees-responsibilities-function-prologue>#</a></h4><p>Once inside the function B, we need to set up a new stack frame:</p><pre tabindex=0><code>address_of_function_B:
    push ebp              ; Save the old base pointer (of function A)
    mov ebp, esp          ; Set EBP to current stack top (new frame base)
    sub esp, N            ; Allocate space for local variables (N bytes)
</code></pre><p>This sequence accomplishes three things:</p><ul><li>Preserves the caller&rsquo;s frame pointer (old EBP) so we can restore it late</li><li>Establishes a new base pointer for the current function</li><li>Allocates stack space for local variables by moving ESP downward</li></ul><h4 id=3-function-execution>3. Function Execution:<a hidden class=anchor aria-hidden=true href=#3-function-execution>#</a></h4><p>The function body executes, with local variables accessible via offsets from EBP:</p><ul><li><code>[ebp-4]</code> accesses the first local variable</li><li><code>[ebp-8]</code> accesses the second, and so on</li><li>Function parameters (if pushed by caller) are at <code>[ebp+8]</code>, <code>[ebp+12]</code>, etc.</li></ul><h4 id=4-callees-responsibilities-function-epilogue>4. Callee&rsquo;s Responsibilities (Function Epilogue):<a hidden class=anchor aria-hidden=true href=#4-callees-responsibilities-function-epilogue>#</a></h4><p>Before returning, we must tear down the stack frame and restore state:</p><pre tabindex=0><code>    mov esp, ebp          ; Deallocate local variables (restore ESP)
    pop ebp               ; Restore the old base pointer
    ret_address = pop()   ; Get return address from stack
    jmp ret_address       ; Jump back to caller
</code></pre><p>This will:</p><ul><li>Collapses the function B&rsquo;s stack frame by resetting <code>ESP</code> to <code>EBP</code></li><li>Restores the caller&rsquo;s base pointer</li><li>Retrieves the return address from the stack (saved by function A)</li><li>Jumps back to continue execution after the original call site</li></ul><h3 id=simplified-function-call-with-callretleave>Simplified Function Call with CALL/RET/LEAVE<a hidden class=anchor aria-hidden=true href=#simplified-function-call-with-callretleave>#</a></h3><p>The x86 instruction set provides three specialized instructions that automate this process:</p><h4 id=the-call-instruction>The CALL Instruction:<a hidden class=anchor aria-hidden=true href=#the-call-instruction>#</a></h4><pre tabindex=0><code>call function_address
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>push next_instruction_address
jmp function_address
</code></pre><p>It automatically pushes the return address (address of the instruction following <code>call</code>) onto the stack and jumps to the target function.</p><h4 id=the-leave-instruction>The LEAVE Instruction:<a hidden class=anchor aria-hidden=true href=#the-leave-instruction>#</a></h4><pre tabindex=0><code>leave
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>mov esp, ebp
pop ebp
</code></pre><p>It efficiently collapses the stack frame and restores the old base pointer in one operation.</p><h4 id=the-ret-instruction>The RET Instruction:<a hidden class=anchor aria-hidden=true href=#the-ret-instruction>#</a></h4><pre tabindex=0><code>ret
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>pop eip          ; Pop return address into instruction pointer
jmp eip          ; Jump to return address
</code></pre><h4 id=complete-example-with-simplified-instructions>Complete Example with Simplified Instructions:<a hidden class=anchor aria-hidden=true href=#complete-example-with-simplified-instructions>#</a></h4><pre tabindex=0><code>; Caller side:
push argument2
push argument1
call my_function        ; Pushes return address and jumps
add esp, 8             ; Clean up arguments (caller cleanup)

; Callee side:
my_function:
    push ebp           ; Save old frame pointer
    mov ebp, esp       ; Set up new frame
    sub esp, 16        ; Allocate local variables
    
    ; ... function body ...
    
    leave              ; Equivalent to: mov esp, ebp; pop ebp
    ret                ; Pop return address and jump to it
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/vulnerabilities/>Vulnerabilities</a></li><li><a href=https://sankethbk.github.io/blog/tags/buffer-overflow/>Buffer Overflow</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>