<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CTF Walkthrough : Matryoshka Challenge | Sanketh's Blog</title><meta name=keywords content="reverse-engineering,elf,gdb,radare2"><meta name=description content="Matryoshka Crackme Solution (Detailed Walkthrough)
This is a detailed write-up for the &ldquo;Matryoshka&rdquo; crackme on crackmes.one.
1. Initial Static Analysis
First, we gather basic information about the binary.
$ file matryoshka
matryoshka: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped

$ checksec matryoshka
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH     Symbols      FORTIFY    Fortified    Fortifiable    FILE
Partial RELRO   Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH  No Symbols   No         0            1              matryoshka
The binary is a stripped 64-bit PIE executable with a stack canary. Looking at the strings gives a major clue about its functionality."><meta name=author content="Gemini"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/2025-11-01-ctf-1-walkthrough/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/2025-11-01-ctf-1-walkthrough/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/2025-11-01-ctf-1-walkthrough/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="CTF Walkthrough : Matryoshka Challenge"><meta property="og:description" content="Matryoshka Crackme Solution (Detailed Walkthrough) This is a detailed write-up for the “Matryoshka” crackme on crackmes.one.
1. Initial Static Analysis First, we gather basic information about the binary.
$ file matryoshka matryoshka: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped $ checksec matryoshka RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO Canary found NX enabled PIE enabled No RPATH No RUNPATH No Symbols No 0 1 matryoshka The binary is a stripped 64-bit PIE executable with a stack canary. Looking at the strings gives a major clue about its functionality."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-05T00:00:00+00:00"><meta property="article:tag" content="Reverse-Engineering"><meta property="article:tag" content="Elf"><meta property="article:tag" content="Gdb"><meta property="article:tag" content="Radare2"><meta name=twitter:card content="summary"><meta name=twitter:title content="CTF Walkthrough : Matryoshka Challenge"><meta name=twitter:description content="Matryoshka Crackme Solution (Detailed Walkthrough)
This is a detailed write-up for the &ldquo;Matryoshka&rdquo; crackme on crackmes.one.
1. Initial Static Analysis
First, we gather basic information about the binary.
$ file matryoshka
matryoshka: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped

$ checksec matryoshka
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH     Symbols      FORTIFY    Fortified    Fortifiable    FILE
Partial RELRO   Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH  No Symbols   No         0            1              matryoshka
The binary is a stripped 64-bit PIE executable with a stack canary. Looking at the strings gives a major clue about its functionality."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"CTF Walkthrough : Matryoshka Challenge","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/2025-11-01-ctf-1-walkthrough/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CTF Walkthrough : Matryoshka Challenge","name":"CTF Walkthrough : Matryoshka Challenge","description":"Matryoshka Crackme Solution (Detailed Walkthrough) This is a detailed write-up for the \u0026ldquo;Matryoshka\u0026rdquo; crackme on crackmes.one.\n1. Initial Static Analysis First, we gather basic information about the binary.\n$ file matryoshka matryoshka: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped $ checksec matryoshka RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO Canary found NX enabled PIE enabled No RPATH No RUNPATH No Symbols No 0 1 matryoshka The binary is a stripped 64-bit PIE executable with a stack canary. Looking at the strings gives a major clue about its functionality.\n","keywords":["reverse-engineering","elf","gdb","radare2"],"articleBody":"Matryoshka Crackme Solution (Detailed Walkthrough) This is a detailed write-up for the “Matryoshka” crackme on crackmes.one.\n1. Initial Static Analysis First, we gather basic information about the binary.\n$ file matryoshka matryoshka: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, stripped $ checksec matryoshka RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO Canary found NX enabled PIE enabled No RPATH No RUNPATH No Symbols No 0 1 matryoshka The binary is a stripped 64-bit PIE executable with a stack canary. Looking at the strings gives a major clue about its functionality.\n$ strings -n 10 matryoshka ... memfd_create ... execve ... /proc/self/fd/%d ... The presence of memfd_create, execve, and /proc/self/fd/%d strongly suggests the program will create a file in memory and then execute it.\n2. Decompilation and Logic of Layer 1 Decompiling the main function (using Ghidra in this case) shows a simple argument check. If argc is not 2, it prints a usage message.\n// Decompiled main function undefined8 main(int argc, long argv) { if (argc == 2) { // ... core logic ... operation(magicString, magic_int, **(char **)(argv + 8) + -0x57, \u0026local_var); } else { puts(\"usage: ./matryoshka key\"); } return 0; } The interesting part is the operation function, which is called with a character from our input (argv[1][0]) minus the constant 0x57.\nThis operation function contains the core logic:\nAn XOR cipher is performed on a large data blob. The result is written to an in-memory file descriptor created by memfd_create. execve is called to execute the content of that file descriptor. // Decompiled operation() function void operation(byte *magicString_data, uint data_size, byte key, ...) { // 1. XOR the data blob with the derived key xor_cypher(magicString_data, data_size, key); // 2. Write the result to an in-memory file FILE *file_stream = write_magicString_to_in_memory_file_and_return_stream(magicString_data, data_size, 1); // 3. Execute the in-memory file exec_memfd_stream(file_stream, ...); return; } 3. Finding the XOR Key The program is executing a data blob, which means the blob itself must be a valid ELF file. All ELF files start with the magic bytes \\x7fELF (0x7f 45 4c 46).\nThe encrypted data blob in the binary starts with 0x70 4A 43 49.\nSince encrypted_byte ^ key = decrypted_byte, we can find the key with key = encrypted_byte ^ decrypted_byte.\n0x70 ^ 0x7f = 0x0f 0x4a ^ 0x45 = 0x0f 0x43 ^ 0x4c = 0x0f 0x49 ^ 0x46 = 0x0f The key is 0x0f. The program calculates the key as input_char - 0x57. Therefore, input_char = 0x0f + 0x57 = 0x66, which is the ASCII character ‘f’.\n4. Investigating the Crash \u0026 Extracting the Payload Running ./matryoshka f produces no output. Using strace reveals why:\n$ strace -f ./matryoshka f ... execve(\"./matryoshka\", [\"./matryoshka\", \"f\"], 0x7ffc...) = 0 memfd_create(\"...\", MFD_CLOEXEC) = 3 ftruncate(3, 43488) = 0 write(3, \"\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u003e\\0\\1\\0\\0\\0...\", 43488) = 43488 execve(\"/proc/self/fd/3\", [\"\", \"\", ...], 0x7ffc...) = -1 EFAULT (Bad address) ... The write call successfully writes a valid ELF header to the file descriptor, but the subsequent execve fails with a “Bad address” error. The argv array passed to it looks corrupt.\nWe can confirm this with GDB. We set a breakpoint on execve and inspect the arguments, which are passed in registers $rdi, $rsi, and $rdx on x86-64.\n$ gdb ./matryoshka (gdb) break execve Breakpoint 1 at 0x1080 (gdb) run f Starting program: /path/to/matryoshka f Breakpoint 1, 0x0000555555555080 in execve@plt () (gdb) # $rdi holds the path, $rsi holds argv (gdb) x/s $rdi 0x5555555592a0: \"/proc/self/fd/3\" (gdb) # The path is correct. Let's check argv. (gdb) x/8gx $rsi 0x7fffffffdc90: 0x000055555555a01c 0x00007fffffffdd6b 0x7fffffffdca0: 0x00007fffffffde90 0x0000000000000000 ... The argv array at $rsi should be an array of pointers to null-terminated strings, ending with a NULL pointer. While argv[3] is NULL, the pointers themselves point to garbage or empty strings, causing execve to fail.\nSince the write to the file descriptor succeeded, we can grab the decrypted binary from the /proc filesystem before the program crashes.\nGet the PID inside GDB:\n(gdb) info inferiors Num Description Executable * 1 process 39550 /path/to/matryoshka In another shell, copy the file from the process’s file descriptor table:\n# Use the PID from GDB (e.g., 39550) $ cp /proc/39550/fd/3 ./layer2.bin 5. Inner Layers and Final Solution The extracted file, layer2.bin, is another nested ELF. The entire process is repeated two more times: analyze the binary, find the XOR key for its payload, and use GDB to extract the next layer.\nAfter extracting the third and final binary, decompiling it reveals a very simple program:\n// Decompiled final layer undefined8 main(int argc, long argv) { int input_num; input_num = atoi(*(char **)(argv + 8)); // atoi(argv[1]) if (input_num == 9) { puts(\"u win good job!!!!\"); } return 0; } The program simply checks if the first argument is the number 9.\nThe final step is to run the last extracted binary with the argument 9:\n$ ./final_layer.bin 9 u win good job!!!! ","wordCount":"819","inLanguage":"en","datePublished":"2025-11-05T00:00:00Z","dateModified":"2025-11-05T00:00:00Z","author":{"@type":"Person","name":"Gemini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/2025-11-01-ctf-1-walkthrough/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CTF Walkthrough : Matryoshka Challenge</h1><div class=post-meta><span title='2025-11-05 00:00:00 +0000 UTC'>November 5, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Gemini&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/2025-11-01-ctf-1-walkthrough.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#matryoshka-crackme-solution-detailed-walkthrough aria-label="Matryoshka Crackme Solution (Detailed Walkthrough)">Matryoshka Crackme Solution (Detailed Walkthrough)</a><ul><li><a href=#1-initial-static-analysis aria-label="1. Initial Static Analysis">1. Initial Static Analysis</a></li><li><a href=#2-decompilation-and-logic-of-layer-1 aria-label="2. Decompilation and Logic of Layer 1">2. Decompilation and Logic of Layer 1</a></li><li><a href=#3-finding-the-xor-key aria-label="3. Finding the XOR Key">3. Finding the XOR Key</a></li><li><a href=#4-investigating-the-crash--extracting-the-payload aria-label="4. Investigating the Crash & Extracting the Payload">4. Investigating the Crash & Extracting the Payload</a></li><li><a href=#5-inner-layers-and-final-solution aria-label="5. Inner Layers and Final Solution">5. Inner Layers and Final Solution</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=matryoshka-crackme-solution-detailed-walkthrough>Matryoshka Crackme Solution (Detailed Walkthrough)<a hidden class=anchor aria-hidden=true href=#matryoshka-crackme-solution-detailed-walkthrough>#</a></h1><p>This is a detailed write-up for the &ldquo;Matryoshka&rdquo; crackme on crackmes.one.</p><h2 id=1-initial-static-analysis>1. Initial Static Analysis<a hidden class=anchor aria-hidden=true href=#1-initial-static-analysis>#</a></h2><p>First, we gather basic information about the binary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ file matryoshka
</span></span><span style=display:flex><span>matryoshka: ELF 64-bit LSB pie executable, x86-64, version <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>SYSV<span style=color:#f92672>)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span style=color:#66d9ef>for</span> GNU/Linux 4.4.0, stripped
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ checksec matryoshka
</span></span><span style=display:flex><span>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH     Symbols      FORTIFY    Fortified    Fortifiable    FILE
</span></span><span style=display:flex><span>Partial RELRO   Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH  No Symbols   No         <span style=color:#ae81ff>0</span>            <span style=color:#ae81ff>1</span>              matryoshka
</span></span></code></pre></div><p>The binary is a stripped 64-bit PIE executable with a stack canary. Looking at the strings gives a major clue about its functionality.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ strings -n <span style=color:#ae81ff>10</span> matryoshka
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>memfd_create
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>execve
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>/proc/self/fd/%d
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>The presence of <code>memfd_create</code>, <code>execve</code>, and <code>/proc/self/fd/%d</code> strongly suggests the program will create a file in memory and then execute it.</p><h2 id=2-decompilation-and-logic-of-layer-1>2. Decompilation and Logic of Layer 1<a hidden class=anchor aria-hidden=true href=#2-decompilation-and-logic-of-layer-1>#</a></h2><p>Decompiling the <code>main</code> function (using Ghidra in this case) shows a simple argument check. If <code>argc</code> is not 2, it prints a usage message.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Decompiled main function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>undefined8 <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>long</span> argv) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... core logic ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>operation</span>(magicString, magic_int, <span style=color:#f92672>**</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(argv <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0x57</span>, <span style=color:#f92672>&amp;</span>local_var);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;usage: ./matryoshka key&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The interesting part is the <code>operation</code> function, which is called with a character from our input (<code>argv[1][0]</code>) minus the constant <code>0x57</code>.</p><p>This <code>operation</code> function contains the core logic:</p><ol><li>An XOR cipher is performed on a large data blob.</li><li>The result is written to an in-memory file descriptor created by <code>memfd_create</code>.</li><li><code>execve</code> is called to execute the content of that file descriptor.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Decompiled operation() function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operation</span>(byte <span style=color:#f92672>*</span>magicString_data, uint data_size, byte key, ...) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. XOR the data blob with the derived key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>xor_cypher</span>(magicString_data, data_size, key);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 2. Write the result to an in-memory file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  FILE <span style=color:#f92672>*</span>file_stream <span style=color:#f92672>=</span> <span style=color:#a6e22e>write_magicString_to_in_memory_file_and_return_stream</span>(magicString_data, data_size, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 3. Execute the in-memory file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>exec_memfd_stream</span>(file_stream, ...);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=3-finding-the-xor-key>3. Finding the XOR Key<a hidden class=anchor aria-hidden=true href=#3-finding-the-xor-key>#</a></h2><p>The program is executing a data blob, which means the blob itself must be a valid ELF file. All ELF files start with the magic bytes <code>\x7fELF</code> (<code>0x7f 45 4c 46</code>).</p><p>The encrypted data blob in the binary starts with <code>0x70 4A 43 49</code>.</p><p>Since <code>encrypted_byte ^ key = decrypted_byte</code>, we can find the key with <code>key = encrypted_byte ^ decrypted_byte</code>.</p><pre tabindex=0><code>0x70 ^ 0x7f = 0x0f
0x4a ^ 0x45 = 0x0f
0x43 ^ 0x4c = 0x0f
0x49 ^ 0x46 = 0x0f
</code></pre><p>The key is <code>0x0f</code>. The program calculates the key as <code>input_char - 0x57</code>. Therefore, <code>input_char = 0x0f + 0x57 = 0x66</code>, which is the ASCII character &lsquo;f&rsquo;.</p><h2 id=4-investigating-the-crash--extracting-the-payload>4. Investigating the Crash & Extracting the Payload<a hidden class=anchor aria-hidden=true href=#4-investigating-the-crash--extracting-the-payload>#</a></h2><p>Running <code>./matryoshka f</code> produces no output. Using <code>strace</code> reveals why:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ strace -f ./matryoshka f
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>execve<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;./matryoshka&#34;</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;./matryoshka&#34;</span>, <span style=color:#e6db74>&#34;f&#34;</span><span style=color:#f92672>]</span>, 0x7ffc...<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>memfd_create<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;...&#34;</span>, MFD_CLOEXEC<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>ftruncate<span style=color:#f92672>(</span>3, 43488<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>write<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0...&#34;</span>, 43488<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>43488</span>
</span></span><span style=display:flex><span>execve<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/proc/self/fd/3&#34;</span>, <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, ...<span style=color:#f92672>]</span>, 0x7ffc...<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 EFAULT <span style=color:#f92672>(</span>Bad address<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>The <code>write</code> call successfully writes a valid ELF header to the file descriptor, but the subsequent <code>execve</code> fails with a &ldquo;Bad address&rdquo; error. The <code>argv</code> array passed to it looks corrupt.</p><p>We can confirm this with GDB. We set a breakpoint on <code>execve</code> and inspect the arguments, which are passed in registers <code>$rdi</code>, <code>$rsi</code>, and <code>$rdx</code> on x86-64.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gdb ./matryoshka
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> break execve
</span></span><span style=display:flex><span>Breakpoint <span style=color:#ae81ff>1</span> at 0x1080
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> run f
</span></span><span style=display:flex><span>Starting program: /path/to/matryoshka f
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 1, 0x0000555555555080 in execve@plt <span style=color:#f92672>()</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> <span style=color:#75715e># $rdi holds the path, $rsi holds argv</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/s $rdi
</span></span><span style=display:flex><span>0x5555555592a0: <span style=color:#e6db74>&#34;/proc/self/fd/3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> <span style=color:#75715e># The path is correct. Let&#39;s check argv.</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/8gx $rsi
</span></span><span style=display:flex><span>0x7fffffffdc90: 0x000055555555a01c  0x00007fffffffdd6b
</span></span><span style=display:flex><span>0x7fffffffdca0: 0x00007fffffffde90  0x0000000000000000
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>The <code>argv</code> array at <code>$rsi</code> should be an array of pointers to null-terminated strings, ending with a <code>NULL</code> pointer. While <code>argv[3]</code> is <code>NULL</code>, the pointers themselves point to garbage or empty strings, causing <code>execve</code> to fail.</p><p>Since the <code>write</code> to the file descriptor succeeded, we can grab the decrypted binary from the <code>/proc</code> filesystem before the program crashes.</p><ol><li><p>Get the PID inside GDB:</p><pre tabindex=0><code class=language-gdb data-lang=gdb>(gdb) info inferiors
  Num  Description       Executable
* 1    process 39550     /path/to/matryoshka
</code></pre></li><li><p>In another shell, copy the file from the process&rsquo;s file descriptor table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Use the PID from GDB (e.g., 39550)</span>
</span></span><span style=display:flex><span>$ cp /proc/39550/fd/3 ./layer2.bin
</span></span></code></pre></div></li></ol><h2 id=5-inner-layers-and-final-solution>5. Inner Layers and Final Solution<a hidden class=anchor aria-hidden=true href=#5-inner-layers-and-final-solution>#</a></h2><p>The extracted file, <code>layer2.bin</code>, is another nested ELF. The entire process is repeated two more times: analyze the binary, find the XOR key for its payload, and use GDB to extract the next layer.</p><p>After extracting the third and final binary, decompiling it reveals a very simple program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Decompiled final layer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>undefined8 <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>long</span> argv) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> input_num;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  input_num <span style=color:#f92672>=</span> <span style=color:#a6e22e>atoi</span>(<span style=color:#f92672>*</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(argv <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>)); <span style=color:#75715e>// atoi(argv[1])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (input_num <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;u win good job!!!!&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The program simply checks if the first argument is the number <code>9</code>.</p><p><strong>The final step is to run the last extracted binary with the argument <code>9</code>:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./final_layer.bin <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>u win good job!!!!
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse-Engineering</a></li><li><a href=https://sankethbk.github.io/blog/tags/elf/>Elf</a></li><li><a href=https://sankethbk.github.io/blog/tags/gdb/>Gdb</a></li><li><a href=https://sankethbk.github.io/blog/tags/radare2/>Radare2</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>