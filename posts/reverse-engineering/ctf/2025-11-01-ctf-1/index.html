<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CTF ‚Äì 1 : Matryoshka | Sanketh's Blog</title><meta name=keywords content="ctf,reverse-engineering"><meta name=description content="Reverse Engineering and CTF Challenge Notes
Reverse engineering is the process of understanding how software works without access to its original source code.
In security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.
This walkthrough documents my first attempt at such a challenge, focusing on ELF-based reverse engineering and the reasoning process behind each step.

1. Static Analysis
Static analysis means inspecting the binary without running it."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="CTF ‚Äì 1 : Matryoshka"><meta property="og:description" content="Reverse Engineering and CTF Challenge Notes Reverse engineering is the process of understanding how software works without access to its original source code.
In security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.
This walkthrough documents my first attempt at such a challenge, focusing on ELF-based reverse engineering and the reasoning process behind each step.
1. Static Analysis Static analysis means inspecting the binary without running it."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-01T00:00:00+00:00"><meta property="article:tag" content="Ctf"><meta property="article:tag" content="Reverse-Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="CTF ‚Äì 1 : Matryoshka"><meta name=twitter:description content="Reverse Engineering and CTF Challenge Notes
Reverse engineering is the process of understanding how software works without access to its original source code.
In security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.
This walkthrough documents my first attempt at such a challenge, focusing on ELF-based reverse engineering and the reasoning process behind each step.

1. Static Analysis
Static analysis means inspecting the binary without running it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"CTF ‚Äì 1 : Matryoshka","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CTF ‚Äì 1 : Matryoshka","name":"CTF ‚Äì 1 : Matryoshka","description":"Reverse Engineering and CTF Challenge Notes Reverse engineering is the process of understanding how software works without access to its original source code.\nIn security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.\nThis walkthrough documents my first attempt at such a challenge, focusing on ELF-based reverse engineering and the reasoning process behind each step.\n1. Static Analysis Static analysis means inspecting the binary without running it.\n","keywords":["ctf","reverse-engineering"],"articleBody":"Reverse Engineering and CTF Challenge Notes Reverse engineering is the process of understanding how software works without access to its original source code.\nIn security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.\nThis walkthrough documents my first attempt at such a challenge, focusing on ELF-based reverse engineering and the reasoning process behind each step.\n1. Static Analysis Static analysis means inspecting the binary without running it.\nfile ./binary # Type, architecture, stripped? strings ./binary # Extract readable strings checksec ./binary # Security features (PIE, NX, RELRO, Canaries) ELF Header readelf -h matryoshka Shows class, endianness, type, entry point, etc.\nHere, Type: DYN means it‚Äôs a PIE executable, not a shared library.\nThe INTERP program header:\nreadelf -l matryoshka | grep INTERP # [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] confirms it‚Äôs an executable using the dynamic loader.\nQuick Summary via file file matryoshka # ELF 64-bit LSB pie executable ... stripped ‚ÄúStripped‚Äù = symbol table removed ‚Üí variable/function names lost.\nInspect Strings strings -n 10 matryoshka | less Look for clues, readable data, or embedded keys.\nSecurity Properties checksec --file matryoshka Feature Status Meaning PIE ‚úÖ Position-independent (ASLR randomization) NX ‚úÖ Non-executable stack Canary ‚úÖ Stack overflow detection RELRO Partial Some GOT protection Symbols ‚ùå Stripped 2. Dynamic Linking \u0026 libc Calls readelf -r matryoshka lists relocations.\nInteresting imports included:\nmemfd_create ftruncate fdopen fwrite execve memfd_create stands out ‚Äî it creates anonymous in-memory files which can later be executed via /proc/self/fd/.\n3. Decompilation \u0026 Function Discovery Using radare2 (or Ghidra):\nr2 matryoshka [0x000010d0]\u003e aaa # analyze all [0x000010d0]\u003e afl # list functions Functions found included main, fcn.00101344, fcn.001012f4, etc.\nThe call chain revealed this logic:\nmain ‚îî‚îÄ‚îÄ operation() ‚îú‚îÄ‚îÄ xor_cipher() ‚îú‚îÄ‚îÄ write_to_memfd() ‚îî‚îÄ‚îÄ exec_memfd_stream() Decompiled Logic (after renaming) void xor_cipher(char *buf, int len, uint8_t key) { for (int i=0; i\u003clen; i++) buf[i] ^= key; } FILE *write_to_memfd(char *buf, int len) { int fd = memfd_create(\"x\", 1); ftruncate(fd, len); FILE *f = fdopen(fd, \"r+\"); fwrite(buf, 1, len, f); rewind(f); return f; } void exec_memfd_stream(FILE *f) { char path[64]; sprintf(path, \"/proc/self/fd/%d\", fileno(f)); char *argv[] = { NULL }; execve(path, argv, NULL); } main performs:\nxor_cipher(magic_blob, len, argv[1][0] - 0x57); FILE *f = write_to_memfd(magic_blob, len); exec_memfd_stream(f); So the program:\nXOR-decrypts an embedded blob. Writes it to an in-memory file. Executes that file. If the XOR key is wrong, the blob is garbage ‚Üí execve fails.\n4. Recovering the XOR Key From .rodata:\nmagic_blob[0..3] = 70 4A 43 49 Expected ELF magic = 7F 45 4C 46 XOR both sequences:\n(70 4A 43 49) ^ (7F 45 4C 46) = 0F 0F 0F 0F ‚Üí XOR key = 0x0F\nSince the program subtracts 0x57 from input char,\ninput_char = 0x0F + 0x57 = 0x66 = 'f' Run:\n./matryoshka f It silently decrypts the blob, writes it to /proc/self/fd/3, and tries to execve it.\n5. Tracing Execution Using strace strace -f -s 200 -o trace.txt ./matryoshka f grep execve trace.txt Second execve call failed with EFAULT (bad argv),\nbut a valid ELF was already written to fd 3.\nExtract the In-Memory File Find PID ‚Üí copy fd:\nls -l /proc//fd cp /proc//fd/3 /tmp/magic_blob.bin file /tmp/magic_blob.bin Result: another valid ELF executable.\n6. Nested Binaries (Matryoshka Concept) Each extracted ELF repeated the same pattern:\nHard-coded string, XOR cipher, memfd + execve. By recursively extracting:\nmatryoshka ‚Üí magic_blob.bin ‚Üí magic_blob2.bin ‚Üí magic_blob3.bin The final layer contained:\nint main(int argc, char **argv) { if (atoi(argv[1]) == 9) puts(\"u win good job!!!!\"); else fail(); } ./magic_blob3.bin 9 # u win good job!!!! 7. What We Learned Concept Insight ELF structure Headers, program segments, and section tables PIE \u0026 ASLR Why offsets are used instead of fixed addresses memfd_create Running programs entirely from RAM XOR cipher Simple but effective obfuscation execve Direct system call interface strace \u0026 gdb System-call and runtime tracing Nested binaries ‚ÄúMatryoshka‚Äù style layering üß† Reflection This challenge elegantly combines:\nbasic cryptography (XOR), Linux process internals, ELF familiarity, and runtime analysis. It demonstrates how self-modifying or self-executing code can conceal payloads ‚Äî a technique used both in CTF puzzles and real-world malware.\nFuture Ideas Write a script to automate recursive extraction of nested ELF layers. Explore how memfd-based execution can evade disk forensics. Try similar challenges on sites like: crackmes.one pwnable.kr root-me.org reversing.kr üèÅ Final Thoughts ‚ÄúEach layer you peel back reveals a little more of how the system really works.‚Äù\nReverse engineering isn‚Äôt just about ‚Äúbreaking‚Äù programs ‚Äî\nit‚Äôs about learning how compilers, linkers, and the OS cooperate to make software run.\n","wordCount":"751","inLanguage":"en","datePublished":"2025-11-01T00:00:00Z","dateModified":"2025-11-01T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-01-ctf-1/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CTF ‚Äì 1 : Matryoshka</h1><div class=post-meta><span title='2025-11-01 00:00:00 +0000 UTC'>November 1, 2025</span>&nbsp;¬∑&nbsp;4 min&nbsp;¬∑&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/ctf/2025-11-01-ctf-1.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#reverse-engineering-and-ctf-challenge-notes aria-label="Reverse Engineering and CTF Challenge Notes">Reverse Engineering and CTF Challenge Notes</a><ul><li><a href=#1-static-analysis aria-label="1. Static Analysis">1. Static Analysis</a><ul><li><a href=#elf-header aria-label="ELF Header">ELF Header</a></li><li><a href=#quick-summary-via-file aria-label="Quick Summary via file">Quick Summary via file</a></li><li><a href=#inspect-strings aria-label="Inspect Strings">Inspect Strings</a></li><li><a href=#security-properties aria-label="Security Properties">Security Properties</a></li></ul></li><li><a href=#2-dynamic-linking--libc-calls aria-label="2. Dynamic Linking & libc Calls">2. Dynamic Linking & libc Calls</a></li><li><a href=#3-decompilation--function-discovery aria-label="3. Decompilation & Function Discovery">3. Decompilation & Function Discovery</a></li><li><a href=#decompiled-logic-after-renaming aria-label="Decompiled Logic (after renaming)">Decompiled Logic (after renaming)</a></li><li><a href=#4-recovering-the-xor-key aria-label="4. Recovering the XOR Key">4. Recovering the XOR Key</a></li><li><a href=#5-tracing-execution aria-label="5. Tracing Execution">5. Tracing Execution</a><ul><li><a href=#using-strace aria-label="Using strace">Using strace</a></li><li><a href=#extract-the-in-memory-file aria-label="Extract the In-Memory File">Extract the In-Memory File</a></li></ul></li><li><a href=#6-nested-binaries-matryoshka-concept aria-label="6. Nested Binaries (Matryoshka Concept)">6. Nested Binaries (Matryoshka Concept)</a></li><li><a href=#7-what-we-learned aria-label="7. What We Learned">7. What We Learned</a></li><li><a href=#-reflection aria-label="üß† Reflection">üß† Reflection</a></li><li><a href=#future-ideas aria-label="Future Ideas">Future Ideas</a></li><li><a href=#-final-thoughts aria-label="üèÅ Final Thoughts">üèÅ Final Thoughts</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=reverse-engineering-and-ctf-challenge-notes>Reverse Engineering and CTF Challenge Notes<a hidden class=anchor aria-hidden=true href=#reverse-engineering-and-ctf-challenge-notes>#</a></h1><p>Reverse engineering is the process of understanding how software works <strong>without access to its original source code</strong>.<br>In security challenges (CTFs), the goal is often to recover hidden data or logic by dissecting a binary.<br>This walkthrough documents my first attempt at such a challenge, focusing on <em>ELF-based reverse engineering</em> and the reasoning process behind each step.</p><hr><h2 id=1-static-analysis>1. Static Analysis<a hidden class=anchor aria-hidden=true href=#1-static-analysis>#</a></h2><p>Static analysis means inspecting the binary <strong>without running it</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>file ./binary           <span style=color:#75715e># Type, architecture, stripped?</span>
</span></span><span style=display:flex><span>strings ./binary        <span style=color:#75715e># Extract readable strings</span>
</span></span><span style=display:flex><span>checksec ./binary       <span style=color:#75715e># Security features (PIE, NX, RELRO, Canaries)</span>
</span></span></code></pre></div><h3 id=elf-header>ELF Header<a hidden class=anchor aria-hidden=true href=#elf-header>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -h matryoshka
</span></span></code></pre></div><p>Shows class, endianness, type, entry point, etc.<br>Here, <code>Type: DYN</code> means it‚Äôs a <strong>PIE executable</strong>, not a shared library.</p><p>The <code>INTERP</code> program header:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -l matryoshka | grep INTERP
</span></span><span style=display:flex><span><span style=color:#75715e># [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span>
</span></span></code></pre></div><p>confirms it‚Äôs an executable using the dynamic loader.</p><h3 id=quick-summary-via-file>Quick Summary via <code>file</code><a hidden class=anchor aria-hidden=true href=#quick-summary-via-file>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>file matryoshka
</span></span><span style=display:flex><span><span style=color:#75715e># ELF 64-bit LSB pie executable ... stripped</span>
</span></span></code></pre></div><p>‚Äú<strong>Stripped</strong>‚Äù = symbol table removed ‚Üí variable/function names lost.</p><h3 id=inspect-strings>Inspect Strings<a hidden class=anchor aria-hidden=true href=#inspect-strings>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>strings -n <span style=color:#ae81ff>10</span> matryoshka | less
</span></span></code></pre></div><p>Look for clues, readable data, or embedded keys.</p><h3 id=security-properties>Security Properties<a hidden class=anchor aria-hidden=true href=#security-properties>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>checksec --file matryoshka
</span></span></code></pre></div><table><thead><tr><th>Feature</th><th>Status</th><th>Meaning</th></tr></thead><tbody><tr><td>PIE</td><td>‚úÖ</td><td>Position-independent (ASLR randomization)</td></tr><tr><td>NX</td><td>‚úÖ</td><td>Non-executable stack</td></tr><tr><td>Canary</td><td>‚úÖ</td><td>Stack overflow detection</td></tr><tr><td>RELRO</td><td>Partial</td><td>Some GOT protection</td></tr><tr><td>Symbols</td><td>‚ùå</td><td>Stripped</td></tr></tbody></table><hr><h2 id=2-dynamic-linking--libc-calls>2. Dynamic Linking & libc Calls<a hidden class=anchor aria-hidden=true href=#2-dynamic-linking--libc-calls>#</a></h2><p><code>readelf -r matryoshka</code> lists relocations.<br>Interesting imports included:</p><pre tabindex=0><code>memfd_create
ftruncate
fdopen
fwrite
execve
</code></pre><p><code>memfd_create</code> stands out ‚Äî it creates <strong>anonymous in-memory files</strong> which can later be executed via <code>/proc/self/fd/&lt;n></code>.</p><hr><h2 id=3-decompilation--function-discovery>3. Decompilation & Function Discovery<a hidden class=anchor aria-hidden=true href=#3-decompilation--function-discovery>#</a></h2><p>Using <strong>radare2</strong> (or Ghidra):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>r2 matryoshka
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>0x000010d0<span style=color:#f92672>]</span>&gt; aaa        <span style=color:#75715e># analyze all</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>0x000010d0<span style=color:#f92672>]</span>&gt; afl        <span style=color:#75715e># list functions</span>
</span></span></code></pre></div><p>Functions found included <code>main</code>, <code>fcn.00101344</code>, <code>fcn.001012f4</code>, etc.<br>The call chain revealed this logic:</p><pre tabindex=0><code>main
 ‚îî‚îÄ‚îÄ operation()
      ‚îú‚îÄ‚îÄ xor_cipher()
      ‚îú‚îÄ‚îÄ write_to_memfd()
      ‚îî‚îÄ‚îÄ exec_memfd_stream()
</code></pre><hr><h2 id=decompiled-logic-after-renaming>Decompiled Logic (after renaming)<a hidden class=anchor aria-hidden=true href=#decompiled-logic-after-renaming>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>xor_cipher</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> len, <span style=color:#66d9ef>uint8_t</span> key) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>len; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        buf[i] <span style=color:#f92672>^=</span> key;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FILE <span style=color:#f92672>*</span><span style=color:#a6e22e>write_to_memfd</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>int</span> len) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>memfd_create</span>(<span style=color:#e6db74>&#34;x&#34;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ftruncate</span>(fd, len);
</span></span><span style=display:flex><span>    FILE <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> <span style=color:#a6e22e>fdopen</span>(fd, <span style=color:#e6db74>&#34;r+&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fwrite</span>(buf, <span style=color:#ae81ff>1</span>, len, f);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rewind</span>(f);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> f;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exec_memfd_stream</span>(FILE <span style=color:#f92672>*</span>f) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> path[<span style=color:#ae81ff>64</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sprintf</span>(path, <span style=color:#e6db74>&#34;/proc/self/fd/%d&#34;</span>, <span style=color:#a6e22e>fileno</span>(f));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[] <span style=color:#f92672>=</span> { NULL };
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>execve</span>(path, argv, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>main</code> performs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>xor_cipher</span>(magic_blob, len, argv[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>0x57</span>);
</span></span><span style=display:flex><span>FILE <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> <span style=color:#a6e22e>write_to_memfd</span>(magic_blob, len);
</span></span><span style=display:flex><span><span style=color:#a6e22e>exec_memfd_stream</span>(f);
</span></span></code></pre></div><p>So the program:</p><ol><li>XOR-decrypts an embedded blob.</li><li>Writes it to an in-memory file.</li><li>Executes that file.</li></ol><p>If the XOR key is wrong, the blob is garbage ‚Üí execve fails.</p><hr><h2 id=4-recovering-the-xor-key>4. Recovering the XOR Key<a hidden class=anchor aria-hidden=true href=#4-recovering-the-xor-key>#</a></h2><p>From <code>.rodata</code>:</p><pre tabindex=0><code>magic_blob[0..3] = 70 4A 43 49
Expected ELF magic = 7F 45 4C 46
</code></pre><p>XOR both sequences:</p><pre tabindex=0><code>(70 4A 43 49) ^ (7F 45 4C 46) = 0F 0F 0F 0F
</code></pre><p>‚Üí XOR key = <code>0x0F</code></p><p>Since the program subtracts <code>0x57</code> from input char,</p><pre tabindex=0><code>input_char = 0x0F + 0x57 = 0x66 = &#39;f&#39;
</code></pre><p>Run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>./matryoshka f
</span></span></code></pre></div><p>It silently decrypts the blob, writes it to <code>/proc/self/fd/3</code>, and tries to <code>execve</code> it.</p><hr><h2 id=5-tracing-execution>5. Tracing Execution<a hidden class=anchor aria-hidden=true href=#5-tracing-execution>#</a></h2><h3 id=using-strace>Using <code>strace</code><a hidden class=anchor aria-hidden=true href=#using-strace>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>strace -f -s <span style=color:#ae81ff>200</span> -o trace.txt ./matryoshka f
</span></span><span style=display:flex><span>grep execve trace.txt
</span></span></code></pre></div><p>Second <code>execve</code> call failed with <code>EFAULT</code> (bad argv),<br>but a valid ELF was already written to fd 3.</p><h3 id=extract-the-in-memory-file>Extract the In-Memory File<a hidden class=anchor aria-hidden=true href=#extract-the-in-memory-file>#</a></h3><p>Find PID ‚Üí copy fd:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l /proc/&lt;pid&gt;/fd
</span></span><span style=display:flex><span>cp /proc/&lt;pid&gt;/fd/3 /tmp/magic_blob.bin
</span></span><span style=display:flex><span>file /tmp/magic_blob.bin
</span></span></code></pre></div><p>Result: another valid ELF executable.</p><hr><h2 id=6-nested-binaries-matryoshka-concept>6. Nested Binaries (Matryoshka Concept)<a hidden class=anchor aria-hidden=true href=#6-nested-binaries-matryoshka-concept>#</a></h2><p>Each extracted ELF repeated the same pattern:</p><ul><li>Hard-coded string,</li><li>XOR cipher,</li><li>memfd + execve.</li></ul><p>By recursively extracting:</p><pre tabindex=0><code>matryoshka ‚Üí magic_blob.bin ‚Üí magic_blob2.bin ‚Üí magic_blob3.bin
</code></pre><p>The final layer contained:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>atoi</span>(argv[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;u win good job!!!!&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fail</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>./magic_blob3.bin <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span><span style=color:#75715e># u win good job!!!!</span>
</span></span></code></pre></div><hr><h2 id=7-what-we-learned>7. What We Learned<a hidden class=anchor aria-hidden=true href=#7-what-we-learned>#</a></h2><table><thead><tr><th>Concept</th><th>Insight</th></tr></thead><tbody><tr><td>ELF structure</td><td>Headers, program segments, and section tables</td></tr><tr><td>PIE & ASLR</td><td>Why offsets are used instead of fixed addresses</td></tr><tr><td>memfd_create</td><td>Running programs entirely from RAM</td></tr><tr><td>XOR cipher</td><td>Simple but effective obfuscation</td></tr><tr><td>execve</td><td>Direct system call interface</td></tr><tr><td>strace & gdb</td><td>System-call and runtime tracing</td></tr><tr><td>Nested binaries</td><td>‚ÄúMatryoshka‚Äù style layering</td></tr></tbody></table><hr><h2 id=-reflection>üß† Reflection<a hidden class=anchor aria-hidden=true href=#-reflection>#</a></h2><p>This challenge elegantly combines:</p><ul><li>basic cryptography (XOR),</li><li>Linux process internals,</li><li>ELF familiarity,</li><li>and runtime analysis.</li></ul><p>It demonstrates how <strong>self-modifying or self-executing code</strong> can conceal payloads ‚Äî a technique used both in CTF puzzles and real-world malware.</p><hr><h2 id=future-ideas>Future Ideas<a hidden class=anchor aria-hidden=true href=#future-ideas>#</a></h2><ul><li>Write a script to <strong>automate recursive extraction</strong> of nested ELF layers.</li><li>Explore how memfd-based execution can evade disk forensics.</li><li>Try similar challenges on sites like:<ul><li><a href=https://crackmes.one>crackmes.one</a></li><li><a href=https://pwnable.kr>pwnable.kr</a></li><li><a href=https://www.root-me.org>root-me.org</a></li><li><a href=http://reversing.kr>reversing.kr</a></li></ul></li></ul><hr><h2 id=-final-thoughts>üèÅ Final Thoughts<a hidden class=anchor aria-hidden=true href=#-final-thoughts>#</a></h2><blockquote><p>‚ÄúEach layer you peel back reveals a little more of how the system really works.‚Äù</p></blockquote><p>Reverse engineering isn‚Äôt just about ‚Äúbreaking‚Äù programs ‚Äî<br>it‚Äôs about <em>learning how compilers, linkers, and the OS cooperate to make software run.</em></p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/ctf/>Ctf</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse-Engineering</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://crackmes.one/crackme/68ff42b82d267f28f69b78c8 target=_blank rel="noopener noreferrer">Matryoshka</a></li></ul></section></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>