<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CTF – 3 : 45exiles Shuffle | Sanketh's Blog</title><meta name=keywords content="ctf,reverse-engineering"><meta name=description content="CTF Writeup: 45exiles Shuffle Challenge
Problem Overview
Challenge Name: 45exiles Shuffle
Core Mechanism:

Program reads user input
Shuffles the input using rand() with a known seed
Compares the shuffled input against a target string stored in memory
If they match, you get the flag

Key Insight: You can read the target (shuffled) string from memory, but that&rsquo;s NOT the answer you need to input. You must reverse the shuffle to find the original input."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="CTF – 3 : 45exiles Shuffle"><meta property="og:description" content="CTF Writeup: 45exiles Shuffle Challenge Problem Overview Challenge Name: 45exiles Shuffle
Core Mechanism:
Program reads user input Shuffles the input using rand() with a known seed Compares the shuffled input against a target string stored in memory If they match, you get the flag Key Insight: You can read the target (shuffled) string from memory, but that’s NOT the answer you need to input. You must reverse the shuffle to find the original input."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-14T00:00:00+00:00"><meta property="article:tag" content="Ctf"><meta property="article:tag" content="Reverse-Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="CTF – 3 : 45exiles Shuffle"><meta name=twitter:description content="CTF Writeup: 45exiles Shuffle Challenge
Problem Overview
Challenge Name: 45exiles Shuffle
Core Mechanism:

Program reads user input
Shuffles the input using rand() with a known seed
Compares the shuffled input against a target string stored in memory
If they match, you get the flag

Key Insight: You can read the target (shuffled) string from memory, but that&rsquo;s NOT the answer you need to input. You must reverse the shuffle to find the original input."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"CTF – 3 : 45exiles Shuffle","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CTF – 3 : 45exiles Shuffle","name":"CTF – 3 : 45exiles Shuffle","description":"CTF Writeup: 45exiles Shuffle Challenge Problem Overview Challenge Name: 45exiles Shuffle\nCore Mechanism:\nProgram reads user input Shuffles the input using rand() with a known seed Compares the shuffled input against a target string stored in memory If they match, you get the flag Key Insight: You can read the target (shuffled) string from memory, but that\u0026rsquo;s NOT the answer you need to input. You must reverse the shuffle to find the original input.\n","keywords":["ctf","reverse-engineering"],"articleBody":"CTF Writeup: 45exiles Shuffle Challenge Problem Overview Challenge Name: 45exiles Shuffle\nCore Mechanism:\nProgram reads user input Shuffles the input using rand() with a known seed Compares the shuffled input against a target string stored in memory If they match, you get the flag Key Insight: You can read the target (shuffled) string from memory, but that’s NOT the answer you need to input. You must reverse the shuffle to find the original input.\nDisassembly of key functions [0x00001160]\u003e pdg @ main ulong main(void) { uint uVar1; int iVar2; int64_t iVar3; ulong uVar4; uint64_t uVar5; int64_t in_FS_OFFSET; int iStack_244; int iStack_240; uchar auStack_228 [256]; uchar auStack_128 [255]; uchar uStack_29; int64_t iStack_20; iStack_20 = *(in_FS_OFFSET + 0x28); iStack_244 = 0; sym.imp.puts(\"Enter the password please :\"); iVar3 = sym.imp.fgets(auStack_228,0x100,_reloc.stdin); if (iVar3 == 0) { uVar4 = 1; } else { iVar3 = sym.imp.strcspn(auStack_228,0x2028); auStack_228[iVar3] = 0; sym.imp.strncpy(auStack_128,auStack_228,0xff); uStack_29 = 0; iStack_240 = 0; while( true ) { uVar5 = sym.imp.strlen(\"Gommage\"); if (uVar5 \u003c= iStack_240) break; iStack_244 = \"Gommage\"[iStack_240] + iStack_244 * 0x1f; iStack_240 = iStack_240 + 1; } uVar1 = sym.imp.strlen(auStack_128); fcn.00001249(auStack_128,uVar1,iStack_244); iVar2 = sym.imp.strcmp(\"Ygta_u3G_t0h_0aG_r3\",auStack_128); if (iVar2 == 0) { sym.imp.puts(\"Good Job !\"); } else { sym.imp.puts(\"No... Maybe another time !\"); } uVar4 = 0; } if (iStack_20 != *(in_FS_OFFSET + 0x28)) { //WARNING: Subroutine does not return sym.imp.__stack_chk_fail(); } return uVar4; } [0x00001160]\u003e pdg @ fcn.00001249 void shuffle(int64_t param_1,int param_2,uint param_3) { uchar uVar1; int iVar2; uint uStack_10; if ((param_1 != 0) \u0026\u0026 (0 \u003c param_2)) { sym.imp.srand(param_3); for (uStack_10 = param_2 + -1; 0 \u003c uStack_10; uStack_10 = uStack_10 + -1) { iVar2 = sym.imp.rand(); iVar2 = iVar2 % (uStack_10 + 1); uVar1 = *(param_1 + uStack_10); *(param_1 + uStack_10) = *(param_1 + iVar2); *(iVar2 + param_1) = uVar1; } } return; } The Main Strategy Why You Can’t Just Read Memory Unlike the previous “good kitty” challenge where we could directly read the answer from the stack, this challenge applies transformations to the input before comparison.\nUser Input → [TRANSFORMATION] → Transformed Input → Compare with Target Since the transformation happens AFTER you enter input:\nTarget in memory = What your input should become AFTER shuffling Answer you need = What produces the target AFTER shuffling You cannot shortcut this - you MUST reverse the transformation.\nUnderstanding Input Transformations Scenario 1: Direct Comparison (Can Read Answer) // Example from \"good kitty\" challenge long flag = calculate_target(); char user_input[8]; read(0, user_input, 8); // Direct byte-by-byte comparison - NO transformation for (int i = 0; i \u003c 8; i++) { if (user_input[i] != ((char*)\u0026flag)[i]) { return FAIL; } } GDB Solution: Read the answer directly!\n(gdb) x/8c $rbp-0xb8 # This IS the answer Scenario 2: Transformed Input (Must Reverse) // Example from 45exiles Shuffle char target[20] = \"scrambled_target_string\"; char user_input[20]; read(0, user_input, 20); // Transform input THEN compare char transformed[20]; shuffle(user_input, transformed, seed); if (strcmp(transformed, target) == 0) { return SUCCESS; } The Problem:\nWhat you can read: target = \"scrambled_target_string\" What you need: original_input = ??? Relationship: shuffle(original_input, seed) = target Solution Path:\n1. Read 'target' from memory (GDB/Ghidra) 2. Understand the shuffle algorithm 3. Implement reverse_shuffle() 4. Calculate: original_input = reverse_shuffle(target, seed) The Shuffle Algorithm Forward Transformation (What Program Does) from ctypes import CDLL libc = CDLL(\"libc.so.6\") def shuffle_string(s, seed): \"\"\"Apply Fisher-Yates shuffle to string\"\"\" libc.srand(seed) arr = list(s) # Iterate backwards for i in range(len(arr) - 1, 0, -1): j = libc.rand() % (i + 1) # Random index from 0 to i arr[i], arr[j] = arr[j], arr[i] # Swap return ''.join(arr) # Example original = \"hello_world\" shuffled = shuffle_string(original, 42) print(f\"Original: {original}\") print(f\"Shuffled: {shuffled}\") Reverse Transformation (What We Need) Key Insight: Record all swap operations, then apply them in reverse order.\ndef unshuffle_string(shuffled, seed): \"\"\"Reverse the shuffle to recover original\"\"\" # Step 1: Record all swaps that were performed libc.srand(seed) # Same seed = same sequence swaps = [] for i in range(len(shuffled) - 1, 0, -1): j = libc.rand() % (i + 1) swaps.append((i, j)) # Record each swap # Step 2: Apply swaps in REVERSE order arr = list(shuffled) for i, j in reversed(swaps): arr[i], arr[j] = arr[j], arr[i] # Undo the swap return ''.join(arr) # Example: Recover original from shuffled shuffled = \"some_scrambled_text\" original = unshuffle_string(shuffled, 42) print(f\"Recovered: {original}\") Why This Works: rand() Determinism Critical Property: rand() with the same seed always produces the same sequence.\n# Test determinism libc.srand(42) r1 = libc.rand() r2 = libc.rand() r3 = libc.rand() # Reset and generate again libc.srand(42) r4 = libc.rand() r5 = libc.rand() r6 = libc.rand() print(r1 == r4) # True print(r2 == r5) # True print(r3 == r6) # True Implications:\nShuffle pattern is 100% reproducible We can replay the exact same swaps We can reverse them perfectly Security Note: ⚠️ This is why rand() should NEVER be used for cryptography or security!\nTools \u0026 Techniques Python for Reversing from ctypes import CDLL # Load libc to match C's rand() libc = CDLL(\"libc.so.6\") # Always use same seed as binary libc.srand(seed_from_binary) # Implement reverse logic Summary 45exiles Shuffle demonstrates a critical CTF concept: transformation-based validation.\nThe Strategy:\nInput transformation prevents direct memory reading Must implement reverse transformation rand() determinism enables perfect reversal Work backwards: target → reverse() → answer Remember: When input is transformed before comparison, there’s no shortcut - you must reverse the transformation to find the original input.\n","wordCount":"885","inLanguage":"en","datePublished":"2025-11-14T00:00:00Z","dateModified":"2025-11-14T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/ctf/2025-11-14-ctf-3/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CTF – 3 : 45exiles Shuffle</h1><div class=post-meta><span title='2025-11-14 00:00:00 +0000 UTC'>November 14, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/ctf/2025-11-14-ctf-3.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ctf-writeup-45exiles-shuffle-challenge aria-label="CTF Writeup: 45exiles Shuffle Challenge">CTF Writeup: 45exiles Shuffle Challenge</a><ul><li><a href=#problem-overview aria-label="Problem Overview">Problem Overview</a><ul><li><a href=#disassembly-of-key-functions aria-label="Disassembly of key functions">Disassembly of key functions</a></li></ul></li><li><a href=#the-main-strategy aria-label="The Main Strategy">The Main Strategy</a><ul><li><a href=#why-you-cant-just-read-memory aria-label="Why You Can&rsquo;t Just Read Memory">Why You Can&rsquo;t Just Read Memory</a></li></ul></li><li><a href=#understanding-input-transformations aria-label="Understanding Input Transformations">Understanding Input Transformations</a><ul><li><a href=#scenario-1-direct-comparison-can-read-answer aria-label="Scenario 1: Direct Comparison (Can Read Answer)">Scenario 1: Direct Comparison (Can Read Answer)</a></li><li><a href=#scenario-2-transformed-input-must-reverse aria-label="Scenario 2: Transformed Input (Must Reverse)">Scenario 2: Transformed Input (Must Reverse)</a></li></ul></li><li><a href=#the-shuffle-algorithm aria-label="The Shuffle Algorithm">The Shuffle Algorithm</a><ul><li><a href=#forward-transformation-what-program-does aria-label="Forward Transformation (What Program Does)">Forward Transformation (What Program Does)</a></li><li><a href=#reverse-transformation-what-we-need aria-label="Reverse Transformation (What We Need)">Reverse Transformation (What We Need)</a></li></ul></li><li><a href=#why-this-works-rand-determinism aria-label="Why This Works: rand() Determinism">Why This Works: rand() Determinism</a></li><li><a href=#tools--techniques aria-label="Tools & Techniques">Tools & Techniques</a><ul><li><a href=#python-for-reversing aria-label="Python for Reversing">Python for Reversing</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=ctf-writeup-45exiles-shuffle-challenge>CTF Writeup: 45exiles Shuffle Challenge<a hidden class=anchor aria-hidden=true href=#ctf-writeup-45exiles-shuffle-challenge>#</a></h1><h2 id=problem-overview>Problem Overview<a hidden class=anchor aria-hidden=true href=#problem-overview>#</a></h2><p><strong>Challenge Name</strong>: 45exiles Shuffle</p><p><strong>Core Mechanism</strong>:</p><ul><li>Program reads user input</li><li><strong>Shuffles the input</strong> using <code>rand()</code> with a known seed</li><li>Compares the shuffled input against a target string stored in memory</li><li>If they match, you get the flag</li></ul><p><strong>Key Insight</strong>: You can read the target (shuffled) string from memory, but that&rsquo;s NOT the answer you need to input. You must <strong>reverse the shuffle</strong> to find the original input.</p><h3 id=disassembly-of-key-functions>Disassembly of key functions<a hidden class=anchor aria-hidden=true href=#disassembly-of-key-functions>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>[<span style=color:#ae81ff>0x00001160</span>]<span style=color:#f92672>&gt;</span> pdg <span style=color:#960050;background-color:#1e0010>@</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ulong <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    uint uVar1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> iVar2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int64_t</span> iVar3;
</span></span><span style=display:flex><span>    ulong uVar4;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> uVar5;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int64_t</span> in_FS_OFFSET;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> iStack_244;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> iStack_240;
</span></span><span style=display:flex><span>    uchar auStack_228 [<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    uchar auStack_128 [<span style=color:#ae81ff>255</span>];
</span></span><span style=display:flex><span>    uchar uStack_29;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int64_t</span> iStack_20;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    iStack_20 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(in_FS_OFFSET <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x28</span>);
</span></span><span style=display:flex><span>    iStack_244 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    sym.imp.<span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;Enter the password please :&#34;</span>);
</span></span><span style=display:flex><span>    iVar3 <span style=color:#f92672>=</span> sym.imp.<span style=color:#a6e22e>fgets</span>(auStack_228,<span style=color:#ae81ff>0x100</span>,_reloc.stdin);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (iVar3 <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        uVar4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        iVar3 <span style=color:#f92672>=</span> sym.imp.<span style=color:#a6e22e>strcspn</span>(auStack_228,<span style=color:#ae81ff>0x2028</span>);
</span></span><span style=display:flex><span>        auStack_228[iVar3] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        sym.imp.<span style=color:#a6e22e>strncpy</span>(auStack_128,auStack_228,<span style=color:#ae81ff>0xff</span>);
</span></span><span style=display:flex><span>        uStack_29 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        iStack_240 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>( true ) {
</span></span><span style=display:flex><span>            uVar5 <span style=color:#f92672>=</span> sym.imp.<span style=color:#a6e22e>strlen</span>(<span style=color:#e6db74>&#34;Gommage&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (uVar5 <span style=color:#f92672>&lt;=</span> iStack_240) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            iStack_244 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Gommage&#34;</span>[iStack_240] <span style=color:#f92672>+</span> iStack_244 <span style=color:#f92672>*</span> <span style=color:#ae81ff>0x1f</span>;
</span></span><span style=display:flex><span>            iStack_240 <span style=color:#f92672>=</span> iStack_240 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        uVar1 <span style=color:#f92672>=</span> sym.imp.<span style=color:#a6e22e>strlen</span>(auStack_128);
</span></span><span style=display:flex><span>        fcn<span style=color:#ae81ff>.00001249</span>(auStack_128,uVar1,iStack_244);
</span></span><span style=display:flex><span>        iVar2 <span style=color:#f92672>=</span> sym.imp.<span style=color:#a6e22e>strcmp</span>(<span style=color:#e6db74>&#34;Ygta_u3G_t0h_0aG_r3&#34;</span>,auStack_128);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (iVar2 <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            sym.imp.<span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;Good Job !&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            sym.imp.<span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;No... Maybe another time !&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        uVar4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (iStack_20 <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(in_FS_OFFSET <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x28</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//WARNING: Subroutine does not return
</span></span></span><span style=display:flex><span>        sym.imp.<span style=color:#a6e22e>__stack_chk_fail</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> uVar4;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>[<span style=color:#ae81ff>0x00001160</span>]<span style=color:#f92672>&gt;</span> pdg <span style=color:#960050;background-color:#1e0010>@</span> fcn<span style=color:#ae81ff>.00001249</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shuffle</span>(<span style=color:#66d9ef>int64_t</span> param_1,<span style=color:#66d9ef>int</span> param_2,uint param_3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    uchar uVar1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> iVar2;
</span></span><span style=display:flex><span>    uint uStack_10;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((param_1 <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;</span> param_2)) {
</span></span><span style=display:flex><span>        sym.imp.<span style=color:#a6e22e>srand</span>(param_3);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (uStack_10 <span style=color:#f92672>=</span> param_2 <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>; <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;</span> uStack_10; uStack_10 <span style=color:#f92672>=</span> uStack_10 <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            iVar2 <span style=color:#f92672>=</span> sym.imp.<span style=color:#a6e22e>rand</span>();
</span></span><span style=display:flex><span>            iVar2 <span style=color:#f92672>=</span> iVar2 <span style=color:#f92672>%</span> (uStack_10 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            uVar1 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(param_1 <span style=color:#f92672>+</span> uStack_10);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>(param_1 <span style=color:#f92672>+</span> uStack_10) <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(param_1 <span style=color:#f92672>+</span> iVar2);
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>(iVar2 <span style=color:#f92672>+</span> param_1) <span style=color:#f92672>=</span> uVar1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=the-main-strategy>The Main Strategy<a hidden class=anchor aria-hidden=true href=#the-main-strategy>#</a></h2><h3 id=why-you-cant-just-read-memory>Why You Can&rsquo;t Just Read Memory<a hidden class=anchor aria-hidden=true href=#why-you-cant-just-read-memory>#</a></h3><p>Unlike the previous &ldquo;good kitty&rdquo; challenge where we could directly read the answer from the stack, this challenge applies <strong>transformations to the input before comparison</strong>.</p><pre tabindex=0><code>User Input → [TRANSFORMATION] → Transformed Input → Compare with Target
</code></pre><p>Since the transformation happens AFTER you enter input:</p><ul><li><strong>Target in memory</strong> = What your input should become AFTER shuffling</li><li><strong>Answer you need</strong> = What produces the target AFTER shuffling</li></ul><p><strong>You cannot shortcut this</strong> - you MUST reverse the transformation.</p><h2 id=understanding-input-transformations>Understanding Input Transformations<a hidden class=anchor aria-hidden=true href=#understanding-input-transformations>#</a></h2><h3 id=scenario-1-direct-comparison-can-read-answer>Scenario 1: Direct Comparison (Can Read Answer)<a hidden class=anchor aria-hidden=true href=#scenario-1-direct-comparison-can-read-answer>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Example from &#34;good kitty&#34; challenge
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> flag <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculate_target</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> user_input[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>read</span>(<span style=color:#ae81ff>0</span>, user_input, <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Direct byte-by-byte comparison - NO transformation
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>8</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (user_input[i] <span style=color:#f92672>!=</span> ((<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>flag)[i]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> FAIL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>GDB Solution</strong>: Read the answer directly!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/8c $rbp-0xb8   <span style=color:#75715e># This IS the answer</span>
</span></span></code></pre></div><h3 id=scenario-2-transformed-input-must-reverse>Scenario 2: Transformed Input (Must Reverse)<a hidden class=anchor aria-hidden=true href=#scenario-2-transformed-input-must-reverse>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Example from 45exiles Shuffle
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> target[<span style=color:#ae81ff>20</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;scrambled_target_string&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> user_input[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>read</span>(<span style=color:#ae81ff>0</span>, user_input, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Transform input THEN compare
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> transformed[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span><span style=color:#a6e22e>shuffle</span>(user_input, transformed, seed);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strcmp</span>(transformed, target) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> SUCCESS;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>The Problem</strong>:</p><pre tabindex=0><code>What you can read:  target = &#34;scrambled_target_string&#34;
What you need:      original_input = ???
Relationship:       shuffle(original_input, seed) = target
</code></pre><p><strong>Solution Path</strong>:</p><pre tabindex=0><code>1. Read &#39;target&#39; from memory (GDB/Ghidra)
2. Understand the shuffle algorithm
3. Implement reverse_shuffle()
4. Calculate: original_input = reverse_shuffle(target, seed)
</code></pre><h2 id=the-shuffle-algorithm>The Shuffle Algorithm<a hidden class=anchor aria-hidden=true href=#the-shuffle-algorithm>#</a></h2><h3 id=forward-transformation-what-program-does>Forward Transformation (What Program Does)<a hidden class=anchor aria-hidden=true href=#forward-transformation-what-program-does>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> ctypes <span style=color:#f92672>import</span> CDLL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>libc <span style=color:#f92672>=</span> CDLL(<span style=color:#e6db74>&#34;libc.so.6&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shuffle_string</span>(s, seed):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Apply Fisher-Yates shuffle to string&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    libc<span style=color:#f92672>.</span>srand(seed)
</span></span><span style=display:flex><span>    arr <span style=color:#f92672>=</span> list(s)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Iterate backwards</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(arr) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        j <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand() <span style=color:#f92672>%</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e># Random index from 0 to i</span>
</span></span><span style=display:flex><span>        arr[i], arr[j] <span style=color:#f92672>=</span> arr[j], arr[i]  <span style=color:#75715e># Swap</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(arr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Example</span>
</span></span><span style=display:flex><span>original <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello_world&#34;</span>
</span></span><span style=display:flex><span>shuffled <span style=color:#f92672>=</span> shuffle_string(original, <span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Original: </span><span style=color:#e6db74>{</span>original<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Shuffled: </span><span style=color:#e6db74>{</span>shuffled<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><h3 id=reverse-transformation-what-we-need>Reverse Transformation (What We Need)<a hidden class=anchor aria-hidden=true href=#reverse-transformation-what-we-need>#</a></h3><p><strong>Key Insight</strong>: Record all swap operations, then apply them in <strong>reverse order</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>unshuffle_string</span>(shuffled, seed):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Reverse the shuffle to recover original&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 1: Record all swaps that were performed</span>
</span></span><span style=display:flex><span>    libc<span style=color:#f92672>.</span>srand(seed)  <span style=color:#75715e># Same seed = same sequence</span>
</span></span><span style=display:flex><span>    swaps <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(shuffled) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        j <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand() <span style=color:#f92672>%</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        swaps<span style=color:#f92672>.</span>append((i, j))  <span style=color:#75715e># Record each swap</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Step 2: Apply swaps in REVERSE order</span>
</span></span><span style=display:flex><span>    arr <span style=color:#f92672>=</span> list(shuffled)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, j <span style=color:#f92672>in</span> reversed(swaps):
</span></span><span style=display:flex><span>        arr[i], arr[j] <span style=color:#f92672>=</span> arr[j], arr[i]  <span style=color:#75715e># Undo the swap</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(arr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Example: Recover original from shuffled</span>
</span></span><span style=display:flex><span>shuffled <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;some_scrambled_text&#34;</span>
</span></span><span style=display:flex><span>original <span style=color:#f92672>=</span> unshuffle_string(shuffled, <span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Recovered: </span><span style=color:#e6db74>{</span>original<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><h2 id=why-this-works-rand-determinism>Why This Works: <code>rand()</code> Determinism<a hidden class=anchor aria-hidden=true href=#why-this-works-rand-determinism>#</a></h2><p><strong>Critical Property</strong>: <code>rand()</code> with the same seed <strong>always</strong> produces the same sequence.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Test determinism</span>
</span></span><span style=display:flex><span>libc<span style=color:#f92672>.</span>srand(<span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>r1 <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand()
</span></span><span style=display:flex><span>r2 <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand()
</span></span><span style=display:flex><span>r3 <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reset and generate again</span>
</span></span><span style=display:flex><span>libc<span style=color:#f92672>.</span>srand(<span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>r4 <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand()
</span></span><span style=display:flex><span>r5 <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand()
</span></span><span style=display:flex><span>r6 <span style=color:#f92672>=</span> libc<span style=color:#f92672>.</span>rand()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(r1 <span style=color:#f92672>==</span> r4)  <span style=color:#75715e># True</span>
</span></span><span style=display:flex><span>print(r2 <span style=color:#f92672>==</span> r5)  <span style=color:#75715e># True</span>
</span></span><span style=display:flex><span>print(r3 <span style=color:#f92672>==</span> r6)  <span style=color:#75715e># True</span>
</span></span></code></pre></div><p><strong>Implications</strong>:</p><ul><li>Shuffle pattern is <strong>100% reproducible</strong></li><li>We can <strong>replay</strong> the exact same swaps</li><li>We can <strong>reverse</strong> them perfectly</li></ul><p><strong>Security Note</strong>: ⚠️ This is why <code>rand()</code> should NEVER be used for cryptography or security!</p><h2 id=tools--techniques>Tools & Techniques<a hidden class=anchor aria-hidden=true href=#tools--techniques>#</a></h2><h3 id=python-for-reversing>Python for Reversing<a hidden class=anchor aria-hidden=true href=#python-for-reversing>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> ctypes <span style=color:#f92672>import</span> CDLL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Load libc to match C&#39;s rand()</span>
</span></span><span style=display:flex><span>libc <span style=color:#f92672>=</span> CDLL(<span style=color:#e6db74>&#34;libc.so.6&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Always use same seed as binary</span>
</span></span><span style=display:flex><span>libc<span style=color:#f92672>.</span>srand(seed_from_binary)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Implement reverse logic</span>
</span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p><strong>45exiles Shuffle</strong> demonstrates a critical CTF concept: <strong>transformation-based validation</strong>.</p><p><strong>The Strategy</strong>:</p><ol><li>Input transformation prevents direct memory reading</li><li>Must implement <strong>reverse transformation</strong></li><li><code>rand()</code> determinism enables <strong>perfect reversal</strong></li><li>Work backwards: <code>target → reverse() → answer</code></li></ol><p><strong>Remember</strong>: When input is transformed before comparison, there&rsquo;s <strong>no shortcut</strong> - you must reverse the transformation to find the original input.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/ctf/>Ctf</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse-Engineering</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://crackmes.one/crackme/686f1b56aadb6eeafb399171 target=_blank rel="noopener noreferrer">45exiles Shuffle</a></li></ul></section></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>