<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ELF Format: Part 2 | Sanketh's Blog</title><meta name=keywords content="elf,reverse engineering"><meta name=description content="ELF Format: Segments and Program Header Table
After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.
What Are Segments?
Segments are the runtime view of an ELF file. While sections (which we&rsquo;ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="ELF Format: Part 2"><meta property="og:description" content="ELF Format: Segments and Program Header Table After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.
What Are Segments? Segments are the runtime view of an ELF file. While sections (which we’ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-13T00:00:00+00:00"><meta property="article:tag" content="Elf"><meta property="article:tag" content="Reverse-Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELF Format: Part 2"><meta name=twitter:description content="ELF Format: Segments and Program Header Table
After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.
What Are Segments?
Segments are the runtime view of an ELF file. While sections (which we&rsquo;ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"ELF Format: Part 2","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ELF Format: Part 2","name":"ELF Format: Part 2","description":"ELF Format: Segments and Program Header Table After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.\nWhat Are Segments? Segments are the runtime view of an ELF file. While sections (which we\u0026rsquo;ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program.\n","keywords":["elf","reverse engineering"],"articleBody":"ELF Format: Segments and Program Header Table After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.\nWhat Are Segments? Segments are the runtime view of an ELF file. While sections (which we’ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program.\nKey points about segments: Segments define what gets loaded into memory and where Each segment specifies permissions (read, write, execute) Only PT_LOAD segments actually allocate memory Other segment types provide metadata or point to data within PT_LOAD segments Segments can overlap with each other in the file and in memory Program Header Table Program Header Table Location The ELF Header tells us everything we need to find the Program Header Table:\nLocation (file offset): e_phoff field in ELF Header Entry size: e_phentsize (32 bytes for 32-bit ELF, 56 bytes for 64-bit ELF) Number of entries: e_phnum Total table size = e_phentsize × e_phnum\n$ readelf -h main | grep \"program headers\" Start of program headers: 64 (bytes into file) Size of program headers: 56 (bytes) Number of program headers: 13 This means:\nProgram Header Table starts at offset 0x40 (64 bytes) Each entry is 56 bytes There are 13 entries Total table size: 56 × 13 = 728 bytes Program Header Entry Structure Each entry in the Program Header Table describes one segment. Here’s the structure defined in the Linux kernel:\ntypedef struct elf32_phdr { Elf32_Word\tp_type; // Segment type Elf32_Off\tp_offset; // File offset where segment begins Elf32_Addr\tp_vaddr; // Virtual address where segment is loaded Elf32_Addr\tp_paddr; // Physical address (rarely used) Elf32_Word\tp_filesz; // Size of segment in file Elf32_Word\tp_memsz; // Size of segment in memory Elf32_Word\tp_flags; // Segment permissions (R/W/X) Elf32_Word\tp_align; // Alignment requirement } Elf32_Phdr; typedef struct elf64_phdr { Elf64_Word p_type; // Segment type Elf64_Word p_flags; // Segment permissions (R/W/X) Elf64_Off p_offset; // File offset where segment begins Elf64_Addr p_vaddr; // Virtual address where segment is loaded Elf64_Addr p_paddr; // Physical address (rarely used) Elf64_Xword p_filesz; // Size of segment in file Elf64_Xword p_memsz; // Size of segment in memory Elf64_Xword p_align; // Alignment requirement } Elf64_Phdr; Note: The order of p_flags differs between 32-bit and 64-bit structures!\nProgram Header Fields Explained 1. p_type - Segment Type Identifies the type of segment. Common types:\nValue Name Description 0 PT_NULL Unused entry 1 PT_LOAD Loadable segment (actually loaded into memory) 2 PT_DYNAMIC Dynamic linking information 3 PT_INTERP Path to program interpreter (dynamic linker) 4 PT_NOTE Auxiliary information 6 PT_PHDR Program header table itself 7 PT_TLS Thread-local storage 2. p_offset - File Offset The byte offset from the beginning of the file where this segment’s data begins. Example: p_offset = 0x1000 means the segment data starts at byte 4096 in the file.\n3. p_vaddr - Virtual Address The virtual memory address where this segment will be loaded. Example: p_vaddr = 0x400000 means this segment will appear at address 0x400000 in the process’s virtual memory space.\n4. p_paddr - Physical Address Physical memory address (mostly relevant for embedded systems and firmware). Usually ignored for regular executables and set to the same value as p_vaddr.\n5. p_filesz - Size in File The number of bytes this segment occupies in the file. If p_filesz = 0, the segment has no data in the file (but may still occupy memory).\n6. p_memsz - Size in Memory The number of bytes this segment will occupy in memory.\nImportant: p_memsz can be larger than p_filesz!\nExtra bytes are zero-initialized This is how .bss (uninitialized data) works Example: p_filesz = 0x100, p_memsz = 0x300 → 256 bytes from file + 512 bytes of zeros 7. p_flags - Permissions Segment permissions, using these flags:\nFlag Value Meaning PF_X 0x1 Executable PF_W 0x2 Writable PF_R 0x4 Readable Flags are combined with bitwise OR:\n0x5 (PF_R | PF_X) = Read + Execute (code segment) 0x6 (PF_R | PF_W) = Read + Write (data segment) 0x4 (PF_R) = Read-only (const data) 8. p_align - Alignment Specifies alignment requirements for the segment.\nMust be a power of 2 Common values: 0x1000 (4 KB, page size on x86-64) p_vaddr and p_offset must be congruent modulo p_align Common Segment Types in Detail 1. PT_LOAD - Loadable Segments The most important segment type! These are the only segments that actually allocate memory and get loaded by the OS. Typical PT_LOAD segments in an executable:\n1. Code Segment (Text) Contains executable code Flags: R-X (Read + Execute) Usually starts at 0x400000 (non-PIE) or a randomized address (PIE) Includes: .text, .plt, .rodata sections 2. Data Segment Contains initialized and uninitialized data Flags: RW- (Read + Write) Includes: .data, .bss, .got sections p_memsz \u003e p_filesz (size of segment in memory will be greater than size of segment in ELF file) for .bss (zero-initialized data) Why Code and Data Segments Are Separated in ELF?\nCode pages are marked read + execute (r-x), while data pages are read + write (rw-). Separating them allows the OS to set page-level protections using the hardware’s memory management unit (MMU). This prevents bugs or exploits (like buffer overflows) from executing injected data. Read-only code can be shared across multiple processes, while writable data must be private to each process. 2. PT_DYNAMIC - Dynamic Linking Information PT_DYNAMIC is a program header segment that points to the .dynamic section of an ELF file. This section contains metadata used by the dynamic linker (like /lib64/ld-linux-x86-64.so.2) to load and relocate shared libraries at runtime.\nYou can think of it as a “table of contents” for everything the dynamic loader needs to know about an executable or shared library.\nImportant: This segment does NOT allocate new memory - it points to data within a PT_LOAD segment.\nELF File │ ├── PT_LOAD (code + data) │ ├── .text │ ├── .rodata │ └── .dynamic ← PT_DYNAMIC points here │ ├── PT_INTERP → Path to dynamic linker ├── PT_DYNAMIC → Contains tags about dynamic linking └── ... How the Dynamic Linker Uses PT_DYNAMIC?\nProgram starts → kernel loads ELF → sees PT_INTERP. The interpreter (dynamic linker) is loaded (e.g. /lib64/ld-linux-x86-64.so.2). The linker reads the PT_DYNAMIC segment to find: Which shared libraries to load (DT_NEEDED) Where symbol tables and relocations are The linker maps the required .so files, performs relocations, resolves symbols, and prepares the GOT/PLT. Finally, control transfers to the program’s _start. 3. PT_INTERP - Program Interpreter The PT_INTERP segment tells the kernel which program should interpret and load this ELF file — usually the dynamic linker.\nIt contains a path string, typically something like: /lib64/ld-linux-x86-64.so.2. This string is null-terminated and stored inside the ELF file’s .interp section. The Program Header Table entry of type PT_INTERP points directly to it (via its offset).\nKey distinction:\nPIE executables: Have PT_INTERP segment Shared libraries: Do NOT have PT_INTERP segment Both have type ET_DYN, but PT_INTERP tells them apart Role during Program Startup When you run an ELF executable:\nThe kernel reads the ELF header, finds a PT_INTERP entry. The kernel does not run your program directly — instead, it: Loads your ELF into memory. Loads the specified interpreter (usually ld-linux.so). Passes control to that interpreter, along with: The program’s memory mappings. The file descriptor. Auxiliary vectors (system info). The interpreter (dynamic linker) then: Resolves shared library dependencies. Performs relocations. Finally jumps to the executable’s entry point. When does Control Transfer to Interpreter Happens?\nThe control transfers immediately to the dynamic linker, before your program starts executing any of its own code.\nHere’s what happens internally:\nKernel loads your ELF file. Reads ELF header → finds PT_INTERP segment. Sees that the program needs a dynamic linker. Kernel loads the interpreter (ld-linux.so) into memory. The path comes from the PT_INTERP string (e.g. /lib64/ld-linux-x86-64.so.2). The linker itself is also an ELF executable. Kernel sets up the process: Maps your program’s PT_LOAD segments into memory (code, data, etc.). Maps the dynamic linker (ld-linux.so) into memory. Prepares stack and auxiliary vectors (program name, environment, etc.). Kernel sets the entry point to the linker, not your program. So the first instruction that runs in user space belongs to the dynamic linker, not to your program. Dynamic linker (user-space loader) takes over: Reads your program’s .dynamic section. Finds all needed shared libraries (libc.so, etc.). Loads them into memory. Applies relocations. Resolves symbol addresses. After everything is ready… The linker finally jumps to your program’s real entry point (the one shown in readelf -h). 4. PT_NOTE - Auxiliary Information Contains auxiliary information for the system:\nBuild ID: Unique identifier for the binary ABI tags: Operating system version requirements GNU properties: Compiler flags, security features Used by debuggers, package managers, and system tools Example:\n$ readelf -n main Displaying notes found in: .note.gnu.property Owner Data size Description GNU 0x00000020\tNT_GNU_PROPERTY_TYPE_0 Properties: x86 feature: IBT, SHSTK x86 ISA needed: x86-64-baseline Displaying notes found in: .note.gnu.build-id Owner Data size Description GNU 0x00000014\tNT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 99eff4059570e3f6b152fcc4b3044bdbd9a3087f Displaying notes found in: .note.ABI-tag Owner Data size Description GNU 0x00000010\tNT_GNU_ABI_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 5. PT_PHDR - Program Header Table Location Specifies where the program header table itself will be in memory.\nSelf-referential: This segment describes where to find the segment table!\nWhy it exists:\nThe dynamic linker needs to access program headers at runtime This segment tells it the memory address where they’re loaded Enables runtime introspection of the program structure But doesn’t ELF header already specifies address of program header table?\nThe ELF header has:\ne_phoff: file offset of the program header table e_phnum: number of entries e_phentsize: size of each entry This helps the OS loader (like the kernel) find and load the segments from the file into memory.\nOnce the executable is loaded, those headers are relocated into virtual memory. The dynamic linker (and sometimes the program itself) might need to find them after relocation, i.e., in memory space — not the original file offset.\nThat’s where PT_PHDR comes in.\nIt’s a runtime reference that tells where the program header table was loaded into memory. The kernel sets up this mapping when it loads the ELF. 6. PT_TLS - Thread-Local Storage Contains the initialization template for thread-local variables.\nEach thread gets its own copy of this data Used by __thread keyword in C/C++ Managed by the threading library (e.g., pthread) Example:\n__thread int my_thread_var = 42; // Each thread has separate copy ","wordCount":"1743","inLanguage":"en","datePublished":"2025-10-13T00:00:00Z","dateModified":"2025-10-13T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-13-elf-format-part-2/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ELF Format: Part 2</h1><div class=post-meta><span title='2025-10-13 00:00:00 +0000 UTC'>October 13, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/2025-10-13-elf-format-part-2.markdown rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elf-format-segments-and-program-header-table aria-label="ELF Format: Segments and Program Header Table">ELF Format: Segments and Program Header Table</a><ul><li><a href=#what-are-segments aria-label="What Are Segments?">What Are Segments?</a><ul><li><a href=#key-points-about-segments aria-label="Key points about segments:">Key points about segments:</a></li></ul></li><li><a href=#program-header-table aria-label="Program Header Table">Program Header Table</a><ul><li><a href=#program-header-table-location aria-label="Program Header Table Location">Program Header Table Location</a></li><li><a href=#program-header-entry-structure aria-label="Program Header Entry Structure">Program Header Entry Structure</a></li><li><a href=#program-header-fields-explained aria-label="Program Header Fields Explained">Program Header Fields Explained</a><ul><li><a href=#1-p_type---segment-type aria-label="1. p_type - Segment Type">1. p_type - Segment Type</a></li><li><a href=#2-p_offset---file-offset aria-label="2. p_offset - File Offset">2. p_offset - File Offset</a></li><li><a href=#3-p_vaddr---virtual-address aria-label="3. p_vaddr - Virtual Address">3. p_vaddr - Virtual Address</a></li><li><a href=#4-p_paddr---physical-address aria-label="4. p_paddr - Physical Address">4. p_paddr - Physical Address</a></li><li><a href=#5-p_filesz---size-in-file aria-label="5. p_filesz - Size in File">5. p_filesz - Size in File</a></li><li><a href=#6-p_memsz---size-in-memory aria-label="6. p_memsz - Size in Memory">6. p_memsz - Size in Memory</a></li><li><a href=#7-p_flags---permissions aria-label="7. p_flags - Permissions">7. p_flags - Permissions</a></li><li><a href=#8-p_align---alignment aria-label="8. p_align - Alignment">8. p_align - Alignment</a></li></ul></li><li><a href=#common-segment-types-in-detail aria-label="Common Segment Types in Detail">Common Segment Types in Detail</a><ul><li><a href=#1-pt_load---loadable-segments aria-label="1. PT_LOAD - Loadable Segments">1. PT_LOAD - Loadable Segments</a><ul><li><a href=#1-code-segment-text aria-label="1. Code Segment (Text)">1. Code Segment (Text)</a></li><li><a href=#2-data-segment aria-label="2. Data Segment">2. Data Segment</a></li></ul></li><li><a href=#2-pt_dynamic---dynamic-linking-information aria-label="2. PT_DYNAMIC - Dynamic Linking Information">2. PT_DYNAMIC - Dynamic Linking Information</a></li><li><a href=#3-pt_interp---program-interpreter aria-label="3. PT_INTERP - Program Interpreter">3. PT_INTERP - Program Interpreter</a><ul><li><a href=#role-during-program-startup aria-label="Role during Program Startup">Role during Program Startup</a></li></ul></li><li><a href=#4-pt_note---auxiliary-information aria-label="4. PT_NOTE - Auxiliary Information">4. PT_NOTE - Auxiliary Information</a></li><li><a href=#5-pt_phdr---program-header-table-location aria-label="5. PT_PHDR - Program Header Table Location">5. PT_PHDR - Program Header Table Location</a></li><li><a href=#6-pt_tls---thread-local-storage aria-label="6. PT_TLS - Thread-Local Storage">6. PT_TLS - Thread-Local Storage</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=elf-format-segments-and-program-header-table>ELF Format: Segments and Program Header Table<a hidden class=anchor aria-hidden=true href=#elf-format-segments-and-program-header-table>#</a></h1><p>After understanding the ELF Header, the next critical component is the Program Header Table. This table describes segments - the portions of the file that will be loaded into memory when the program executes.</p><h2 id=what-are-segments>What Are Segments?<a hidden class=anchor aria-hidden=true href=#what-are-segments>#</a></h2><p>Segments are the runtime view of an ELF file. While sections (which we&rsquo;ll cover later) are used during linking and debugging, segments are what the operating system cares about when loading and executing a program.</p><h3 id=key-points-about-segments>Key points about segments:<a hidden class=anchor aria-hidden=true href=#key-points-about-segments>#</a></h3><ul><li>Segments define what gets loaded into memory and where</li><li>Each segment specifies permissions (read, write, execute)</li><li>Only PT_LOAD segments actually allocate memory</li><li>Other segment types provide metadata or point to data within PT_LOAD segments</li><li>Segments can overlap with each other in the file and in memory</li></ul><h2 id=program-header-table>Program Header Table<a hidden class=anchor aria-hidden=true href=#program-header-table>#</a></h2><h3 id=program-header-table-location>Program Header Table Location<a hidden class=anchor aria-hidden=true href=#program-header-table-location>#</a></h3><p>The ELF Header tells us everything we need to find the Program Header Table:</p><ul><li>Location (file offset): e_phoff field in ELF Header</li><li>Entry size: e_phentsize (32 bytes for 32-bit ELF, 56 bytes for 64-bit ELF)</li><li>Number of entries: e_phnum</li></ul><p>Total table size = e_phentsize × e_phnum</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep <span style=color:#e6db74>&#34;program headers&#34;</span>
</span></span><span style=display:flex><span>  Start of program headers:          <span style=color:#ae81ff>64</span> <span style=color:#f92672>(</span>bytes into file<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Size of program headers:           <span style=color:#ae81ff>56</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Number of program headers:         <span style=color:#ae81ff>13</span>
</span></span></code></pre></div><p>This means:</p><ul><li>Program Header Table starts at offset 0x40 (64 bytes)</li><li>Each entry is 56 bytes</li><li>There are 13 entries</li><li>Total table size: 56 × 13 = 728 bytes</li></ul><h3 id=program-header-entry-structure>Program Header Entry Structure<a hidden class=anchor aria-hidden=true href=#program-header-entry-structure>#</a></h3><p>Each entry in the Program Header Table describes one segment. Here&rsquo;s the structure defined in the Linux kernel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf32_phdr {
</span></span><span style=display:flex><span>  Elf32_Word	p_type;      <span style=color:#75715e>// Segment type
</span></span></span><span style=display:flex><span>  Elf32_Off	    p_offset;    <span style=color:#75715e>// File offset where segment begins
</span></span></span><span style=display:flex><span>  Elf32_Addr	p_vaddr;     <span style=color:#75715e>// Virtual address where segment is loaded
</span></span></span><span style=display:flex><span>  Elf32_Addr	p_paddr;     <span style=color:#75715e>// Physical address (rarely used)
</span></span></span><span style=display:flex><span>  Elf32_Word	p_filesz;    <span style=color:#75715e>// Size of segment in file
</span></span></span><span style=display:flex><span>  Elf32_Word	p_memsz;     <span style=color:#75715e>// Size of segment in memory
</span></span></span><span style=display:flex><span>  Elf32_Word	p_flags;     <span style=color:#75715e>// Segment permissions (R/W/X)
</span></span></span><span style=display:flex><span>  Elf32_Word	p_align;     <span style=color:#75715e>// Alignment requirement
</span></span></span><span style=display:flex><span>} Elf32_Phdr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf64_phdr {
</span></span><span style=display:flex><span>  Elf64_Word p_type;       <span style=color:#75715e>// Segment type
</span></span></span><span style=display:flex><span>  Elf64_Word p_flags;      <span style=color:#75715e>// Segment permissions (R/W/X)
</span></span></span><span style=display:flex><span>  Elf64_Off p_offset;      <span style=color:#75715e>// File offset where segment begins
</span></span></span><span style=display:flex><span>  Elf64_Addr p_vaddr;      <span style=color:#75715e>// Virtual address where segment is loaded
</span></span></span><span style=display:flex><span>  Elf64_Addr p_paddr;      <span style=color:#75715e>// Physical address (rarely used)
</span></span></span><span style=display:flex><span>  Elf64_Xword p_filesz;    <span style=color:#75715e>// Size of segment in file
</span></span></span><span style=display:flex><span>  Elf64_Xword p_memsz;     <span style=color:#75715e>// Size of segment in memory
</span></span></span><span style=display:flex><span>  Elf64_Xword p_align;     <span style=color:#75715e>// Alignment requirement
</span></span></span><span style=display:flex><span>} Elf64_Phdr;
</span></span></code></pre></div><p>Note: The order of p_flags differs between 32-bit and 64-bit structures!</p><h3 id=program-header-fields-explained>Program Header Fields Explained<a hidden class=anchor aria-hidden=true href=#program-header-fields-explained>#</a></h3><h4 id=1-p_type---segment-type>1. p_type - Segment Type<a hidden class=anchor aria-hidden=true href=#1-p_type---segment-type>#</a></h4><p>Identifies the type of segment. Common types:</p><table><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>PT_NULL</td><td>Unused entry</td></tr><tr><td>1</td><td>PT_LOAD</td><td>Loadable segment (actually loaded into memory)</td></tr><tr><td>2</td><td>PT_DYNAMIC</td><td>Dynamic linking information</td></tr><tr><td>3</td><td>PT_INTERP</td><td>Path to program interpreter (dynamic linker)</td></tr><tr><td>4</td><td>PT_NOTE</td><td>Auxiliary information</td></tr><tr><td>6</td><td>PT_PHDR</td><td>Program header table itself</td></tr><tr><td>7</td><td>PT_TLS</td><td>Thread-local storage</td></tr></tbody></table><h4 id=2-p_offset---file-offset>2. p_offset - File Offset<a hidden class=anchor aria-hidden=true href=#2-p_offset---file-offset>#</a></h4><p>The byte offset from the beginning of the file where this segment&rsquo;s data begins. Example: p_offset = 0x1000 means the segment data starts at byte 4096 in the file.</p><h4 id=3-p_vaddr---virtual-address>3. p_vaddr - Virtual Address<a hidden class=anchor aria-hidden=true href=#3-p_vaddr---virtual-address>#</a></h4><p>The virtual memory address where this segment will be loaded. Example: <code>p_vaddr = 0x400000</code> means this segment will appear at address <code>0x400000</code> in the process&rsquo;s virtual memory space.</p><h4 id=4-p_paddr---physical-address>4. p_paddr - Physical Address<a hidden class=anchor aria-hidden=true href=#4-p_paddr---physical-address>#</a></h4><p>Physical memory address (mostly relevant for embedded systems and firmware). Usually ignored for regular executables and set to the same value as <code>p_vaddr</code>.</p><h4 id=5-p_filesz---size-in-file>5. p_filesz - Size in File<a hidden class=anchor aria-hidden=true href=#5-p_filesz---size-in-file>#</a></h4><p>The number of bytes this segment occupies in the file. If <code>p_filesz = 0</code>, the segment has no data in the file (but may still occupy memory).</p><h4 id=6-p_memsz---size-in-memory>6. p_memsz - Size in Memory<a hidden class=anchor aria-hidden=true href=#6-p_memsz---size-in-memory>#</a></h4><p>The number of bytes this segment will occupy in memory.</p><p><strong>Important: <code>p_memsz</code> can be larger than <code>p_filesz</code>!</strong></p><ul><li>Extra bytes are zero-initialized</li><li>This is how <code>.bss</code> (uninitialized data) works</li><li>Example: <code>p_filesz = 0x100</code>, <code>p_memsz = 0x300</code> → 256 bytes from file + 512 bytes of zeros</li></ul><h4 id=7-p_flags---permissions>7. p_flags - Permissions<a hidden class=anchor aria-hidden=true href=#7-p_flags---permissions>#</a></h4><p>Segment permissions, using these flags:</p><table><thead><tr><th>Flag</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>PF_X</td><td>0x1</td><td>Executable</td></tr><tr><td>PF_W</td><td>0x2</td><td>Writable</td></tr><tr><td>PF_R</td><td>0x4</td><td>Readable</td></tr></tbody></table><p>Flags are combined with bitwise OR:</p><ul><li><code>0x5 (PF_R | PF_X)</code> = Read + Execute (code segment)</li><li><code>0x6 (PF_R | PF_W)</code> = Read + Write (data segment)</li><li><code>0x4 (PF_R)</code> = Read-only (const data)</li></ul><h4 id=8-p_align---alignment>8. p_align - Alignment<a hidden class=anchor aria-hidden=true href=#8-p_align---alignment>#</a></h4><p>Specifies alignment requirements for the segment.</p><ul><li>Must be a power of 2</li><li>Common values: 0x1000 (4 KB, page size on x86-64)</li><li><code>p_vaddr</code> and <code>p_offset</code> must be congruent modulo <code>p_align</code></li></ul><h3 id=common-segment-types-in-detail>Common Segment Types in Detail<a hidden class=anchor aria-hidden=true href=#common-segment-types-in-detail>#</a></h3><h4 id=1-pt_load---loadable-segments>1. PT_LOAD - Loadable Segments<a hidden class=anchor aria-hidden=true href=#1-pt_load---loadable-segments>#</a></h4><p>The most important segment type! These are the only segments that actually allocate memory and get loaded by the OS.
Typical PT_LOAD segments in an executable:</p><h5 id=1-code-segment-text>1. Code Segment (Text)<a hidden class=anchor aria-hidden=true href=#1-code-segment-text>#</a></h5><ul><li>Contains executable code</li><li>Flags: R-X (Read + Execute)</li><li>Usually starts at <code>0x400000</code> (non-PIE) or a randomized address (PIE)</li><li>Includes: <code>.text</code>, <code>.plt</code>, <code>.rodata</code> sections</li></ul><h5 id=2-data-segment>2. Data Segment<a hidden class=anchor aria-hidden=true href=#2-data-segment>#</a></h5><ul><li>Contains initialized and uninitialized data</li><li>Flags: RW- (Read + Write)</li><li>Includes: <code>.data</code>, <code>.bss</code>, <code>.got</code> sections</li><li><code>p_memsz > p_filesz</code> (size of segment in memory will be greater than size of segment in ELF file) for <code>.bss</code> (zero-initialized data)</li></ul><p><strong>Why Code and Data Segments Are Separated in ELF?</strong></p><ul><li>Code pages are marked read + execute (r-x), while data pages are read + write (rw-). Separating them allows the OS to set page-level protections using the hardware’s memory management unit (MMU). This prevents bugs or exploits (like buffer overflows) from executing injected data.</li><li>Read-only code can be shared across multiple processes, while writable data must be private to each process.</li></ul><h4 id=2-pt_dynamic---dynamic-linking-information>2. PT_DYNAMIC - Dynamic Linking Information<a hidden class=anchor aria-hidden=true href=#2-pt_dynamic---dynamic-linking-information>#</a></h4><p><code>PT_DYNAMIC</code> is a program header segment that points to the <code>.dynamic</code> section of an ELF file.
This section contains metadata used by the dynamic linker (like <code>/lib64/ld-linux-x86-64.so.2</code>) to load and relocate shared libraries at runtime.</p><p>You can think of it as a “table of contents” for everything the dynamic loader needs to know about an executable or shared library.</p><p>Important: This segment does NOT allocate new memory - it points to data within a <code>PT_LOAD</code> segment.</p><pre tabindex=0><code>ELF File
│
├── PT_LOAD (code + data)
│     ├── .text
│     ├── .rodata
│     └── .dynamic  ← PT_DYNAMIC points here
│
├── PT_INTERP       → Path to dynamic linker
├── PT_DYNAMIC      → Contains tags about dynamic linking
└── ...
</code></pre><p><strong>How the Dynamic Linker Uses <code>PT_DYNAMIC</code>?</strong></p><ol><li>Program starts → kernel loads ELF → sees <code>PT_INTERP</code>.</li><li>The interpreter (dynamic linker) is loaded (e.g. <code>/lib64/ld-linux-x86-64.so.2</code>).</li><li>The linker reads the <code>PT_DYNAMIC</code> segment to find:<ul><li>Which shared libraries to load (<code>DT_NEEDED</code>)</li><li>Where symbol tables and relocations are</li></ul></li><li>The linker maps the required <code>.so</code> files, performs relocations, resolves symbols, and prepares the GOT/PLT.</li><li>Finally, control transfers to the program’s <code>_start</code>.</li></ol><h4 id=3-pt_interp---program-interpreter>3. PT_INTERP - Program Interpreter<a hidden class=anchor aria-hidden=true href=#3-pt_interp---program-interpreter>#</a></h4><p>The <code>PT_INTERP</code> segment tells the kernel which program should interpret and load this ELF file — usually the dynamic linker.</p><p>It contains a path string, typically something like: <code>/lib64/ld-linux-x86-64.so.2</code>. This string is null-terminated and stored inside the ELF file’s <code>.interp</code> section. The Program Header Table entry of type <code>PT_INTERP</code> points directly to it (via its offset).</p><p><strong>Key distinction:</strong></p><ul><li>PIE executables: Have <code>PT_INTERP</code> segment</li><li>Shared libraries: Do NOT have <code>PT_INTERP</code> segment</li><li>Both have type <code>ET_DYN</code>, but <code>PT_INTERP</code> tells them apart</li></ul><h5 id=role-during-program-startup>Role during Program Startup<a hidden class=anchor aria-hidden=true href=#role-during-program-startup>#</a></h5><p>When you run an ELF executable:</p><ol><li>The kernel reads the ELF header, finds a <code>PT_INTERP</code> entry.</li><li>The kernel does not run your program directly — instead, it:<ul><li>Loads your ELF into memory.</li><li>Loads the specified interpreter (usually ld-linux.so).</li><li>Passes control to that interpreter, along with:<ul><li>The program’s memory mappings.</li><li>The file descriptor.</li><li>Auxiliary vectors (system info).</li></ul></li></ul></li><li>The interpreter (dynamic linker) then:<ul><li>Resolves shared library dependencies.</li><li>Performs relocations.</li><li>Finally jumps to the executable’s entry point.</li></ul></li></ol><p><strong>When does Control Transfer to Interpreter Happens?</strong></p><p>The control transfers immediately to the dynamic linker, before your program starts executing any of its own code.</p><p>Here’s what happens internally:</p><ol><li>Kernel loads your ELF file.<ul><li>Reads ELF header → finds <code>PT_INTERP</code> segment.</li><li>Sees that the program needs a dynamic linker.</li></ul></li><li>Kernel loads the interpreter (<code>ld-linux.so</code>) into memory.<ul><li>The path comes from the <code>PT_INTERP</code> string (e.g. <code>/lib64/ld-linux-x86-64.so.2</code>).</li><li>The linker itself is also an ELF executable.</li></ul></li><li>Kernel sets up the process:<ul><li>Maps your program’s <code>PT_LOAD</code> segments into memory (code, data, etc.).</li><li>Maps the dynamic linker (<code>ld-linux.so</code>) into memory.</li><li>Prepares stack and auxiliary vectors (program name, environment, etc.).</li></ul></li><li>Kernel sets the entry point to the linker, not your program.<ul><li>So the first instruction that runs in user space belongs to the dynamic linker, not to your program.</li></ul></li><li>Dynamic linker (user-space loader) takes over:<ul><li>Reads your program’s .dynamic section.</li><li>Finds all needed shared libraries (libc.so, etc.).</li><li>Loads them into memory.</li><li>Applies relocations.</li><li>Resolves symbol addresses.</li></ul></li><li>After everything is ready&mldr;<ul><li>The linker finally jumps to your program’s real entry point (the one shown in readelf -h).</li></ul></li></ol><h4 id=4-pt_note---auxiliary-information>4. PT_NOTE - Auxiliary Information<a hidden class=anchor aria-hidden=true href=#4-pt_note---auxiliary-information>#</a></h4><p>Contains auxiliary information for the system:</p><ul><li><strong>Build ID</strong>: Unique identifier for the binary</li><li><strong>ABI tags</strong>: Operating system version requirements</li><li><strong>GNU properties</strong>: Compiler flags, security features</li><li>Used by debuggers, package managers, and system tools</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -n main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Displaying notes found in: .note.gnu.property
</span></span><span style=display:flex><span>  Owner                Data size 	Description
</span></span><span style=display:flex><span>  GNU                  0x00000020	NT_GNU_PROPERTY_TYPE_0
</span></span><span style=display:flex><span>      Properties: x86 feature: IBT, SHSTK
</span></span><span style=display:flex><span>	x86 ISA needed: x86-64-baseline
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Displaying notes found in: .note.gnu.build-id
</span></span><span style=display:flex><span>  Owner                Data size 	Description
</span></span><span style=display:flex><span>  GNU                  0x00000014	NT_GNU_BUILD_ID <span style=color:#f92672>(</span>unique build ID bitstring<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    Build ID: 99eff4059570e3f6b152fcc4b3044bdbd9a3087f
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Displaying notes found in: .note.ABI-tag
</span></span><span style=display:flex><span>  Owner                Data size 	Description
</span></span><span style=display:flex><span>  GNU                  0x00000010	NT_GNU_ABI_TAG <span style=color:#f92672>(</span>ABI version tag<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    OS: Linux, ABI: 3.2.0
</span></span></code></pre></div><h4 id=5-pt_phdr---program-header-table-location>5. PT_PHDR - Program Header Table Location<a hidden class=anchor aria-hidden=true href=#5-pt_phdr---program-header-table-location>#</a></h4><p>Specifies where the program header table itself will be in memory.</p><p><strong>Self-referential:</strong> This segment describes where to find the segment table!</p><p><strong>Why it exists:</strong></p><ul><li>The dynamic linker needs to access program headers at runtime</li><li>This segment tells it the memory address where they&rsquo;re loaded</li><li>Enables runtime introspection of the program structure</li></ul><p><strong>But doesn&rsquo;t ELF header already specifies address of program header table?</strong></p><p>The ELF header has:</p><ul><li><code>e_phoff</code>: file offset of the program header table</li><li><code>e_phnum</code>: number of entries</li><li><code>e_phentsize</code>: size of each entry</li></ul><p>This helps the OS loader (like the kernel) find and load the segments from the file into memory.</p><p>Once the executable is loaded, those headers are relocated into virtual memory.
The dynamic linker (and sometimes the program itself) might need to find them after relocation, i.e., in memory space — not the original file offset.</p><p>That’s where PT_PHDR comes in.</p><ul><li>It’s a runtime reference that tells where the program header table was loaded into memory.</li><li>The kernel sets up this mapping when it loads the ELF.</li></ul><h4 id=6-pt_tls---thread-local-storage>6. PT_TLS - Thread-Local Storage<a hidden class=anchor aria-hidden=true href=#6-pt_tls---thread-local-storage>#</a></h4><p>Contains the initialization template for thread-local variables.</p><ul><li>Each thread gets its own copy of this data</li><li>Used by <code>__thread</code> keyword in C/C++</li><li>Managed by the threading library (e.g., pthread)</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>__thread <span style=color:#66d9ef>int</span> my_thread_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;  <span style=color:#75715e>// Each thread has separate copy
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/elf/>Elf</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse-Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>