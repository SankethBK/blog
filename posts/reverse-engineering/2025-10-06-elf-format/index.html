<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ELF Format: Part 1 | Sanketh's Blog</title><meta name=keywords content="elf,reverse engineering"><meta name=description content="ELF Format: ELF Header
What is ELF?
ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:

Executable files (a.out, /bin/ls)
Object files (.o)
Shared libraries (.so)
Core dumps

It’s a container format that describes:

What parts of the file get loaded into memory,
Where execution starts,
How relocations and dynamic linking are handled.
Contains useful information for the debuggers.

General Structure of an ELF File
An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="ELF Format: Part 1"><meta property="og:description" content="ELF Format: ELF Header What is ELF? ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:
Executable files (a.out, /bin/ls) Object files (.o) Shared libraries (.so) Core dumps It’s a container format that describes:
What parts of the file get loaded into memory, Where execution starts, How relocations and dynamic linking are handled. Contains useful information for the debuggers. General Structure of an ELF File An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-01T00:00:00+00:00"><meta property="article:tag" content="Elf"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELF Format: Part 1"><meta name=twitter:description content="ELF Format: ELF Header
What is ELF?
ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:

Executable files (a.out, /bin/ls)
Object files (.o)
Shared libraries (.so)
Core dumps

It’s a container format that describes:

What parts of the file get loaded into memory,
Where execution starts,
How relocations and dynamic linking are handled.
Contains useful information for the debuggers.

General Structure of an ELF File
An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"ELF Format: Part 1","item":"https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ELF Format: Part 1","name":"ELF Format: Part 1","description":"ELF Format: ELF Header What is ELF? ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:\nExecutable files (a.out, /bin/ls) Object files (.o) Shared libraries (.so) Core dumps It’s a container format that describes:\nWhat parts of the file get loaded into memory, Where execution starts, How relocations and dynamic linking are handled. Contains useful information for the debuggers. General Structure of an ELF File An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution.\n","keywords":["elf","reverse engineering"],"articleBody":"ELF Format: ELF Header What is ELF? ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:\nExecutable files (a.out, /bin/ls) Object files (.o) Shared libraries (.so) Core dumps It’s a container format that describes:\nWhat parts of the file get loaded into memory, Where execution starts, How relocations and dynamic linking are handled. Contains useful information for the debuggers. General Structure of an ELF File An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution.\nThe Big Picture At a high level, every ELF file contains:\n1. ELF Header: Always at the beginning (offset 0x0)\nIdentifies the file as ELF Contains metadata about the file (architecture, entry point, etc.) Points to the Program Header Table and Section Header Table 2. Program Header Table - Describes segments (runtime view)\nUsed by the operating system loader Tells the OS what to load into memory and where Each entry describes a segment 3. Section Header Table - Describes sections (link-time view)\nUsed by the linker and debugger Contains metadata about each section Can be stripped from executables (not needed at runtime) Segments - Chunks of data loaded into memory at runtime\nDefined by program headers Examples: code segment (executable), data segment (writable) Sections - Logical divisions of the file for linking/debugging\nDefined by section headers Examples: .text (code), .data (initialized data), .symtab (symbols) ELF Header The ELF Header is always located at the very beginning of an ELF file (offset 0x0) and serves as the “table of contents” for the entire file. It’s a fixed-size structure that contains essential metadata about the binary.\nSize of ELF Header 32-bit ELF files: 52 bytes 64-bit ELF files: 64 bytes The size difference accommodates larger address spaces in 64-bit architectures.\nThis is where the structure of ELF header si defined in linux kernel include/uapi/linux/elf.h.\n#define EI_NIDENT\t16 typedef struct elf32_hdr { unsigned char\te_ident[EI_NIDENT]; Elf32_Half\te_type; Elf32_Half\te_machine; Elf32_Word\te_version; Elf32_Addr\te_entry; /* Entry point */ Elf32_Off\te_phoff; Elf32_Off\te_shoff; Elf32_Word\te_flags; Elf32_Half\te_ehsize; Elf32_Half\te_phentsize; Elf32_Half\te_phnum; Elf32_Half\te_shentsize; Elf32_Half\te_shnum; Elf32_Half\te_shstrndx; } Elf32_Ehdr; typedef struct elf64_hdr { unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry;\t/* Entry point virtual address */ Elf64_Off e_phoff;\t/* Program header table file offset */ Elf64_Off e_shoff;\t/* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx; } Elf64_Ehdr; ELF Header Components The ELF Header can be divided into two main parts: the identification bytes (E_IDENT) and the header fields.\n1. E_IDENT - Identification Bytes (16 bytes) The first 16 bytes of every ELF file contain identification information that describes how to interpret the rest of the file.\n1. Magic Number (4 bytes) Offset 0-3: 0x7F 'E' 'L' 'F' 0x7F: Non-printable byte to prevent misinterpretation as text ‘E’ ‘L’ ‘F’: ASCII characters spelling “ELF” This signature allows tools to quickly verify a file is ELF format 2. Class (1 byte, offset 4) Specifies whether this is a 32-bit or 64-bit ELF file:\n1 (ELFCLASS32): 32-bit architecture 2 (ELFCLASS64): 64-bit architecture This is crucial because some data types (addresses, offsets) have different sizes depending on the class.\n3. Data Encoding (1 byte, offset 5) Specifies the byte order (endianness):\n1 (ELFDATA2LSB): Little-endian (least significant byte first) 2 (ELFDATA2MSB): Big-endian (most significant byte first) 4. Version (1 byte, offset 6) ELF format version:\n1 (EV_CURRENT): Current version This has been 1 since the late 1980s and has never changed! 5. OS/ABI (1 byte, offset 7) Identifies the target operating system and ABI (Application Binary Interface):\n0 (ELFOSABI_SYSV): UNIX System V ABI (generic, most common) 3 (ELFOSABI_LINUX): Linux 9 (ELFOSABI_FREEBSD): FreeBSD Many others… Note: Even Linux binaries often have this set to 0 (SYSV), which is perfectly valid. Statically compiled Linux binaries sometimes use 3.\n6. ABI Version (1 byte, offset 8) Version of the OS/ABI:\nAlmost never used in practice Usually set to 0 7. Padding (7 bytes, offsets 9-15) Reserved for future use, currently unused:\nAll set to 0 Allows for future extensions without changing the header size You can see what the EI_IDENT field says by looking at the output of readelf -h.\n2. Main Header Fields After the 16-byte E_IDENT section, the remaining fields provide critical information about the file structure.\n1. e_type (2 bytes) - Object File Type Specifies what kind of ELF file this is:\nValue Name Description 0 ET_NONE No file type (unknown/invalid) 1 ET_REL Relocatable file (object file .o) 2 ET_EXEC Executable file (no PIE/ASLR) 3 ET_DYN Shared object file (.so) or PIE executable 4 ET_CORE Core dump file Important distinction:\nET_EXEC: Traditional executable with fixed load addresses (no ASLR support) Compile with: gcc -no-pie program.c ET_DYN: Modern position-independent executable OR shared library Executables: Have PT_INTERP segment Libraries: No PT_INTERP segment Compile with: gcc program.c (default on modern systems) 2. e_machine (2 bytes) - Target Architecture Specifies the required machine architecture:\nValue Name Architecture 0x02 EM_SPARC SPARC. 0x03 EM_386 Intel x86 (32-bit) 0x08 EM_MIPS MIPS 0x14 EM_PPC PowerPC 0x28 EM_ARM ARM (32-bit) 0x3E EM_X86_64 AMD/Intel x86-64 (64-bit) 0xB7 EM_AARCH64 ARM 64-bit 0xF3 EM_RISCV RISC-V Over 200 architectures are defined in the ELF specification.\n3. e_version (4 bytes) - Version ELF version number:\n1 (EV_CURRENT): Current version Same as the version in E_IDENT, but 4 bytes instead of 1 4. e_entry (4 or 8 bytes) - Entry Point Address Virtual memory address where execution begins:\nFor executables: Address of the first instruction to execute For shared libraries: Address of initialization/constructor function Set to 0 if there’s no entry point (e.g., relocatable object files) Example: 0x0000000000401050 (typical entry point for x86-64)\nImportant Note: This is a virtual address (where the code will be in memory after loading), NOT a file offset (where the code is stored in the ELF file on disk). The OS uses program headers to map file contents to virtual memory addresses. We’ll explore how to locate the actual file offset of the entry point code when we discuss program headers and segments in detail.\nWhy not start at 0x0? The bottom of the virtual address space (typically 0x0 to 0x10000 or higher) is intentionally left unmapped to catch NULL pointer dereferences - if your program tries to access address 0x0, it will immediately segfault rather than silently corrupting memory. Starting at addresses like 0x400000 is a security and debugging feature, not a waste of memory, since virtual address space is separate from physical RAM usage.\n5. e_phoff (4 or 8 bytes) - Program Header Offset File offset (in bytes) to the Program Header Table:\nTells the loader where to find segment descriptions Typically immediately after the ELF Header Example: 0x40 (64 bytes - right after 64-byte ELF header) 6. e_shoff (4 or 8 bytes) - Section Header Offset File offset (in bytes) to the Section Header Table:\nTells linkers/debuggers where to find section descriptions Can be anywhere in the file (commonly at the end) Can be 0 if no section headers present (stripped binary) 7. e_flags (4 bytes) - Processor-Specific Flags Architecture-specific flags:\nx86/x86-64: Usually 0 (no flags defined) ARM: Specifies ARM/Thumb mode, floating-point ABI, etc. MIPS: Specifies ABI version, ISA level, etc. RISC-V: Specifies extensions (RVC, floating-point, etc.) Interpretation depends entirely on the target architecture.\n8. e_ehsize (2 bytes) - ELF Header Size Size of the ELF Header itself:\n52 bytes for 32-bit ELF 64 bytes for 64-bit ELF Seems redundant (we already know the format), but allows for future extensibility.\n9. e_phentsize (2 bytes) - Program Header Entry Size Size of one entry in the Program Header Table:\n32 bytes for 32-bit ELF 56 bytes for 64-bit ELF 10. e_phnum (2 bytes) - Program Header Count Number of entries in the Program Header Table:\nTypical executables have 5-13 segments Maximum is 65,535 (though typically much fewer) Can be 0 for object files (no segments) To find Program Header Table size:\nTable size = e_phentsize × e_phnum\n11. e_shentsize (2 bytes) - Section Header Entry Size Size of one entry in the Section Header Table:\n40 bytes for 32-bit ELF 64 bytes for 64-bit ELF 12. e_shnum (2 bytes) - Section Header Count Number of entries in the Section Header Table:\nTypical executables have 20-40 sections Object files can have many more Can be 0 if sections stripped 13. e_shstrndx (2 bytes) - Section Header String Table Index Index of the section that contains section names:\nPoints to the .shstrtab section This section is a string table containing all section names Used to look up section names (like “.text”, “.data”, etc.) Special value 0 (SHN_UNDEF): No string table How section names work:\nSection header contains sh_name field (an offset) Look up section at index e_shstrndx That section contains a string table sh_name is an offset into that string table Read the null-terminated string at that offset = section name! ELF Data Types ELF defines its own data types that vary based on the file class:\nType 32-bit Size 64-bit Size Description Elf32_Half / Elf64_Half 2 bytes 2 bytes Unsigned short Elf32_Word / Elf64_Word 4 bytes 4 bytes Unsigned int Elf32_Addr / Elf64_Addr 4 bytes 8 bytes Address Elf32_Off / Elf64_Off 4 bytes 8 bytes File offset Viewing the ELF Header You can inspect the ELF header of any binary using readelf:\nreadelf -h main Example output: ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x401090 Start of program headers: 64 (bytes into file) Start of section headers: 14048 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 ","wordCount":"1666","inLanguage":"en","datePublished":"2025-10-01T00:00:00Z","dateModified":"2025-10-01T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/reverse-engineering/2025-10-06-elf-format/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ELF Format: Part 1</h1><div class=post-meta><span title='2025-10-01 00:00:00 +0000 UTC'>October 1, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/reverse-engineering/2025-10-06-elf-format.markdown rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elf-format-elf-header aria-label="ELF Format: ELF Header">ELF Format: ELF Header</a><ul><li><a href=#what-is-elf aria-label="What is ELF?">What is ELF?</a></li><li><a href=#general-structure-of-an-elf-file aria-label="General Structure of an ELF File">General Structure of an ELF File</a><ul><li><a href=#the-big-picture aria-label="The Big Picture">The Big Picture</a></li></ul></li><li><a href=#elf-header aria-label="ELF Header">ELF Header</a><ul><li><a href=#size-of-elf-header aria-label="Size of ELF Header">Size of ELF Header</a></li><li><a href=#elf-header-components aria-label="ELF Header Components">ELF Header Components</a><ul><li><a href=#1-e_ident---identification-bytes-16-bytes aria-label="1. E_IDENT - Identification Bytes (16 bytes)">1. E_IDENT - Identification Bytes (16 bytes)</a><ul><li><a href=#1-magic-number-4-bytes aria-label="1. Magic Number (4 bytes)">1. Magic Number (4 bytes)</a></li><li><a href=#2-class-1-byte-offset-4 aria-label="2. Class (1 byte, offset 4)">2. Class (1 byte, offset 4)</a></li><li><a href=#3-data-encoding-1-byte-offset-5 aria-label="3. Data Encoding (1 byte, offset 5)">3. Data Encoding (1 byte, offset 5)</a></li><li><a href=#4-version-1-byte-offset-6 aria-label="4. Version (1 byte, offset 6)">4. Version (1 byte, offset 6)</a></li><li><a href=#5-osabi-1-byte-offset-7 aria-label="5. OS/ABI (1 byte, offset 7)">5. OS/ABI (1 byte, offset 7)</a></li><li><a href=#6-abi-version-1-byte-offset-8 aria-label="6. ABI Version (1 byte, offset 8)">6. ABI Version (1 byte, offset 8)</a></li><li><a href=#7-padding-7-bytes-offsets-9-15 aria-label="7. Padding (7 bytes, offsets 9-15)">7. Padding (7 bytes, offsets 9-15)</a></li></ul></li></ul></li><li><a href=#2-main-header-fields aria-label="2. Main Header Fields">2. Main Header Fields</a><ul><li><a href=#1-e_type-2-bytes---object-file-type aria-label="1. e_type (2 bytes) - Object File Type">1. e_type (2 bytes) - Object File Type</a></li><li><a href=#2-e_machine-2-bytes---target-architecture aria-label="2. e_machine (2 bytes) - Target Architecture">2. e_machine (2 bytes) - Target Architecture</a></li><li><a href=#3-e_version-4-bytes---version aria-label="3. e_version (4 bytes) - Version">3. e_version (4 bytes) - Version</a></li><li><a href=#4-e_entry-4-or-8-bytes---entry-point-address aria-label="4. e_entry (4 or 8 bytes) - Entry Point Address">4. e_entry (4 or 8 bytes) - Entry Point Address</a></li><li><a href=#5-e_phoff-4-or-8-bytes---program-header-offset aria-label="5. e_phoff (4 or 8 bytes) - Program Header Offset">5. e_phoff (4 or 8 bytes) - Program Header Offset</a></li><li><a href=#6-e_shoff-4-or-8-bytes---section-header-offset aria-label="6. e_shoff (4 or 8 bytes) - Section Header Offset">6. e_shoff (4 or 8 bytes) - Section Header Offset</a></li><li><a href=#7-e_flags-4-bytes---processor-specific-flags aria-label="7. e_flags (4 bytes) - Processor-Specific Flags">7. e_flags (4 bytes) - Processor-Specific Flags</a></li><li><a href=#8-e_ehsize-2-bytes---elf-header-size aria-label="8. e_ehsize (2 bytes) - ELF Header Size">8. e_ehsize (2 bytes) - ELF Header Size</a></li><li><a href=#9-e_phentsize-2-bytes---program-header-entry-size aria-label="9. e_phentsize (2 bytes) - Program Header Entry Size">9. e_phentsize (2 bytes) - Program Header Entry Size</a></li><li><a href=#10-e_phnum-2-bytes---program-header-count aria-label="10. e_phnum (2 bytes) - Program Header Count">10. e_phnum (2 bytes) - Program Header Count</a></li><li><a href=#11-e_shentsize-2-bytes---section-header-entry-size aria-label="11. e_shentsize (2 bytes) - Section Header Entry Size">11. e_shentsize (2 bytes) - Section Header Entry Size</a></li><li><a href=#12-e_shnum-2-bytes---section-header-count aria-label="12. e_shnum (2 bytes) - Section Header Count">12. e_shnum (2 bytes) - Section Header Count</a></li><li><a href=#13-e_shstrndx-2-bytes---section-header-string-table-index aria-label="13. e_shstrndx (2 bytes) - Section Header String Table Index">13. e_shstrndx (2 bytes) - Section Header String Table Index</a></li></ul></li></ul></li><li><a href=#elf-data-types aria-label="ELF Data Types">ELF Data Types</a></li><li><a href=#viewing-the-elf-header aria-label="Viewing the ELF Header">Viewing the ELF Header</a><ul><li><a href=#example-output aria-label="Example output:">Example output:</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=elf-format-elf-header>ELF Format: ELF Header<a hidden class=anchor aria-hidden=true href=#elf-format-elf-header>#</a></h1><h2 id=what-is-elf>What is ELF?<a hidden class=anchor aria-hidden=true href=#what-is-elf>#</a></h2><p>ELF (Executable and Linkable Format) is the standard binary format used by Unix-like systems (Linux, BSD, etc.) for:</p><ul><li>Executable files (a.out, /bin/ls)</li><li>Object files (.o)</li><li>Shared libraries (.so)</li><li>Core dumps</li></ul><p>It’s a container format that describes:</p><ul><li>What parts of the file get loaded into memory,</li><li>Where execution starts,</li><li>How relocations and dynamic linking are handled.</li><li>Contains useful information for the debuggers.</li></ul><h2 id=general-structure-of-an-elf-file>General Structure of an ELF File<a hidden class=anchor aria-hidden=true href=#general-structure-of-an-elf-file>#</a></h2><p>An ELF file is organized into several key components that serve different purposes during compilation, linking, and execution.</p><h3 id=the-big-picture>The Big Picture<a hidden class=anchor aria-hidden=true href=#the-big-picture>#</a></h3><p>At a high level, every ELF file contains:</p><p><strong>1. ELF Header:</strong> Always at the beginning (offset 0x0)</p><ul><li>Identifies the file as ELF</li><li>Contains metadata about the file (architecture, entry point, etc.)</li><li>Points to the Program Header Table and Section Header Table</li></ul><p><strong>2. Program Header Table - Describes segments (runtime view)</strong></p><ul><li>Used by the operating system loader</li><li>Tells the OS what to load into memory and where</li><li>Each entry describes a segment</li></ul><p><strong>3. Section Header Table - Describes sections (link-time view)</strong></p><ul><li>Used by the linker and debugger</li><li>Contains metadata about each section</li><li>Can be stripped from executables (not needed at runtime)</li></ul><p><strong>Segments - Chunks of data loaded into memory at runtime</strong></p><ul><li>Defined by program headers</li><li>Examples: code segment (executable), data segment (writable)</li></ul><p><strong>Sections - Logical divisions of the file for linking/debuggin</strong>g</p><ul><li>Defined by section headers</li><li>Examples: .text (code), .data (initialized data), .symtab (symbols)</li></ul><p><img alt="ELF Strcture" loading=lazy src=/blog/images/elf-structure-overview.png></p><h2 id=elf-header>ELF Header<a hidden class=anchor aria-hidden=true href=#elf-header>#</a></h2><p>The ELF Header is always located at the very beginning of an ELF file (offset 0x0) and serves as the &ldquo;table of contents&rdquo; for the entire file. It&rsquo;s a fixed-size structure that contains essential metadata about the binary.</p><h3 id=size-of-elf-header>Size of ELF Header<a hidden class=anchor aria-hidden=true href=#size-of-elf-header>#</a></h3><ul><li><strong>32-bit ELF files</strong>: 52 bytes</li><li><strong>64-bit ELF files</strong>: 64 bytes</li></ul><p>The size difference accommodates larger address spaces in 64-bit architectures.</p><p>This is where the structure of ELF header si defined in linux kernel <code>include/uapi/linux/elf.h</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#define EI_NIDENT	16
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf32_hdr {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>	e_ident[EI_NIDENT];
</span></span><span style=display:flex><span>  Elf32_Half	e_type;
</span></span><span style=display:flex><span>  Elf32_Half	e_machine;
</span></span><span style=display:flex><span>  Elf32_Word	e_version;
</span></span><span style=display:flex><span>  Elf32_Addr	e_entry;  <span style=color:#75715e>/* Entry point */</span>
</span></span><span style=display:flex><span>  Elf32_Off	e_phoff;
</span></span><span style=display:flex><span>  Elf32_Off	e_shoff;
</span></span><span style=display:flex><span>  Elf32_Word	e_flags;
</span></span><span style=display:flex><span>  Elf32_Half	e_ehsize;
</span></span><span style=display:flex><span>  Elf32_Half	e_phentsize;
</span></span><span style=display:flex><span>  Elf32_Half	e_phnum;
</span></span><span style=display:flex><span>  Elf32_Half	e_shentsize;
</span></span><span style=display:flex><span>  Elf32_Half	e_shnum;
</span></span><span style=display:flex><span>  Elf32_Half	e_shstrndx;
</span></span><span style=display:flex><span>} Elf32_Ehdr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf64_hdr {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>	e_ident[EI_NIDENT];	<span style=color:#75715e>/* ELF &#34;magic number&#34; */</span>
</span></span><span style=display:flex><span>  Elf64_Half e_type;
</span></span><span style=display:flex><span>  Elf64_Half e_machine;
</span></span><span style=display:flex><span>  Elf64_Word e_version;
</span></span><span style=display:flex><span>  Elf64_Addr e_entry;		<span style=color:#75715e>/* Entry point virtual address */</span>
</span></span><span style=display:flex><span>  Elf64_Off e_phoff;		<span style=color:#75715e>/* Program header table file offset */</span>
</span></span><span style=display:flex><span>  Elf64_Off e_shoff;		<span style=color:#75715e>/* Section header table file offset */</span>
</span></span><span style=display:flex><span>  Elf64_Word e_flags;
</span></span><span style=display:flex><span>  Elf64_Half e_ehsize;
</span></span><span style=display:flex><span>  Elf64_Half e_phentsize;
</span></span><span style=display:flex><span>  Elf64_Half e_phnum;
</span></span><span style=display:flex><span>  Elf64_Half e_shentsize;
</span></span><span style=display:flex><span>  Elf64_Half e_shnum;
</span></span><span style=display:flex><span>  Elf64_Half e_shstrndx;
</span></span><span style=display:flex><span>} Elf64_Ehdr;
</span></span></code></pre></div><h3 id=elf-header-components>ELF Header Components<a hidden class=anchor aria-hidden=true href=#elf-header-components>#</a></h3><p>The ELF Header can be divided into two main parts: the <strong>identification bytes</strong> (E_IDENT) and the <strong>header fields</strong>.</p><h4 id=1-e_ident---identification-bytes-16-bytes>1. E_IDENT - Identification Bytes (16 bytes)<a hidden class=anchor aria-hidden=true href=#1-e_ident---identification-bytes-16-bytes>#</a></h4><p>The first 16 bytes of every ELF file contain identification information that describes how to interpret the rest of the file.</p><h5 id=1-magic-number-4-bytes>1. Magic Number (4 bytes)<a hidden class=anchor aria-hidden=true href=#1-magic-number-4-bytes>#</a></h5><pre tabindex=0><code>Offset 0-3: 0x7F &#39;E&#39; &#39;L&#39; &#39;F&#39;
</code></pre><ul><li><strong>0x7F</strong>: Non-printable byte to prevent misinterpretation as text</li><li><strong>&lsquo;E&rsquo; &lsquo;L&rsquo; &lsquo;F&rsquo;</strong>: ASCII characters spelling &ldquo;ELF&rdquo;</li><li>This signature allows tools to quickly verify a file is ELF format</li></ul><h5 id=2-class-1-byte-offset-4>2. Class (1 byte, offset 4)<a hidden class=anchor aria-hidden=true href=#2-class-1-byte-offset-4>#</a></h5><p>Specifies whether this is a 32-bit or 64-bit ELF file:</p><ul><li><strong>1 (ELFCLASS32)</strong>: 32-bit architecture</li><li><strong>2 (ELFCLASS64)</strong>: 64-bit architecture</li></ul><p>This is crucial because some data types (addresses, offsets) have different sizes depending on the class.</p><h5 id=3-data-encoding-1-byte-offset-5>3. Data Encoding (1 byte, offset 5)<a hidden class=anchor aria-hidden=true href=#3-data-encoding-1-byte-offset-5>#</a></h5><p>Specifies the byte order (endianness):</p><ul><li><strong>1 (ELFDATA2LSB)</strong>: Little-endian (least significant byte first)</li><li><strong>2 (ELFDATA2MSB)</strong>: Big-endian (most significant byte first)</li></ul><h5 id=4-version-1-byte-offset-6>4. Version (1 byte, offset 6)<a hidden class=anchor aria-hidden=true href=#4-version-1-byte-offset-6>#</a></h5><p>ELF format version:</p><ul><li><strong>1 (EV_CURRENT)</strong>: Current version</li><li>This has been 1 since the late 1980s and has never changed!</li></ul><h5 id=5-osabi-1-byte-offset-7>5. OS/ABI (1 byte, offset 7)<a hidden class=anchor aria-hidden=true href=#5-osabi-1-byte-offset-7>#</a></h5><p>Identifies the target operating system and ABI (Application Binary Interface):</p><ul><li><strong>0 (ELFOSABI_SYSV)</strong>: UNIX System V ABI (generic, most common)</li><li><strong>3 (ELFOSABI_LINUX)</strong>: Linux</li><li><strong>9 (ELFOSABI_FREEBSD)</strong>: FreeBSD</li><li>Many others&mldr;</li></ul><p><strong>Note:</strong> Even Linux binaries often have this set to 0 (SYSV), which is perfectly valid. Statically compiled Linux binaries sometimes use 3.</p><h5 id=6-abi-version-1-byte-offset-8>6. ABI Version (1 byte, offset 8)<a hidden class=anchor aria-hidden=true href=#6-abi-version-1-byte-offset-8>#</a></h5><p>Version of the OS/ABI:</p><ul><li>Almost never used in practice</li><li>Usually set to 0</li></ul><h5 id=7-padding-7-bytes-offsets-9-15>7. Padding (7 bytes, offsets 9-15)<a hidden class=anchor aria-hidden=true href=#7-padding-7-bytes-offsets-9-15>#</a></h5><p>Reserved for future use, currently unused:</p><ul><li>All set to 0</li><li>Allows for future extensions without changing the header size</li></ul><p>You can see what the EI_IDENT field says by looking at the output of readelf -h.</p><h3 id=2-main-header-fields>2. Main Header Fields<a hidden class=anchor aria-hidden=true href=#2-main-header-fields>#</a></h3><p>After the 16-byte E_IDENT section, the remaining fields provide critical information about the file structure.</p><h4 id=1-e_type-2-bytes---object-file-type>1. e_type (2 bytes) - Object File Type<a hidden class=anchor aria-hidden=true href=#1-e_type-2-bytes---object-file-type>#</a></h4><p>Specifies what kind of ELF file this is:</p><table><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>ET_NONE</td><td>No file type (unknown/invalid)</td></tr><tr><td>1</td><td>ET_REL</td><td>Relocatable file (object file <code>.o</code>)</td></tr><tr><td>2</td><td>ET_EXEC</td><td>Executable file (no PIE/ASLR)</td></tr><tr><td>3</td><td>ET_DYN</td><td>Shared object file (<code>.so</code>) or PIE executable</td></tr><tr><td>4</td><td>ET_CORE</td><td>Core dump file</td></tr></tbody></table><p><strong>Important distinction:</strong></p><ul><li><strong>ET_EXEC</strong>: Traditional executable with fixed load addresses (no ASLR support)<ul><li>Compile with: <code>gcc -no-pie program.c</code></li></ul></li><li><strong>ET_DYN</strong>: Modern position-independent executable OR shared library<ul><li>Executables: Have PT_INTERP segment</li><li>Libraries: No PT_INTERP segment</li><li>Compile with: <code>gcc program.c</code> (default on modern systems)</li></ul></li></ul><h4 id=2-e_machine-2-bytes---target-architecture>2. e_machine (2 bytes) - Target Architecture<a hidden class=anchor aria-hidden=true href=#2-e_machine-2-bytes---target-architecture>#</a></h4><p>Specifies the required machine architecture:</p><table><thead><tr><th>Value</th><th>Name</th><th>Architecture</th></tr></thead><tbody><tr><td>0x02</td><td>EM_SPARC</td><td>SPARC.</td></tr><tr><td>0x03</td><td>EM_386</td><td>Intel x86 (32-bit)</td></tr><tr><td>0x08</td><td>EM_MIPS</td><td>MIPS</td></tr><tr><td>0x14</td><td>EM_PPC</td><td>PowerPC</td></tr><tr><td>0x28</td><td>EM_ARM</td><td>ARM (32-bit)</td></tr><tr><td>0x3E</td><td>EM_X86_64</td><td>AMD/Intel x86-64 (64-bit)</td></tr><tr><td>0xB7</td><td>EM_AARCH64</td><td>ARM 64-bit</td></tr><tr><td>0xF3</td><td>EM_RISCV</td><td>RISC-V</td></tr></tbody></table><p>Over 200 architectures are defined in the ELF specification.</p><h4 id=3-e_version-4-bytes---version>3. e_version (4 bytes) - Version<a hidden class=anchor aria-hidden=true href=#3-e_version-4-bytes---version>#</a></h4><p>ELF version number:</p><ul><li><strong>1 (EV_CURRENT)</strong>: Current version</li><li>Same as the version in E_IDENT, but 4 bytes instead of 1</li></ul><h4 id=4-e_entry-4-or-8-bytes---entry-point-address>4. e_entry (4 or 8 bytes) - Entry Point Address<a hidden class=anchor aria-hidden=true href=#4-e_entry-4-or-8-bytes---entry-point-address>#</a></h4><p>Virtual memory address where execution begins:</p><ul><li>For executables: Address of the first instruction to execute</li><li>For shared libraries: Address of initialization/constructor function</li><li><strong>Set to 0</strong> if there&rsquo;s no entry point (e.g., relocatable object files)</li></ul><p>Example: <code>0x0000000000401050</code> (typical entry point for x86-64)</p><p><strong>Important Note:</strong> This is a <strong>virtual address</strong> (where the code will be in memory after loading), NOT a file offset (where the code is stored in the ELF file on disk). The OS uses program headers to map file contents to virtual memory addresses. We&rsquo;ll explore how to locate the actual file offset of the entry point code when we discuss program headers and segments in detail.</p><p><strong>Why not start at 0x0?</strong> The bottom of the virtual address space (typically 0x0 to 0x10000 or higher) is intentionally left unmapped to catch NULL pointer dereferences - if your program tries to access address 0x0, it will immediately segfault rather than silently corrupting memory. Starting at addresses like 0x400000 is a security and debugging feature, not a waste of memory, since virtual address space is separate from physical RAM usage.</p><h4 id=5-e_phoff-4-or-8-bytes---program-header-offset>5. e_phoff (4 or 8 bytes) - Program Header Offset<a hidden class=anchor aria-hidden=true href=#5-e_phoff-4-or-8-bytes---program-header-offset>#</a></h4><p>File offset (in bytes) to the Program Header Table:</p><ul><li>Tells the loader where to find segment descriptions</li><li>Typically immediately after the ELF Header</li><li>Example: <code>0x40</code> (64 bytes - right after 64-byte ELF header)</li></ul><h4 id=6-e_shoff-4-or-8-bytes---section-header-offset>6. e_shoff (4 or 8 bytes) - Section Header Offset<a hidden class=anchor aria-hidden=true href=#6-e_shoff-4-or-8-bytes---section-header-offset>#</a></h4><p>File offset (in bytes) to the Section Header Table:</p><ul><li>Tells linkers/debuggers where to find section descriptions</li><li>Can be anywhere in the file (commonly at the end)</li><li><strong>Can be 0</strong> if no section headers present (stripped binary)</li></ul><h4 id=7-e_flags-4-bytes---processor-specific-flags>7. e_flags (4 bytes) - Processor-Specific Flags<a hidden class=anchor aria-hidden=true href=#7-e_flags-4-bytes---processor-specific-flags>#</a></h4><p>Architecture-specific flags:</p><ul><li><strong>x86/x86-64</strong>: Usually 0 (no flags defined)</li><li><strong>ARM</strong>: Specifies ARM/Thumb mode, floating-point ABI, etc.</li><li><strong>MIPS</strong>: Specifies ABI version, ISA level, etc.</li><li><strong>RISC-V</strong>: Specifies extensions (RVC, floating-point, etc.)</li></ul><p>Interpretation depends entirely on the target architecture.</p><h4 id=8-e_ehsize-2-bytes---elf-header-size>8. e_ehsize (2 bytes) - ELF Header Size<a hidden class=anchor aria-hidden=true href=#8-e_ehsize-2-bytes---elf-header-size>#</a></h4><p>Size of the ELF Header itself:</p><ul><li><strong>52 bytes</strong> for 32-bit ELF</li><li><strong>64 bytes</strong> for 64-bit ELF</li></ul><p>Seems redundant (we already know the format), but allows for future extensibility.</p><h4 id=9-e_phentsize-2-bytes---program-header-entry-size>9. e_phentsize (2 bytes) - Program Header Entry Size<a hidden class=anchor aria-hidden=true href=#9-e_phentsize-2-bytes---program-header-entry-size>#</a></h4><p>Size of one entry in the Program Header Table:</p><ul><li><strong>32 bytes</strong> for 32-bit ELF</li><li><strong>56 bytes</strong> for 64-bit ELF</li></ul><h4 id=10-e_phnum-2-bytes---program-header-count>10. e_phnum (2 bytes) - Program Header Count<a hidden class=anchor aria-hidden=true href=#10-e_phnum-2-bytes---program-header-count>#</a></h4><p>Number of entries in the Program Header Table:</p><ul><li>Typical executables have 5-13 segments</li><li>Maximum is 65,535 (though typically much fewer)</li><li><strong>Can be 0</strong> for object files (no segments)</li></ul><p><strong>To find Program Header Table size:</strong></p><p>Table size = e_phentsize × e_phnum</p><h4 id=11-e_shentsize-2-bytes---section-header-entry-size>11. e_shentsize (2 bytes) - Section Header Entry Size<a hidden class=anchor aria-hidden=true href=#11-e_shentsize-2-bytes---section-header-entry-size>#</a></h4><p>Size of one entry in the Section Header Table:</p><ul><li><strong>40 bytes</strong> for 32-bit ELF</li><li><strong>64 bytes</strong> for 64-bit ELF</li></ul><h4 id=12-e_shnum-2-bytes---section-header-count>12. e_shnum (2 bytes) - Section Header Count<a hidden class=anchor aria-hidden=true href=#12-e_shnum-2-bytes---section-header-count>#</a></h4><p>Number of entries in the Section Header Table:</p><ul><li>Typical executables have 20-40 sections</li><li>Object files can have many more</li><li><strong>Can be 0</strong> if sections stripped</li></ul><h4 id=13-e_shstrndx-2-bytes---section-header-string-table-index>13. e_shstrndx (2 bytes) - Section Header String Table Index<a hidden class=anchor aria-hidden=true href=#13-e_shstrndx-2-bytes---section-header-string-table-index>#</a></h4><p>Index of the section that contains section names:</p><ul><li>Points to the <code>.shstrtab</code> section</li><li>This section is a string table containing all section names</li><li>Used to look up section names (like &ldquo;.text&rdquo;, &ldquo;.data&rdquo;, etc.)</li><li><strong>Special value 0 (SHN_UNDEF)</strong>: No string table</li></ul><p><strong>How section names work:</strong></p><ol><li>Section header contains <code>sh_name</code> field (an offset)</li><li>Look up section at index <code>e_shstrndx</code></li><li>That section contains a string table</li><li><code>sh_name</code> is an offset into that string table</li><li>Read the null-terminated string at that offset = section name!</li></ol><h2 id=elf-data-types>ELF Data Types<a hidden class=anchor aria-hidden=true href=#elf-data-types>#</a></h2><p>ELF defines its own data types that vary based on the file class:</p><table><thead><tr><th>Type</th><th>32-bit Size</th><th>64-bit Size</th><th>Description</th></tr></thead><tbody><tr><td>Elf32_Half / Elf64_Half</td><td>2 bytes</td><td>2 bytes</td><td>Unsigned short</td></tr><tr><td>Elf32_Word / Elf64_Word</td><td>4 bytes</td><td>4 bytes</td><td>Unsigned int</td></tr><tr><td>Elf32_Addr / Elf64_Addr</td><td>4 bytes</td><td>8 bytes</td><td>Address</td></tr><tr><td>Elf32_Off / Elf64_Off</td><td>4 bytes</td><td>8 bytes</td><td>File offset</td></tr></tbody></table><h2 id=viewing-the-elf-header>Viewing the ELF Header<a hidden class=anchor aria-hidden=true href=#viewing-the-elf-header>#</a></h2><p>You can inspect the ELF header of any binary using <code>readelf</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>readelf -h main
</span></span></code></pre></div><h3 id=example-output>Example output:<a hidden class=anchor aria-hidden=true href=#example-output>#</a></h3><pre tabindex=0><code>ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x401090
  Start of program headers:          64 (bytes into file)
  Start of section headers:          14048 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/elf/>Elf</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>