<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Executing a "Hello, World!" Program at Boot Time | Sanketh's Blog</title><meta name=keywords content="boot"><meta name=description content="BIOS Boot Recap
Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the 0x55AA signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR)."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/boot/2025-07-07-running-hello-world-on-boot/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.e2ed8047f83ad264119a8881d8496bb9bd824712cec7cb80665766cf714041fe.css integrity="sha256-4u2AR/g60mQRmoiB2Elrub2CRxLOx8uAZldmz3FAQf4=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/boot/2025-07-07-running-hello-world-on-boot/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/boot/2025-07-07-running-hello-world-on-boot/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content='Executing a "Hello, World!" Program at Boot Time'><meta property="og:description" content="BIOS Boot Recap Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the 0x55AA signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR)."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-12T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-12T00:00:00+00:00"><meta property="article:tag" content="Boot"><meta name=twitter:card content="summary"><meta name=twitter:title content='Executing a "Hello, World!" Program at Boot Time'><meta name=twitter:description content="BIOS Boot Recap
Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the 0x55AA signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Executing a \"Hello, World!\" Program at Boot Time","item":"https://sankethbk.github.io/blog/posts/boot/2025-07-07-running-hello-world-on-boot/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Executing a \"Hello, World!\" Program at Boot Time","name":"Executing a \u0022Hello, World!\u0022 Program at Boot Time","description":"BIOS Boot Recap Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the 0x55AA signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR).\n","keywords":["boot"],"articleBody":"BIOS Boot Recap Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the 0x55AA signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR).\nMBR Structure Breakdown:\nBytes 0-445 (446 bytes): The boot code, often called the “bootstrap” code. This is the small program that the BIOS executes. Bytes 446-509 (64 bytes): The partition table, which contains four 16-byte entries, each describing a primary partition. Bytes 510-511 (2 bytes): The boot signature (0x55AA), which validates the sector as bootable. What is this 446-byte code supposed to do? 1. Hardware Initialization: The code initializes basic hardware components and sets up the processor to operate in a known state.\nThe hardware initialization performed by MBR code is quite limited but crucial for establishing a stable foundation for the boot process. Let me detail what actually happens:\nProcessor State Setup: Register Initialization: Sets up segment registers (CS, DS, ES, SS) to known values Initializes the stack pointer (SP) to create a small working stack Clears or sets specific CPU flags to ensure predictable behavior The BIOS typically loads MBR at physical address 0x7C00, so CS:IP points there Interrupt Handling: May disable interrupts temporarily during critical operations Sets up or modifies interrupt vectors for basic hardware services Ensures the processor can handle hardware interrupts predictably Memory Setup: Stack Configuration: Establishes a small stack space (usually just a few hundred bytes) Sets SS (Stack Segment) and SP (Stack Pointer) registers This is essential since the code needs stack space for function calls and local variables Memory Map Awareness: The code must work within the known memory layout established by BIOS Avoids overwriting critical BIOS data areas Understands where it can safely use memory for temporary storage 2. Partition Table Reading: It reads and interprets the partition table (located in the remaining 66 bytes of the 512-byte MBR) to identify which partition is marked as active/bootable.\n3. Active Partition Location: The code searches through the four partition table entries to find the one marked with the boot flag (0x80), indicating it’s the active partition.\n4. Loading the Volume Boot Record: Once the active partition is identified, the boot loader loads the first sector of that partition (called the Volume Boot Record or VBR) into memory.\n5. Transfer Control: After loading the VBR, the MBR code transfers execution control to the VBR, which then continues the boot process by loading the operating system.\n6. Error Handling: The code includes basic error handling to display messages like “Invalid partition table” or “Missing operating system” if problems are encountered.\nProcessor States It operates in 16-bit real mode with very limited memory and no operating system services. The code is typically written in assembly language and must be extremely efficient.\nWhat is Real Mode? Real mode is the default operating mode that x86 processors (starting with the 8086) boot into. It’s called “real” because memory addresses correspond directly to actual physical memory locations - there’s no virtual memory or memory protection.\nKey Characteristics of 16-bit Real Mode: Memory Addressing: Uses 16-bit registers but can access up to 1MB of memory (20-bit addressing) Memory is accessed using a segmented model with segment:offset pairs Example: address 0x1000:0x0500 means segment 0x1000 shifted left 4 bits + offset 0x0500. This gives physical address: (0x1000 « 4) + 0x0500 = 0x10500 Register Size: All general-purpose registers (AX, BX, CX, DX, etc.) are 16 bits wide You can access 8-bit portions (AH/AL for register AX) No 32-bit extended registers available Memory Limitations: Maximum addressable memory: 1MB (actually 1MB + 64KB - 16 bytes due to segment wraparound) No memory protection - any code can access any memory location No virtual memory management Instruction Set: Limited to 8086/8088 instruction set No protected mode instructions No floating-point unit access (unless manually enabled) Why This Matters for MBR Code? Size Constraints: With only 16-bit registers and limited addressing modes, the code must be extremely compact and efficient. Direct Hardware Access: The code can directly access hardware ports and memory locations without operating system mediation. No Modern Conveniences: No stack overflow protection, no memory management, no multitasking support. Immediate Hardware Control: The processor starts in real mode, so the MBR code has direct control over the hardware from the moment it runs. Transition to Protected Mode: Modern operating systems quickly transition from real mode to protected mode (32-bit) or long mode (64-bit) to gain access to:\nFull memory addressing capabilities Memory protection and virtual memory Advanced processor features Better security and stability The MBR’s job is essentially to bridge the gap between the primitive real mode environment and loading code that can set up a more sophisticated operating environment.\nCapabilities and Constraints of MBR Code ","wordCount":"827","inLanguage":"en","datePublished":"2025-07-12T00:00:00Z","dateModified":"2025-07-12T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/boot/2025-07-07-running-hello-world-on-boot/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Executing a "Hello, World!" Program at Boot Time</h1><div class=post-meta><span title='2025-07-12 00:00:00 +0000 UTC'>July 12, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/boot/2025-07-07-running-hello-world-on-boot.markdown rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#bios-boot-recap aria-label="BIOS Boot Recap">BIOS Boot Recap</a></li><li><a href=#what-is-this-446-byte-code-supposed-to-do aria-label="What is this 446-byte code supposed to do?">What is this 446-byte code supposed to do?</a><ul><li><a href=#1-hardware-initialization aria-label="1. Hardware Initialization:">1. Hardware Initialization:</a><ul><li><a href=#processor-state-setup aria-label="Processor State Setup:">Processor State Setup:</a><ul><li><a href=#register-initialization aria-label="Register Initialization:">Register Initialization:</a></li><li><a href=#interrupt-handling aria-label="Interrupt Handling:">Interrupt Handling:</a></li><li><a href=#memory-setup aria-label="Memory Setup:">Memory Setup:</a></li><li><a href=#stack-configuration aria-label="Stack Configuration:">Stack Configuration:</a></li><li><a href=#memory-map-awareness aria-label="Memory Map Awareness:">Memory Map Awareness:</a></li></ul></li></ul></li><li><a href=#2-partition-table-reading aria-label="2. Partition Table Reading:">2. Partition Table Reading:</a></li><li><a href=#3-active-partition-location aria-label="3. Active Partition Location:">3. Active Partition Location:</a></li><li><a href=#4-loading-the-volume-boot-record aria-label="4. Loading the Volume Boot Record:">4. Loading the Volume Boot Record:</a></li><li><a href=#5-transfer-control aria-label="5. Transfer Control:">5. Transfer Control:</a></li><li><a href=#6-error-handling aria-label="6. Error Handling:">6. Error Handling:</a></li></ul></li><li><a href=#processor-states aria-label="Processor States">Processor States</a><ul><li><a href=#what-is-real-mode aria-label="What is Real Mode?">What is Real Mode?</a></li><li><a href=#key-characteristics-of-16-bit-real-mode aria-label="Key Characteristics of 16-bit Real Mode:">Key Characteristics of 16-bit Real Mode:</a><ul><li><a href=#memory-addressing aria-label="Memory Addressing:">Memory Addressing:</a></li><li><a href=#register-size aria-label="Register Size:">Register Size:</a></li><li><a href=#memory-limitations aria-label="Memory Limitations:">Memory Limitations:</a></li><li><a href=#instruction-set aria-label="Instruction Set:">Instruction Set:</a></li></ul></li><li><a href=#why-this-matters-for-mbr-code aria-label="Why This Matters for MBR Code?">Why This Matters for MBR Code?</a></li><li><a href=#transition-to-protected-mode aria-label="Transition to Protected Mode:">Transition to Protected Mode:</a></li></ul></li><li><a href=#capabilities-and-constraints-of-mbr-code aria-label="Capabilities and Constraints of MBR Code">Capabilities and Constraints of MBR Code</a></li></ul></div></details></div><div class=post-content><h2 id=bios-boot-recap>BIOS Boot Recap<a hidden class=anchor aria-hidden=true href=#bios-boot-recap>#</a></h2><p>Previously, we saw that after the BIOS firmware is loaded, it searches for a bootable device from a list of storage options, such as a hard drive, SSD, USB, or network interface. The BIOS identifies a valid bootable device by checking for the <code>0x55AA</code> signature at the end of the first sector. Once found, it loads the 512 bytes from this sector (LBA 0), which is known as the Master Boot Record (MBR).</p><p><strong>MBR Structure Breakdown:</strong></p><ul><li><strong>Bytes 0-445 (446 bytes):</strong> The boot code, often called the &ldquo;bootstrap&rdquo; code. This is the small program that the BIOS executes.</li><li><strong>Bytes 446-509 (64 bytes):</strong> The partition table, which contains four 16-byte entries, each describing a primary partition.</li><li><strong>Bytes 510-511 (2 bytes):</strong> The boot signature (<code>0x55AA</code>), which validates the sector as bootable.</li></ul><h2 id=what-is-this-446-byte-code-supposed-to-do>What is this 446-byte code supposed to do?<a hidden class=anchor aria-hidden=true href=#what-is-this-446-byte-code-supposed-to-do>#</a></h2><h3 id=1-hardware-initialization>1. Hardware Initialization:<a hidden class=anchor aria-hidden=true href=#1-hardware-initialization>#</a></h3><p>The code initializes basic hardware components and sets up the processor to operate in a known state.</p><p>The hardware initialization performed by MBR code is quite limited but crucial for establishing a stable foundation for the boot process. Let me detail what actually happens:</p><h4 id=processor-state-setup>Processor State Setup:<a hidden class=anchor aria-hidden=true href=#processor-state-setup>#</a></h4><h5 id=register-initialization>Register Initialization:<a hidden class=anchor aria-hidden=true href=#register-initialization>#</a></h5><ul><li>Sets up segment registers (CS, DS, ES, SS) to known values</li><li>Initializes the stack pointer (SP) to create a small working stack</li><li>Clears or sets specific CPU flags to ensure predictable behavior</li><li>The BIOS typically loads MBR at physical address 0x7C00, so CS:IP points there</li></ul><h5 id=interrupt-handling>Interrupt Handling:<a hidden class=anchor aria-hidden=true href=#interrupt-handling>#</a></h5><ul><li>May disable interrupts temporarily during critical operations</li><li>Sets up or modifies interrupt vectors for basic hardware services</li><li>Ensures the processor can handle hardware interrupts predictably</li></ul><h5 id=memory-setup>Memory Setup:<a hidden class=anchor aria-hidden=true href=#memory-setup>#</a></h5><h5 id=stack-configuration>Stack Configuration:<a hidden class=anchor aria-hidden=true href=#stack-configuration>#</a></h5><ul><li>Establishes a small stack space (usually just a few hundred bytes)</li><li>Sets SS (Stack Segment) and SP (Stack Pointer) registers</li><li>This is essential since the code needs stack space for function calls and local variables</li></ul><h5 id=memory-map-awareness>Memory Map Awareness:<a hidden class=anchor aria-hidden=true href=#memory-map-awareness>#</a></h5><ul><li>The code must work within the known memory layout established by BIOS</li><li>Avoids overwriting critical BIOS data areas</li><li>Understands where it can safely use memory for temporary storage</li></ul><h3 id=2-partition-table-reading>2. Partition Table Reading:<a hidden class=anchor aria-hidden=true href=#2-partition-table-reading>#</a></h3><p>It reads and interprets the partition table (located in the remaining 66 bytes of the 512-byte MBR) to identify which partition is marked as active/bootable.</p><h3 id=3-active-partition-location>3. Active Partition Location:<a hidden class=anchor aria-hidden=true href=#3-active-partition-location>#</a></h3><p>The code searches through the four partition table entries to find the one marked with the boot flag (0x80), indicating it&rsquo;s the active partition.</p><h3 id=4-loading-the-volume-boot-record>4. Loading the Volume Boot Record:<a hidden class=anchor aria-hidden=true href=#4-loading-the-volume-boot-record>#</a></h3><p>Once the active partition is identified, the boot loader loads the first sector of that partition (called the Volume Boot Record or VBR) into memory.</p><h3 id=5-transfer-control>5. Transfer Control:<a hidden class=anchor aria-hidden=true href=#5-transfer-control>#</a></h3><p>After loading the VBR, the MBR code transfers execution control to the VBR, which then continues the boot process by loading the operating system.</p><h3 id=6-error-handling>6. Error Handling:<a hidden class=anchor aria-hidden=true href=#6-error-handling>#</a></h3><p>The code includes basic error handling to display messages like &ldquo;Invalid partition table&rdquo; or &ldquo;Missing operating system&rdquo; if problems are encountered.</p><h2 id=processor-states>Processor States<a hidden class=anchor aria-hidden=true href=#processor-states>#</a></h2><p>It operates in 16-bit real mode with very limited memory and no operating system services. The code is typically written in assembly language and must be extremely efficient.</p><h3 id=what-is-real-mode>What is Real Mode?<a hidden class=anchor aria-hidden=true href=#what-is-real-mode>#</a></h3><p>Real mode is the default operating mode that x86 processors (starting with the 8086) boot into. It&rsquo;s called &ldquo;real&rdquo; because memory addresses correspond directly to actual physical memory locations - there&rsquo;s no virtual memory or memory protection.</p><h3 id=key-characteristics-of-16-bit-real-mode>Key Characteristics of 16-bit Real Mode:<a hidden class=anchor aria-hidden=true href=#key-characteristics-of-16-bit-real-mode>#</a></h3><h4 id=memory-addressing>Memory Addressing:<a hidden class=anchor aria-hidden=true href=#memory-addressing>#</a></h4><ul><li>Uses 16-bit registers but can access up to 1MB of memory (20-bit addressing)</li><li>Memory is accessed using a segmented model with segment:offset pairs</li><li>Example: address 0x1000:0x0500 means segment 0x1000 shifted left 4 bits + offset 0x0500. This gives physical address: (0x1000 &#171; 4) + 0x0500 = 0x10500</li></ul><h4 id=register-size>Register Size:<a hidden class=anchor aria-hidden=true href=#register-size>#</a></h4><ul><li>All general-purpose registers (AX, BX, CX, DX, etc.) are 16 bits wide</li><li>You can access 8-bit portions (AH/AL for register AX)</li><li>No 32-bit extended registers available</li></ul><h4 id=memory-limitations>Memory Limitations:<a hidden class=anchor aria-hidden=true href=#memory-limitations>#</a></h4><ul><li>Maximum addressable memory: 1MB (actually 1MB + 64KB - 16 bytes due to segment wraparound)</li><li>No memory protection - any code can access any memory location</li><li>No virtual memory management</li></ul><h4 id=instruction-set>Instruction Set:<a hidden class=anchor aria-hidden=true href=#instruction-set>#</a></h4><ul><li>Limited to 8086/8088 instruction set</li><li>No protected mode instructions</li><li>No floating-point unit access (unless manually enabled)</li></ul><h3 id=why-this-matters-for-mbr-code>Why This Matters for MBR Code?<a hidden class=anchor aria-hidden=true href=#why-this-matters-for-mbr-code>#</a></h3><ul><li>Size Constraints: With only 16-bit registers and limited addressing modes, the code must be extremely compact and efficient.</li><li>Direct Hardware Access: The code can directly access hardware ports and memory locations without operating system mediation.</li><li>No Modern Conveniences: No stack overflow protection, no memory management, no multitasking support.</li><li>Immediate Hardware Control: The processor starts in real mode, so the MBR code has direct control over the hardware from the moment it runs.</li></ul><h3 id=transition-to-protected-mode>Transition to Protected Mode:<a hidden class=anchor aria-hidden=true href=#transition-to-protected-mode>#</a></h3><p>Modern operating systems quickly transition from real mode to protected mode (32-bit) or long mode (64-bit) to gain access to:</p><ul><li>Full memory addressing capabilities</li><li>Memory protection and virtual memory</li><li>Advanced processor features</li><li>Better security and stability</li></ul><p>The MBR&rsquo;s job is essentially to bridge the gap between the primitive real mode environment and loading code that can set up a more sophisticated operating environment.</p><h2 id=capabilities-and-constraints-of-mbr-code>Capabilities and Constraints of MBR Code<a hidden class=anchor aria-hidden=true href=#capabilities-and-constraints-of-mbr-code>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/boot/>Boot</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>