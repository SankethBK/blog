<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What happens when you turn on computer? | Sanketh's Blog</title><meta name=keywords content="boot"><meta name=description content="1. Power‑On & Hardware Reset
1. Power‑Good Signal
The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it&rsquo;s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it&rsquo;s volatile.
2. CPU Reset Vector
The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically 0xFFFFFFF0 (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard&rsquo;s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.e2ed8047f83ad264119a8881d8496bb9bd824712cec7cb80665766cf714041fe.css integrity="sha256-4u2AR/g60mQRmoiB2Elrub2CRxLOx8uAZldmz3FAQf4=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="What happens when you turn on computer?"><meta property="og:description" content="1. Power‑On & Hardware Reset 1. Power‑Good Signal The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it’s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it’s volatile.
2. CPU Reset Vector The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically 0xFFFFFFF0 (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard’s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-02T00:00:00+00:00"><meta property="article:tag" content="Boot"><meta name=twitter:card content="summary"><meta name=twitter:title content="What happens when you turn on computer?"><meta name=twitter:description content="1. Power‑On & Hardware Reset
1. Power‑Good Signal
The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it&rsquo;s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it&rsquo;s volatile.
2. CPU Reset Vector
The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically 0xFFFFFFF0 (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard&rsquo;s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"What happens when you turn on computer?","item":"https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What happens when you turn on computer?","name":"What happens when you turn on computer?","description":"1. Power‑On \u0026amp; Hardware Reset 1. Power‑Good Signal The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it\u0026rsquo;s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it\u0026rsquo;s volatile.\n2. CPU Reset Vector The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically 0xFFFFFFF0 (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard\u0026rsquo;s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware.\n","keywords":["boot"],"articleBody":"1. Power‑On \u0026 Hardware Reset 1. Power‑Good Signal The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it’s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it’s volatile.\n2. CPU Reset Vector The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically 0xFFFFFFF0 (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard’s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware.\n3. Microcode / Internal Init Microcode is low-level firmware that lives inside the CPU itself. Microcode sits between the CPU’s hardware and the instruction set architecture (ISA). It’s a set of hardware-level instructions that implement the higher-level machine code instructions or control the finite-state machine within the processor. Modern CPUs may load or patch microcode from firmware to work around hardware errata before executing any instructions without changing the physical hardware.\n2. Firmware Initialization 1. POST (Power‑On Self Test) When you press the power button, electricity flows to the motherboard and the Basic Input/Output System (BIOS) or Unified Extensible Firmware Interface (UEFI) stored in non-volatile memory springs to life. This firmware is the first code that runs, and it immediately begins the Power-On Self-Test. During POST, the system checks critical hardware components like RAM, CPU, storage devices, and peripheral connections. You’ll often hear beeps or see LED indicators during this phase - these are diagnostic codes indicating whether hardware is functioning properly. Sets up basic text or graphic mode so you can see firmware messages.\n2. Core Hardware Initialization After POST completes successfully, the firmware initializes hardware components in a specific order. It configures the CPU, sets up memory controllers, initializes storage controllers, and establishes communication pathways between components. The firmware also detects and catalogs all connected hardware, building a map of available resources that will be passed to the operating system later.\n3. Option ROMs \u0026 Plug‑In Cards The firmware then scans all PCI and PCIe expansion slots 1, looking for add-in cards that have their own firmware called Option ROMs. These are small pieces of code stored on the expansion cards themselves - think of them as mini-BIOS programs for specific hardware components.\nCommon examples include RAID controller cards (which need to initialize disk arrays), network interface cards (NICs) that might support network booting 2, graphics cards (which contain video BIOS for display initialization), and storage controllers for SCSI or SAS drives. When the firmware finds an Option ROM, it loads and executes this code, allowing the expansion card to initialize itself, register its services with the system, and make its capabilities available to both the firmware and the eventual operating system.\n3. Boot Device Selection 1. Boot Order The firmware consults its boot priority list (which you can modify in BIOS/UEFI settings) to determine which storage device to boot from. This could be a hard drive, SSD, USB drive, optical disc, or network location. It searches each device in order until it finds one with a valid boot sector or boot loader. The firmware examines each device for bootable signatures - on legacy BIOS systems, it looks for the magic number 0x55AA at the end of the first sector, while UEFI systems search for valid EFI boot applications in the EFI System Partition. If a device fails to respond or lacks bootable content, the firmware moves to the next device in the priority list. This process continues until a valid boot device is found or all options are exhausted, at which point you’ll see an error like “No bootable device found.”\n2. Secure Boot (UEFI only) Secure Boot is a security feature that creates a chain of trust from firmware to operating system by using cryptographic signatures. When enabled, the firmware maintains a database of trusted cryptographic keys and will only execute boot loaders and OS kernels that are digitally signed with certificates matching these trusted keys. This prevents malicious software, rootkits, or unauthorized operating systems from loading during the boot process.\n4. Bootloader Stage: Master Boot Record (MBR) vs GUID Partition Table (GPT) 1. Master Boot Record (MBR) - Legacy BIOS Systems The MBR is a 512-byte sector located at the very beginning of a storage device (Logical Block Address 0) 3. This single sector contains everything needed to understand the disk’s partition layout and begin the boot process.\nMBR Structure Breakdown: Bytes 0-445 (446 bytes): Boot code area containing the Master Boot Record code, often called the “bootstrap” code. This is a tiny program that the BIOS loads and executes directly. Bytes 446-509 (64 bytes): Partition table containing four 16-byte entries, each describing a primary partition. Bytes 510-511 (2 bytes): Boot signature 0x55AA that validates this as a bootable sector Each Partition Table Entry (16 bytes) contains:\nBoot flag (1 byte) - indicates if this partition is active/bootable Starting CHS address (3 bytes) - Cylinder, Head, Sector in old addressing Partition type (1 byte) - identifies the file system (0x83 for Linux, 0x07 for NTFS, etc.) Ending CHS address (3 bytes) Starting LBA address (4 bytes) - modern sector addressing Partition size in sectors (4 bytes) MBR Boot Process: When the BIOS finds a valid MBR, it loads all 512 bytes into memory at address 0x7C00 and jumps to that location. The MBR code then examines the partition table, finds the active partition (boot flag set), and loads the first sector of that partition (called the Partition Boot Record or Volume Boot Record) which contains the actual operating system boot loader.\nMBR Limitations: Maximum of 4 primary partitions (workaround: extended partitions) Cannot handle disks larger than 2TB due to 32-bit LBA addressing Single point of failure - if MBR is corrupted, entire disk becomes unbootable No built-in redundancy or error correction How MBR Supports booting multiple OSes The MBR’s job is simple and dumb. It scans the four entries in its partition table, finds the one and only one partition that has the “active” flag set, and then it loads the bootloader from that partition. It ignores the other three. That’s it. The MBR boot code has no menu system, no user interface, no choice mechanism - it’s too small and primitive for that.\nThe MBR itself doesn’t load the operating system. Its sole job is to pass control to the next stage. This process is called chain loading.\nBIOS/UEFI (in legacy mode) loads the MBR code (from the first sector of the boot device) into memory and executes it. MBR code finds the active partition and loads the boot code from that partition’s first sector. This is known as the Partition Boot Record (PBR) or Volume Boot Record (VBR). PBR/VBR code contains the instructions needed to load the actual operating system files (like the Windows bootmgr or the Linux GRUB loader) from its own partition. This creates a chain of trust, where each small program is responsible for loading and executing the next, slightly larger and more complex program, until the full OS kernel is running. Example Multi-Boot Setup\nPartition 1: /boot (active, contains GRUB) ← MBR points here Partition 2: Ubuntu root filesystem Partition 3: Windows NTFS Partition 4: Shared data Boot sequence:\nMBR → finds active Partition 1 → loads GRUB GRUB → shows menu: “Ubuntu or Windows?” User selects → GRUB loads appropriate kernel or chain-loads Windows boot loader Overcoming the 4-Partition Limit: Extended and Logical Partitions The MBR’s limit of four primary partitions was a significant constraint. To work around this, the concept of an extended partition was introduced.\nYou can designate one of your four primary partitions as an “extended partition.” This extended partition doesn’t hold a filesystem directly. Instead, it acts as a container for multiple logical partitions. You can create many logical partitions inside this single extended partition, each with its own drive letter and filesystem. A common disk layout might look like this:\nPrimary Partition 1: Windows OS (C:) Primary Partition 2: Linux OS Primary Partition 3 (Extended Partition Container): Logical Partition 1: Data Drive (D:) Logical Partition 2: Backup Drive (E:) Logical Partition 3: Shared Files (F:) Primary Partition 4: Empty/Unused This system was a functional, if complex, workaround. However, it’s a perfect example of the legacy baggage that led to the development of the much simpler and more powerful GUID Partition Table (GPT).\nGUID Partition Table (GPT) - Modern UEFI Systems GPT is a much more sophisticated partitioning scheme that addresses all of MBR’s limitations. It’s part of the UEFI specification and provides better data integrity and flexibility.\nLBA 0: Protective MBR: For backward compatibility, the very first sector of a GPT disk still contains a 512 byte MBR styled memory called “protective” MBR. This MBR has a single partition entry of size same as disk’s size and type 0xEE (invalid partition type, to prevent legacy tools from misidentifying). This tricks the legacy MBR-only tools into thinking that the disk is already full so it can’t create any new partitions from misidentifying the disk as unformatted and accidentally overwriting it. LBA 1: Primary GPT Header: This header defines the layout of the partition table itself. It contains: A signature (“EFI PART”) to identify it as a GPT disk. The location of the partition entries. The number of partition entries. A unique GUID (Globally Unique Identifier) for the entire disk. A CRC32 checksum for the header and the partition table, which allows the system to verify their integrity. LBA 2 to LBA 33 (typically): Partition Entry Array: This is where the actual partition information is stored. By default, GPT allocates space for 128 partition entries (128 bytes each), though this can be changed. Partition Data: The rest of the disk is used for the actual partitions. Last 33 LBAs: Backup GPT header and partition entries (mirror of the beginning). Each Partition Table Entry (128 bytes) contains: Partition Type GUID (16 bytes): A unique ID that specifies the partition’s purpose (e.g., an EFI System Partition, a Microsoft basic data partition). This is far more specific than MBR’s single-byte type code. Unique Partition GUID (16 bytes): Every single partition on the disk gets its own unique identifier. Starting and Ending LBA address (8 bytes each): Uses 64-bit addressing, allowing for astronomically large disk sizes. Partition Attributes (8 bytes): Flags that define properties like “read-only” or “bootable.” Partition Name (72 bytes): A human-readable name (e.g., “Linux home”) stored in Unicode. GPT/UEFI Boot Process: The boot process on a UEFI system with a GPT disk is fundamentally different and more robust than the legacy BIOS/MBR method.\nThe UEFI firmware initializes and scans the storage devices. Instead of executing code from a boot sector, the UEFI firmware actively looks for a specific partition known as the EFI System Partition (ESP). The ESP is identified by its Partition Type GUID. The UEFI firmware understands file systems (typically FAT32), so it can mount the ESP and browse its contents. It looks for a bootloader application at a standardized file path, such as \\EFI\\BOOT\\BOOTX64.EFI (for removable media) or a vendor-specific path like \\EFI\\Microsoft\\Boot\\bootmgfw.efi for Windows. Once found, the firmware executes this .efi bootloader file directly, which then takes over to load the operating system kernel. GPT Advantages over MBR: Massive Disk Sizes: Supports disks larger than 2TB (up to 9.4 ZB - zettabytes - in theory) thanks to 64-bit LBA addressing. More Partitions: Allows for 128 primary partitions by default, eliminating the need for the complex extended/logical partition scheme. Redundancy and Reliability: The backup GPT header and CRC32 checksums provide protection against data corruption in the partition table. If the primary header is damaged, the disk can be recovered from the backup. No “Active” Partition: The bootable partition is defined in the UEFI firmware’s boot manager settings, not by a fragile flag on the partition itself, making multi-booting cleaner. Unique IDs: Using GUIDs for both the disk and partitions prevents potential conflicts and collisions that could occur with MBR systems. 5. Kernel Loading Once the bootloader has been identified and loaded by either the BIOS/MBR or UEFI/GPT process, its one and only job is to find the operating system’s kernel, load it into memory, and hand over control of the system. This is the moment the actual operating system begins to take charge.\n1. Boot Loader to Kernel Handoff The bootloader (like GRUB for Linux or the Windows Boot Manager) knows where to find the kernel file on the storage device (e.g., vmlinuz in Linux 4, ntoskrnl.exe in Windows 5). But the kernel alone isn’t enough.\nModern kernels are modular and don’t contain every possible hardware driver. To solve this chicken-and-egg problem—where the kernel needs drivers to access the disk, but the drivers are on the disk—the bootloader also loads an initial RAM disk (initrd) or initial RAM filesystem (initramfs) into memory alongside the kernel.\nThis initrd is a temporary, compressed filesystem that contains the essential drivers and tools needed for the kernel to access the main storage device and other critical hardware.\n1. Memory Layout Setup: The kernel is loaded at a specific memory address (typically around 1MB on x86 systems). Boot loader creates a memory map showing which areas are safe to use. Sets up initial page tables for virtual memory management. Preserves important boot information in memory that the kernel will need. 2. CPU State Preparation: Switches CPU from 16-bit real mode to 32-bit protected mode (or 64-bit long mode). Disables interrupts temporarily. Sets up initial stack pointer. Prepares CPU registers with boot parameters. Boot Parameters: The boot loader passes crucial information to the kernel through standardized protocols:\nLinux: Boot protocol with command line arguments, initrd location, memory map Windows: Boot Configuration Data (BCD) and hardware abstraction layer info Hardware details: Available RAM, CPU features, device tree (on ARM systems) 3. Kernel Initialization: Building the System The moment the kernel begins executing, it runs in a highly constrained environment. It must bootstrap itself, initializing all its core subsystems to transform the raw hardware into a fully functional operating system.\n1. Entry Point and Early Setup The kernel’s very first instructions are architecture-specific and focus on creating a stable environment for the rest of the initialization:\nInitializes Core CPU Structures: Sets up the Interrupt Descriptor Table (IDT) to handle hardware interrupts and exceptions, though interrupts remain disabled for now. Processes Boot Information: Parses the command-line arguments and memory map passed by the bootloader to understand its environment and available resources. Validates Integrity: If Secure Boot is enabled, the kernel validates its own digital signature to ensure it hasn’t been tampered with. 2. Memory Management Initialization The kernel immediately takes control of all system memory:\nVirtual Memory Setup: It creates a comprehensive set of page tables to map virtual addresses to physical RAM addresses, establishing the kernel’s own protected address space. Physical Memory Management: Using the map from the bootloader, it builds a complete picture of physical memory, initializing allocators (like the buddy and slab allocators) to manage free and used memory frames. 3. Core Subsystem Initialization With memory management active, the kernel brings its fundamental components online:\nProcess Management: Creates the first process, the idle process (PID 0), and initializes the process scheduler, which is responsible for task switching. Interrupt and Exception Handling: Configures the system’s interrupt controllers (PIC/APIC) and enables interrupts, allowing hardware to communicate with the CPU. Synchronization Primitives: Initializes the low-level mechanisms like mutexes, semaphores, and spinlocks that are essential for preventing data corruption on multiprocessor systems. 4. Device and Driver Infrastructure The kernel sets up the framework for communicating with hardware:\nDevice Model Framework: Initializes the device driver subsystem and parses hardware information from ACPI tables (on x86) or a device tree (on ARM) to discover what hardware is present. Essential Driver Loading: Loads the built-in drivers compiled directly into the kernel, focusing on those needed to access the root filesystem (e.g., SATA/NVMe drivers). Hardware Abstraction: Initializes platform-specific code and Hardware Abstraction Layers (HAL) to provide a consistent interface for the rest of the kernel to interact with the underlying hardware. 5. Filesystem and I/O Preparation Before it can mount the root filesystem, the kernel prepares its I/O subsystems:\nVirtual File System (VFS): Initializes the VFS, an abstraction layer that allows the kernel to treat all filesystems (like ext4, NTFS, etc.) in a uniform way. Block Device Layer: Initializes the subsystem that manages block devices (like hard drives and SSDs) and sets up I/O schedulers to optimize disk requests. 6. Initial Process Creation The kernel creates its own essential background threads (like kthreadd for managing other kernel threads) and then prepares to make the critical leap from kernel space to user space.\n7. Transition to User Space Mounting the Root Filesystem: The kernel first mounts the initrd/initramfs as a temporary root filesystem. The drivers and tools in the initrd are used to mount the real root filesystem from the main storage device. Launching the Init Process: The kernel creates the very first user-space process, which is given Process ID 1 (PID 1). This process is the ancestor of all other user processes. On modern Linux systems, this is systemd; on Windows, it’s smss.exe. 8. Handoff to the Init System At this point, the kernel’s primary initialization is complete. It has transformed into a fully preemptive, multitasking operating system kernel. While the kernel continues to run for the lifetime of the system—managing hardware, handling interrupts, and processing system calls—it now hands the responsibility of finishing the boot process to the init system. The init system is responsible for starting all the higher-level services, such as networking, background daemons, and ultimately, the user login screen.\nPCI (Peripheral Component Interconnect) and PCIe (Peripheral Component Interconnect Express) are both interface standards for connecting hardware components to a computer’s motherboard, but PCIe is a newer, faster, and more flexible version of PCI. ↩︎\nNetwork booting (PXE - Preboot Execution Environment) allows a computer to boot an operating system directly from a network server rather than local storage. When enabled, the network card’s Option ROM takes control during the boot process and broadcasts a DHCP request that includes PXE-specific information. A PXE-enabled DHCP server responds with an IP address for the client plus the location of a TFTP (Trivial File Transfer Protocol) server and the filename of a network boot loader. The client then downloads this small boot loader over the network and executes it, which in turn can download a kernel, initial ramdisk, or even a complete operating system image. This technology is commonly used in corporate environments for automated OS deployment, diskless workstations, and system recovery scenarios, as it allows administrators to boot and manage hundreds of computers from a central server without needing individual storage devices or manual intervention on each machine. ↩︎\nLogical Block Address 0 refers to the first addressable unit of storage on a device. Think of LBA as a simple numbering system that starts from 0 and counts up sequentially. Modern storage devices use LBA as an abstraction layer that hides the physical complexity of how data is actually stored. Whether it’s a traditional hard drive with physical cylinders, heads, and sectors, or a solid-state drive with flash memory cells arranged in pages and blocks, the operating system and firmware see everything as a linear sequence of logical blocks. ↩︎\nvmlinuz is the name of the Linux kernel executable file. The name is historical and descriptive:\nvm: Stands for Virtual Memory, indicating the kernel supports this feature. linuz: Refers to the Linux kernel, and the z at the end signifies that it is a zlib-compressed executable. When the bootloader loads this file, the first thing the kernel does is decompress itself into memory before it begins initializing the system. ↩︎ ntoskrnl.exe stands for Windows NT Operating System Kernel. It is the fundamental kernel space module for the Windows NT family of operating systems (including all modern versions like Windows 10/11 and Windows Server). This single executable file contains the Windows kernel, the executive, the memory manager, and other core components responsible for managing the system’s hardware and software resources. ↩︎\n","wordCount":"3389","inLanguage":"en","datePublished":"2025-07-02T00:00:00Z","dateModified":"2025-07-02T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/boot/2025-07-02-how-computer-boots/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">What happens when you turn on computer?</h1><div class=post-meta><span title='2025-07-02 00:00:00 +0000 UTC'>July 2, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/boot/2025-07-02-how-computer-boots.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-poweron--hardware-reset aria-label="1. Power‑On & Hardware Reset">1. Power‑On & Hardware Reset</a><ul><li><a href=#1-powergood-signal aria-label="1. Power‑Good Signal">1. Power‑Good Signal</a></li><li><a href=#2-cpu-reset-vector aria-label="2. CPU Reset Vector">2. CPU Reset Vector</a></li><li><a href=#3-microcode--internal-init aria-label="3. Microcode / Internal Init">3. Microcode / Internal Init</a></li></ul></li><li><a href=#2-firmware-initialization aria-label="2. Firmware Initialization">2. Firmware Initialization</a><ul><li><a href=#1-post-poweron-self-test aria-label="1. POST (Power‑On Self Test)">1. POST (Power‑On Self Test)</a></li><li><a href=#2-core-hardware-initialization aria-label="2. Core Hardware Initialization">2. Core Hardware Initialization</a></li><li><a href=#3-option-roms--plugin-cards aria-label="3. Option ROMs & Plug‑In Cards">3. Option ROMs & Plug‑In Cards</a></li></ul></li><li><a href=#3-boot-device-selection aria-label="3. Boot Device Selection">3. Boot Device Selection</a><ul><li><a href=#1-boot-order aria-label="1. Boot Order">1. Boot Order</a></li><li><a href=#2-secure-boot-uefi-only aria-label="2. Secure Boot (UEFI only)">2. Secure Boot (UEFI only)</a></li></ul></li><li><a href=#4-bootloader-stage-master-boot-record-mbr-vs-guid-partition-table-gpt aria-label="4. Bootloader Stage: Master Boot Record (MBR) vs GUID Partition Table (GPT)">4. Bootloader Stage: Master Boot Record (MBR) vs GUID Partition Table (GPT)</a><ul><li><a href=#1-master-boot-record-mbr---legacy-bios-systems aria-label="1. Master Boot Record (MBR) - Legacy BIOS Systems">1. Master Boot Record (MBR) - Legacy BIOS Systems</a><ul><li><a href=#mbr-structure-breakdown aria-label="MBR Structure Breakdown:">MBR Structure Breakdown:</a></li><li><a href=#mbr-boot-process aria-label="MBR Boot Process:">MBR Boot Process:</a></li><li><a href=#mbr-limitations aria-label="MBR Limitations:">MBR Limitations:</a></li><li><a href=#how-mbr-supports-booting-multiple-oses aria-label="How MBR Supports booting multiple OSes">How MBR Supports booting multiple OSes</a></li><li><a href=#overcoming-the-4-partition-limit-extended-and-logical-partitions aria-label="Overcoming the 4-Partition Limit: Extended and Logical Partitions">Overcoming the 4-Partition Limit: Extended and Logical Partitions</a></li></ul></li><li><a href=#guid-partition-table-gpt---modern-uefi-systems aria-label="GUID Partition Table (GPT) - Modern UEFI Systems">GUID Partition Table (GPT) - Modern UEFI Systems</a><ul><li><a href=#each-partition-table-entry-128-bytes-contains aria-label="Each Partition Table Entry (128 bytes) contains:">Each Partition Table Entry (128 bytes) contains:</a></li><li><a href=#gptuefi-boot-process aria-label="GPT/UEFI Boot Process:">GPT/UEFI Boot Process:</a></li><li><a href=#gpt-advantages-over-mbr aria-label="GPT Advantages over MBR:">GPT Advantages over MBR:</a></li></ul></li></ul></li><li><a href=#5-kernel-loading aria-label="5. Kernel Loading">5. Kernel Loading</a><ul><li><a href=#1-boot-loader-to-kernel-handoff aria-label="1. Boot Loader to Kernel Handoff">1. Boot Loader to Kernel Handoff</a><ul><li><a href=#1-memory-layout-setup aria-label="1. Memory Layout Setup:">1. Memory Layout Setup:</a></li><li><a href=#2-cpu-state-preparation aria-label="2. CPU State Preparation:">2. CPU State Preparation:</a></li></ul></li></ul></li><li><a href=#3-kernel-initialization-building-the-system aria-label="3. Kernel Initialization: Building the System">3. Kernel Initialization: Building the System</a><ul><li><a href=#1-entry-point-and-early-setup aria-label="1. Entry Point and Early Setup">1. Entry Point and Early Setup</a></li><li><a href=#2-memory-management-initialization aria-label="2. Memory Management Initialization">2. Memory Management Initialization</a></li><li><a href=#3-core-subsystem-initialization aria-label="3. Core Subsystem Initialization">3. Core Subsystem Initialization</a></li><li><a href=#4-device-and-driver-infrastructure aria-label="4. Device and Driver Infrastructure">4. Device and Driver Infrastructure</a></li><li><a href=#5-filesystem-and-io-preparation aria-label="5. Filesystem and I/O Preparation">5. Filesystem and I/O Preparation</a></li><li><a href=#6-initial-process-creation aria-label="6. Initial Process Creation">6. Initial Process Creation</a></li><li><a href=#7-transition-to-user-space aria-label="7. Transition to User Space">7. Transition to User Space</a></li><li><a href=#8-handoff-to-the-init-system aria-label="8. Handoff to the Init System">8. Handoff to the Init System</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=1-poweron--hardware-reset>1. Power‑On & Hardware Reset<a hidden class=anchor aria-hidden=true href=#1-poweron--hardware-reset>#</a></h2><h3 id=1-powergood-signal>1. Power‑Good Signal<a hidden class=anchor aria-hidden=true href=#1-powergood-signal>#</a></h3><p>The power supply stabilizes voltages and asserts a “Power‑Good” (PWR_OK) line to the motherboard. All devices receive power and begin to initialize themselves. The Central Processing Unit (CPU) is initially held in a reset mode, meaning it&rsquo;s not yet executing instructions. The memory layout is powered up, although the RAM itself has no content since it&rsquo;s volatile.</p><h3 id=2-cpu-reset-vector>2. CPU Reset Vector<a hidden class=anchor aria-hidden=true href=#2-cpu-reset-vector>#</a></h3><p>The reset vector is a predetermined memory address where the CPU begins execution after being powered on or reset. On x86 processors, this address is typically <code>0xFFFFFFF0</code> (near the top of the 4GB address space). When the CPU comes out of reset, its program counter (instruction pointer) is automatically set to this address. The motherboard&rsquo;s memory mapping ensures that this address points to the BIOS/UEFI firmware ROM chip, so the very first instruction the CPU executes comes from the firmware.</p><h3 id=3-microcode--internal-init>3. Microcode / Internal Init<a hidden class=anchor aria-hidden=true href=#3-microcode--internal-init>#</a></h3><p>Microcode is low-level firmware that lives inside the CPU itself. Microcode sits between the CPU&rsquo;s hardware and the instruction set architecture (ISA). It&rsquo;s a set of hardware-level instructions that implement the higher-level machine code instructions or control the finite-state machine within the processor.
Modern CPUs may load or patch microcode from firmware to work around hardware errata before executing any instructions without changing the physical hardware.</p><h2 id=2-firmware-initialization>2. Firmware Initialization<a hidden class=anchor aria-hidden=true href=#2-firmware-initialization>#</a></h2><h3 id=1-post-poweron-self-test>1. POST (Power‑On Self Test)<a hidden class=anchor aria-hidden=true href=#1-post-poweron-self-test>#</a></h3><p>When you press the power button, electricity flows to the motherboard and the Basic Input/Output System (BIOS) or Unified Extensible Firmware Interface (UEFI) stored in non-volatile memory springs to life. This firmware is the first code that runs, and it immediately begins the Power-On Self-Test. During POST, the system checks critical hardware components like RAM, CPU, storage devices, and peripheral connections. You&rsquo;ll often hear beeps or see LED indicators during this phase - these are diagnostic codes indicating whether hardware is functioning properly. Sets up basic text or graphic mode so you can see firmware messages.</p><h3 id=2-core-hardware-initialization>2. Core Hardware Initialization<a hidden class=anchor aria-hidden=true href=#2-core-hardware-initialization>#</a></h3><p>After POST completes successfully, the firmware initializes hardware components in a specific order. It configures the CPU, sets up memory controllers, initializes storage controllers, and establishes communication pathways between components. The firmware also detects and catalogs all connected hardware, building a map of available resources that will be passed to the operating system later.</p><h3 id=3-option-roms--plugin-cards>3. Option ROMs & Plug‑In Cards<a hidden class=anchor aria-hidden=true href=#3-option-roms--plugin-cards>#</a></h3><p>The firmware then scans all PCI and PCIe expansion slots <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, looking for add-in cards that have their own firmware called Option ROMs. These are small pieces of code stored on the expansion cards themselves - think of them as mini-BIOS programs for specific hardware components.</p><p>Common examples include RAID controller cards (which need to initialize disk arrays), network interface cards (NICs) that might support network booting <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, graphics cards (which contain video BIOS for display initialization), and storage controllers for SCSI or SAS drives. When the firmware finds an Option ROM, it loads and executes this code, allowing the expansion card to initialize itself, register its services with the system, and make its capabilities available to both the firmware and the eventual operating system.</p><h2 id=3-boot-device-selection>3. Boot Device Selection<a hidden class=anchor aria-hidden=true href=#3-boot-device-selection>#</a></h2><h3 id=1-boot-order>1. Boot Order<a hidden class=anchor aria-hidden=true href=#1-boot-order>#</a></h3><p>The firmware consults its boot priority list (which you can modify in BIOS/UEFI settings) to determine which storage device to boot from. This could be a hard drive, SSD, USB drive, optical disc, or network location. It searches each device in order until it finds one with a valid boot sector or boot loader. The firmware examines each device for bootable signatures - on legacy BIOS systems, it looks for the magic number <code>0x55AA</code> at the end of the first sector, while UEFI systems search for valid EFI boot applications in the EFI System Partition. If a device fails to respond or lacks bootable content, the firmware moves to the next device in the priority list. This process continues until a valid boot device is found or all options are exhausted, at which point you&rsquo;ll see an error like &ldquo;No bootable device found.&rdquo;</p><h3 id=2-secure-boot-uefi-only>2. Secure Boot (UEFI only)<a hidden class=anchor aria-hidden=true href=#2-secure-boot-uefi-only>#</a></h3><p>Secure Boot is a security feature that creates a chain of trust from firmware to operating system by using cryptographic signatures. When enabled, the firmware maintains a database of trusted cryptographic keys and will only execute boot loaders and OS kernels that are digitally signed with certificates matching these trusted keys. This prevents malicious software, rootkits, or unauthorized operating systems from loading during the boot process.</p><h2 id=4-bootloader-stage-master-boot-record-mbr-vs-guid-partition-table-gpt>4. Bootloader Stage: Master Boot Record (MBR) vs GUID Partition Table (GPT)<a hidden class=anchor aria-hidden=true href=#4-bootloader-stage-master-boot-record-mbr-vs-guid-partition-table-gpt>#</a></h2><h3 id=1-master-boot-record-mbr---legacy-bios-systems>1. Master Boot Record (MBR) - Legacy BIOS Systems<a hidden class=anchor aria-hidden=true href=#1-master-boot-record-mbr---legacy-bios-systems>#</a></h3><p>The MBR is a 512-byte sector located at the very beginning of a storage device (Logical Block Address 0) <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. This single sector contains everything needed to understand the disk&rsquo;s partition layout and begin the boot process.</p><h4 id=mbr-structure-breakdown>MBR Structure Breakdown:<a hidden class=anchor aria-hidden=true href=#mbr-structure-breakdown>#</a></h4><ul><li><strong>Bytes 0-445 (446 bytes):</strong> Boot code area containing the Master Boot Record code, often called the &ldquo;bootstrap&rdquo; code. This is a tiny program that the BIOS loads and executes directly.</li><li><strong>Bytes 446-509 (64 bytes):</strong> Partition table containing four 16-byte entries, each describing a primary partition.</li><li><strong>Bytes 510-511 (2 bytes):</strong> Boot signature <code>0x55AA</code> that validates this as a bootable sector</li></ul><p><strong>Each Partition Table Entry (16 bytes) contains:</strong></p><ul><li>Boot flag (1 byte) - indicates if this partition is active/bootable</li><li>Starting CHS address (3 bytes) - Cylinder, Head, Sector in old addressing</li><li>Partition type (1 byte) - identifies the file system (<code>0x83</code> for Linux, <code>0x07</code> for NTFS, etc.)</li><li>Ending CHS address (3 bytes)</li><li>Starting LBA address (4 bytes) - modern sector addressing</li><li>Partition size in sectors (4 bytes)</li></ul><h4 id=mbr-boot-process>MBR Boot Process:<a hidden class=anchor aria-hidden=true href=#mbr-boot-process>#</a></h4><p>When the BIOS finds a valid MBR, it loads all 512 bytes into memory at address <code>0x7C00</code> and jumps to that location. The MBR code then examines the partition table, finds the active partition (boot flag set), and loads the first sector of that partition (called the Partition Boot Record or Volume Boot Record) which contains the actual operating system boot loader.</p><h4 id=mbr-limitations>MBR Limitations:<a hidden class=anchor aria-hidden=true href=#mbr-limitations>#</a></h4><ul><li>Maximum of 4 primary partitions (workaround: extended partitions)</li><li>Cannot handle disks larger than 2TB due to 32-bit LBA addressing</li><li>Single point of failure - if MBR is corrupted, entire disk becomes unbootable</li><li>No built-in redundancy or error correction</li></ul><h4 id=how-mbr-supports-booting-multiple-oses>How MBR Supports booting multiple OSes<a hidden class=anchor aria-hidden=true href=#how-mbr-supports-booting-multiple-oses>#</a></h4><p>The MBR&rsquo;s job is simple and dumb. It scans the four entries in its partition table, finds the one and only one partition that has the &ldquo;active&rdquo; flag set, and then it loads the bootloader from that partition. It ignores the other three. That&rsquo;s it. The MBR boot code has no menu system, no user interface, no choice mechanism - it&rsquo;s too small and primitive for that.</p><p>The MBR itself doesn&rsquo;t load the operating system. Its sole job is to pass control to the next stage. This process is called <strong>chain loading</strong>.</p><ol><li>BIOS/UEFI (in legacy mode) loads the MBR code (from the first sector of the boot device) into memory and executes it.</li><li>MBR code finds the active partition and loads the boot code from that partition&rsquo;s first sector. This is known as the Partition Boot Record (PBR) or Volume Boot Record (VBR).</li><li>PBR/VBR code contains the instructions needed to load the actual operating system files (like the Windows bootmgr or the Linux GRUB loader) from its own partition.</li><li>This creates a chain of trust, where each small program is responsible for loading and executing the next, slightly larger and more complex program, until the full OS kernel is running.</li></ol><p>Example Multi-Boot Setup</p><pre tabindex=0><code>Partition 1: /boot (active, contains GRUB) ← MBR points here
Partition 2: Ubuntu root filesystem
Partition 3: Windows NTFS
Partition 4: Shared data
</code></pre><p>Boot sequence:</p><ol><li>MBR → finds active Partition 1 → loads GRUB</li><li>GRUB → shows menu: &ldquo;Ubuntu or Windows?&rdquo;</li><li>User selects → GRUB loads appropriate kernel or chain-loads Windows boot loader</li></ol><h4 id=overcoming-the-4-partition-limit-extended-and-logical-partitions>Overcoming the 4-Partition Limit: Extended and Logical Partitions<a hidden class=anchor aria-hidden=true href=#overcoming-the-4-partition-limit-extended-and-logical-partitions>#</a></h4><p>The MBR&rsquo;s limit of four primary partitions was a significant constraint. To work around this, the concept of an extended partition was introduced.</p><ul><li>You can designate one of your four primary partitions as an &ldquo;extended partition.&rdquo;</li><li>This extended partition doesn&rsquo;t hold a filesystem directly. Instead, it acts as a container for multiple logical partitions.</li><li>You can create many logical partitions inside this single extended partition, each with its own drive letter and filesystem.</li></ul><p>A common disk layout might look like this:</p><ul><li>Primary Partition 1: Windows OS (C:)</li><li>Primary Partition 2: Linux OS</li><li>Primary Partition 3 (Extended Partition Container):<ul><li>Logical Partition 1: Data Drive (D:)</li><li>Logical Partition 2: Backup Drive (E:)</li><li>Logical Partition 3: Shared Files (F:)</li></ul></li><li>Primary Partition 4: Empty/Unused</li></ul><p>This system was a functional, if complex, workaround. However, it&rsquo;s a perfect example of the legacy baggage that led to the development of the much simpler and more powerful GUID Partition Table (GPT).</p><h3 id=guid-partition-table-gpt---modern-uefi-systems>GUID Partition Table (GPT) - Modern UEFI Systems<a hidden class=anchor aria-hidden=true href=#guid-partition-table-gpt---modern-uefi-systems>#</a></h3><p>GPT is a much more sophisticated partitioning scheme that addresses all of MBR&rsquo;s limitations. It&rsquo;s part of the UEFI specification and provides better data integrity and flexibility.</p><ul><li><strong>LBA 0: Protective MBR:</strong> For backward compatibility, the very first sector of a GPT disk still contains a 512 byte MBR styled memory called &ldquo;protective&rdquo; MBR. This MBR has a single partition entry of size same as disk&rsquo;s size and type <code>0xEE</code> (invalid partition type, to prevent legacy tools from misidentifying). This tricks the legacy MBR-only tools into thinking that the disk is already full so it can&rsquo;t create any new partitions from misidentifying the disk as unformatted and accidentally overwriting it.</li><li><strong>LBA 1: Primary GPT Header:</strong> This header defines the layout of the partition table itself. It contains:<ul><li>A signature (&ldquo;EFI PART&rdquo;) to identify it as a GPT disk.</li><li>The location of the partition entries.</li><li>The number of partition entries.</li><li>A unique GUID (Globally Unique Identifier) for the entire disk.</li><li>A CRC32 checksum for the header and the partition table, which allows the system to verify their integrity.</li></ul></li><li><strong>LBA 2 to LBA 33 (typically):</strong> Partition Entry Array: This is where the actual partition information is stored. By default, GPT allocates space for 128 partition entries (128 bytes each), though this can be changed.</li><li><strong>Partition Data:</strong> The rest of the disk is used for the actual partitions.</li><li><strong>Last 33 LBAs:</strong> Backup GPT header and partition entries (mirror of the beginning).</li></ul><h4 id=each-partition-table-entry-128-bytes-contains>Each Partition Table Entry (128 bytes) contains:<a hidden class=anchor aria-hidden=true href=#each-partition-table-entry-128-bytes-contains>#</a></h4><ul><li><strong>Partition Type GUID (16 bytes):</strong> A unique ID that specifies the partition&rsquo;s purpose (e.g., an EFI System Partition, a Microsoft basic data partition). This is far more
specific than MBR&rsquo;s single-byte type code.</li><li><strong>Unique Partition GUID (16 bytes):</strong> Every single partition on the disk gets its own unique identifier.</li><li><strong>Starting and Ending LBA address (8 bytes each):</strong> Uses 64-bit addressing, allowing for astronomically large disk sizes.</li><li><strong>Partition Attributes (8 bytes):</strong> Flags that define properties like &ldquo;read-only&rdquo; or &ldquo;bootable.&rdquo;</li><li><strong>Partition Name (72 bytes):</strong> A human-readable name (e.g., &ldquo;Linux home&rdquo;) stored in Unicode.</li></ul><h4 id=gptuefi-boot-process>GPT/UEFI Boot Process:<a hidden class=anchor aria-hidden=true href=#gptuefi-boot-process>#</a></h4><p>The boot process on a UEFI system with a GPT disk is fundamentally different and more robust than the legacy BIOS/MBR method.</p><ol><li>The UEFI firmware initializes and scans the storage devices.</li><li>Instead of executing code from a boot sector, the UEFI firmware actively looks for a specific partition known as the EFI System Partition (ESP). The ESP is identified by its Partition Type GUID.</li><li>The UEFI firmware understands file systems (typically FAT32), so it can mount the ESP and browse its contents.</li><li>It looks for a bootloader application at a standardized file path, such as<code> \EFI\BOOT\BOOTX64.EFI</code> (for removable media) or a vendor-specific path like <code>\EFI\Microsoft\Boot\bootmgfw.efi</code> for Windows.</li><li>Once found, the firmware executes this <code>.efi</code> bootloader file directly, which then takes over to load the operating system kernel.</li></ol><h4 id=gpt-advantages-over-mbr>GPT Advantages over MBR:<a hidden class=anchor aria-hidden=true href=#gpt-advantages-over-mbr>#</a></h4><ul><li><strong>Massive Disk Sizes:</strong> Supports disks larger than 2TB (up to 9.4 ZB - zettabytes - in theory) thanks to 64-bit LBA addressing.</li><li><strong>More Partitions:</strong> Allows for 128 primary partitions by default, eliminating the need for the complex extended/logical partition scheme.</li><li><strong>Redundancy and Reliability</strong>: The backup GPT header and CRC32 checksums provide protection against data corruption in the partition table. If the primary header is damaged, the disk can be recovered from the backup.</li><li><strong>No &ldquo;Active&rdquo; Partition:</strong> The bootable partition is defined in the UEFI firmware&rsquo;s boot manager settings, not by a fragile flag on the partition itself, making multi-booting cleaner.</li><li><strong>Unique IDs:</strong> Using GUIDs for both the disk and partitions prevents potential conflicts and collisions that could occur with MBR systems.</li></ul><h2 id=5-kernel-loading>5. Kernel Loading<a hidden class=anchor aria-hidden=true href=#5-kernel-loading>#</a></h2><p>Once the bootloader has been identified and loaded by either the BIOS/MBR or UEFI/GPT process, its one and only job is to find the operating system&rsquo;s kernel, load it into memory, and hand over control of the system. This is the moment the actual operating system begins to take charge.</p><h3 id=1-boot-loader-to-kernel-handoff>1. Boot Loader to Kernel Handoff<a hidden class=anchor aria-hidden=true href=#1-boot-loader-to-kernel-handoff>#</a></h3><p>The bootloader (like GRUB for Linux or the Windows Boot Manager) knows where to find the kernel file on the storage device (e.g., <code>vmlinuz</code> in Linux <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, <code>ntoskrnl.exe</code> in Windows <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>). But the kernel alone isn&rsquo;t enough.</p><p>Modern kernels are modular and don&rsquo;t contain every possible hardware driver. To solve this chicken-and-egg problem—where the kernel needs drivers to access the disk, but the drivers are on the disk—the bootloader also loads an <strong>initial RAM disk (initrd</strong>) or <strong>initial RAM filesystem (initramfs)</strong> into memory alongside the kernel.</p><p>This <code>initrd</code> is a temporary, compressed filesystem that contains the essential drivers and tools needed for the kernel to access the main storage device and other critical hardware.</p><h4 id=1-memory-layout-setup>1. Memory Layout Setup:<a hidden class=anchor aria-hidden=true href=#1-memory-layout-setup>#</a></h4><ul><li>The kernel is loaded at a specific memory address (typically around 1MB on x86 systems).</li><li>Boot loader creates a memory map showing which areas are safe to use.</li><li>Sets up initial page tables for virtual memory management.</li><li>Preserves important boot information in memory that the kernel will need.</li></ul><h4 id=2-cpu-state-preparation>2. CPU State Preparation:<a hidden class=anchor aria-hidden=true href=#2-cpu-state-preparation>#</a></h4><ul><li>Switches CPU from 16-bit real mode to 32-bit protected mode (or 64-bit long mode).</li><li>Disables interrupts temporarily.</li><li>Sets up initial stack pointer.</li><li>Prepares CPU registers with boot parameters.</li></ul><p><strong>Boot Parameters:</strong> The boot loader passes crucial information to the kernel through standardized protocols:</p><ul><li>Linux: Boot protocol with command line arguments, initrd location, memory map</li><li>Windows: Boot Configuration Data (BCD) and hardware abstraction layer info</li><li>Hardware details: Available RAM, CPU features, device tree (on ARM systems)</li></ul><h2 id=3-kernel-initialization-building-the-system>3. Kernel Initialization: Building the System<a hidden class=anchor aria-hidden=true href=#3-kernel-initialization-building-the-system>#</a></h2><p>The moment the kernel begins executing, it runs in a highly constrained environment. It must bootstrap itself, initializing all its core subsystems to transform the raw hardware into a fully functional operating system.</p><h3 id=1-entry-point-and-early-setup>1. Entry Point and Early Setup<a hidden class=anchor aria-hidden=true href=#1-entry-point-and-early-setup>#</a></h3><p>The kernel&rsquo;s very first instructions are architecture-specific and focus on creating a stable environment for the rest of the initialization:</p><ul><li><strong>Initializes Core CPU Structures:</strong> Sets up the Interrupt Descriptor Table (IDT) to handle hardware interrupts and exceptions, though interrupts remain disabled for now.</li><li><strong>Processes Boot Information:</strong> Parses the command-line arguments and memory map passed by the bootloader to understand its environment and available resources.</li><li><strong>Validates Integrity:</strong> If Secure Boot is enabled, the kernel validates its own digital signature to ensure it hasn&rsquo;t been tampered with.</li></ul><h3 id=2-memory-management-initialization>2. Memory Management Initialization<a hidden class=anchor aria-hidden=true href=#2-memory-management-initialization>#</a></h3><p>The kernel immediately takes control of all system memory:</p><ul><li><strong>Virtual Memory Setup:</strong> It creates a comprehensive set of page tables to map virtual addresses to physical RAM addresses, establishing the kernel&rsquo;s own protected address space.</li><li><strong>Physical Memory Management:</strong> Using the map from the bootloader, it builds a complete picture of physical memory, initializing allocators (like the buddy and slab allocators) to manage free and used memory frames.</li></ul><h3 id=3-core-subsystem-initialization>3. Core Subsystem Initialization<a hidden class=anchor aria-hidden=true href=#3-core-subsystem-initialization>#</a></h3><p>With memory management active, the kernel brings its fundamental components online:</p><ul><li><strong>Process Management:</strong> Creates the first process, the idle process (PID 0), and initializes the process scheduler, which is responsible for task switching.</li><li><strong>Interrupt and Exception Handling:</strong> Configures the system&rsquo;s interrupt controllers (PIC/APIC) and enables interrupts, allowing hardware to communicate with the CPU.</li><li><strong>Synchronization Primitives:</strong> Initializes the low-level mechanisms like mutexes, semaphores, and spinlocks that are essential for preventing data corruption on multiprocessor systems.</li></ul><h3 id=4-device-and-driver-infrastructure>4. Device and Driver Infrastructure<a hidden class=anchor aria-hidden=true href=#4-device-and-driver-infrastructure>#</a></h3><p>The kernel sets up the framework for communicating with hardware:</p><ul><li><strong>Device Model Framework:</strong> Initializes the device driver subsystem and parses hardware information from ACPI tables (on x86) or a device tree (on ARM) to discover what hardware is present.</li><li><strong>Essential Driver Loading:</strong> Loads the built-in drivers compiled directly into the kernel, focusing on those needed to access the root filesystem (e.g., SATA/NVMe drivers).</li><li><strong>Hardware Abstraction:</strong> Initializes platform-specific code and Hardware Abstraction Layers (HAL) to provide a consistent interface for the rest of the kernel to interact with the underlying hardware.</li></ul><h3 id=5-filesystem-and-io-preparation>5. Filesystem and I/O Preparation<a hidden class=anchor aria-hidden=true href=#5-filesystem-and-io-preparation>#</a></h3><p>Before it can mount the root filesystem, the kernel prepares its I/O subsystems:</p><ul><li><strong>Virtual File System (VFS):</strong> Initializes the VFS, an abstraction layer that allows the kernel to treat all filesystems (like ext4, NTFS, etc.) in a uniform way.</li><li><strong>Block Device Layer:</strong> Initializes the subsystem that manages block devices (like hard drives and SSDs) and sets up I/O schedulers to optimize disk requests.</li></ul><h3 id=6-initial-process-creation>6. Initial Process Creation<a hidden class=anchor aria-hidden=true href=#6-initial-process-creation>#</a></h3><p>The kernel creates its own essential background threads (like kthreadd for managing other kernel threads) and then prepares to make the critical leap from kernel space to user space.</p><h3 id=7-transition-to-user-space>7. Transition to User Space<a hidden class=anchor aria-hidden=true href=#7-transition-to-user-space>#</a></h3><ul><li><strong>Mounting the Root Filesystem:</strong> The kernel first mounts the initrd/initramfs as a temporary root filesystem. The drivers and tools in the initrd are used to mount the real root filesystem from the main storage device.</li><li><strong>Launching the Init Process:</strong> The kernel creates the very first user-space process, which is given Process ID 1 (PID 1). This process is the ancestor of all other user processes. On modern Linux systems, this is systemd; on Windows, it&rsquo;s smss.exe.</li></ul><h3 id=8-handoff-to-the-init-system>8. Handoff to the Init System<a hidden class=anchor aria-hidden=true href=#8-handoff-to-the-init-system>#</a></h3><p>At this point, the kernel&rsquo;s primary initialization is complete. It has transformed into a fully preemptive, multitasking operating system kernel. While the kernel continues to run for the lifetime of the system—managing hardware, handling interrupts, and processing system calls—it now hands the responsibility of finishing the boot process to the <strong>init system</strong>. The init system is responsible for starting all the higher-level services, such as networking, background daemons, and ultimately, the user login screen.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><strong>PCI (Peripheral Component Interconnect) and PCIe (Peripheral Component Interconnect Express)</strong> are both interface standards for connecting hardware components to a computer&rsquo;s motherboard, but PCIe is a newer, faster, and more flexible version of PCI.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><strong>Network booting (PXE - Preboot Execution Environment)</strong> allows a computer to boot an operating system directly from a network server rather than local storage. When enabled, the network card&rsquo;s Option ROM takes control during the boot process and broadcasts a DHCP request that includes PXE-specific information. A PXE-enabled DHCP server responds with an IP address for the client plus the location of a TFTP (Trivial File Transfer Protocol) server and the filename of a network boot loader. The client then downloads this small boot loader over the network and executes it, which in turn can download a kernel, initial ramdisk, or even a complete operating system image. This technology is commonly used in corporate environments for automated OS deployment, diskless workstations, and system recovery scenarios, as it allows administrators to boot and manage hundreds of computers from a central server without needing individual storage devices or manual intervention on each machine.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><strong>Logical Block Address 0</strong> refers to the first addressable unit of storage on a device. Think of LBA as a simple numbering system that starts from 0 and counts up sequentially. Modern storage devices use LBA as an abstraction layer that hides the physical complexity of how data is actually stored. Whether it&rsquo;s a traditional hard drive with physical cylinders, heads, and sectors, or a solid-state drive with flash memory cells arranged in pages and blocks, the operating system and firmware see everything as a linear sequence of logical blocks.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>vmlinuz is the name of the Linux kernel executable file. The name is historical and descriptive:</p><ul><li>vm: Stands for Virtual Memory, indicating the kernel supports this feature.</li><li>linuz: Refers to the Linux kernel, and the z at the end signifies that it is a zlib-compressed executable.
When the bootloader loads this file, the first thing the kernel does is decompress itself into memory before it begins initializing the system.</li></ul>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:5><p>ntoskrnl.exe stands for Windows NT Operating System Kernel. It is the fundamental kernel space module for the Windows NT family of operating systems (including all modern versions like Windows 10/11 and Windows Server). This single executable file contains the Windows kernel, the executive, the memory manager, and other core components responsible for managing the system&rsquo;s hardware and software resources.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/boot/>Boot</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://en.wikipedia.org/wiki/Option_ROM target=_blank rel="noopener noreferrer">Option ROM</a></li><li><a href=https://en.wikipedia.org/wiki/Network_booting target=_blank rel="noopener noreferrer">Network Boot</a></li><li><a href=https://wiki.osdev.org/Bootloader target=_blank rel="noopener noreferrer">Bootloader Wiki</a></li></ul></section></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>