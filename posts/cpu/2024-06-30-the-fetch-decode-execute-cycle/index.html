<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Fetch Decode Execute Cycle | Sanketh's Blog</title><meta name=keywords content="cpu"><meta name=description content="The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.
What is Machine Code?
Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.35209f447ca2bd8f0aeed477774f0834b04a48cbf75605da5097d2e25b7d585a.css integrity="sha256-NSCfRHyivY8K7tR3d08INLBKSMv3VgXaUJfS4lt9WFo=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="The Fetch Decode Execute Cycle"><meta property="og:description" content="The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.
What is Machine Code? Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-30T00:00:00+00:00"><meta property="article:tag" content="Cpu"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Fetch Decode Execute Cycle"><meta name=twitter:description content="The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.
What is Machine Code?
Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"The Fetch Decode Execute Cycle","item":"https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Fetch Decode Execute Cycle","name":"The Fetch Decode Execute Cycle","description":"The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.\nWhat is Machine Code? Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation.\n","keywords":["cpu"],"articleBody":"The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.\nWhat is Machine Code? Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation.\nMachine code is loaded into RAM before execution and stored in code segment of the process. Machine code instructions typically follow a specific format that is closely related to the architecture’s Instruction Set Architecture (ISA). Depending on the processor, a computer’s instruction sets might either be of uniform length or vary in length, eg: In MIPS all instructions are 32 bits long, x86 instructions can range from 1 to 15 bytes. Machine code instructions typically follow a specific format that is closely related to the architecture’s Instruction Set Architecture (ISA). While the exact format can vary between different ISAs, a general pattern for machine code instructions can be described as follows:\n, , opcode: The operation code specifies the operation to be performed (e.g., ADD, SUB, LOAD, STORE). This is the mnemonic representation of the binary code that the CPU understands. destination register: The register where the result of the operation will be stored. source register 1: The first operand register. source register 2: The second operand register (if applicable) Assembly Machine code is difficult for humans to read and interpret. To bridge this gap, a disassembler converts machine code into assembly language. Assembly language provides a direct mapping between numerical machine code and a human-readable version, replacing numerical opcodes and operands with readable strings. Additionally, programmers can write code in assembly language, which an assembler then converts back into machine code for the CPU to execute.\nThe Fetch, Decode, Execute Cycle Different components of the CPU work together in order to execute a program each performing a distinct function. By dividing the work into separate stages, multiple instructions can be processed simultaneously at different stages of the cycle, this is called pipelining. Pipelining increases the throughput of the CPU, as one instruction can be fetched while another is decoded, another is executed, and another is writing back.\n1. Fetch The Program Counter (PC) is a special purpose register that always holds the address of the next instruction to be executed. During the fetch stage, the address stored in the PC is copied to the Memory Address Register (MAR). The PC is then incremented to point to the memory address of the subsequent instruction. The CPU retrieves the instruction at the memory address specified by the MAR and copies it into the Memory Data Register (MDR). The instruction is copied to Instruction Register (IR) at the end of fetch cycle.\nThe PC is incremented immediately after the address stored in it is copied to the MAR and doesn’t wait for the current instruction to complete because in a pipelined CPU, multiple instructions are processed simultaneously at different stages of the instruction cycle. Incrementing the PC right away allows the next instruction to enter the fetch stage while the current instruction is moving through the decode and execute stages. This overlap increases overall instruction throughput.\nThe control unit orchestrates the entire process, sending signals to the other components to ensure they operate in the correct sequence. It ensures the address is sent to memory, the instruction is fetched, and the PC is incremented.\nThe initial instruction cycle starts immediately when the system is powered on, using a predefined PC value specific to the system’s architecture (for example, in Intel IA-32 CPUs, the predefined PC value is 0xfffffff0). This address usually points to a set of instructions stored in read-only memory (ROM), which initiates the loading or booting of the operating system.\n2. Decode The decode stage involves interpreting the fetched instruction and preparing the necessary components of the CPU for the execution stage. The Instruction Decoder interprets the opcode and determines the type of operation to be performed (e.g., addition, subtraction, load, store), opcode is also used to decide number of operands to be fetched. If the instruction is a memory operation, the decoder also identifies the addressing mode and determines the effective memory address to be used in the following execute stage.\n3. Execute In the execute stage, the CPU carries out the instruction decoded in the previous stage. Depending on the type of instruction, different components of the CPU are involved: If the instruction is an arithmetic or logic operation (such as addition, subtraction, or bitwise operations), the Arithmetic Logic Unit (ALU) is activated. If the instruction involves data transfer (such as loading data from memory into a register or storing data from a register into memory), the CPU will interact with the memory unit. For a load instruction, the CPU sends the memory address to the Memory Address Register (MAR) and retrieves the data from that address into the Memory Data Register (MDR). For a store instruction, it writes the data from the register to the specified memory address. If the instruction is a control operation (such as a jump, branch, or call), the Program Counter (PC) is updated to reflect the new address for the next instruction. This may involve adding an offset to the current PC value or directly loading a new address into the PC.\n","wordCount":"1016","inLanguage":"en","datePublished":"2024-06-30T00:00:00Z","dateModified":"2024-06-30T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">The Fetch Decode Execute Cycle</h1><div class=post-meta><span title='2024-06-30 00:00:00 +0000 UTC'>June 30, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/cpu/2024-06-30-the-fetch-decode-execute-cycle.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-machine-code aria-label="What is Machine Code?">What is Machine Code?</a><ul><li><a href=#assembly aria-label=Assembly>Assembly</a></li></ul></li><li><a href=#the-fetch-decode-execute-cycle aria-label="The Fetch, Decode, Execute Cycle">The Fetch, Decode, Execute Cycle</a><ul><li><a href=#1-fetch aria-label="1. Fetch">1. Fetch</a></li><li><a href=#2-decode aria-label="2. Decode">2. Decode</a></li><li><a href=#3-execute aria-label="3. Execute">3. Execute</a></li></ul></li></ul></div></details></div><div class=post-content><p>The Fetch-decode-execute cycle or instruction cycle is how CPU executes programs. During this cycle, the CPU retrieves an instruction from memory (fetch), interprets what action is required (decode), and then carries out the necessary operations to complete the instruction (execute). This cycle is crucial for the CPU to perform any computational tasks, and it repeats continuously while the computer is powered on.</p><h2 id=what-is-machine-code>What is Machine Code?<a hidden class=anchor aria-hidden=true href=#what-is-machine-code>#</a></h2><p>Machine code is the lowest-level programming language that consists of binary instructions directly executed by a CPU. Any program is compiled to a binary executable is transformed into machine code. Machine code consists of set of instructions which varies for each CPU architecture and is decided by the CPU manufacturer, eg: ARM, MIPS, x86, etc. Machine code consists of a set of instructions defined by the Instruction Set Architecture (ISA) of each CPU. The ISA, determined by the CPU manufacturer, varies across different architectures such as ARM, MIPS, and x86. This architecture-specific design means that machine code written for one type of CPU cannot be directly executed on another without translation or emulation.</p><p>Machine code is loaded into RAM before execution and stored in code segment of the process. Machine code instructions typically follow a specific format that is closely related to the architecture&rsquo;s Instruction Set Architecture (ISA). Depending on the processor, a computer&rsquo;s instruction sets might either be of uniform length or vary in length, eg: In MIPS all instructions are 32 bits long, x86 instructions can range from 1 to 15 bytes. Machine code instructions typically follow a specific format that is closely related to the architecture&rsquo;s Instruction Set Architecture (ISA). While the exact format can vary between different ISAs, a general pattern for machine code instructions can be described as follows:</p><pre tabindex=0><code>&lt;opcode&gt; &lt;destination register&gt;, &lt;source register 1&gt;, &lt;source register 2&gt;
</code></pre><ul><li>opcode: The operation code specifies the operation to be performed (e.g., ADD, SUB, LOAD, STORE). This is the mnemonic representation of the binary code that the CPU understands.</li><li>destination register: The register where the result of the operation will be stored.</li><li>source register 1: The first operand register.</li><li>source register 2: The second operand register (if applicable)</li></ul><h3 id=assembly>Assembly<a hidden class=anchor aria-hidden=true href=#assembly>#</a></h3><p>Machine code is difficult for humans to read and interpret. To bridge this gap, a disassembler converts machine code into assembly language. Assembly language provides a direct mapping between numerical machine code and a human-readable version, replacing numerical opcodes and operands with readable strings. Additionally, programmers can write code in assembly language, which an assembler then converts back into machine code for the CPU to execute.</p><h2 id=the-fetch-decode-execute-cycle>The Fetch, Decode, Execute Cycle<a hidden class=anchor aria-hidden=true href=#the-fetch-decode-execute-cycle>#</a></h2><p>Different components of the CPU work together in order to execute a program each performing a distinct function. By dividing the work into separate stages, multiple instructions can be processed simultaneously at different stages of the cycle, this is called <strong>pipelining</strong>. Pipelining increases the throughput of the CPU, as one instruction can be fetched while another is decoded, another is executed, and another is writing back.</p><h3 id=1-fetch>1. Fetch<a hidden class=anchor aria-hidden=true href=#1-fetch>#</a></h3><p>The Program Counter (PC) is a special purpose register that always holds the address of the next instruction to be executed. During the fetch stage, the address stored in the PC is copied to the Memory Address Register (MAR). The PC is then incremented to point to the memory address of the subsequent instruction. The CPU retrieves the instruction at the memory address specified by the MAR and copies it into the Memory Data Register (MDR). The instruction is copied to Instruction Register (IR) at the end of fetch cycle.</p><p>The PC is incremented immediately after the address stored in it is copied to the MAR and doesn&rsquo;t wait for the current instruction to complete because in a pipelined CPU, multiple instructions are processed simultaneously at different stages of the instruction cycle. Incrementing the PC right away allows the next instruction to enter the fetch stage while the current instruction is moving through the decode and execute stages. This overlap increases overall instruction throughput.</p><p>The control unit orchestrates the entire process, sending signals to the other components to ensure they operate in the correct sequence. It ensures the address is sent to memory, the instruction is fetched, and the PC is incremented.</p><p>The initial instruction cycle starts immediately when the system is powered on, using a predefined PC value specific to the system&rsquo;s architecture (for example, in Intel IA-32 CPUs, the predefined PC value is 0xfffffff0). This address usually points to a set of instructions stored in read-only memory (ROM), which initiates the loading or booting of the operating system.</p><h3 id=2-decode>2. Decode<a hidden class=anchor aria-hidden=true href=#2-decode>#</a></h3><p>The decode stage involves interpreting the fetched instruction and preparing the necessary components of the CPU for the execution stage. The Instruction Decoder interprets the opcode and determines the type of operation to be performed (e.g., addition, subtraction, load, store), opcode is also used to decide number of operands to be fetched. If the instruction is a memory operation, the decoder also identifies the addressing mode and determines the effective memory address to be used in the following execute stage.</p><h3 id=3-execute>3. Execute<a hidden class=anchor aria-hidden=true href=#3-execute>#</a></h3><p>In the execute stage, the CPU carries out the instruction decoded in the previous stage. Depending on the type of instruction, different components of the CPU are involved: If the instruction is an arithmetic or logic operation (such as addition, subtraction, or bitwise operations), the Arithmetic Logic Unit (ALU) is activated. If the instruction involves data transfer (such as loading data from memory into a register or storing data from a register into memory), the CPU will interact with the memory unit. For a load instruction, the CPU sends the memory address to the Memory Address Register (MAR) and retrieves the data from that address into the Memory Data Register (MDR). For a store instruction, it writes the data from the register to the specified memory address. If the instruction is a control operation (such as a jump, branch, or call), the Program Counter (PC) is updated to reflect the new address for the next instruction. This may involve adding an offset to the current PC value or directly loading a new address into the PC.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/cpu/>Cpu</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>