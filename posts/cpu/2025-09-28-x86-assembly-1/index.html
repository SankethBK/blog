<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>x86 Assembly Part 1: Registers | Sanketh's Blog</title><meta name=keywords content="cpu,x86"><meta name=description content="When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions."><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="x86 Assembly Part 1: Registers"><meta property="og:description" content="When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-28T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-28T00:00:00+00:00"><meta property="article:tag" content="Cpu"><meta property="article:tag" content="X86"><meta name=twitter:card content="summary"><meta name=twitter:title content="x86 Assembly Part 1: Registers"><meta name=twitter:description content="When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"x86 Assembly Part 1: Registers","item":"https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"x86 Assembly Part 1: Registers","name":"x86 Assembly Part 1: Registers","description":"When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions.\n","keywords":["cpu","x86"],"articleBody":"When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions.\nRegisters In assembly programming, registers are small, high-speed storage locations built directly into the CPU. Unlike memory, which sits outside the processor and takes more time to access, registers can be read from and written to in a single CPU cycle. They hold data, addresses, counters, flags, or other control information that instructions operate on. In x86, almost every instruction involves registers in some way, making them the most important place to start.\nOne of the defining traits of the x86 family is its strong backward compatibility. Every new generation of processors has preserved the ability to run software written for earlier ones, all the way back to the original 8086 released in 1978. This means that even on modern x86-64 CPUs, the fundamental registers introduced with the 8086 are still present and usable. For that reason, when learning x86 assembly, it makes sense to start with the registers of the 8086 — they form the foundation on which later extensions (32-bit and 64-bit registers) were built.\nEvolution of x86 Registers 8086 (1978) First 16-bit processor in the family. Introduced 8 general-purpose registers: AX, BX, CX, DX, SP, BP, SI, DI. Each could be accessed as 16-bit, with AX, BX, CX, DX further split into high/low 8-bit halves (AH/AL, etc.). Added segment registers: CS, DS, SS, ES for memory addressing. Also defined the IP (instruction pointer) and FLAGS register. 80286 (1982) Still 16-bit general-purpose registers. Expanded segment registers with protected mode and descriptors. 80386 (1985) Extended all general-purpose registers to 32-bit: EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI. Instruction pointer became EIP, flags became EFLAGS. Added new segment registers FS and GS. x86-64 (2003) Extended all general-purpose registers to 64-bit: RAX, RBX, RCX, etc. Instruction pointer became RIP, flags became RFLAGS. Added 8 new general-purpose registers: R8–R15. Expanded SIMD registers (XMM0–XMM15, later XMM0–XMM31 in AVX-512). General Purpose Registers (GPRs) General Purpose Registers are the core working registers of the CPU. They are called “general purpose” because they can hold operands for arithmetic, memory addresses, loop counters, function parameters, or return values — depending on how the instruction set or calling convention uses them.\nIn the x86-64 era, all GPRs are 64 bits wide (RAX, RBX, …, R15). But these registers trace their roots back to the 8086, where they were just 16 bits. With the 80386, they were extended to 32-bit, and finally to 64-bit with AMD64.\nUnlike ARM or MIPS “General Purpose” doesn’t mean the CPU never cares what’s inside.\nOn x86, all GPRs can hold arbitrary values, but some instructions implicitly use specific registers — so while you can put anything in them, certain instructions will overwrite or expect them.\nRegister 8086 (16-bit) 80286 (16-bit) 80386 (32-bit) x86-64 (64-bit) 8-bit Low 8-bit High Primary Purpose Why This Name? Implicit Instructions RAX AX AX EAX RAX AL AH Accumulator Named “Accumulator” because it accumulates results from arithmetic operations. Historically the primary register for math operations, I/O, and function return values. The “A” stands for Accumulator. MUL, IMUL, DIV, IDIV, IN, OUT, SYSCALL, LODS, STOS, SCAS, XLAT, CPUID RBX BX BX EBX RBX BL BH Base Called “Base” because it was originally used as a base pointer for indexed addressing modes, particularly for accessing arrays and data structures. The “B” stands for Base. Modern usage is mostly general purpose. XLAT (AL = [DS:RBX+AL]) RCX CX CX ECX RCX CL CH Counter Named “Counter” because it serves as an implicit loop counter. Used by loop instructions and string operations that repeat a specific number of times. The “C” stands for Counter. CL (low byte) is used for variable shift/rotate counts. LOOP, LOOPE, LOOPNE, REP/REPE/REPNE, JCXZ, SHL/SHR/SAL/SAR (CL), RCL/RCR/ROL/ROR (CL), SHLD/SHRD (CL) RDX DX DX EDX RDX DL DH Data Called “Data” because it holds data for I/O operations and serves as an extension of RAX for operations needing extra precision (like 128-bit multiplication/division results). The “D” stands for Data. MUL, IMUL, DIV, IDIV, IN, OUT (DX as port) RSI SI SI ESI RSI SIL - Source Index “Source Index” because it points to the source location in string/memory operations. Automatically incremented/decremented during string operations. The “SI” stands for Source Index. MOVS, CMPS, LODS, REP MOVS, REP CMPS RDI DI DI EDI RDI DIL - Destination Index “Destination Index” because it points to the destination location in string/memory operations. Works as the counterpart to RSI in block memory operations. The “DI” stands for Destination Index. MOVS, CMPS, STOS, SCAS, REP MOVS, REP STOS, REP SCAS RBP BP BP EBP RBP BPL - Base Pointer “Base Pointer” refers to its conventional role as the base of the current stack frame. Points to a fixed location in the stack frame, allowing reliable access to local variables and parameters even as RSP changes. The “BP” stands for Base Pointer. ENTER, LEAVE RSP SP SP ESP RSP SPL - Stack Pointer “Stack Pointer” because it always points to the top of the call stack. Automatically adjusted by push/pop operations and function calls. Critical for program execution flow and function calling. The “SP” stands for Stack Pointer. PUSH, POP, CALL, RET, ENTER, LEAVE, INT, IRET, Interrupts/Exceptions R8 - - - R8 R8B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R9 - - - R9 R9B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R10 - - - R10 R10B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R11 - - - R11 R11B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R12 - - - R12 R12B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R13 - - - R13 R13B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R14 - - - R14 R14B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) R15 - - - R15 R15B - Extended GPR Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions. None (truly general purpose) The “E” prefix in 32-bit mode stands for “Extended” The “R” prefix in 64-bit mode stands for “Register” R8-R15 were introduced with x86-64 architecture AH, BH, CH, DH (high 8-bit registers) are only available for the original four registers (RAX, RBX, RCX, RDX) SIL, DIL, BPL, SPL (low 8-bit versions of SI, DI, BP, SP) are only accessible in 64-bit mode Special Purpose Registers Special Purpose Registers are registers inside the CPU that hold critical control or status information needed for program execution (like instruction pointer, flags, or stack pointer). They are not intended to be freely modified by the programmer like general-purpose registers, since the CPU itself updates and uses them to manage execution flow.\nInstruction Pointer (IP / EIP / RIP) The Instruction Pointer (IP) in 8086 (later called EIP in 32-bit and RIP in 64-bit CPUs) is a special-purpose register that always points to the next instruction to be executed in memory. It works together with the Code Segment (CS) register to form the address of the current instruction. After fetching an instruction, the CPU automatically updates the IP to point to the following instruction, unless execution flow is changed by jumps, calls, interrupts, or returns. Not directly writable by normal instructions – it changes as the program executes, though programmers can alter it indirectly using control-transfer instructions (e.g., JMP, CALL, RET). Flags Register (FLAGS / EFLAGS / RFLAGS) The Flags Register is a special-purpose register that holds status flags and control flags, reflecting the results of operations and controlling CPU behavior. Status flags indicate outcomes of arithmetic or logical operations, e.g.: CF – Carry Flag ZF – Zero Flag SF – Sign Flag OF – Overflow Flag PF – Parity Flag Control flags influence CPU operation, e.g.: IF – Interrupt Enable Flag DF – Direction Flag (for string instructions) Implicit usage by instructions: Many instructions check flags automatically. For example: JZ / JE (Jump if Zero / Equal) → uses ZF JNZ / JNE (Jump if Not Zero / Not Equal) → uses ZF LOOP uses ECX/RCX and modifies ZF indirectly in some cases The CPU automatically updates most flags during arithmetic/logical instructions. Some flags (like DF) can be set/cleared with special instructions (CLD, STD). Programmers usually do not write arbitrary values into RFLAGS; they read or modify specific flags as needed using dedicated instructions. Stack Pointer (SP / ESP / RSP) The Stack Pointer is a special-purpose register that points to the top of the stack in memory. SP in 8086 ESP in 80386 (32-bit) RSP in x86-64 (64-bit) The CPU uses it implicitly in all stack operations, making it critical for function calls, local variables, and return addresses. Used by instructions implicitly: PUSH / POP – adjusts the stack pointer automatically while storing or loading values. CALL / RET – stores the return address on the stack and retrieves it using the stack pointer. ENTER / LEAVE – stack frame setup/teardown. Normally, programmers do not modify SP/RSP directly, except in low-level assembly routines or context switching. Direct changes can easily corrupt the stack. Works together with BP/EBP/RBP to manage stack frames and access function parameters or local variables. Segment Registers (CS, DS, SS, ES, FS, GS) Segment Registers are special-purpose registers used by the CPU to determine the base address of different memory segments. CS – Code Segment (points to the segment containing the currently executing instructions) DS – Data Segment (default segment for most data accesses) SS – Stack Segment (used for stack operations) ES – Extra Segment (used for string and memory operations) FS, GS – Additional segments (commonly used in modern x86-64 for thread-local storage or OS kernel data) Each segment register works together with an offset to form a physical memory address (in real mode) or is part of a segment descriptor (in protected mode). Implicit usage by instructions: CS is used automatically by CALL, RET, JMP, and interrupts. SS is used implicitly for PUSH, POP, CALL, RET. DS is typically the default for data accesses unless overridden. ES, FS, GS can be used with string or memory instructions and some system-level operations. Programmers usually do not modify segment registers directly in modern 64-bit programming; they are mostly handled by the OS. Code and Data Sections in Assembly When writing assembly programs, the source file is usually divided into sections. Each section has a specific purpose, and the assembler + linker use this division to organize the final executable.\n1. Code Section (.text) Contains the actual instructions (machine code) the CPU executes.\nTypically marked with the directive:\nsection .text global _start ; or main, depending on OS/ABI _start: mov eax, 1 ; system call number for exit (Linux 32-bit) int 0x80 ; invoke system call On most platforms, .text must be read-only + executable (no writable data here).\n2. Data Section (.data) Contains initialized global or static variables. Example:\nsection .data msg db \"Hello, world!\", 0xA len equ $ - msg Variables here have a fixed value when the program starts.\n3. BSS Section (.bss) Contains uninitialized global or static variables.\nMemory is reserved but not explicitly initialized in the file; the OS zeroes it at runtime.\nExample:\nsection .bss buffer resb 64 ; reserve 64 bytes Why separate .bss from .data?\nSaves disk space in the executable - uninitialized data doesn’t need to be stored in the file The OS automatically zeros this memory when loading the program 4. Stack Section (Runtime) Unlike the sections above, the stack is not defined in your assembly source code. Instead, it is created automatically at runtime by the operating system when your program starts.\nKey characteristics:\nAllocated by OS: The OS sets up the stack before your program’s first instruction executes RSP initialized: The stack pointer (RSP) is set to point to the top of this allocated stack space Dynamic memory: Used for function call frames, local variables, return addresses, and temporary storage Grows downward: On x86/x86-64, the stack grows from high memory addresses toward low addresses Size varies: Typical default sizes range from 1MB to 8MB, depending on the OS You interact with the stack using:\npush rax ; Decrements RSP, stores RAX at [RSP] pop rbx ; Loads value from [RSP] into RBX, increments RSP call function ; Pushes return address, jumps to function ret ; Pops return address into RIP Defining Data in Assembly Inside the data or bss sections, we use directives to reserve memory and define constants. These don’t generate instructions — they just tell the assembler how to lay out memory.\n1. Defining Data with db, dw, dd, dq These directives allocate memory and optionally initialize it. Suffix indicates the size: db → define byte (8-bit) dw → define word (16-bit) dd → define doubleword (32-bit) dq → define quadword (64-bit) Example\nsection .data byteVal db 0x1A ; one byte wordVal dw 1234 ; two bytes (little-endian) arr dd 1, 2, 3, 4 ; array of 4 dwords msg db \"Hello\", 0 ; string with null terminator 2. Reserving Space with res Directives Used in the .bss section (uninitialized data). Doesn’t take up space in the executable, only reserves memory at runtime. Examples: resb → reserve bytes resw → reserve words resd → reserve doublewords resq → reserve quadwords Example:\nsection .bss buffer resb 64 ; reserve 64 bytes table resd 16 ; reserve 16 dwords 3. Constants with equ and %define equ: creates a symbol with a fixed value (like a constant). Replaced by the assembler during assembly.\nExample:\nlen equ 100 buffer resb len ; reserve 100 bytes %define: macro-style substitution (similar to #define in C). Useful for constants or code snippets.\nExample:\n%define SYS_EXIT 60 %define STDOUT 1 4. Using Labels to Reference Data When you declare data in .data or .bss, the label becomes a symbol that represents the address of that data in memory.\nsection .data msg db \"Hi!\", 0 ; 'msg' is the label, points to the start of the string num dw 1234 ; 'num' is the label for a 16-bit word Here:\nmsg → address of the string “Hi!” num → address of the word 1234 5. Dereferencing Data with [] To access the contents stored at a label (rather than the address itself), we use square brackets [].\nExample\nmov rax, msg ; loads the ADDRESS of msg into rax mov al, [msg] ; loads the FIRST BYTE of msg (\"H\") into al mov ax, [num] ; loads the 16-bit value 1234 into ax [label] → means “value stored at memory pointed by label.” label (without brackets) → means “the address of the label.” 6. Using Labels with Offsets Since labels mark the start of data, you can access later elements by adding an offset.\nmov al, [msg+1] ; loads 'i' from \"Hi!\" mov al, [msg+2] ; loads '!' This is especially useful for arrays and strings.\n","wordCount":"2716","inLanguage":"en","datePublished":"2025-08-28T00:00:00Z","dateModified":"2025-08-28T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/cpu/2025-09-28-x86-assembly-1/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">x86 Assembly Part 1: Registers</h1><div class=post-meta><span title='2025-08-28 00:00:00 +0000 UTC'>August 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/cpu/2025-09-28-x86-assembly-1.markdown rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#registers aria-label=Registers>Registers</a><ul><li><a href=#evolution-of-x86-registers aria-label="Evolution of x86 Registers">Evolution of x86 Registers</a><ul><li><a href=#8086-1978 aria-label="8086 (1978)">8086 (1978)</a></li><li><a href=#80286-1982 aria-label="80286 (1982)">80286 (1982)</a></li><li><a href=#80386-1985 aria-label="80386 (1985)">80386 (1985)</a></li><li><a href=#x86-64-2003 aria-label="x86-64 (2003)">x86-64 (2003)</a></li></ul></li><li><a href=#general-purpose-registers-gprs aria-label="General Purpose Registers (GPRs)">General Purpose Registers (GPRs)</a></li><li><a href=#special-purpose-registers aria-label="Special Purpose Registers">Special Purpose Registers</a><ul><li><a href=#instruction-pointer-ip--eip--rip aria-label="Instruction Pointer (IP / EIP / RIP)">Instruction Pointer (IP / EIP / RIP)</a></li><li><a href=#flags-register-flags--eflags--rflags aria-label="Flags Register (FLAGS / EFLAGS / RFLAGS)">Flags Register (FLAGS / EFLAGS / RFLAGS)</a></li></ul></li><li><a href=#stack-pointer-sp--esp--rsp aria-label="Stack Pointer (SP / ESP / RSP)">Stack Pointer (SP / ESP / RSP)</a></li><li><a href=#segment-registers-cs-ds-ss-es-fs-gs aria-label="Segment Registers (CS, DS, SS, ES, FS, GS)">Segment Registers (CS, DS, SS, ES, FS, GS)</a></li></ul></li><li><a href=#code-and-data-sections-in-assembly aria-label="Code and Data Sections in Assembly">Code and Data Sections in Assembly</a><ul><li><a href=#1-code-section-text aria-label="1. Code Section (.text)">1. Code Section (.text)</a></li><li><a href=#2-data-section-data aria-label="2. Data Section (.data)">2. Data Section (.data)</a></li><li><a href=#3-bss-section-bss aria-label="3. BSS Section (.bss)">3. BSS Section (.bss)</a></li><li><a href=#4-stack-section-runtime aria-label="4. Stack Section (Runtime)">4. Stack Section (Runtime)</a></li><li><a href=#defining-data-in-assembly aria-label="Defining Data in Assembly">Defining Data in Assembly</a><ul><li><a href=#1-defining-data-with-db-dw-dd-dq aria-label="1. Defining Data with db, dw, dd, dq">1. Defining Data with db, dw, dd, dq</a></li><li><a href=#2-reserving-space-with-res-directives aria-label="2. Reserving Space with res Directives">2. Reserving Space with res Directives</a></li><li><a href=#3-constants-with-equ-and-define aria-label="3. Constants with equ and %define">3. Constants with equ and %define</a></li><li><a href=#4-using-labels-to-reference-data aria-label="4. Using Labels to Reference Data">4. Using Labels to Reference Data</a></li><li><a href=#5-dereferencing-data-with- aria-label="5. Dereferencing Data with []">5. Dereferencing Data with []</a></li><li><a href=#6-using-labels-with-offsets aria-label="6. Using Labels with Offsets">6. Using Labels with Offsets</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>When learning assembly, it’s easy to get lost in the “why” of CPU design, but this blog will stay focused on the x86 instruction set itself. The goal here isn’t to study computer architecture or dive into microarchitectural details — instead, we’ll build a working reference for how to write and understand x86 assembly code. Everything that follows is about the x86 family of processors, starting from the registers that form the foundation of all instructions.</p><h2 id=registers>Registers<a hidden class=anchor aria-hidden=true href=#registers>#</a></h2><p>In assembly programming, registers are small, high-speed storage locations built directly into the CPU. Unlike memory, which sits outside the processor and takes more time to access, registers can be read from and written to in a single CPU cycle. They hold data, addresses, counters, flags, or other control information that instructions operate on. In x86, almost every instruction involves registers in some way, making them the most important place to start.</p><p>One of the defining traits of the x86 family is its strong backward compatibility. Every new generation of processors has preserved the ability to run software written for earlier ones, all the way back to the original 8086 released in 1978. This means that even on modern x86-64 CPUs, the fundamental registers introduced with the 8086 are still present and usable. For that reason, when learning x86 assembly, it makes sense to start with the registers of the 8086 — they form the foundation on which later extensions (32-bit and 64-bit registers) were built.</p><h3 id=evolution-of-x86-registers>Evolution of x86 Registers<a hidden class=anchor aria-hidden=true href=#evolution-of-x86-registers>#</a></h3><h4 id=8086-1978>8086 (1978)<a hidden class=anchor aria-hidden=true href=#8086-1978>#</a></h4><ul><li>First 16-bit processor in the family.</li><li>Introduced <strong>8 general-purpose registers:</strong> AX, BX, CX, DX, SP, BP, SI, DI.</li><li>Each could be accessed as 16-bit, with AX, BX, CX, DX further split into high/low 8-bit halves (AH/AL, etc.).</li><li>Added segment registers: CS, DS, SS, ES for memory addressing.</li><li>Also defined the IP (instruction pointer) and FLAGS register.</li></ul><h4 id=80286-1982>80286 (1982)<a hidden class=anchor aria-hidden=true href=#80286-1982>#</a></h4><ul><li>Still 16-bit general-purpose registers.</li><li>Expanded segment registers with protected mode and descriptors.</li></ul><h4 id=80386-1985>80386 (1985)<a hidden class=anchor aria-hidden=true href=#80386-1985>#</a></h4><ul><li>Extended all general-purpose registers to 32-bit: EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI.</li><li>Instruction pointer became EIP, flags became EFLAGS.</li><li>Added new segment registers FS and GS.</li></ul><h4 id=x86-64-2003>x86-64 (2003)<a hidden class=anchor aria-hidden=true href=#x86-64-2003>#</a></h4><ul><li>Extended all general-purpose registers to 64-bit: RAX, RBX, RCX, etc.</li><li>Instruction pointer became RIP, flags became RFLAGS.</li><li>Added 8 new general-purpose registers: R8–R15.</li><li>Expanded SIMD registers (XMM0–XMM15, later XMM0–XMM31 in AVX-512).</li></ul><h3 id=general-purpose-registers-gprs>General Purpose Registers (GPRs)<a hidden class=anchor aria-hidden=true href=#general-purpose-registers-gprs>#</a></h3><p>General Purpose Registers are the core working registers of the CPU. They are called “general purpose” because they can hold operands for arithmetic, memory addresses, loop counters, function parameters, or return values — depending on how the instruction set or calling convention uses them.</p><p>In the x86-64 era, all GPRs are 64 bits wide (RAX, RBX, …, R15). But these registers trace their roots back to the 8086, where they were just 16 bits. With the 80386, they were extended to 32-bit, and finally to 64-bit with AMD64.</p><p><strong>Unlike ARM or MIPS &ldquo;General Purpose” doesn’t mean the CPU never cares what’s inside.</strong></p><p>On x86, all GPRs can hold arbitrary values, but some instructions implicitly use specific registers — so while you can put anything in them, certain instructions will overwrite or expect them.</p><table><thead><tr><th>Register</th><th>8086 (16-bit)</th><th>80286 (16-bit)</th><th>80386 (32-bit)</th><th>x86-64 (64-bit)</th><th>8-bit Low</th><th>8-bit High</th><th>Primary Purpose</th><th>Why This Name?</th><th>Implicit Instructions</th></tr></thead><tbody><tr><td>RAX</td><td>AX</td><td>AX</td><td>EAX</td><td>RAX</td><td>AL</td><td>AH</td><td>Accumulator</td><td>Named &ldquo;Accumulator&rdquo; because it accumulates results from arithmetic operations. Historically the primary register for math operations, I/O, and function return values. The &ldquo;A&rdquo; stands for Accumulator.</td><td>MUL, IMUL, DIV, IDIV, IN, OUT, SYSCALL, LODS, STOS, SCAS, XLAT, CPUID</td></tr><tr><td>RBX</td><td>BX</td><td>BX</td><td>EBX</td><td>RBX</td><td>BL</td><td>BH</td><td>Base</td><td>Called &ldquo;Base&rdquo; because it was originally used as a base pointer for indexed addressing modes, particularly for accessing arrays and data structures. The &ldquo;B&rdquo; stands for Base. Modern usage is mostly general purpose.</td><td>XLAT (AL = [DS:RBX+AL])</td></tr><tr><td>RCX</td><td>CX</td><td>CX</td><td>ECX</td><td>RCX</td><td>CL</td><td>CH</td><td>Counter</td><td>Named &ldquo;Counter&rdquo; because it serves as an implicit loop counter. Used by loop instructions and string operations that repeat a specific number of times. The &ldquo;C&rdquo; stands for Counter. CL (low byte) is used for variable shift/rotate counts.</td><td>LOOP, LOOPE, LOOPNE, REP/REPE/REPNE, JCXZ, SHL/SHR/SAL/SAR (CL), RCL/RCR/ROL/ROR (CL), SHLD/SHRD (CL)</td></tr><tr><td>RDX</td><td>DX</td><td>DX</td><td>EDX</td><td>RDX</td><td>DL</td><td>DH</td><td>Data</td><td>Called &ldquo;Data&rdquo; because it holds data for I/O operations and serves as an extension of RAX for operations needing extra precision (like 128-bit multiplication/division results). The &ldquo;D&rdquo; stands for Data.</td><td>MUL, IMUL, DIV, IDIV, IN, OUT (DX as port)</td></tr><tr><td>RSI</td><td>SI</td><td>SI</td><td>ESI</td><td>RSI</td><td>SIL</td><td>-</td><td>Source Index</td><td>&ldquo;Source Index&rdquo; because it points to the source location in string/memory operations. Automatically incremented/decremented during string operations. The &ldquo;SI&rdquo; stands for Source Index.</td><td>MOVS, CMPS, LODS, REP MOVS, REP CMPS</td></tr><tr><td>RDI</td><td>DI</td><td>DI</td><td>EDI</td><td>RDI</td><td>DIL</td><td>-</td><td>Destination Index</td><td>&ldquo;Destination Index&rdquo; because it points to the destination location in string/memory operations. Works as the counterpart to RSI in block memory operations. The &ldquo;DI&rdquo; stands for Destination Index.</td><td>MOVS, CMPS, STOS, SCAS, REP MOVS, REP STOS, REP SCAS</td></tr><tr><td>RBP</td><td>BP</td><td>BP</td><td>EBP</td><td>RBP</td><td>BPL</td><td>-</td><td>Base Pointer</td><td>&ldquo;Base Pointer&rdquo; refers to its conventional role as the base of the current stack frame. Points to a fixed location in the stack frame, allowing reliable access to local variables and parameters even as RSP changes. The &ldquo;BP&rdquo; stands for Base Pointer.</td><td>ENTER, LEAVE</td></tr><tr><td>RSP</td><td>SP</td><td>SP</td><td>ESP</td><td>RSP</td><td>SPL</td><td>-</td><td>Stack Pointer</td><td>&ldquo;Stack Pointer&rdquo; because it always points to the top of the call stack. Automatically adjusted by push/pop operations and function calls. Critical for program execution flow and function calling. The &ldquo;SP&rdquo; stands for Stack Pointer.</td><td>PUSH, POP, CALL, RET, ENTER, LEAVE, INT, IRET, Interrupts/Exceptions</td></tr><tr><td>R8</td><td>-</td><td>-</td><td>-</td><td>R8</td><td>R8B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R9</td><td>-</td><td>-</td><td>-</td><td>R9</td><td>R9B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R10</td><td>-</td><td>-</td><td>-</td><td>R10</td><td>R10B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R11</td><td>-</td><td>-</td><td>-</td><td>R11</td><td>R11B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R12</td><td>-</td><td>-</td><td>-</td><td>R12</td><td>R12B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R13</td><td>-</td><td>-</td><td>-</td><td>R13</td><td>R13B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R14</td><td>-</td><td>-</td><td>-</td><td>R14</td><td>R14B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr><tr><td>R15</td><td>-</td><td>-</td><td>-</td><td>R15</td><td>R15B</td><td>-</td><td>Extended GPR</td><td>Part of the x86-64 extension. Named simply R8-R15 with no historical baggage. These were added to provide more truly general-purpose registers without implicit behaviors from legacy instructions.</td><td>None (truly general purpose)</td></tr></tbody></table><ul><li>The &ldquo;E&rdquo; prefix in 32-bit mode stands for &ldquo;Extended&rdquo;</li><li>The &ldquo;R&rdquo; prefix in 64-bit mode stands for &ldquo;Register&rdquo;</li><li>R8-R15 were introduced with x86-64 architecture</li><li>AH, BH, CH, DH (high 8-bit registers) are only available for the original four registers (RAX, RBX, RCX, RDX)</li><li>SIL, DIL, BPL, SPL (low 8-bit versions of SI, DI, BP, SP) are only accessible in 64-bit mode</li></ul><h3 id=special-purpose-registers>Special Purpose Registers<a hidden class=anchor aria-hidden=true href=#special-purpose-registers>#</a></h3><p>Special Purpose Registers are registers inside the CPU that hold critical control or status information needed for program execution (like instruction pointer, flags, or stack pointer). They are not intended to be freely modified by the programmer like general-purpose registers, since the CPU itself updates and uses them to manage execution flow.</p><h4 id=instruction-pointer-ip--eip--rip>Instruction Pointer (IP / EIP / RIP)<a hidden class=anchor aria-hidden=true href=#instruction-pointer-ip--eip--rip>#</a></h4><ul><li>The Instruction Pointer (IP) in 8086 (later called EIP in 32-bit and RIP in 64-bit CPUs) is a special-purpose register that always points to the next instruction to be executed in memory.</li><li>It works together with the Code Segment (CS) register to form the address of the current instruction.</li><li>After fetching an instruction, the CPU automatically updates the IP to point to the following instruction, unless execution flow is changed by jumps, calls, interrupts, or returns.</li><li>Not directly writable by normal instructions – it changes as the program executes, though programmers can alter it indirectly using control-transfer instructions (e.g., JMP, CALL, RET).</li></ul><h4 id=flags-register-flags--eflags--rflags>Flags Register (FLAGS / EFLAGS / RFLAGS)<a hidden class=anchor aria-hidden=true href=#flags-register-flags--eflags--rflags>#</a></h4><ul><li>The Flags Register is a special-purpose register that holds status flags and control flags, reflecting the results of operations and controlling CPU behavior.</li><li>Status flags indicate outcomes of arithmetic or logical operations, e.g.:<ul><li>CF – Carry Flag</li><li>ZF – Zero Flag</li><li>SF – Sign Flag</li><li>OF – Overflow Flag</li><li>PF – Parity Flag</li></ul></li><li>Control flags influence CPU operation, e.g.:<ul><li>IF – Interrupt Enable Flag</li><li>DF – Direction Flag (for string instructions)</li></ul></li><li>Implicit usage by instructions:<ul><li>Many instructions check flags automatically. For example:<ul><li>JZ / JE (Jump if Zero / Equal) → uses ZF</li><li>JNZ / JNE (Jump if Not Zero / Not Equal) → uses ZF</li><li>LOOP uses ECX/RCX and modifies ZF indirectly in some cases</li></ul></li></ul></li><li>The CPU automatically updates most flags during arithmetic/logical instructions. Some flags (like DF) can be set/cleared with special instructions (CLD, STD).</li><li>Programmers usually do not write arbitrary values into RFLAGS; they read or modify specific flags as needed using dedicated instructions.</li></ul><h3 id=stack-pointer-sp--esp--rsp>Stack Pointer (SP / ESP / RSP)<a hidden class=anchor aria-hidden=true href=#stack-pointer-sp--esp--rsp>#</a></h3><ul><li>The Stack Pointer is a special-purpose register that points to the top of the stack in memory.<ul><li>SP in 8086</li><li>ESP in 80386 (32-bit)</li><li>RSP in x86-64 (64-bit)</li></ul></li><li>The CPU uses it implicitly in all stack operations, making it critical for function calls, local variables, and return addresses.</li><li>Used by instructions implicitly:<ul><li>PUSH / POP – adjusts the stack pointer automatically while storing or loading values.</li><li>CALL / RET – stores the return address on the stack and retrieves it using the stack pointer.</li><li>ENTER / LEAVE – stack frame setup/teardown.</li></ul></li><li>Normally, programmers do not modify SP/RSP directly, except in low-level assembly routines or context switching. Direct changes can easily corrupt the stack.</li><li>Works together with BP/EBP/RBP to manage stack frames and access function parameters or local variables.</li></ul><h3 id=segment-registers-cs-ds-ss-es-fs-gs>Segment Registers (CS, DS, SS, ES, FS, GS)<a hidden class=anchor aria-hidden=true href=#segment-registers-cs-ds-ss-es-fs-gs>#</a></h3><ul><li>Segment Registers are special-purpose registers used by the CPU to determine the base address of different memory segments.<ul><li>CS – Code Segment (points to the segment containing the currently executing instructions)</li><li>DS – Data Segment (default segment for most data accesses)</li><li>SS – Stack Segment (used for stack operations)</li><li>ES – Extra Segment (used for string and memory operations)</li><li>FS, GS – Additional segments (commonly used in modern x86-64 for thread-local storage or OS kernel data)</li></ul></li><li>Each segment register works together with an offset to form a physical memory address (in real mode) or is part of a segment descriptor (in protected mode).</li><li>Implicit usage by instructions:<ul><li>CS is used automatically by CALL, RET, JMP, and interrupts.</li><li>SS is used implicitly for PUSH, POP, CALL, RET.</li><li>DS is typically the default for data accesses unless overridden.</li><li>ES, FS, GS can be used with string or memory instructions and some system-level operations.</li></ul></li><li>Programmers usually do not modify segment registers directly in modern 64-bit programming; they are mostly handled by the OS.</li></ul><h2 id=code-and-data-sections-in-assembly>Code and Data Sections in Assembly<a hidden class=anchor aria-hidden=true href=#code-and-data-sections-in-assembly>#</a></h2><p>When writing assembly programs, the source file is usually divided into sections. Each section has a specific purpose, and the assembler + linker use this division to organize the final executable.</p><h3 id=1-code-section-text>1. Code Section (.text)<a hidden class=anchor aria-hidden=true href=#1-code-section-text>#</a></h3><p>Contains the actual instructions (machine code) the CPU executes.</p><p>Typically marked with the directive:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>section</span> <span style=color:#66d9ef>.text</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>global</span> <span style=color:#66d9ef>_start</span>    <span style=color:#75715e>; or main, depending on OS/ABI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>_start:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>eax</span>, <span style=color:#ae81ff>1</span>   <span style=color:#75715e>; system call number for exit (Linux 32-bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>int</span> <span style=color:#ae81ff>0x80</span>     <span style=color:#75715e>; invoke system call
</span></span></span></code></pre></div><p>On most platforms, .text must be read-only + executable (no writable data here).</p><h3 id=2-data-section-data>2. Data Section (.data)<a hidden class=anchor aria-hidden=true href=#2-data-section-data>#</a></h3><p>Contains initialized global or static variables.
Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>section</span> <span style=color:#66d9ef>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>db</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>Hello</span>, <span style=color:#66d9ef>world</span>!<span style=color:#960050;background-color:#1e0010>&#34;</span>, <span style=color:#ae81ff>0xA</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>len</span> <span style=color:#66d9ef>equ</span> <span style=color:#66d9ef>$</span> - <span style=color:#66d9ef>msg</span>
</span></span></code></pre></div><p>Variables here have a fixed value when the program starts.</p><h3 id=3-bss-section-bss>3. BSS Section (.bss)<a hidden class=anchor aria-hidden=true href=#3-bss-section-bss>#</a></h3><p>Contains uninitialized global or static variables.</p><p>Memory is reserved but not explicitly initialized in the file; the OS zeroes it at runtime.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>section</span> <span style=color:#66d9ef>.bss</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span> <span style=color:#66d9ef>resb</span> <span style=color:#ae81ff>64</span>    <span style=color:#75715e>; reserve 64 bytes
</span></span></span></code></pre></div><p><strong>Why separate .bss from .data?</strong></p><ul><li>Saves disk space in the executable - uninitialized data doesn&rsquo;t need to be stored in the file</li><li>The OS automatically zeros this memory when loading the program</li></ul><h3 id=4-stack-section-runtime>4. Stack Section (Runtime)<a hidden class=anchor aria-hidden=true href=#4-stack-section-runtime>#</a></h3><p>Unlike the sections above, the stack is not defined in your assembly source code. Instead, it is created automatically at runtime by the operating system when your program starts.</p><p><strong>Key characteristics:</strong></p><ul><li><strong>Allocated by OS:</strong> The OS sets up the stack before your program&rsquo;s first instruction executes</li><li><strong>RSP initialized:</strong> The stack pointer (RSP) is set to point to the top of this allocated stack space</li><li><strong>Dynamic memory:</strong> Used for function call frames, local variables, return addresses, and temporary storage</li><li><strong>Grows downward:</strong> On x86/x86-64, the stack grows from high memory addresses toward low addresses</li><li><strong>Size varies:</strong> Typical default sizes range from 1MB to 8MB, depending on the OS</li></ul><p><strong>You interact with the stack using:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>push</span> <span style=color:#66d9ef>rax</span>        <span style=color:#75715e>; Decrements RSP, stores RAX at [RSP]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rbx</span>         <span style=color:#75715e>; Loads value from [RSP] into RBX, increments RSP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>function</span>   <span style=color:#75715e>; Pushes return address, jumps to function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ret</span>             <span style=color:#75715e>; Pops return address into RIP
</span></span></span></code></pre></div><h3 id=defining-data-in-assembly>Defining Data in Assembly<a hidden class=anchor aria-hidden=true href=#defining-data-in-assembly>#</a></h3><p>Inside the data or bss sections, we use directives to reserve memory and define constants. These don’t generate instructions — they just tell the assembler how to lay out memory.</p><h4 id=1-defining-data-with-db-dw-dd-dq>1. Defining Data with db, dw, dd, dq<a hidden class=anchor aria-hidden=true href=#1-defining-data-with-db-dw-dd-dq>#</a></h4><ul><li>These directives allocate memory and optionally initialize it.</li><li>Suffix indicates the size:<ul><li>db → define byte (8-bit)</li><li>dw → define word (16-bit)</li><li>dd → define doubleword (32-bit)</li><li>dq → define quadword (64-bit)</li></ul></li></ul><p>Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>section</span> <span style=color:#66d9ef>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>byteVal</span> <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>0x1A</span>        <span style=color:#75715e>; one byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>wordVal</span> <span style=color:#66d9ef>dw</span> <span style=color:#ae81ff>1234</span>        <span style=color:#75715e>; two bytes (little-endian)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>arr</span>     <span style=color:#66d9ef>dd</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>  <span style=color:#75715e>; array of 4 dwords
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>msg</span>     <span style=color:#66d9ef>db</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>Hello</span><span style=color:#960050;background-color:#1e0010>&#34;</span>, <span style=color:#ae81ff>0</span>  <span style=color:#75715e>; string with null terminator
</span></span></span></code></pre></div><h4 id=2-reserving-space-with-res-directives>2. Reserving Space with res Directives<a hidden class=anchor aria-hidden=true href=#2-reserving-space-with-res-directives>#</a></h4><ul><li>Used in the .bss section (uninitialized data).</li><li>Doesn’t take up space in the executable, only reserves memory at runtime.</li><li>Examples:<ul><li>resb → reserve bytes</li><li>resw → reserve words</li><li>resd → reserve doublewords</li><li>resq → reserve quadwords</li></ul></li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>section</span> <span style=color:#66d9ef>.bss</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span> <span style=color:#66d9ef>resb</span> <span style=color:#ae81ff>64</span>     <span style=color:#75715e>; reserve 64 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>table</span>  <span style=color:#66d9ef>resd</span> <span style=color:#ae81ff>16</span>     <span style=color:#75715e>; reserve 16 dwords
</span></span></span></code></pre></div><h4 id=3-constants-with-equ-and-define>3. Constants with equ and %define<a hidden class=anchor aria-hidden=true href=#3-constants-with-equ-and-define>#</a></h4><ul><li>equ: creates a symbol with a fixed value (like a constant).<ul><li><p>Replaced by the assembler during assembly.</p></li><li><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>len</span> <span style=color:#66d9ef>equ</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>buffer</span> <span style=color:#66d9ef>resb</span> <span style=color:#66d9ef>len</span>   <span style=color:#75715e>; reserve 100 bytes
</span></span></span></code></pre></div></li></ul></li><li>%define: macro-style substitution (similar to #define in C).<ul><li><p>Useful for constants or code snippets.</p></li><li><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>%</span><span style=color:#a6e22e>define</span> <span style=color:#66d9ef>SYS_EXIT</span> <span style=color:#ae81ff>60</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>%</span><span style=color:#a6e22e>define</span> <span style=color:#66d9ef>STDOUT</span>   <span style=color:#ae81ff>1</span>
</span></span></code></pre></div></li></ul></li></ul><h4 id=4-using-labels-to-reference-data>4. Using Labels to Reference Data<a hidden class=anchor aria-hidden=true href=#4-using-labels-to-reference-data>#</a></h4><p>When you declare data in .data or .bss, the label becomes a symbol that represents the address of that data in memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>section</span> <span style=color:#66d9ef>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>db</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>Hi</span>!<span style=color:#960050;background-color:#1e0010>&#34;</span>, <span style=color:#ae81ff>0</span>     <span style=color:#75715e>; &#39;msg&#39; is the label, points to the start of the string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>num</span> <span style=color:#66d9ef>dw</span> <span style=color:#ae81ff>1234</span>         <span style=color:#75715e>; &#39;num&#39; is the label for a 16-bit word
</span></span></span></code></pre></div><p>Here:</p><ul><li>msg → address of the string &ldquo;Hi!&rdquo;</li><li>num → address of the word 1234</li></ul><h4 id=5-dereferencing-data-with->5. Dereferencing Data with []<a hidden class=anchor aria-hidden=true href=#5-dereferencing-data-with->#</a></h4><p>To access the contents stored at a label (rather than the address itself), we use square brackets <code>[]</code>.</p><p>Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>rax</span>, <span style=color:#66d9ef>msg</span>      <span style=color:#75715e>; loads the ADDRESS of msg into rax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>msg</span>]     <span style=color:#75715e>; loads the FIRST BYTE of msg (&#34;H&#34;) into al
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, [<span style=color:#66d9ef>num</span>]     <span style=color:#75715e>; loads the 16-bit value 1234 into ax
</span></span></span></code></pre></div><ul><li>[label] → means &ldquo;value stored at memory pointed by label.&rdquo;</li><li>label (without brackets) → means &ldquo;the address of the label.&rdquo;</li></ul><h4 id=6-using-labels-with-offsets>6. Using Labels with Offsets<a hidden class=anchor aria-hidden=true href=#6-using-labels-with-offsets>#</a></h4><p>Since labels mark the start of data, you can access later elements by adding an offset.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>msg</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>1</span>]   <span style=color:#75715e>; loads &#39;i&#39; from &#34;Hi!&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>al</span>, [<span style=color:#66d9ef>msg</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>2</span>]   <span style=color:#75715e>; loads &#39;!&#39; 
</span></span></span></code></pre></div><p>This is especially useful for arrays and strings.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/cpu/>Cpu</a></li><li><a href=https://sankethbk.github.io/blog/tags/x86/>X86</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html target=_blank rel="noopener noreferrer">x86 Assembly Guide (Yale University)</a></li></ul></section></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>