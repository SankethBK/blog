<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hello World in Real Mode | Sanketh's Blog</title><meta name=keywords content="cpu,x86"><meta name=description content="When your x86 computer first starts up, it&rsquo;s in a surprisingly primitive state:

No operating system - Obviously, since we haven&rsquo;t loaded one yet
No memory management - No virtual memory, no protection between processes
No file system - Can&rsquo;t open files, no directories, no abstraction layer
No network stack - No TCP/IP, no internet connectivity
No device drivers - No USB drivers, no graphics drivers, nothing

What Services Are Available at Boot Time?
Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="Hello World in Real Mode"><meta property="og:description" content="When your x86 computer first starts up, it’s in a surprisingly primitive state:
No operating system - Obviously, since we haven’t loaded one yet No memory management - No virtual memory, no protection between processes No file system - Can’t open files, no directories, no abstraction layer No network stack - No TCP/IP, no internet connectivity No device drivers - No USB drivers, no graphics drivers, nothing What Services Are Available at Boot Time? Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-09T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-09T00:00:00+00:00"><meta property="article:tag" content="Cpu"><meta property="article:tag" content="X86"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hello World in Real Mode"><meta name=twitter:description content="When your x86 computer first starts up, it&rsquo;s in a surprisingly primitive state:

No operating system - Obviously, since we haven&rsquo;t loaded one yet
No memory management - No virtual memory, no protection between processes
No file system - Can&rsquo;t open files, no directories, no abstraction layer
No network stack - No TCP/IP, no internet connectivity
No device drivers - No USB drivers, no graphics drivers, nothing

What Services Are Available at Boot Time?
Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Hello World in Real Mode","item":"https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hello World in Real Mode","name":"Hello World in Real Mode","description":"When your x86 computer first starts up, it\u0026rsquo;s in a surprisingly primitive state:\nNo operating system - Obviously, since we haven\u0026rsquo;t loaded one yet No memory management - No virtual memory, no protection between processes No file system - Can\u0026rsquo;t open files, no directories, no abstraction layer No network stack - No TCP/IP, no internet connectivity No device drivers - No USB drivers, no graphics drivers, nothing What Services Are Available at Boot Time? Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:\n","keywords":["cpu","x86"],"articleBody":"When your x86 computer first starts up, it’s in a surprisingly primitive state:\nNo operating system - Obviously, since we haven’t loaded one yet No memory management - No virtual memory, no protection between processes No file system - Can’t open files, no directories, no abstraction layer No network stack - No TCP/IP, no internet connectivity No device drivers - No USB drivers, no graphics drivers, nothing What Services Are Available at Boot Time? Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:\n1. Real Mode (16-bit) The processor starts in “real mode,” a compatibility mode that mimics the original 8086 processor from 1978. This means:\n16-bit registers and instructions Direct access to the first 1MB of memory Segmented memory model (remember those segment:offset addresses?) No memory protection—we can access any memory location\n2. BIOS Interrupts The BIOS provides a set of software interrupts—essentially function calls that handle basic hardware operations:\n; Print a character to screen mov ah, 0x0E ; Teletype function mov al, 'H' ; Character to print int 0x10 ; Call BIOS video interrupt ; Read from disk mov ah, 0x02 ; Read sectors function mov al, 1 ; Number of sectors to read int 0x13 ; Call BIOS disk interrupt 3. Basic Hardware Access We have direct access to:\nVGA text buffer at memory address 0xB8000 I/O ports for communicating with hardware Timer and keyboard through BIOS interrupts Floppy and hard disk access (though limited) 4. 512 Bytes of Code Space Your bootloader gets exactly 512 bytes—that’s it. The last two bytes must be the boot signature 0x55AA, leaving you with 510 bytes for actual code. For perspective, this blog post is already several kilobytes!\nThe Memory Map When your bootloader starts, the memory layout looks like this:\n0x00000 - 0x003FF: Interrupt Vector Table (BIOS interrupts) 0x00400 - 0x004FF: BIOS Data Area 0x00500 - 0x07BFF: Free conventional memory (about 30KB) 0x07C00 - 0x07DFF: Your bootloader lives here! (512 bytes) 0x07E00 - 0x9FFFF: Free conventional memory (about 600KB) 0xA0000 - 0xBFFFF: Video memory 0xC0000 - 0xFFFFF: BIOS ROM and system ROM What This Means for Us This primitive environment is both limiting and liberating:\nThe Constraints: Every byte counts in your 512-byte budget No standard library—want to print text? You write the code No error handling safety net—one wrong memory access and you crash Assembly language only (well, you could compile C, but good luck fitting it in 512 bytes) The Freedom: Complete control over the hardware No abstraction layers slowing you down Direct memory access to anywhere in the first megabyte You’re the first code to run—you set the rules Why BIOS Services Exist? 1. Hardware Abstraction Reason: In the early 1980s, different vendors made their own variants of keyboards, displays, disks, and peripherals. Writing software that directly hit I/O ports meant every program would need a separate version for each hardware model. BIOS solution: Provide a consistent set of software interrupts (INT xx) that abstract hardware details. For example: INT 10h (video) lets you print characters or move the cursor without caring if the machine has CGA, MDA, or later VGA. INT 13h (disk) lets you read sectors without knowing if the disk controller is an XT, AT, or SCSI. 2. Bootstrapping Reason: At power-on, the CPU starts in a minimal state (real mode, no OS, no drivers). There must be some “first code” available to load the operating system.\nBIOS solution: Lives in ROM, so it’s always present. It initializes the hardware to a usable state, and exposes just enough functions (disk read, video output) to let a boot sector load the next stage.\n3. Uniform Programming Model Reason: Early software (like DOS, or even bootloaders) shouldn’t need to know hardware timing quirks, sector translation schemes, or different video memory layouts.\nBIOS solution: Offers a stable interface across generations. A program written for the IBM PC in 1981 could still run years later on a 486 because the BIOS kept compatibility with the same INT calls.\n4. Reduced Complexity in Small Programs Reason: Bootloaders and diagnostic tools have size constraints (like the 446-byte MBR). Reimplementing low-level drivers inside such tiny programs is impractical.\nBIOS solution: Offload those duties to ROM. The boot sector just calls INT 13h to read sectors instead of re-implementing a floppy/hard disk driver in 200 bytes.\n5. Portability Across Peripherals Reason: New hardware (keyboards, disks, graphics cards) could be added without breaking old software. Vendors extended the BIOS to expose functions for their devices.\nBIOS solution: As long as the vendor provided BIOS routines, DOS and bootloaders didn’t need to change.\nUses of BIOS Services Boot Process – MBR uses INT 13h to load the VBR/bootloader. Basic Output – Boot messages (“Missing OS”) via INT 10h. Keyboard Input – Get keystrokes with INT 16h without scanning the keyboard matrix. Timers – Use BIOS tick count (INT 1Ah) for delays. Diagnostics – POST routines test RAM, CPU, and peripherals before handing control to user code. Fallback for Small Programs – Even today, some boot utilities or OS installers fall back to BIOS INT calls before switching to protected/long mode. Why OS Boots into Real Mode First Even back then why was it so important to maintain that backward compatibiltiy when 80286 came not long after 8086? SInce the normal programs have to be migrated anyway when running on 0286 ,due to the virtuak memory, why real mode still exists?\n1. Hardware Reset Behavior Every Intel x86 CPU since the 8086 (1978) starts in real mode after reset. That’s not just a design choice by operating systems — it’s baked into the silicon. At power-on, the CPU initializes its instruction pointer (CS:IP = FFFF:0000 on 8086, later 0xFFFFFFF0 on 386+) and executes in real mode. So: OS doesn’t choose to start in real mode. The CPU gives you real mode, and you have to transition to protected/long mode yourself.\n2. Backward Compatibility for Boot Code By the time the 80286 arrived (1982), there were already millions of PCs with 8088/8086 chips. The IBM PC BIOS and boot sector code were all written assuming 16-bit real mode. If Intel had changed the reset mode to protected mode, none of those BIOSes, bootloaders, or DOS programs would have worked. Vendors wanted to keep using the same BIOS ROMs, same boot disks, and same operating systems across 8086 → 286 → 386. Maintaining compatibility meant any 8086 software (like DOS, or bootloaders) still ran on newer CPUs.\n3. BIOS and Early Boot Environment BIOS itself is written in 16-bit real mode code. All BIOS services (INT 10h, 13h, 16h, etc.) assume a real-mode environment. Before you can even load your OS kernel, you need BIOS to read from disk, show text, and accept keyboard input. That forces early boot to happen in real mode. 4. The 80286 “Protected Mode Problem” The 286 introduced protected mode, but with serious limitations: No way to easily switch back to real mode (you had to reset the CPU). Segment limits were awkward; no flat memory model yet. That made it impractical to just “live” in protected mode all the time in the early OSes. DOS and BIOS had to stay in real mode. It wasn’t until the 80386 (1985) with its 32-bit protected mode and paging that operating systems like Linux/Windows could truly ditch real mode for runtime. But even then, they still had to start in real mode for BIOS and boot compatibility. 5. Migration vs. Bootstrapping Programs needed to be rewritten for 286+ to use virtual memory and protected mode features. But the boot path (BIOS → boot sector → loader) still had to work the same everywhere. So Intel made sure: “every chip boots in real mode, just like an 8086.” That way, the very first instructions are universal across generations. Hello World Program in x86 Assembly Using BIOS Services BITS 16 ORG 0x7C00 ; BIOS loads us here start: ; Set up segment registers safely xor ax, ax ; AX = 0 mov ds, ax mov es, ax mov ss, ax mov sp, 0x7C00 ; stack just below our code mov si, msg ; DS:SI points to string print_loop: lodsb ; AL = [SI], SI++ cmp al, 0 je done mov ah, 0x0E ; BIOS teletype function int 0x10 ; print AL to screen jmp print_loop done: jmp $ ; hang forever msg db \"Hello, World!\", 0 ; --- Boot sector padding and signature --- times 510-($-$$) db 0 dw 0xAA55 Why this works BIOS loads the first sector (512 bytes) of the boot device at 0x7C00 and jumps there. We initialize DS/ES/SS to 0 and SP near 0x7C00 for a valid stack. The loop walks the string msg character by character, printing each via BIOS INT 10h, function 0Eh. times 510-($-$$) db 0 pads to 510 bytes. dw 0xAA55 is the boot signature the BIOS checks. Hello World using direct VGA text memory writes (Memory Mapped I/O) BITS 16 ORG 0x7C00 start: ; Set up segment registers xor ax, ax mov ds, ax mov es, ax mov ss, ax mov sp, 0x7C00 ; Point ES:DI to VGA text buffer at 0xB8000 mov ax, 0xB800 mov es, ax xor di, di ; offset 0 mov si, msg print_loop: lodsb ; AL = [SI], SI++ cmp al, 0 je done mov ah, 0x0F ; attribute byte: white on black stosw ; write AX to ES:DI (char + attr), DI += 2 jmp print_loop done: jmp $ ; hang forever msg db \"Hello, World! (VRAM)\", 0 ; --- Boot sector padding and signature --- times 510-($-$$) db 0 dw 0xAA55 Running the Boot Sector Program Let’s now see how to actually assemble and run the Hello World boot sector on your own system.\nStep 1. Assemble the Code We use NASM (Netwide Assembler) to convert our assembly source into a raw binary image:\nnasm -f bin boot.asm -o boot.bin nasm → The assembler tool. -f bin → Output format is flat binary (no ELF/COFF headers, just raw bytes). Perfect for boot sectors since the BIOS just loads 512 bytes directly into memory. boot.asm → Your source file containing the bootloader code. -o boot.bin → Output file will be a 512-byte binary image. Step 2. Run in QEMU We’ll use QEMU, a popular emulator, to test the binary safely (no need to risk your actual hard drive):\nqemu-system-x86_64 -drive format=raw,file=boot.bin qemu-system-x86_64 → Launches the QEMU emulator in x86-64 mode. -drive format=raw,file=boot.bin → Tells QEMU to treat boot.bin as a raw disk image and boot from it. When executed, QEMU will emulate the BIOS loading your boot sector into memory at 0x7C00 and running it. You’ll see the “Hello World” message printed to the virtual screen.\nStep 3. (Optional) Inspect the Binary To check that the boot sector is exactly 512 bytes and ends with the 0x55AA boot signature:\n❯ hexdump -C boot.bin | tail 00000000 31 c0 8e d8 8e c0 8e d0 bc 00 7c be 1b 7c ac 3c |1.........|..|.\u003c| 00000010 00 74 06 b4 0e cd 10 eb f5 eb fe 48 65 6c 6c 6f |.t.........Hello| 00000020 2c 20 57 6f 72 6c 64 21 00 00 00 00 00 00 00 00 |, World!........| 00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 000001f0 00 We can see the last two bytes 55 aa at the bottom.\n","wordCount":"1900","inLanguage":"en","datePublished":"2025-08-09T00:00:00Z","dateModified":"2025-08-09T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/cpu/2025-09-16-hello-world-in-real-mode/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Hello World in Real Mode</h1><div class=post-meta><span title='2025-08-09 00:00:00 +0000 UTC'>August 9, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/cpu/2025-09-16-hello-world-in-real-mode.markdown rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-services-are-available-at-boot-time aria-label="What Services Are Available at Boot Time?">What Services Are Available at Boot Time?</a><ul><li><a href=#1-real-mode-16-bit aria-label="1. Real Mode (16-bit)">1. Real Mode (16-bit)</a></li><li><a href=#2-bios-interrupts aria-label="2. BIOS Interrupts">2. BIOS Interrupts</a></li><li><a href=#3-basic-hardware-access aria-label="3. Basic Hardware Access">3. Basic Hardware Access</a></li><li><a href=#4-512-bytes-of-code-space aria-label="4. 512 Bytes of Code Space">4. 512 Bytes of Code Space</a></li></ul></li><li><a href=#the-memory-map aria-label="The Memory Map">The Memory Map</a></li><li><a href=#what-this-means-for-us aria-label="What This Means for Us">What This Means for Us</a><ul><li><a href=#the-constraints aria-label="The Constraints:">The Constraints:</a></li><li><a href=#the-freedom aria-label="The Freedom:">The Freedom:</a></li></ul></li><li><a href=#why-bios-services-exist aria-label="Why BIOS Services Exist?">Why BIOS Services Exist?</a><ul><li><a href=#1-hardware-abstraction aria-label="1. Hardware Abstraction">1. Hardware Abstraction</a></li><li><a href=#2-bootstrapping aria-label="2. Bootstrapping">2. Bootstrapping</a></li><li><a href=#3-uniform-programming-model aria-label="3. Uniform Programming Model">3. Uniform Programming Model</a></li><li><a href=#4-reduced-complexity-in-small-programs aria-label="4. Reduced Complexity in Small Programs">4. Reduced Complexity in Small Programs</a></li><li><a href=#5-portability-across-peripherals aria-label="5. Portability Across Peripherals">5. Portability Across Peripherals</a></li></ul></li><li><a href=#uses-of-bios-services aria-label="Uses of BIOS Services">Uses of BIOS Services</a></li><li><a href=#why-os-boots-into-real-mode-first aria-label="Why OS Boots into Real Mode First">Why OS Boots into Real Mode First</a><ul><li><a href=#1-hardware-reset-behavior aria-label="1. Hardware Reset Behavior">1. Hardware Reset Behavior</a></li><li><a href=#2-backward-compatibility-for-boot-code aria-label="2. Backward Compatibility for Boot Code">2. Backward Compatibility for Boot Code</a></li><li><a href=#3-bios-and-early-boot-environment aria-label="3. BIOS and Early Boot Environment">3. BIOS and Early Boot Environment</a></li><li><a href=#4-the-80286-protected-mode-problem aria-label="4. The 80286 “Protected Mode Problem”">4. The 80286 “Protected Mode Problem”</a></li><li><a href=#5-migration-vs-bootstrapping aria-label="5. Migration vs. Bootstrapping">5. Migration vs. Bootstrapping</a></li></ul></li><li><a href=#hello-world-program-in-x86-assembly-using-bios-services aria-label="Hello World Program in x86 Assembly Using BIOS Services">Hello World Program in x86 Assembly Using BIOS Services</a><ul><li><a href=#why-this-works aria-label="Why this works">Why this works</a></li></ul></li><li><a href=#hello-world-using-direct-vga-text-memory-writes-memory-mapped-io aria-label="Hello World using direct VGA text memory writes (Memory Mapped I/O)">Hello World using direct VGA text memory writes (Memory Mapped I/O)</a></li><li><a href=#running-the-boot-sector-program aria-label="Running the Boot Sector Program">Running the Boot Sector Program</a><ul><li><a href=#step-1-assemble-the-code aria-label="Step 1. Assemble the Code">Step 1. Assemble the Code</a></li><li><a href=#step-2-run-in-qemu aria-label="Step 2. Run in QEMU">Step 2. Run in QEMU</a></li><li><a href=#step-3-optional-inspect-the-binary aria-label="Step 3. (Optional) Inspect the Binary">Step 3. (Optional) Inspect the Binary</a></li></ul></li></ul></div></details></div><div class=post-content><p>When your x86 computer first starts up, it&rsquo;s in a surprisingly primitive state:</p><ul><li><strong>No operating system</strong> - Obviously, since we haven&rsquo;t loaded one yet</li><li><strong>No memory management</strong> - No virtual memory, no protection between processes</li><li><strong>No file system</strong> - Can&rsquo;t open files, no directories, no abstraction layer</li><li><strong>No network stack</strong> - No TCP/IP, no internet connectivity</li><li><strong>No device drivers</strong> - No USB drivers, no graphics drivers, nothing</li></ul><h2 id=what-services-are-available-at-boot-time>What Services Are Available at Boot Time?<a hidden class=anchor aria-hidden=true href=#what-services-are-available-at-boot-time>#</a></h2><p>Despite the barren landscape, the BIOS (Basic Input/Output System) gives us a few essential tools:</p><h3 id=1-real-mode-16-bit>1. Real Mode (16-bit)<a hidden class=anchor aria-hidden=true href=#1-real-mode-16-bit>#</a></h3><p>The processor starts in &ldquo;real mode,&rdquo; a compatibility mode that mimics the original 8086 processor from 1978. This means:</p><p>16-bit registers and instructions
Direct access to the first 1MB of memory
Segmented memory model (remember those segment:offset addresses?)
No memory protection—we can access any memory location</p><h3 id=2-bios-interrupts>2. BIOS Interrupts<a hidden class=anchor aria-hidden=true href=#2-bios-interrupts>#</a></h3><p>The BIOS provides a set of software interrupts—essentially function calls that handle basic hardware operations:</p><pre tabindex=0><code>; Print a character to screen
mov ah, 0x0E    ; Teletype function
mov al, &#39;H&#39;     ; Character to print
int 0x10        ; Call BIOS video interrupt

; Read from disk
mov ah, 0x02    ; Read sectors function
mov al, 1       ; Number of sectors to read
int 0x13        ; Call BIOS disk interrupt
</code></pre><h3 id=3-basic-hardware-access>3. Basic Hardware Access<a hidden class=anchor aria-hidden=true href=#3-basic-hardware-access>#</a></h3><p>We have direct access to:</p><ul><li><strong>VGA text buffer</strong> at memory address 0xB8000</li><li><strong>I/O ports</strong> for communicating with hardware</li><li><strong>Timer</strong> and <strong>keyboard</strong> through BIOS interrupts</li><li><strong>Floppy and hard disk access</strong> (though limited)</li></ul><h3 id=4-512-bytes-of-code-space>4. 512 Bytes of Code Space<a hidden class=anchor aria-hidden=true href=#4-512-bytes-of-code-space>#</a></h3><p>Your bootloader gets exactly 512 bytes—that&rsquo;s it. The last two bytes must be the boot signature <code>0x55AA</code>, leaving you with 510 bytes for actual code. For perspective, this blog post is already several kilobytes!</p><h2 id=the-memory-map>The Memory Map<a hidden class=anchor aria-hidden=true href=#the-memory-map>#</a></h2><p>When your bootloader starts, the memory layout looks like this:</p><pre tabindex=0><code>0x00000 - 0x003FF: Interrupt Vector Table (BIOS interrupts)
0x00400 - 0x004FF: BIOS Data Area
0x00500 - 0x07BFF: Free conventional memory (about 30KB)
0x07C00 - 0x07DFF: Your bootloader lives here! (512 bytes)
0x07E00 - 0x9FFFF: Free conventional memory (about 600KB)
0xA0000 - 0xBFFFF: Video memory
0xC0000 - 0xFFFFF: BIOS ROM and system ROM
</code></pre><h2 id=what-this-means-for-us>What This Means for Us<a hidden class=anchor aria-hidden=true href=#what-this-means-for-us>#</a></h2><p>This primitive environment is both limiting and liberating:</p><h3 id=the-constraints>The Constraints:<a hidden class=anchor aria-hidden=true href=#the-constraints>#</a></h3><ul><li>Every byte counts in your 512-byte budget</li><li>No standard library—want to print text? You write the code</li><li>No error handling safety net—one wrong memory access and you crash</li><li>Assembly language only (well, you could compile C, but good luck fitting it in 512 bytes)</li></ul><h3 id=the-freedom>The Freedom:<a hidden class=anchor aria-hidden=true href=#the-freedom>#</a></h3><ul><li>Complete control over the hardware</li><li>No abstraction layers slowing you down</li><li>Direct memory access to anywhere in the first megabyte</li><li>You&rsquo;re the first code to run—you set the rules</li></ul><h2 id=why-bios-services-exist>Why BIOS Services Exist?<a hidden class=anchor aria-hidden=true href=#why-bios-services-exist>#</a></h2><h3 id=1-hardware-abstraction>1. Hardware Abstraction<a hidden class=anchor aria-hidden=true href=#1-hardware-abstraction>#</a></h3><ul><li><strong>Reason:</strong> In the early 1980s, different vendors made their own variants of keyboards, displays, disks, and peripherals. Writing software that directly hit I/O ports meant every program would need a separate version for each hardware model.</li><li><strong>BIOS solution:</strong> Provide a consistent set of software interrupts (INT xx) that abstract hardware details. For example:<ul><li><code>INT 10h</code> (video) lets you print characters or move the cursor without caring if the machine has CGA, MDA, or later VGA.</li><li><code>INT 13h</code> (disk) lets you read sectors without knowing if the disk controller is an XT, AT, or SCSI.</li></ul></li></ul><h3 id=2-bootstrapping>2. Bootstrapping<a hidden class=anchor aria-hidden=true href=#2-bootstrapping>#</a></h3><ul><li><p><strong>Reason:</strong> At power-on, the CPU starts in a minimal state (real mode, no OS, no drivers). There must be some “first code” available to load the operating system.</p></li><li><p><strong>BIOS solution:</strong> Lives in ROM, so it’s always present. It initializes the hardware to a usable state, and exposes just enough functions (disk read, video output) to let a boot sector load the next stage.</p></li></ul><h3 id=3-uniform-programming-model>3. Uniform Programming Model<a hidden class=anchor aria-hidden=true href=#3-uniform-programming-model>#</a></h3><ul><li><p><strong>Reason:</strong> Early software (like DOS, or even bootloaders) shouldn’t need to know hardware timing quirks, sector translation schemes, or different video memory layouts.</p></li><li><p><strong>BIOS solution:</strong> Offers a stable interface across generations. A program written for the IBM PC in 1981 could still run years later on a 486 because the BIOS kept compatibility with the same INT calls.</p></li></ul><h3 id=4-reduced-complexity-in-small-programs>4. Reduced Complexity in Small Programs<a hidden class=anchor aria-hidden=true href=#4-reduced-complexity-in-small-programs>#</a></h3><ul><li><p><strong>Reason:</strong> Bootloaders and diagnostic tools have size constraints (like the 446-byte MBR). Reimplementing low-level drivers inside such tiny programs is impractical.</p></li><li><p><strong>BIOS solution:</strong> Offload those duties to ROM. The boot sector just calls INT 13h to read sectors instead of re-implementing a floppy/hard disk driver in 200 bytes.</p></li></ul><h3 id=5-portability-across-peripherals>5. Portability Across Peripherals<a hidden class=anchor aria-hidden=true href=#5-portability-across-peripherals>#</a></h3><ul><li><p><strong>Reason:</strong> New hardware (keyboards, disks, graphics cards) could be added without breaking old software. Vendors extended the BIOS to expose functions for their devices.</p></li><li><p><strong>BIOS solution:</strong> As long as the vendor provided BIOS routines, DOS and bootloaders didn’t need to change.</p></li></ul><h2 id=uses-of-bios-services>Uses of BIOS Services<a hidden class=anchor aria-hidden=true href=#uses-of-bios-services>#</a></h2><ul><li><strong>Boot Process</strong> – MBR uses <code>INT 13h</code> to load the VBR/bootloader.</li><li><strong>Basic Output</strong> – Boot messages (“Missing OS”) via <code>INT 10h</code>.</li><li><strong>Keyboard Input</strong> – Get keystrokes with <code>INT 16h</code> without scanning the keyboard matrix.</li><li><strong>Timers</strong> – Use BIOS tick count (<code>INT 1Ah</code>) for delays.</li><li><strong>Diagnostics</strong> – POST routines test RAM, CPU, and peripherals before handing control to user code.</li><li><strong>Fallback for Small Programs</strong> – Even today, some boot utilities or OS installers fall back to BIOS INT calls before switching to protected/long mode.</li></ul><h2 id=why-os-boots-into-real-mode-first>Why OS Boots into Real Mode First<a hidden class=anchor aria-hidden=true href=#why-os-boots-into-real-mode-first>#</a></h2><p>Even back then why was it so important to maintain that backward compatibiltiy when 80286 came not long after 8086? SInce the normal programs have to be migrated anyway when running on 0286 ,due to the virtuak memory, why real mode still exists?</p><h3 id=1-hardware-reset-behavior>1. Hardware Reset Behavior<a hidden class=anchor aria-hidden=true href=#1-hardware-reset-behavior>#</a></h3><ul><li>Every Intel x86 CPU since the 8086 (1978) starts in real mode after reset.</li><li>That’s not just a design choice by operating systems — it’s baked into the silicon.</li><li>At power-on, the CPU initializes its instruction pointer (CS:IP = FFFF:0000 on 8086, later 0xFFFFFFF0 on 386+) and executes in real mode.</li></ul><p>So: OS doesn’t choose to start in real mode. The CPU gives you real mode, and you have to transition to protected/long mode yourself.</p><h3 id=2-backward-compatibility-for-boot-code>2. Backward Compatibility for Boot Code<a hidden class=anchor aria-hidden=true href=#2-backward-compatibility-for-boot-code>#</a></h3><ul><li>By the time the 80286 arrived (1982), there were already millions of PCs with 8088/8086 chips.</li><li>The IBM PC BIOS and boot sector code were all written assuming 16-bit real mode.</li><li>If Intel had changed the reset mode to protected mode, none of those BIOSes, bootloaders, or DOS programs would have worked.</li><li>Vendors wanted to keep using the same BIOS ROMs, same boot disks, and same operating systems across 8086 → 286 → 386.</li></ul><p>Maintaining compatibility meant any 8086 software (like DOS, or bootloaders) still ran on newer CPUs.</p><h3 id=3-bios-and-early-boot-environment>3. BIOS and Early Boot Environment<a hidden class=anchor aria-hidden=true href=#3-bios-and-early-boot-environment>#</a></h3><ul><li>BIOS itself is written in 16-bit real mode code.</li><li>All BIOS services (INT 10h, 13h, 16h, etc.) assume a real-mode environment.</li><li>Before you can even load your OS kernel, you need BIOS to read from disk, show text, and accept keyboard input. That forces early boot to happen in real mode.</li></ul><h3 id=4-the-80286-protected-mode-problem>4. The 80286 “Protected Mode Problem”<a hidden class=anchor aria-hidden=true href=#4-the-80286-protected-mode-problem>#</a></h3><ul><li>The 286 introduced protected mode, but with serious limitations:<ul><li>No way to easily switch back to real mode (you had to reset the CPU).</li><li>Segment limits were awkward; no flat memory model yet.</li></ul></li><li>That made it impractical to just “live” in protected mode all the time in the early OSes. DOS and BIOS had to stay in real mode.</li><li>It wasn’t until the 80386 (1985) with its 32-bit protected mode and paging that operating systems like Linux/Windows could truly ditch real mode for runtime. But even then, they still had to start in real mode for BIOS and boot compatibility.</li></ul><h3 id=5-migration-vs-bootstrapping>5. Migration vs. Bootstrapping<a hidden class=anchor aria-hidden=true href=#5-migration-vs-bootstrapping>#</a></h3><ul><li>Programs needed to be rewritten for 286+ to use virtual memory and protected mode features.</li><li>But the boot path (BIOS → boot sector → loader) still had to work the same everywhere.</li><li>So Intel made sure: “every chip boots in real mode, just like an 8086.” That way, the very first instructions are universal across generations.</li></ul><h2 id=hello-world-program-in-x86-assembly-using-bios-services>Hello World Program in x86 Assembly Using BIOS Services<a hidden class=anchor aria-hidden=true href=#hello-world-program-in-x86-assembly-using-bios-services>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>BITS</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ORG</span> <span style=color:#ae81ff>0x7C00</span>          <span style=color:#75715e>; BIOS loads us here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>start:
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Set up segment registers safely
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>xor</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>ax</span>       <span style=color:#75715e>; AX = 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ds</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>es</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ss</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>0x7C00</span>   <span style=color:#75715e>; stack just below our code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>si</span>, <span style=color:#66d9ef>msg</span>      <span style=color:#75715e>; DS:SI points to string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>print_loop:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lodsb</span>            <span style=color:#75715e>; AL = [SI], SI++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>je</span> <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ah</span>, <span style=color:#ae81ff>0x0E</span>     <span style=color:#75715e>; BIOS teletype function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>int</span> <span style=color:#ae81ff>0x10</span>         <span style=color:#75715e>; print AL to screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>jmp</span> <span style=color:#66d9ef>print_loop</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>done:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jmp</span> <span style=color:#66d9ef>$</span>            <span style=color:#75715e>; hang forever
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>db</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>Hello</span>, <span style=color:#66d9ef>World</span>!<span style=color:#960050;background-color:#1e0010>&#34;</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; --- Boot sector padding and signature ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>times</span> <span style=color:#ae81ff>510</span>-(<span style=color:#66d9ef>$-$$</span>) <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dw</span> <span style=color:#ae81ff>0xAA55</span>
</span></span></code></pre></div><h3 id=why-this-works>Why this works<a hidden class=anchor aria-hidden=true href=#why-this-works>#</a></h3><ul><li>BIOS loads the first sector (512 bytes) of the boot device at <code>0x7C00</code> and jumps there.</li><li>We initialize DS/ES/SS to 0 and SP near <code>0x7C00</code> for a valid stack.</li><li>The loop walks the string msg character by character, printing each via BIOS INT 10h, function 0Eh.</li><li><code>times 510-($-$$)</code> db 0 pads to 510 bytes.</li><li><code>dw 0xAA55</code> is the boot signature the BIOS checks.</li></ul><h2 id=hello-world-using-direct-vga-text-memory-writes-memory-mapped-io>Hello World using direct VGA text memory writes (Memory Mapped I/O)<a hidden class=anchor aria-hidden=true href=#hello-world-using-direct-vga-text-memory-writes-memory-mapped-io>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>BITS</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ORG</span> <span style=color:#ae81ff>0x7C00</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>start:
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Set up segment registers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>xor</span> <span style=color:#66d9ef>ax</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ds</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>es</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ss</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>0x7C00</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Point ES:DI to VGA text buffer at 0xB8000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ax</span>, <span style=color:#ae81ff>0xB800</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>es</span>, <span style=color:#66d9ef>ax</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>xor</span> <span style=color:#66d9ef>di</span>, <span style=color:#66d9ef>di</span>          <span style=color:#75715e>; offset 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>si</span>, <span style=color:#66d9ef>msg</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print_loop:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lodsb</span>               <span style=color:#75715e>; AL = [SI], SI++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>al</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>je</span> <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>ah</span>, <span style=color:#ae81ff>0x0F</span>        <span style=color:#75715e>; attribute byte: white on black
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>stosw</span>               <span style=color:#75715e>; write AX to ES:DI (char + attr), DI += 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>jmp</span> <span style=color:#66d9ef>print_loop</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>done:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jmp</span> <span style=color:#66d9ef>$</span>               <span style=color:#75715e>; hang forever
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>msg</span> <span style=color:#66d9ef>db</span> <span style=color:#960050;background-color:#1e0010>&#34;</span><span style=color:#66d9ef>Hello</span>, <span style=color:#66d9ef>World</span>! (<span style=color:#66d9ef>VRAM</span>)<span style=color:#960050;background-color:#1e0010>&#34;</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; --- Boot sector padding and signature ---
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>times</span> <span style=color:#ae81ff>510</span>-(<span style=color:#66d9ef>$-$$</span>) <span style=color:#66d9ef>db</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>dw</span> <span style=color:#ae81ff>0xAA55</span>
</span></span></code></pre></div><h2 id=running-the-boot-sector-program>Running the Boot Sector Program<a hidden class=anchor aria-hidden=true href=#running-the-boot-sector-program>#</a></h2><p>Let’s now see how to actually assemble and run the Hello World boot sector on your own system.</p><h3 id=step-1-assemble-the-code>Step 1. Assemble the Code<a hidden class=anchor aria-hidden=true href=#step-1-assemble-the-code>#</a></h3><p>We use NASM (Netwide Assembler) to convert our assembly source into a raw binary image:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nasm -f bin boot.asm -o boot.bin
</span></span></code></pre></div><ul><li><code>nasm</code> → The assembler tool.</li><li><code>-f bin</code> → Output format is flat binary (no ELF/COFF headers, just raw bytes). Perfect for boot sectors since the BIOS just loads 512 bytes directly into memory.</li><li><code>boot.asm</code> → Your source file containing the bootloader code.</li><li><code>-o boot.bin</code> → Output file will be a 512-byte binary image.</li></ul><h3 id=step-2-run-in-qemu>Step 2. Run in QEMU<a hidden class=anchor aria-hidden=true href=#step-2-run-in-qemu>#</a></h3><p>We’ll use QEMU, a popular emulator, to test the binary safely (no need to risk your actual hard drive):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>qemu-system-x86_64 -drive format<span style=color:#f92672>=</span>raw,file<span style=color:#f92672>=</span>boot.bin
</span></span></code></pre></div><ul><li><code>qemu-system-x86_64</code> → Launches the QEMU emulator in x86-64 mode.</li><li><code>-drive format=raw,file=boot.bin</code> → Tells QEMU to treat boot.bin as a raw disk image and boot from it.</li></ul><p>When executed, QEMU will emulate the BIOS loading your boot sector into memory at <code>0x7C00</code> and running it. You’ll see the &ldquo;Hello World&rdquo; message printed to the virtual screen.</p><p><img alt="Program Outout" loading=lazy src=/blog/images/hello-world-real-mode.png></p><h3 id=step-3-optional-inspect-the-binary>Step 3. (Optional) Inspect the Binary<a hidden class=anchor aria-hidden=true href=#step-3-optional-inspect-the-binary>#</a></h3><p>To check that the boot sector is exactly 512 bytes and ends with the 0x55AA boot signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ hexdump -C boot.bin | tail
</span></span><span style=display:flex><span><span style=color:#ae81ff>00000000</span>  <span style=color:#ae81ff>31</span> c0 8e d8 8e c0 8e d0  bc <span style=color:#ae81ff>00</span> 7c be 1b 7c ac 3c  |1.........|..|.&lt;|
</span></span><span style=display:flex><span><span style=color:#ae81ff>00000010</span>  <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>74</span> <span style=color:#ae81ff>06</span> b4 0e cd <span style=color:#ae81ff>10</span> eb  f5 eb fe <span style=color:#ae81ff>48</span> <span style=color:#ae81ff>65</span> 6c 6c 6f  |.t.........Hello|
</span></span><span style=display:flex><span><span style=color:#ae81ff>00000020</span>  2c <span style=color:#ae81ff>20</span> <span style=color:#ae81ff>57</span> 6f <span style=color:#ae81ff>72</span> 6c <span style=color:#ae81ff>64</span> <span style=color:#ae81ff>21</span>  <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>  |, World!........|
</span></span><span style=display:flex><span><span style=color:#ae81ff>00000030</span>  <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>  <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>  |................|
</span></span><span style=display:flex><span>*
</span></span><span style=display:flex><span>000001f0  <span style=color:#ae81ff>00</span>
</span></span></code></pre></div><p>We can see the last two bytes 55 aa at the bottom.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/cpu/>Cpu</a></li><li><a href=https://sankethbk.github.io/blog/tags/x86/>X86</a></li></ul></footer></article><section id=references><h2>References</h2><ul><li><a href=https://www.cs.virginia.edu/~evans/cs216/guides/x86.html target=_blank rel="noopener noreferrer">x86 Assembly Guide (CS Virginia)</a></li><li><a href=https://www.felixcloutier.com/x86/ target=_blank rel="noopener noreferrer">x86 and amd64 instruction reference</a></li><li><a href=https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html target=_blank rel="noopener noreferrer">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></li></ul></section></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>