<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ELF Format: Part 3 | Sanketh's Blog</title><meta name=keywords content="elf,reverse engineering"><meta name=description content="ELF Format: Sections and Section Header Table
In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&rsquo;ll look at Section Headers and Sections - the link-time and debugging view.
What Are Sections?
Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&rsquo;s contents for:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="ELF Format: Part 3"><meta property="og:description" content="ELF Format: Sections and Section Header Table In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we’ll look at Section Headers and Sections - the link-time and debugging view.
What Are Sections? Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file’s contents for:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-15T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-15T00:00:00+00:00"><meta property="article:tag" content="Elf"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELF Format: Part 3"><meta name=twitter:description content="ELF Format: Sections and Section Header Table
In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&rsquo;ll look at Section Headers and Sections - the link-time and debugging view.
What Are Sections?
Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&rsquo;s contents for:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"ELF Format: Part 3","item":"https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ELF Format: Part 3","name":"ELF Format: Part 3","description":"ELF Format: Sections and Section Header Table In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we\u0026rsquo;ll look at Section Headers and Sections - the link-time and debugging view.\nWhat Are Sections? Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file\u0026rsquo;s contents for:\n","keywords":["elf","reverse engineering"],"articleBody":"ELF Format: Sections and Section Header Table In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we’ll look at Section Headers and Sections - the link-time and debugging view.\nWhat Are Sections? Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file’s contents for:\nLinkers - combining object files into executables Debuggers - finding symbols, source code mappings Analysis tools - examining specific parts of the binary Key distinction from segments:\nSegments = Required at runtime (OS needs them to execute) Sections = Optional at runtime (can be stripped from executables)\nYou can strip all section headers and the program will still run:\n$ readelf -S main | wc -l 68 $ objcopy --strip-section-headers main main2 $ readelf -S main2 There are no sections in this file. $ ./main2 Hi there! Sections vs Segments: The Relationship Sections (like .text, .data, .bss, .rodata) Represent logical divisions of code and data within the file. Used by linkers and debuggers — they organize how functions, variables, and symbols are stored in the file.\nSegments (PT_LOAD, PT_DYNAMIC, PT_INTERP, etc.) Represent runtime mappings — how parts of the file are placed into memory by the OS loader when the program runs.\nHow They Relate\nDuring linking, the linker groups related sections into loadable segments based on their flags (R, W, X) and alignment requirements.\nSegment (Type) Typical Sections Permissions Text Segment (PT_LOAD) .interp, .text, .rodata R-X Data Segment (PT_LOAD) .data, .bss RW- So, a segment is usually a contiguous chunk of the file containing one or more sections that share similar memory attributes.\nKey Facts\nA section can exist outside any segment. These are used only at link or debug time and are not mapped into memory. Examples: .symtab, .strtab, .debug_*, .comment.\nA section can never belong to more than one segment. Each section appears in at most one segment, as each piece of data is loaded into a single memory region.\nA segment can exist without any section. Some segments (like PT_INTERP, PT_PHDR, or PT_NOTE) describe runtime structures or metadata not represented as regular sections.\nSection Header Table The Section Header Table is an array of section header entries, each describing one section.\nSection Header Table Location The ELF Header tells us where to find it:\nLocation (file offset): e_shoff field in ELF Header Entry size: e_shentsize (40 bytes for 32-bit, 64 bytes for 64-bit) Number of entries: e_shnum String table index: e_shstrndx (which section contains section names) Total table size = e_shentsize × e_shnum\n$ readelf -h main | grep section Start of section headers: 14176 (bytes into file) Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 This means:\nSection Header Table starts at offset 0x3760 (14176 bytes) Each entry is 64 bytes There are 31 entries Section #30 contains the string table with section names Section Header Entry Structure Each entry describes one section. Here’s the structure from the Linux kernel:\ntypedef struct elf32_shdr { Elf32_Word\tsh_name; // Section name (string table offset) Elf32_Word\tsh_type; // Section type Elf32_Word\tsh_flags; // Section flags Elf32_Addr\tsh_addr; // Virtual address in memory Elf32_Off\tsh_offset; // File offset Elf32_Word\tsh_size; // Section size Elf32_Word\tsh_link; // Link to another section Elf32_Word\tsh_info; // Additional information Elf32_Word\tsh_addralign; // Alignment constraints Elf32_Word\tsh_entsize; // Entry size if section holds table } Elf32_Shdr; typedef struct elf64_shdr { Elf64_Word\tsh_name; // Section name (string table offset) Elf64_Word\tsh_type; // Section type Elf64_Xword\tsh_flags; // Section flags Elf64_Addr\tsh_addr; // Virtual address in memory Elf64_Off\tsh_offset; // File offset Elf64_Xword\tsh_size; // Section size Elf64_Word\tsh_link; // Link to another section Elf64_Word\tsh_info; // Additional information Elf64_Xword\tsh_addralign; // Alignment constraints Elf64_Xword\tsh_entsize; // Entry size if section holds table } Elf64_Shdr; Section Header Fields Explained 1. sh_name - Section Name This is NOT a string! It’s an offset into the section header string table.\nHow section names work:\nStep 1: ELF Header’s e_shstrndx tells us which section contains names\n$ readelf -h main | grep \"string table index\" Section header string table index: 30 Step 2: Section #30 is a string table (.shstrtab)\nOffset 0: \\0 Offset 1: .symtab\\0 Offset 9: .strtab\\0 Offset 17: .text\\0 Offset 23: .data\\0 ... Step 3: Each section’s sh_name is an offset into this table\nSection #1: sh_name = 1 → \".symtab\" Section #2: sh_name = 9 → \".strtab\" Section #3: sh_name = 17 → \".text\" ELF String Tables\nIn ELF, strings are stored in dedicated tables rather than repeated everywhere. This design keeps the binary compact and makes parsing easier. There are two main types of string tables:\n1. Section Header String Table (.shstrtab)\n.shstrtab is also a type of section, it holds the names of other sections, other sections just refer to the index from this table\n$ readelf -S main | grep .shstrtab [28] .shstrtab STRTAB 0000000000000000 0000303b It means 28th index of section header table is section header string table. ELF header’s e_shstrndx also indicates same\nWe can inspect the contents of .shstrtab by\n$ readelf -p .shstrtab main String dump of section '.shstrtab': [ 1] .shstrtab [ b] .interp [ 13] .note.gnu.property [ 26] .note.gnu.build-id [ 39] .note.ABI-tag [ 47] .gnu.hash [ 51] .dynsym [ 59] .dynstr [ 61] .gnu.version [ 6e] .gnu.version_r [ 7d] .rela.dyn [ 87] .rela.plt [ 91] .init [ 97] .plt.got [ a0] .plt.sec [ a9] .text [ af] .fini [ b5] .rodata [ bd] .eh_frame_hdr [ cb] .eh_frame [ d5] .init_array [ e1] .fini_array [ ed] .dynamic [ f6] .data [ fc] .bss [ 101] .comment 2. Symbol String Table (.strtab)\nPurpose: Stores symbol names used by the linker and debugger. Symbols (like function and variable names) in .symtab point to offsets in .strtab. This separation of symbols and section names allows the ELF format to handle linking and debugging information efficiently. 2. sh_type - Section Type Each section in an ELF file has a type, defined by the sh_type field in its section header. This tells the linker or loader what kind of data the section holds and how it should be treated.\nValue Name Description 0 SHT_NULL Inactive section (placeholder) 1 SHT_PROGBITS Program data (code, data, anything) 2 SHT_SYMTAB Symbol table (for linking) 3 SHT_STRTAB String table 4 SHT_RELA Relocation entries with addends 5 SHT_HASH Symbol hash table 6 SHT_DYNAMIC Dynamic linking information 7 SHT_NOTE Auxiliary information 8 SHT_NOBITS Section occupies no file space (.bss) 9 SHT_REL Relocation entries without addends 11 SHT_DYNSYM Dynamic symbol table 1. SHT_NULL — Inactive Section This is a placeholder entry that marks an unused section header. It has no data and is typically found as the first entry in the section header table (index 0). Every ELF file starts with this null section.\n2. SHT_PROGBITS — Program Data This is the most common section type. It holds actual program content — like executable instructions (.text), initialized data (.data), or read-only constants (.rodata). These sections are loaded into memory when the program runs.\n3. SHT_SYMTAB — Symbol Table Contains a full list of symbols defined or referenced in the program. This table is mainly used by the linker during relocation and symbol resolution. Each entry describes a symbol’s name, address, size, and type (function, variable, etc.). It’s usually found in relocatable (.o) files.\n4. SHT_STRTAB — String Table Stores strings used by other sections — for example, section names (.shstrtab) or symbol names (.strtab). Other sections don’t store names directly; instead, they store an offset into this string table.\n5. SHT_RELA — Relocation Entries with Addends Holds relocation information that includes explicit addends (extra constant values). Used by the linker to adjust symbol references when combining multiple object files. You’ll see this in files targeting architectures like x86-64, where addends are stored in the relocation entry itself.\n6. SHT_HASH — Symbol Hash Table Provides a quick way for the dynamic linker to find symbols at runtime using a hash lookup. This section speeds up symbol resolution for shared libraries.\n7. SHT_DYNAMIC — Dynamic Linking Information Contains metadata needed for dynamic linking — such as shared library names, symbol dependencies, and relocation entries. This section appears only in dynamically linked executables and shared objects (.so files).\n8. SHT_NOTE — Auxiliary Information Stores extra information such as build IDs, ABI tags, or core dump metadata. Notes are often used by debuggers or by the kernel when generating core dumps.\n9. SHT_NOBITS — No File Storage (e.g., .bss) Represents sections that occupy memory at runtime but take no space in the file. A classic example is .bss, which holds uninitialized global or static variables. The loader allocates and zero-initializes it in memory.\n10. SHT_REL — Relocation Entries without Addends Similar to SHT_RELA, but here addends are stored in the section being relocated, not in the relocation entry. Used on architectures like x86 (32-bit ELF).\n11. SHT_DYNSYM — Dynamic Symbol Table A smaller, optimized version of the symbol table used at runtime by the dynamic linker. It lists only the symbols needed for dynamic linking, unlike .symtab, which includes all symbols.\n3. sh_flags - Section Flags Attributes of the section:\nFlag Value Meaning SHF_WRITE 0x1 Section is writable at runtime SHF_ALLOC 0x2 Section occupies memory during execution SHF_EXECINSTR 0x4 Section contains executable code SHF_MERGE 0x10 Section may be merged SHF_STRINGS 0x20 Section contains null-terminated strings SHF_TLS 0x400 Section contains thread-local data Flag combinations tell you about the section:\n.text: SHF_ALLOC | SHF_EXECINSTR (AX) - loaded, executable .data: SHF_WRITE | SHF_ALLOC (WA) - loaded, writable .rodata: SHF_ALLOC (A) - loaded, read-only .symtab: No flags - not loaded at runtime! Important: SHF_ALLOC flag\nSections WITH SHF_ALLOC are part of segments (loaded to memory) Sections WITHOUT SHF_ALLOC are not loaded (debugging/linking only) 4. sh_addr - Virtual Address Virtual memory address where the section appears at runtime.\nFor sections with SHF_ALLOC: actual runtime address For sections without SHF_ALLOC: usually 0 (not loaded) $ readelf -S main [Nr] Name Type Address Off Size Flg [14] .text PROGBITS 0000000000001060 001060 000185 AX [24] .symtab SYMTAB 0000000000000000 002c48 000690 .text has address 0x1060 (will be at this address in memory) .symtab has address 0x0 (not loaded, address irrelevant)\n5. sh_offset - File Offset Byte offset from the beginning of the file where the section’s data starts. Example: sh_offset = 0x1060 means section data begins at byte 4192 in the file.\n6. sh_size - Section Size Size of the section in bytes. Special case: For SHT_NOBITS sections (like .bss), this is the size in memory, but there are 0 bytes in the file!\n7. sh_link — Linking One Section to Another The sh_link field in a section header holds a reference (index) to another section in the same ELF file.\nBut what it points to depends on the type of the section.\nIn other words, the ELF spec reuses sh_link for different purposes depending on the sh_type.\nHow sh_link is interpreted\nSection Type sh_link Meaning SHT_SYMTAB / SHT_DYNSYM Index of the string table section that holds the names of symbols in this symbol table. SHT_REL / SHT_RELA Index of the symbol table that the relocation entries refer to. SHT_DYNAMIC Index of the string table used by entries in the .dynamic section. SHT_HASH Index of the symbol table to which the hash applies. 8. sh_info - Additional Information Extra information, meaning depends on section type:\nSection Type sh_info Meaning SHT_SYMTAB / SHT_DYNSYM Index of first non-local symbol SHT_REL / SHT_RELA Section index to which relocations apply 9. sh_addralign - Alignment Alignment constraint for the section.\nValue must be 0 or power of 2 0 or 1 means no alignment sh_addr must be aligned: sh_addr % sh_addralign == 0 Example: sh_addralign = 16 means section must start at 16-byte boundary.\n10. sh_entsize - Entry Size If section contains a table of fixed-size entries, this is the size of each entry.\nFor .symtab: size of symbol table entry (24 bytes for 64-bit) For .rela.text: size of relocation entry For non-table sections: 0 Calculate number of entries:\nnum_entries = sh_size / sh_entsize\nBroad Classifications of Sections Category Purpose Examples Code Executable instructions .text, .plt, .init Data Program variables .data, .bss, .rodata Linking / Loader Metadata Linking, relocation, symbol info .symtab, .rel.*, .dynamic, .got Debugging / Profiling Developer tools .debug_*, .note.* Special / Misc Constructors, ABI info, interpreter .init_array, .interp Code Sections 1. .text - Executable Code Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: Machine code instructions This is where your compiled functions live:\nLet’s inspect the .text section of a simple C program\n// main.c #include void greet() { printf(\"Hello, ELF!\\n\"); } int main() { greet(); return 0; } $ gcc -g -O0 -o main main.c -g: tells compiler to include debugging symbols in the output: variable names, function names, line numbers, file names, etc. -O0: optimization level 0 means: No optimization (keeps code structure close to source) $ readelf -S main | grep .text [16] .text PROGBITS 0000000000001060 00001060 We can see .text section is at offset 1060 bytes.\nTo get the raw dump of .text section:\n$ objdump -s -j .text main main: file format elf64-x86-64 Contents of section .text: 1060 f30f1efa 31ed4989 d15e4889 e24883e4 ....1.I..^H..H.. 1070 f0505445 31c031c9 488d3de4 000000ff .PTE1.1.H.=..... 1080 15532f00 00f4662e 0f1f8400 00000000 .S/...f......... 1090 488d3d79 2f000048 8d05722f 00004839 H.=y/..H..r/..H9 10a0 f8741548 8b05362f 00004885 c07409ff .t.H..6/..H..t.. 10b0 e00f1f80 00000000 c30f1f80 00000000 ................ 10c0 488d3d49 2f000048 8d35422f 00004829 H.=I/..H.5B/..H) 10d0 fe4889f0 48c1ee3f 48c1f803 4801c648 .H..H..?H...H..H 10e0 d1fe7414 488b0505 2f000048 85c07408 ..t.H.../..H..t. 10f0 ffe0660f 1f440000 c30f1f80 00000000 ..f..D.......... 1100 f30f1efa 803d052f 00000075 2b554883 .....=./...u+UH. 1110 3de22e00 00004889 e5740c48 8b3de62e =.....H..t.H.=.. 1120 0000e819 ffffffe8 64ffffff c605dd2e ........d....... 1130 0000015d c30f1f00 c30f1f80 00000000 ...]............ 1140 f30f1efa e977ffff fff30f1e fa554889 .....w.......UH. 1150 e5488d05 ac0e0000 4889c7e8 f0feffff .H......H....... 1160 905dc3f3 0f1efa55 4889e5b8 00000000 .].....UH....... 1170 e8d4ffff ffb80000 00005dc3 ..........]. (main refers to file name in above command, not the main function)\nTo get the disassembled output of .text section:\n$ objdump -d -j .text main main: file format elf64-x86-64 Disassembly of section .text: 0000000000001060 \u003c_start\u003e: 1060:\tf3 0f 1e fa endbr64 1064:\t31 ed xor %ebp,%ebp 1066:\t49 89 d1 mov %rdx,%r9 1069:\t5e pop %rsi 106a:\t48 89 e2 mov %rsp,%rdx 106d:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1071:\t50 push %rax 1072:\t54 push %rsp 1073:\t45 31 c0 xor %r8d,%r8d 1076:\t31 c9 xor %ecx,%ecx 1078:\t48 8d 3d e4 00 00 00 lea 0xe4(%rip),%rdi # 1163 107f:\tff 15 53 2f 00 00 call *0x2f53(%rip) # 3fd8 \u003c__libc_start_main@GLIBC_2.34\u003e 1085:\tf4 hlt 1086:\t66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 108d:\t00 00 00 0000000000001090 : 1090:\t48 8d 3d 79 2f 00 00 lea 0x2f79(%rip),%rdi # 4010 \u003c__TMC_END__\u003e 1097:\t48 8d 05 72 2f 00 00 lea 0x2f72(%rip),%rax # 4010 \u003c__TMC_END__\u003e 109e:\t48 39 f8 cmp %rdi,%rax 10a1:\t74 15 je 10b8 10a3:\t48 8b 05 36 2f 00 00 mov 0x2f36(%rip),%rax # 3fe0 \u003c_ITM_deregisterTMCloneTable@Base\u003e 10aa:\t48 85 c0 test %rax,%rax 10ad:\t74 09 je 10b8 10af:\tff e0 jmp *%rax 10b1:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 10b8:\tc3 ret 10b9:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 00000000000010c0 : 10c0:\t48 8d 3d 49 2f 00 00 lea 0x2f49(%rip),%rdi # 4010 \u003c__TMC_END__\u003e 10c7:\t48 8d 35 42 2f 00 00 lea 0x2f42(%rip),%rsi # 4010 \u003c__TMC_END__\u003e 10ce:\t48 29 fe sub %rdi,%rsi 10d1:\t48 89 f0 mov %rsi,%rax 10d4:\t48 c1 ee 3f shr $0x3f,%rsi 10d8:\t48 c1 f8 03 sar $0x3,%rax 10dc:\t48 01 c6 add %rax,%rsi 10df:\t48 d1 fe sar $1,%rsi 10e2:\t74 14 je 10f8 10e4:\t48 8b 05 05 2f 00 00 mov 0x2f05(%rip),%rax # 3ff0 \u003c_ITM_registerTMCloneTable@Base\u003e 10eb:\t48 85 c0 test %rax,%rax 10ee:\t74 08 je 10f8 10f0:\tff e0 jmp *%rax 10f2:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 10f8:\tc3 ret 10f9:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001100 \u003c__do_global_dtors_aux\u003e: 1100:\tf3 0f 1e fa endbr64 1104:\t80 3d 05 2f 00 00 00 cmpb $0x0,0x2f05(%rip) # 4010 \u003c__TMC_END__\u003e 110b:\t75 2b jne 1138 \u003c__do_global_dtors_aux+0x38\u003e 110d:\t55 push %rbp 110e:\t48 83 3d e2 2e 00 00 cmpq $0x0,0x2ee2(%rip) # 3ff8 \u003c__cxa_finalize@GLIBC_2.2.5\u003e 1115:\t00 1116:\t48 89 e5 mov %rsp,%rbp 1119:\t74 0c je 1127 \u003c__do_global_dtors_aux+0x27\u003e 111b:\t48 8b 3d e6 2e 00 00 mov 0x2ee6(%rip),%rdi # 4008 \u003c__dso_handle\u003e 1122:\te8 19 ff ff ff call 1040 \u003c__cxa_finalize@plt\u003e 1127:\te8 64 ff ff ff call 1090 112c:\tc6 05 dd 2e 00 00 01 movb $0x1,0x2edd(%rip) # 4010 \u003c__TMC_END__\u003e 1133:\t5d pop %rbp 1134:\tc3 ret 1135:\t0f 1f 00 nopl (%rax) 1138:\tc3 ret 1139:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001140 : 1140:\tf3 0f 1e fa endbr64 1144:\te9 77 ff ff ff jmp 10c0 0000000000001149 : 1149:\tf3 0f 1e fa endbr64 114d:\t55 push %rbp 114e:\t48 89 e5 mov %rsp,%rbp 1151:\t48 8d 05 ac 0e 00 00 lea 0xeac(%rip),%rax # 2004 \u003c_IO_stdin_used+0x4\u003e 1158:\t48 89 c7 mov %rax,%rdi 115b:\te8 f0 fe ff ff call 1050 1160:\t90 nop 1161:\t5d pop %rbp 1162:\tc3 ret 0000000000001163 : 1163:\tf3 0f 1e fa endbr64 1167:\t55 push %rbp 1168:\t48 89 e5 mov %rsp,%rbp 116b:\tb8 00 00 00 00 mov $0x0,%eax 1170:\te8 d4 ff ff ff call 1149 1175:\tb8 00 00 00 00 mov $0x0,%eax 117a:\t5d pop %rbp 117b:\tc3 ret It converts raw bytes back to assembly mnemonics.\nEach line in the disassembly follows this pattern:\nADDRESS: MACHINE_CODE ASSEMBLY_INSTRUCTION COMMENTS We can see the _start label is at address 1060, which matches with the start address mentioned in ELF header.\n$ readelf -h main | grep \"Entry point address:\" Entry point address: 0x1060 We can see the definitions of main and greet functions in assembly.\nWe can see main() calls greet() 1170: call 1149 greet() calls puts@plt 115b: call 1050 puts@plt is in .plt section (dynamic linking)\ngreet() references string in .rodata 1151: lea 0xeac(%rip),%rax # Points to 0x2004 in .rodata\n(%rip) means RIP-relative addressing. RIP-relative addressing means the address is computed relative to the current instruction pointer.\neffective_address = current_instruction_address + displacement effective_address = 0x1151 + 0xEAC = 0x2004 We can verify that address falls in the range of .rodata section.\n[18] .rodata PROGBITS 0000000000002000 00002000 0000000000000010 0000000000000000 A 0 0 4 [19] .eh_frame_hdr PROGBITS 0000000000002010 00002010 000000000000003c 0000000000000000 A 0 0 4 We can also inspect the .rodata section to confirm it\n$ readelf -x .rodata main Hex dump of section '.rodata': 0x00002000 01000200 48656c6c 6f2c2045 4c462100 ....Hello, ELF!. 2. .plt (Procedure Linkage Table) Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: Stubs for calling shared library functions The Procedure Linkage Table (PLT) is a section in ELF executables and shared libraries that enables lazy binding — meaning, external (shared library) functions like printf, puts, or malloc are resolved only when first called, not when the program starts.\nWhen your program calls puts(\"hi\");, the compiler doesn’t know where puts actually lives — it’s defined in the C library (libc.so.6). So instead of a direct call, it generates a call to a stub in .plt. This stub is responsible for eventually reaching the real puts function in memory.\nDespite the name “Procedure Linkage Table”, the PLT is NOT a table - it’s continuous executable code (an array of small code stubs).\n.plt section (executable code): ┌─────────────────────────────────┐ │ PLT[0]: Resolver stub (code) │ ← 16 bytes of code ├─────────────────────────────────┤ │ PLT[1]: printf stub (code) │ ← 16 bytes of code ├─────────────────────────────────┤ │ PLT[2]: malloc stub (code) │ ← 16 bytes of code ├─────────────────────────────────┤ │ PLT[3]: free stub (code) │ ← 16 bytes of code └─────────────────────────────────┘ Each “entry” is a small function (code snippet), not a data structure.\nPLT Entry “Format” Each PLT entry is 16 bytes of x86-64 assembly:\n# Generic PLT entry format (16 bytes): : 0: endbr64 # 4 bytes - security feature 4: jmp *GOT[n] # 6 bytes - indirect jump through GOT 10: push $index # 5 bytes - push relocation index 15: jmp PLT[0] # 5 bytes - jump to resolver (total: 16 bytes, but padding makes them aligned) Why It’s Called a “Table”\nHistorical reasons! It’s organized like a table:\nFixed-size entries (16 bytes each) Array-like access (PLT[0], PLT[1], PLT[2]…) Indexed by relocation number Let’s take this C program\n#include #include int main() { printf(\"Before malloc\\n\"); void *ptr = malloc(100); printf(\"Allocated at: %p\\n\", ptr); free(ptr); printf(\"After free\\n\"); return 0; } We can get its .plt by\n$ objdump -d -j .plt demo demo: file format elf64-x86-64 Disassembly of section .plt: 0000000000401020 \u003c.plt\u003e: 401020:\tff 35 ca 2f 00 00 push 0x2fca(%rip) # 403ff0 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 401026:\tff 25 cc 2f 00 00 jmp *0x2fcc(%rip) # 403ff8 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 40102c:\t0f 1f 40 00 nopl 0x0(%rax) 401030:\tf3 0f 1e fa endbr64 401034:\t68 00 00 00 00 push $0x0 401039:\te9 e2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40103e:\t66 90 xchg %ax,%ax 401040:\tf3 0f 1e fa endbr64 401044:\t68 01 00 00 00 push $0x1 401049:\te9 d2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40104e:\t66 90 xchg %ax,%ax 401050:\tf3 0f 1e fa endbr64 401054:\t68 02 00 00 00 push $0x2 401059:\te9 c2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40105e:\t66 90 xchg %ax,%ax 401060:\tf3 0f 1e fa endbr64 401064:\t68 03 00 00 00 push $0x3 401069:\te9 b2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40106e:\t66 90 xchg %ax,%ax $ readelf -r demo Relocation section '.rela.dyn' at offset 0x518 contains 2 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000403fd8 000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0 000000403fe0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 Relocation section '.rela.plt' at offset 0x548 contains 4 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000404000 000100000007 R_X86_64_JUMP_SLO 0000000000000000 free@GLIBC_2.2.5 + 0 000000404008 000300000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000404010 000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0 000000404018 000600000007 R_X86_64_JUMP_SLO 0000000000000000 malloc@GLIBC_2.2.5 + 0 Let’s analyze this output\nPLT[0]: Resolver (0x401020) ← Common trampoline PLT[1]: free (0x401030) PLT[2]: puts (0x401040) PLT[3]: printf (0x401050) PLT[3]: malloc (0x401050) PLT[0] - The Resolver Trampoline (0x401020) 0000000000401020 \u003c.plt\u003e: 401020: ff 35 ca 2f 00 00 push 0x2fca(%rip) # 403ff0 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 401026: ff 25 cc 2f 00 00 jmp *0x2fcc(%rip) # 403ff8 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 40102c: 0f 1f 40 00 nopl 0x0(%rax) push 0x2fca(%rip) → Pushes GOT[1] (link_map structure) Address: 0x401020 + 6 + 0x2fca = 0x403ff0 This is _GLOBAL_OFFSET_TABLE_+0x8 (GOT[1]) Contains runtime info about loaded libraries jmp *0x2fcc(%rip) → Jumps to GOT[2] (resolver function) Address: 0x401026 + 6 + 0x2fcc = 0x403ff8 This is _GLOBAL_OFFSET_TABLE_+0x10 (GOT[2]) Contains address of _dl_runtime_resolve in ld.so nopl → Padding/alignment The subsequent PLT entries (PLT1, PLT2, etc.) Example: PLT1 (for free):\n401030: f3 0f 1e fa endbr64 401034: 68 00 00 00 00 push $0x0 401039: e9 e2 ff ff ff jmp 401020 \u003c.plt\u003e Breakdown:\nendbr64 - security push $0x0 — push the function index (here 0 → corresponds to first relocation entry). jmp 401020 — jump back to PLT0, which will now use that index to find the corresponding GOT entry (GOT[3] onwards). xchg %ax,%ax - Padding (2-byte NOP) Now let’s track the entre process\nIf we disassemble the code, we can see the call to printf jumps to address 0x401090\n4011d5:\te8 b6 fe ff ff call 401090 The address 0x401090 falls inside .plt.sec section. Modern GCC uses .plt.sec (PLT secondary) for Intel CET (Control-flow Enforcement Technology).\nsanketh@sanketh-81de:~/assembly/plt$ objdump -d -j .plt.sec demo demo: file format elf64-x86-64 Disassembly of section .plt.sec: 0000000000401070 : 401070:\tf3 0f 1e fa endbr64 401074:\tff 25 86 2f 00 00 jmp *0x2f86(%rip) # 404000 40107a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000401080 : 401080:\tf3 0f 1e fa endbr64 401084:\tff 25 7e 2f 00 00 jmp *0x2f7e(%rip) # 404008 40108a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000401090 : 401090:\tf3 0f 1e fa endbr64 401094:\tff 25 76 2f 00 00 jmp *0x2f76(%rip) # 404010 40109a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 00000000004010a0 : 4010a0:\tf3 0f 1e fa endbr64 4010a4:\tff 25 6e 2f 00 00 jmp *0x2f6e(%rip) # 404018 4010aa:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) Our binary has two PLT-related sections:\n1. .plt - Lazy binding resolver stubs\n0x401020: PLT[0] - Common resolver 0x401030: PLT[1] - free resolver stub 0x401040: PLT[2] - puts resolver stub 0x401050: PLT[3] - printf resolver stub 0x401060: PLT[4] - malloc resolver stub 2. .plt.sec - Actual PLT entries (with CET security)\n0x401070: free@plt 0x401080: puts@plt 0x401090: printf@plt ← Your code calls this! 0x4010a0: malloc@plt 3. .plt.got Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: PLT entries for GOT references The .plt.got section is an extension of the traditional .plt, used primarily in position-independent executables (PIE) and shared libraries.\nWhen the compiler generates smaller or more optimized PLT entries, it sometimes places them in .plt.got instead of .plt.\nThese entries rely more directly on the GOT (Global Offset Table) for function address lookups, reducing the indirection and improving performance slightly.\nYou’ll usually see .plt.got in binaries built with:\nGCC’s newer toolchains PIE (Position Independent Executable) enabled Or with RELRO and lazy binding disabled (-Wl,-z,now) $ readelf -S main | grep .plt [11] .rela.plt RELA 0000000000000610 00000610 [13] .plt PROGBITS 0000000000001020 00001020 [14] .plt.got PROGBITS 0000000000001040 00001040 [15] .plt.sec PROGBITS 0000000000001050 00001050 $ objdump -d -j .plt.got main main: file format elf64-x86-64 Disassembly of section .plt.got: 0000000000001040 \u003c__cxa_finalize@plt\u003e: 1040:\tf3 0f 1e fa endbr64 1044:\tff 25 ae 2f 00 00 jmp *0x2fae(%rip) # 3ff8 \u003c__cxa_finalize@GLIBC_2.2.5\u003e 104a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) You’ll find shorter stubs, sometimes just a single indirect jump via the GOT — because by this point, all symbols are already resolved.\n4. .plt.sec Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: Secure PLT stubs (used in hardened binaries) The .plt.sec section is a security-enhanced variant of the traditional .plt. It’s introduced in modern toolchains (GCC ≥ 9, binutils ≥ 2.31) to support Control Flow Integrity (CFI) and Intel’s Indirect Branch Tracking (IBT) features.\nEach entry in .plt.sec is similar to a normal PLT stub, but with additional instructions or metadata to prevent malicious redirection of function calls — protecting against attacks like Return-Oriented Programming (ROP) or GOT overwrite exploits.\nYou’ll usually see .plt.sec when your binary is built with flags like:\n-fpie -fcf-protection=full -O2 $ readelf -S main | grep .plt [13] .plt PROGBITS 0000000000001030 00001030 [14] .plt.got PROGBITS 0000000000001060 00001060 [15] .plt.sec PROGBITS 0000000000001080 00001080 Disassembly (simplified example):\n$ objdump -d -j .plt.sec main main: file format elf64-x86-64 Disassembly of section .plt.sec: 0000000000001050 : 1050:\tf3 0f 1e fa endbr64 1054:\tff 25 76 2f 00 00 jmp *0x2f76(%rip) # 3fd0 105a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) The endbr64 instruction (added by GCC for IBT) is used to mark safe entry points for indirect jumps — the CPU validates that control flow only transfers to legitimate call targets.\nData Sections 1. .rodata - Read-Only Data Type: SHT_PROGBITS Flags: SHF_ALLOC (A) Contains: Constants, string literals const char *msg = \"Hello, World!\"; // String stored in .rodata const int max = 100; $ readelf -x .rodata main Hex dump of section '.rodata': 0x00002000 01000200 48656c6c 6f2c2045 4c462100 ....Hello, ELF!. The .rodata section stores data that should never be modified at runtime. Typical contents include:\nString literals (“Hello, ELF!”) const variables in C/C++ Floating-point constants Lookup or jump tables generated by the compiler Because it’s read-only, this section is usually mapped into memory with read-only permissions (R-) by the OS loader.\nThis prevents accidental modification and improves security — if a program tries to modify it, it will trigger a segmentation fault.\n2. .data - Initialized Data Type: SHT_PROGBITS Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Initialized global and static variables The .data section stores all read–write variables whose initial values are known at compile time. These variables are part of the executable image — the compiler embeds their initial values directly into the ELF file. When the program loads into memory, the loader copies these values into writable memory so your program can modify them at runtime.\nint global_var = 42; // Stored in .data static int static_var = 100; // Stored in .data 3. .bss — Uninitialized Data Type: SHT_NOBITS Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Uninitialized global and static variables (default-initialized to zero) The .bss section holds variables that exist for the lifetime of the program (global or static), but don’t have explicit initial values in your source code. Unlike .data, this section does not occupy any space in the ELF file itself — only the size is recorded. When the program loads, the OS automatically allocates memory for .bss and fills it with zeros.\nExample\nint global_uninit; // Goes into .bss static int static_uninit; // Goes into .bss int main() { return global_uninit; // Initially 0 } Inspect:\n$ gcc -o main main.c $ readelf -S main | grep .bss [25] .bss NOBITS 0000000000004000 00003010 Notice the NOBITS type — that means no bytes are actually stored in the file; only the size (number of bytes required) is recorded.\nIf you dump it:\n$ readelf -x .bss main readelf: Warning: Section '.bss' has no data to dump. That’s because .bss doesn’t exist in the binary — it’s just a placeholder for the loader.\nWhat Happens at Runtime\nThe loader allocates memory for .bss variables. It initializes all bytes to zero (per the C standard). The variables behave like normal globals at runtime. Dynamic Linking Sections 1. .got (Global Offset Table) Type: SHT_PROGBITS Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Holds addresses of global variables and dynamically linked functions used by position-independent code (PIC). In Position-Independent Code (PIC) — used in shared libraries and ASLR-enabled executables, the compiler cannot assume any fixed address for globals or external functions. Instead of hardcoding addresses, the code goes through an indirect table of addresses called the Global Offset Table (GOT).\nEach GOT entry holds the actual runtime address of a symbol (variable or function). At runtime, the dynamic linker (ld.so) fills in the correct addresses so that your program can access everything correctly no matter where it’s loaded in memory.\nGOT Entry Format The GOT is just a contiguous array of addresses. Each entry is 8 bytes (on x86-64):\ntypedef struct { Elf64_Addr address; // The resolved runtime address of the symbol } GOTEntry; So effectively:\n.got: +0x00 -\u003e address of _DYNAMIC +0x08 -\u003e address of __libc_start_main +0x10 -\u003e address of puts ... But logically we can think of GOT as\n| Symbol | GOT Entry (before relocation) | GOT Entry (after relocation) | | ------------------- | ----------------------------- | ---------------------------- | | `puts@GLIBC_2.2.5` | 0x0000000000000000 | 0x00007ffff7e2e6b0 | | `__libc_start_main` | 0x0000000000000000 | 0x00007ffff7e1e170 | | `global_var` | 0x0000000000000000 | 0x0000555555556020 | If GOT is just a list of addresses, then how does linker know which address maps to which symbol?\nThe relocation entries map GOT addresses to symbols.\nEach relocation entry says:\nOffset: 0x3fc0 ← GOT entry address Symbol: malloc ← What symbol this entry is for Type: R_X86_64_JUMP_SLOT So the dynamic linker knows: “GOT entry at address 0x3fc0 should contain the address of malloc”\nWe will dive deep into relocations in later parts.\nHow the GOT Gets Filled? Compiler phase: Generates code with placeholders referring to GOT offsets. Linker phase (ld): Emits relocation entries: .rela.dyn → global variables and data symbols .rela.plt → functions called through the PLT Runtime (ld.so): When the program loads: Reads relocations from .rela.dyn and .rela.plt Writes real addresses into .got and .got.plt entries 2. .got.plt — Global Offset Table for PLT Type: SHT_PROGBITS Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Addresses of dynamically linked functions used by the PLT The .got.plt section is a special part of the Global Offset Table (GOT) that works hand-in-hand with the Procedure Linkage Table (PLT). When the linker creates a PLT (Procedure Linkage Table), it also allocates a small .got.plt table alongside it.\nWhen your program calls an external function (like puts, printf, or malloc), it doesn’t know their real addresses at compile time. Instead, it goes through a small trampoline in .plt, which uses the .got.plt entries to eventually reach the actual function in the shared library.\nHow It Works\nEach entry in .got.plt holds the runtime-resolved address of an external function. Initially, these entries point to the PLT stubs (so the dynamic linker can intercept the first call). After the function is resolved, the dynamic linker updates the GOT entry with the real function address — so the next call goes directly there. This mechanism enables lazy binding — external symbols are resolved only when first used, improving startup performance.\nThe first 3 entries in .got.plt are reserved for the dynamic linker’s internal use:\nGOT Entry Initially Contains Purpose / Explanation GOT[0] Address of _DYNAMIC section Points to the .dynamic section of the current ELF object. This section holds metadata like needed shared libraries, symbol tables, relocation info, etc. The dynamic linker uses this to locate all dynamic linking data for the object being relocated. GOT[1] Address of the link_map structure (set at runtime by ld.so) Each loaded shared object (executable or .so) has a link_map entry describing it — base address, name, dependencies, relocation tables, etc. The dynamic linker uses GOT[1] to know which object’s context it’s resolving symbols for when a lazy PLT call happens. GOT[2] Address of dl_runtime_resolve (or dl_runtime_resolve_xsave on x86_64) This is the resolver function inside ld.so. When a function call through the PLT occurs for the first time, control jumps through PLT[0], which uses GOT[2] to call the resolver. The resolver looks up the symbol, fixes the GOT entry for future calls, and finally jumps to the actual function. After these 3, the remaining GOT entries in .got.plt correspond to function symbols (e.g. printf, malloc, etc.), one per PLT entry.\nHow they’re used during lazy binding When a program calls a function (say printf) for the first time:\nThe call goes through the PLT (Procedure Linkage Table). The first PLT entry (PLT[0]) is special — it sets up a call like this (simplified): jmp *GOT[2] # Jump to the dynamic resolver (ld.so) pushq $reloc_index # Index of the relocation to resolve jmp *GOT[1] # Linker uses link_map + reloc_index The resolver (dl_runtime_resolve) uses: GOT[1] → to find the link_map of the current object GOT[0] → to access _DYNAMIC metadata if needed It then patches the GOT entry for printf with its actual address. Future calls to printf jump directly to the resolved address — no more resolver overhead. 3. .dynamic Type: SHT_DYNAMIC Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Dynamic linking information When you compile a dynamically linked program (default in Linux), the compiler embeds a .dynamic section in your binary. This section acts as a directory of pointers and configuration values that tell the dynamic linker:\nArray of Elf64_Dyn structures containing tags like:\nDT_NEEDED: Required shared libraries DT_SYMTAB: Address of symbol table DT_STRTAB: Address of string table DT_RELA: Address of relocation table $ readelf -d main Dynamic section at offset 0x2dc8 contains 27 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x117c 0x0000000000000019 (INIT_ARRAY) 0x3db8 0x000000000000001b (INIT_ARRAYSZ) 8 (bytes) 0x000000000000001a (FINI_ARRAY) 0x3dc0 0x000000000000001c (FINI_ARRAYSZ) 8 (bytes) 0x000000006ffffef5 (GNU_HASH) 0x3b0 0x0000000000000005 (STRTAB) 0x480 0x0000000000000006 (SYMTAB) 0x3d8 0x000000000000000a (STRSZ) 141 (bytes) 0x000000000000000b (SYMENT) 24 (bytes) 0x0000000000000015 (DEBUG) 0x0 0x0000000000000003 (PLTGOT) 0x3fb8 0x0000000000000002 (PLTRELSZ) 24 (bytes) 0x0000000000000014 (PLTREL) RELA 0x0000000000000017 (JMPREL) 0x610 0x0000000000000007 (RELA) 0x550 0x0000000000000008 (RELASZ) 192 (bytes) 0x0000000000000009 (RELAENT) 24 (bytes) 0x000000000000001e (FLAGS) BIND_NOW 0x000000006ffffffb (FLAGS_1) Flags: NOW PIE 0x000000006ffffffe (VERNEED) 0x520 0x000000006fffffff (VERNEEDNUM) 1 0x000000006ffffff0 (VERSYM) 0x50e 0x000000006ffffff9 (RELACOUNT) 3 0x0000000000000000 (NULL) 0x0 At runtime, the loader (ld-linux.so) reads these entries to correctly link your program with shared libraries before it starts executing main().\nSymbol and String Tables 1. .symtab - Symbol Table Type: SHT_SYMTAB Flags: None (not loaded) Contains: All symbols (functions, global/static variables) used for linking and debugging The .symtab section holds a table of symbols that represent every significant entity in your program — functions, variables, and sections.\nEach entry is an Elf64_Sym structure:\ntypedef struct { Elf64_Word st_name; // Symbol name (string table offset) unsigned char st_info; // Type and binding unsigned char st_other; // Visibility Elf64_Half st_shndx; // Section index Elf64_Addr st_value; // Symbol value (address) Elf64_Xword st_size; // Symbol size } Elf64_Sym; How it’s used\nThe linker uses .symtab to match symbol definitions (e.g., int x;) with their references (e.g., extern int x;) across multiple object files. Each symbol name in .symtab corresponds to an offset in the .strtab (string table) section, where actual names are stored. $ readelf -s main | head Symbol table '.dynsym' contains 7 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND _[...]@GLIBC_2.34 (2) 2: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterT[...] 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.2.5 (3) 4: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 5: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMC[...] 6: 0000000000000000 0 FUNC WEAK DEFAULT UND [...]@GLIBC_2.2.5 (3) Interpretation:\nType: Describes what the symbol is (FUNC, OBJECT, etc.) Bind: Whether it’s LOCAL (visible only in file) or GLOBAL (visible to linker) Ndx: Section index where the symbol is defined (e.g., .text, .data) Value: Its address (if defined) Name: Symbol name (resolved from .strtab) Here’s the detailed explanation for .strtab (String Table):\n2. .strtab – String Table Type: SHT_STRTAB Flags: (none) (not loaded into memory) Contains: Null-terminated strings used by other sections like .symtab and relocation entries. Each symbol in .symtab doesn’t store its name directly — instead, the st_name field holds an offset into .strtab, where the actual string (symbol name) is stored.\nExample\nSuppose you have these symbols:\nint var; void func() {} The .symtab entries might look like this:\nSymbol st_name (offset) st_value … var 0x00 0x601000 … func 0x04 0x401020 … And the .strtab will actually contain:\n0x00: \"var\\0func\\0\" Notes\n.strtab appears alongside .symtab, used mainly by the linker and debugger, not at runtime. It’s not loaded into memory (unlike .rodata or .data). There’s often also a .shstrtab — the section header string table, which stores section names (like .text, .data, .bss). 3. .dynstr – Dynamic String Table Type: SHT_STRTAB Flags: SHF_ALLOC (A) — loaded into memory Contains: Null-terminated strings used by dynamic linking sections such as .dynsym, .rela.plt, and .dynamic. Purpose\n.dynstr serves the same purpose as .strtab, but only for symbols needed at runtime — i.e., dynamic symbols that the loader (ld.so) must resolve when the program is loaded.\nExample\nIf your program uses shared libraries like:\nprintf(\"Hi\"); Then the dynamic symbol table (.dynsym) will contain an entry for printf, and its st_name field will point to an offset inside .dynstr:\nSymbol st_name (offset) st_value … printf 0x00 0x0000 … And .dynstr will contain:\n0x00: \"printf\\0libc.so.6\\0\" Comparison\nSection Used By Loaded? Contains Purpose .strtab Linker / Debugger ❌ All symbols For static linking and debugging .dynstr Runtime linker (ld.so) ✅ Dynamic symbols For dynamic linking Relocations Relocation sections follow the pattern: .rela. or .rel.\nEach .rela.* section contains relocations that need to be applied to a specific target section. However, relocations serve different purposes depending on when and how they’re resolved.\nWhy do we need them?\nWhen compiling a single .o file, the compiler doesn’t know:\nWhere other functions will be located (like printf, helper_function) Where data from other files will be What the final memory layout will be after linking Where the code itself will be loaded in memory So the compiler:\nPuts placeholder values (usually zeros) in the machine code Creates relocation entries that tell the linker how to fix these placeholders Anatomy of a relocation entry Each entry has these fields:\nOffset: 0x000000002f Info: 000600000004 Type: R_X86_64_PLT32 Sym. Value: 0000000000000000 Sym. Name: add_numbers Addend: -4 1. Offset\nWhere in the target section to apply the patch For .rela.text: offset within .text section This is the location of the placeholder bytes 2. Type\nHow to calculate the patch value Different types = different formulas Common types\nRelocation Description Typical Use R_X86_64_64 Absolute 64-bit address Global/static data, function pointers R_X86_64_PC32 32-bit PC-relative address References to globals or functions (when in same module) R_X86_64_PLT32 32-bit PC-relative address to PLT entry Function calls to external symbols R_X86_64_GOT32 32-bit offset to GOT entry Access via GOT (rare now, replaced by GOTPCREL) R_X86_64_GOTPCREL 32-bit PC-relative offset to GOT entry Access to globals through GOT (PIC/PIE code) R_X86_64_GLOB_DAT Set GOT entry to absolute address Used in dynamic linking (e.g. for globals) R_X86_64_JUMP_SLOT Set PLT entry to function address Used by dynamic linker for function calls R_X86_64_RELATIVE Adjust by base address Used by dynamic loader for position-independent executables R_X86_64_COPY Copy data from shared object Used for global variables defined in executable and shared in libraries 3. Symbol Name\nWhat symbol this relocation refers to Could be a function name, section name, or variable name Linker looks up where this symbol ended up 4. Addend\nExtra offset to add to the calculation Often -4 for PC-relative calls (compensates for instruction size) 5. Info (encoded field)\nContains both the symbol table index and type You usually ignore this - readelf decodes it for you Relocation Categories 1. Static/Link-Time Relocations Resolved by the static linker (ld) when creating the executable.\nThese appear in .o (object) files and are resolved during the linking phase. Once linking is complete, these sections are removed from the final executable.\nRelocation Section Applies To Contains Relocations For When Resolved .rela.text .text section Function calls, data references in code Link time .rela.data .data section Pointers in initialized global variables Link time .rela.rodata .rodata section Pointers in constant data (e.g., string arrays) Link time .rela.eh_frame .eh_frame section Exception handling metadata, stack unwinding Link time .rela.init_array .init_array section Constructor function pointers Link time .rela.fini_array .fini_array section Destructor function pointers Link time What happens:\nCompiler creates these when generating .o files Static linker (ld) reads these relocations Patches the placeholder bytes with calculated addresses Removes these sections from the final executable 2. Runtime/Dynamic Relocations Resolved by the dynamic linker (ld.so) when loading the program\nThese appear in dynamically linked executables and shared libraries. They are kept in the binary because they must be processed every time the program runs (due to ASLR and shared library loading).\nRelocation Section Applies To Contains Relocations For When Resolved .rela.dyn .got, .data, .bss Global variables, data pointers, GOT entries Program startup .rela.plt .got.plt (or merged .got) Function calls through PLT/GOT Lazy binding (on first call) or at startup What happens:\nPresent in the final executable Dynamic linker (ld.so) processes them at runtime Adjusts for ASLR (random base address) Resolves symbols from shared libraries Sections remain (needed for every program execution) 3. Complete Relocation Process Initial State (After Loading, Before Any Calls)\nEach external function has three related components: A .plt.sec entry (small code stub) A .plt resolver stub (fallback code) A .got.plt entry (8-byte address slot) All GOT entries initially point to the .plt (PLT[0]) resolver stubs, not to real functions The dynamic linker has filled GOT[1] (link_map) and GOT[2] (_dl_runtime_resolve) First Call to an External Function\nCode calls printf@plt (jumps to .plt.sec entry) .plt.sec stub contains the jump to .got.plt entry for that function (address in .got.plt is present in relocation for that function) .got.plt still contains stub which takes it to the corresponding entry for that function in .plt .plt entry will push the relocation index for that function and jump to PLT resolver at PLT[0] Resolver stub pushes relocation index (identifies which function) and jumps to PLT[0] (common resolver trampoline) PLT[0] pushes GOT[1] (context) and jumps through GOT[2] (to dynamic linker) Dynamic linker receives control with relocation index and context Dynamic linker looks up the function symbol in loaded shared libraries Dynamic linker finds function address in appropriate library (e.g., libc.so) Dynamic linker writes real function address into the .got.plt entry (key step!) Dynamic linker jumps to the real function and returns to caller Subsequent Calls to Same function\nCode calls printf@plt (jumps to .plt.sec entry) .plt.sec stub jumps to the entry in .got.plt .got.plt now contains real function address → lands directly in the function Function executes and returns to call // demo.c #include #include int main() { printf(\"Before malloc\\n\"); void *ptr = malloc(100); printf(\"Allocated at: %p\\n\", ptr); free(ptr); printf(\"After free\\n\"); return 0; } This is the section header table\n$ readelf -S demo There are 31 section headers, starting at offset 0x36d0: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400318 00000318 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.gnu.pr[...] NOTE 0000000000400338 00000338 0000000000000030 0000000000000000 A 0 0 8 [ 3] .note.gnu.bu[...] NOTE 0000000000400368 00000368 0000000000000024 0000000000000000 A 0 0 4 [ 4] .note.ABI-tag NOTE 000000000040038c 0000038c 0000000000000020 0000000000000000 A 0 0 4 [ 5] .gnu.hash GNU_HASH 00000000004003b0 000003b0 000000000000001c 0000000000000000 A 6 0 8 [ 6] .dynsym DYNSYM 00000000004003d0 000003d0 00000000000000a8 0000000000000018 A 7 1 8 [ 7] .dynstr STRTAB 0000000000400478 00000478 000000000000005b 0000000000000000 A 0 0 1 [ 8] .gnu.version VERSYM 00000000004004d4 000004d4 000000000000000e 0000000000000002 A 6 0 2 [ 9] .gnu.version_r VERNEED 00000000004004e8 000004e8 0000000000000030 0000000000000000 A 7 1 8 [10] .rela.dyn RELA 0000000000400518 00000518 0000000000000030 0000000000000018 A 6 0 8 [11] .rela.plt RELA 0000000000400548 00000548 0000000000000060 0000000000000018 AI 6 24 8 [12] .init PROGBITS 0000000000401000 00001000 000000000000001b 0000000000000000 AX 0 0 4 [13] .plt PROGBITS 0000000000401020 00001020 0000000000000050 0000000000000010 AX 0 0 16 [14] .plt.sec PROGBITS 0000000000401070 00001070 0000000000000040 0000000000000010 AX 0 0 16 [15] .text PROGBITS 00000000004010b0 000010b0 000000000000014c 0000000000000000 AX 0 0 16 [16] .fini PROGBITS 00000000004011fc 000011fc 000000000000000d 0000000000000000 AX 0 0 4 [17] .rodata PROGBITS 0000000000402000 00002000 000000000000002f 0000000000000000 A 0 0 4 [18] .eh_frame_hdr PROGBITS 0000000000402030 00002030 0000000000000034 0000000000000000 A 0 0 4 [19] .eh_frame PROGBITS 0000000000402068 00002068 00000000000000a4 0000000000000000 A 0 0 8 [20] .init_array INIT_ARRAY 0000000000403df8 00002df8 0000000000000008 0000000000000008 WA 0 0 8 [21] .fini_array FINI_ARRAY 0000000000403e00 00002e00 0000000000000008 0000000000000008 WA 0 0 8 [22] .dynamic DYNAMIC 0000000000403e08 00002e08 00000000000001d0 0000000000000010 WA 7 0 8 [23] .got PROGBITS 0000000000403fd8 00002fd8 0000000000000010 0000000000000008 WA 0 0 8 [24] .got.plt PROGBITS 0000000000403fe8 00002fe8 0000000000000038 0000000000000008 WA 0 0 8 [25] .data PROGBITS 0000000000404020 00003020 0000000000000010 0000000000000000 WA 0 0 8 [26] .bss NOBITS 0000000000404030 00003030 0000000000000008 0000000000000000 WA 0 0 1 [27] .comment PROGBITS 0000000000000000 00003030 000000000000002b 0000000000000001 MS 0 0 1 [28] .symtab SYMTAB 0000000000000000 00003060 0000000000000378 0000000000000018 29 18 8 [29] .strtab STRTAB 0000000000000000 000033d8 00000000000001d7 0000000000000000 0 0 1 [30] .shstrtab STRTAB 0000000000000000 000035af 000000000000011f 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) We can see relocation entries for free, puts, printf and malloc.\n$ readelf -r demo Relocation section '.rela.dyn' at offset 0x518 contains 2 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000403fd8 000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0 000000403fe0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 Relocation section '.rela.plt' at offset 0x548 contains 4 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000404000 000100000007 R_X86_64_JUMP_SLO 0000000000000000 free@GLIBC_2.2.5 + 0 000000404008 000300000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000404010 000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0 000000404018 000600000007 R_X86_64_JUMP_SLO 0000000000000000 malloc@GLIBC_2.2.5 + 0 Let’s dosassemble the .text section\n$ objdump -d -j .text demo demo: file format elf64-x86-64 Disassembly of section .text: 00000000004010b0 \u003c_start\u003e: 4010b0:\tf3 0f 1e fa endbr64 4010b4:\t31 ed xor %ebp,%ebp 4010b6:\t49 89 d1 mov %rdx,%r9 4010b9:\t5e pop %rsi 4010ba:\t48 89 e2 mov %rsp,%rdx 4010bd:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 4010c1:\t50 push %rax 4010c2:\t54 push %rsp 4010c3:\t45 31 c0 xor %r8d,%r8d 4010c6:\t31 c9 xor %ecx,%ecx 4010c8:\t48 c7 c7 96 11 40 00 mov $0x401196,%rdi 4010cf:\tff 15 03 2f 00 00 call *0x2f03(%rip) # 403fd8 \u003c__libc_start_main@GLIBC_2.34\u003e 4010d5:\tf4 hlt 4010d6:\t66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 4010dd:\t00 00 00 00000000004010e0 \u003c_dl_relocate_static_pie\u003e: 4010e0:\tf3 0f 1e fa endbr64 4010e4:\tc3 ret 4010e5:\t66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 4010ec:\t00 00 00 4010ef:\t90 nop 00000000004010f0 : 4010f0:\tb8 30 40 40 00 mov $0x404030,%eax 4010f5:\t48 3d 30 40 40 00 cmp $0x404030,%rax 4010fb:\t74 13 je 401110 4010fd:\tb8 00 00 00 00 mov $0x0,%eax 401102:\t48 85 c0 test %rax,%rax 401105:\t74 09 je 401110 401107:\tbf 30 40 40 00 mov $0x404030,%edi 40110c:\tff e0 jmp *%rax 40110e:\t66 90 xchg %ax,%ax 401110:\tc3 ret 401111:\t66 66 2e 0f 1f 84 00 data16 cs nopw 0x0(%rax,%rax,1) 401118:\t00 00 00 00 40111c:\t0f 1f 40 00 nopl 0x0(%rax) 0000000000401120 : 401120:\tbe 30 40 40 00 mov $0x404030,%esi 401125:\t48 81 ee 30 40 40 00 sub $0x404030,%rsi 40112c:\t48 89 f0 mov %rsi,%rax 40112f:\t48 c1 ee 3f shr $0x3f,%rsi 401133:\t48 c1 f8 03 sar $0x3,%rax 401137:\t48 01 c6 add %rax,%rsi 40113a:\t48 d1 fe sar $1,%rsi 40113d:\t74 11 je 401150 40113f:\tb8 00 00 00 00 mov $0x0,%eax 401144:\t48 85 c0 test %rax,%rax 401147:\t74 07 je 401150 401149:\tbf 30 40 40 00 mov $0x404030,%edi 40114e:\tff e0 jmp *%rax 401150:\tc3 ret 401151:\t66 66 2e 0f 1f 84 00 data16 cs nopw 0x0(%rax,%rax,1) 401158:\t00 00 00 00 40115c:\t0f 1f 40 00 nopl 0x0(%rax) 0000000000401160 \u003c__do_global_dtors_aux\u003e: 401160:\tf3 0f 1e fa endbr64 401164:\t80 3d c5 2e 00 00 00 cmpb $0x0,0x2ec5(%rip) # 404030 \u003c__TMC_END__\u003e 40116b:\t75 13 jne 401180 \u003c__do_global_dtors_aux+0x20\u003e 40116d:\t55 push %rbp 40116e:\t48 89 e5 mov %rsp,%rbp 401171:\te8 7a ff ff ff call 4010f0 401176:\tc6 05 b3 2e 00 00 01 movb $0x1,0x2eb3(%rip) # 404030 \u003c__TMC_END__\u003e 40117d:\t5d pop %rbp 40117e:\tc3 ret 40117f:\t90 nop 401180:\tc3 ret 401181:\t66 66 2e 0f 1f 84 00 data16 cs nopw 0x0(%rax,%rax,1) 401188:\t00 00 00 00 40118c:\t0f 1f 40 00 nopl 0x0(%rax) 0000000000401190 : 401190:\tf3 0f 1e fa endbr64 401194:\teb 8a jmp 401120 0000000000401196 : 401196:\tf3 0f 1e fa endbr64 40119a:\t55 push %rbp 40119b:\t48 89 e5 mov %rsp,%rbp 40119e:\t48 83 ec 10 sub $0x10,%rsp 4011a2:\t48 8d 05 5b 0e 00 00 lea 0xe5b(%rip),%rax # 402004 \u003c_IO_stdin_used+0x4\u003e 4011a9:\t48 89 c7 mov %rax,%rdi 4011ac:\te8 cf fe ff ff call 401080 4011b1:\tbf 64 00 00 00 mov $0x64,%edi 4011b6:\te8 e5 fe ff ff call 4010a0 4011bb:\t48 89 45 f8 mov %rax,-0x8(%rbp) 4011bf:\t48 8b 45 f8 mov -0x8(%rbp),%rax 4011c3:\t48 89 c6 mov %rax,%rsi 4011c6:\t48 8d 05 45 0e 00 00 lea 0xe45(%rip),%rax # 402012 \u003c_IO_stdin_used+0x12\u003e 4011cd:\t48 89 c7 mov %rax,%rdi 4011d0:\tb8 00 00 00 00 mov $0x0,%eax 4011d5:\te8 b6 fe ff ff call 401090 4011da:\t48 8b 45 f8 mov -0x8(%rbp),%rax 4011de:\t48 89 c7 mov %rax,%rdi 4011e1:\te8 8a fe ff ff call 401070 4011e6:\t48 8d 05 37 0e 00 00 lea 0xe37(%rip),%rax # 402024 \u003c_IO_stdin_used+0x24\u003e 4011ed:\t48 89 c7 mov %rax,%rdi 4011f0:\te8 8b fe ff ff call 401080 4011f5:\tb8 00 00 00 00 mov $0x0,%eax 4011fa:\tc9 leave 4011fb:\tc3 ret We can see calls to\ncall 401080 call 401090 call 401070 call 401080 We can see these addresses match to their corresponding stubs in .plt.sec section\n$ objdump -d -j .plt.sec demo demo: file format elf64-x86-64 Disassembly of section .plt.sec: 0000000000401070 : 401070:\tf3 0f 1e fa endbr64 401074:\tff 25 86 2f 00 00 jmp *0x2f86(%rip) # 404000 40107a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000401080 : 401080:\tf3 0f 1e fa endbr64 401084:\tff 25 7e 2f 00 00 jmp *0x2f7e(%rip) # 404008 40108a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000401090 : 401090:\tf3 0f 1e fa endbr64 401094:\tff 25 76 2f 00 00 jmp *0x2f76(%rip) # 404010 40109a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 00000000004010a0 : 4010a0:\tf3 0f 1e fa endbr64 4010a4:\tff 25 6e 2f 00 00 jmp *0x2f6e(%rip) # 404018 4010aa:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) PLT section\n$ objdump -d -j .plt demo demo: file format elf64-x86-64 Disassembly of section .plt: 0000000000401020 \u003c.plt\u003e: 401020:\tff 35 ca 2f 00 00 push 0x2fca(%rip) # 403ff0 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 401026:\tff 25 cc 2f 00 00 jmp *0x2fcc(%rip) # 403ff8 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 40102c:\t0f 1f 40 00 nopl 0x0(%rax) 401030:\tf3 0f 1e fa endbr64 401034:\t68 00 00 00 00 push $0x0 401039:\te9 e2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40103e:\t66 90 xchg %ax,%ax 401040:\tf3 0f 1e fa endbr64 401044:\t68 01 00 00 00 push $0x1 401049:\te9 d2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40104e:\t66 90 xchg %ax,%ax 401050:\tf3 0f 1e fa endbr64 401054:\t68 02 00 00 00 push $0x2 401059:\te9 c2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40105e:\t66 90 xchg %ax,%ax 401060:\tf3 0f 1e fa endbr64 401064:\t68 03 00 00 00 push $0x3 401069:\te9 b2 ff ff ff jmp 401020 \u003c_init+0x20\u003e 40106e:\t66 90 xchg %ax,%ax We can verify the initial addresses stored in .got.plt entries are references to corresponding entries in .plt (addresses are in little endian)\n$ readelf -x .got.plt demo Hex dump of section '.got.plt': NOTE: This section has relocations against it, but these have NOT been applied to this dump. 0x00403fe8 083e4000 00000000 00000000 00000000 .\u003e@............. 0x00403ff8 00000000 00000000 30104000 00000000 ........0.@..... 0x00404008 40104000 00000000 50104000 00000000 @.@.....P.@..... 0x00404018 60104000 00000000 `.@..... Eg 404000 maps to 401030 (PLT[1]), 404008 maps to 401040 (PLT[2]), etc.\nLet’s run the program and see the addresses in .got.plt getting updated to actual values. I have disabled ASLR and compiled the binary as no-pie executable for simplicity.\n$ gdb ./demo (gdb) break main Breakpoint 1 at 0x40119e (gdb) run Starting program: /home/sanketh/assembly/plt/demo Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000 [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Breakpoint 1, 0x000000000040119e in main () (initial got entries, its not showing puts and malloc as they don't span new rows) (gdb) x/4gx 0x404000 0x404000 :\t0x0000000000401030\t0x0000000000401040 0x404010 :\t0x0000000000401050\t0x0000000000401060 (gdb) next Single stepping until exit from function main, (gdb) x/4gx 0x404000 0x404000 :\t0x00007ffff7cadd30\t0x00007ffff7c87be0 0x404010 :\t0x00007ffff7c60100\t0x00007ffff7cad650 We can see .got.plt section got updated with actual values.\n","wordCount":"9076","inLanguage":"en","datePublished":"2025-10-15T00:00:00Z","dateModified":"2025-10-15T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ELF Format: Part 3</h1><div class=post-meta><span title='2025-10-15 00:00:00 +0000 UTC'>October 15, 2025</span>&nbsp;·&nbsp;43 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/cpu/2025-10-15-elf-format-part-3.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elf-format-sections-and-section-header-table aria-label="ELF Format: Sections and Section Header Table">ELF Format: Sections and Section Header Table</a><ul><li><a href=#what-are-sections aria-label="What Are Sections?">What Are Sections?</a></li><li><a href=#sections-vs-segments-the-relationship aria-label="Sections vs Segments: The Relationship">Sections vs Segments: The Relationship</a></li><li><a href=#section-header-table aria-label="Section Header Table">Section Header Table</a><ul><li><a href=#section-header-table-location aria-label="Section Header Table Location">Section Header Table Location</a></li><li><a href=#section-header-entry-structure aria-label="Section Header Entry Structure">Section Header Entry Structure</a></li><li><a href=#section-header-fields-explained aria-label="Section Header Fields Explained">Section Header Fields Explained</a><ul><li><a href=#1-sh_name---section-name aria-label="1. sh_name - Section Name">1. sh_name - Section Name</a></li><li><a href=#2-sh_type---section-type aria-label="2. sh_type - Section Type">2. sh_type - Section Type</a><ul><li><a href=#1-sht_null--inactive-section aria-label="1. SHT_NULL — Inactive Section">1. SHT_NULL — Inactive Section</a></li><li><a href=#2-sht_progbits--program-data aria-label="2. SHT_PROGBITS — Program Data">2. SHT_PROGBITS — Program Data</a></li><li><a href=#3-sht_symtab--symbol-table aria-label="3. SHT_SYMTAB — Symbol Table">3. SHT_SYMTAB — Symbol Table</a></li><li><a href=#4-sht_strtab--string-table aria-label="4. SHT_STRTAB — String Table">4. SHT_STRTAB — String Table</a></li><li><a href=#5-sht_rela--relocation-entries-with-addends aria-label="5. SHT_RELA — Relocation Entries with Addends">5. SHT_RELA — Relocation Entries with Addends</a></li><li><a href=#6-sht_hash--symbol-hash-table aria-label="6. SHT_HASH — Symbol Hash Table">6. SHT_HASH — Symbol Hash Table</a></li><li><a href=#7-sht_dynamic--dynamic-linking-information aria-label="7. SHT_DYNAMIC — Dynamic Linking Information">7. SHT_DYNAMIC — Dynamic Linking Information</a></li><li><a href=#8-sht_note--auxiliary-information aria-label="8. SHT_NOTE — Auxiliary Information">8. SHT_NOTE — Auxiliary Information</a></li><li><a href=#9-sht_nobits--no-file-storage-eg-bss aria-label="9. SHT_NOBITS — No File Storage (e.g., .bss)">9. SHT_NOBITS — No File Storage (e.g., .bss)</a></li><li><a href=#10-sht_rel--relocation-entries-without-addends aria-label="10. SHT_REL — Relocation Entries without Addends">10. SHT_REL — Relocation Entries without Addends</a></li><li><a href=#11-sht_dynsym--dynamic-symbol-table aria-label="11. SHT_DYNSYM — Dynamic Symbol Table">11. SHT_DYNSYM — Dynamic Symbol Table</a></li></ul></li><li><a href=#3-sh_flags---section-flags aria-label="3. sh_flags - Section Flags">3. sh_flags - Section Flags</a></li><li><a href=#4-sh_addr---virtual-address aria-label="4. sh_addr - Virtual Address">4. sh_addr - Virtual Address</a></li><li><a href=#5-sh_offset---file-offset aria-label="5. sh_offset - File Offset">5. sh_offset - File Offset</a></li><li><a href=#6-sh_size---section-size aria-label="6. sh_size - Section Size">6. sh_size - Section Size</a></li><li><a href=#7-sh_link--linking-one-section-to-another aria-label="7. sh_link — Linking One Section to Another">7. sh_link — Linking One Section to Another</a></li><li><a href=#8-sh_info---additional-information aria-label="8. sh_info - Additional Information">8. sh_info - Additional Information</a></li><li><a href=#9-sh_addralign---alignment aria-label="9. sh_addralign - Alignment">9. sh_addralign - Alignment</a></li><li><a href=#10-sh_entsize---entry-size aria-label="10. sh_entsize - Entry Size">10. sh_entsize - Entry Size</a></li></ul></li></ul></li><li><a href=#broad-classifications-of-sections aria-label="Broad Classifications of Sections">Broad Classifications of Sections</a></li><li><a href=#code-sections aria-label="Code Sections">Code Sections</a><ul><li><a href=#1-text---executable-code aria-label="1. .text - Executable Code">1. .text - Executable Code</a></li><li><a href=#2-plt-procedure-linkage-table aria-label="2. .plt (Procedure Linkage Table)">2. .plt (Procedure Linkage Table)</a><ul><li><a href=#plt-entry-format aria-label="PLT Entry &ldquo;Format&rdquo;">PLT Entry &ldquo;Format&rdquo;</a></li><li><a href=#plt0---the-resolver-trampoline-0x401020 aria-label="PLT[0] - The Resolver Trampoline (0x401020)">PLT[0] - The Resolver Trampoline (0x401020)</a></li><li><a href=#the-subsequent-plt-entries-plt1-plt2-etc aria-label="The subsequent PLT entries (PLT1, PLT2, etc.)">The subsequent PLT entries (PLT1, PLT2, etc.)</a></li></ul></li><li><a href=#3-pltgot aria-label="3. .plt.got">3. .plt.got</a></li><li><a href=#4-pltsec aria-label="4. .plt.sec">4. .plt.sec</a></li></ul></li><li><a href=#data-sections aria-label="Data Sections">Data Sections</a><ul><li><a href=#1-rodata---read-only-data aria-label="1. .rodata - Read-Only Data">1. .rodata - Read-Only Data</a></li><li><a href=#2-data---initialized-data aria-label="2. .data - Initialized Data">2. .data - Initialized Data</a></li><li><a href=#3-bss--uninitialized-data aria-label="3. .bss — Uninitialized Data">3. .bss — Uninitialized Data</a></li></ul></li><li><a href=#dynamic-linking-sections aria-label="Dynamic Linking Sections">Dynamic Linking Sections</a><ul><li><a href=#1-got-global-offset-table aria-label="1. .got (Global Offset Table)">1. .got (Global Offset Table)</a><ul><li><a href=#got-entry-format aria-label="GOT Entry Format">GOT Entry Format</a></li><li><a href=#how-the-got-gets-filled aria-label="How the GOT Gets Filled?">How the GOT Gets Filled?</a></li></ul></li><li><a href=#2-gotplt--global-offset-table-for-plt aria-label="2. .got.plt — Global Offset Table for PLT">2. .got.plt — Global Offset Table for PLT</a><ul><li><a href=#how-theyre-used-during-lazy-binding aria-label="How they’re used during lazy binding">How they’re used during lazy binding</a></li></ul></li><li><a href=#3-dynamic aria-label="3. .dynamic">3. .dynamic</a></li></ul></li><li><a href=#symbol-and-string-tables aria-label="Symbol and String Tables">Symbol and String Tables</a><ul><li><a href=#1-symtab---symbol-table aria-label="1. .symtab - Symbol Table">1. .symtab - Symbol Table</a></li><li><a href=#2-strtab--string-table aria-label="2. .strtab – String Table">2. .strtab – String Table</a></li><li><a href=#3-dynstr--dynamic-string-table aria-label="3. .dynstr – Dynamic String Table">3. .dynstr – Dynamic String Table</a></li></ul></li><li><a href=#relocations aria-label=Relocations>Relocations</a><ul><li><a href=#anatomy-of-a-relocation-entry aria-label="Anatomy of a relocation entry">Anatomy of a relocation entry</a></li><li><a href=#relocation-categories aria-label="Relocation Categories">Relocation Categories</a><ul><li><a href=#1-staticlink-time-relocations aria-label="1. Static/Link-Time Relocations">1. Static/Link-Time Relocations</a></li><li><a href=#2-runtimedynamic-relocations aria-label="2. Runtime/Dynamic Relocations">2. Runtime/Dynamic Relocations</a></li><li><a href=#3-complete-relocation-process aria-label="3. Complete Relocation Process">3. Complete Relocation Process</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=elf-format-sections-and-section-header-table>ELF Format: Sections and Section Header Table<a hidden class=anchor aria-hidden=true href=#elf-format-sections-and-section-header-table>#</a></h1><p>In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&rsquo;ll look at Section Headers and Sections - the link-time and debugging view.</p><h2 id=what-are-sections>What Are Sections?<a hidden class=anchor aria-hidden=true href=#what-are-sections>#</a></h2><p>Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&rsquo;s contents for:</p><ul><li><strong>Linkers</strong> - combining object files into executables</li><li><strong>Debuggers</strong> - finding symbols, source code mappings</li><li><strong>Analysis tools</strong> - examining specific parts of the binary</li></ul><p><strong>Key distinction from segments:</strong></p><p>Segments = Required at runtime (OS needs them to execute)
Sections = Optional at runtime (can be stripped from executables)</p><p>You can strip all section headers and the program will still run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | wc -l
</span></span><span style=display:flex><span><span style=color:#ae81ff>68</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ objcopy --strip-section-headers main  main2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ readelf -S main2
</span></span><span style=display:flex><span>There are no sections in this file.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./main2
</span></span><span style=display:flex><span>Hi there!
</span></span></code></pre></div><h2 id=sections-vs-segments-the-relationship>Sections vs Segments: The Relationship<a hidden class=anchor aria-hidden=true href=#sections-vs-segments-the-relationship>#</a></h2><ul><li><p>Sections (like <code>.text</code>, <code>.data</code>, <code>.bss</code>, <code>.rodata</code>)
Represent logical divisions of code and data within the file.
Used by linkers and debuggers — they organize how functions, variables, and symbols are stored in the file.</p></li><li><p>Segments (<code>PT_LOAD</code>, <code>PT_DYNAMIC</code>, <code>PT_INTERP</code>, etc.)
Represent runtime mappings — how parts of the file are placed into memory by the OS loader when the program runs.</p></li></ul><p><strong>How They Relate</strong></p><p>During linking, the linker groups related sections into loadable segments based on their flags (<code>R</code>, <code>W</code>, <code>X</code>) and alignment requirements.</p><table><thead><tr><th>Segment (Type)</th><th>Typical Sections</th><th>Permissions</th></tr></thead><tbody><tr><td>Text Segment (<code>PT_LOAD</code>)</td><td><code>.interp</code>, <code>.text</code>, <code>.rodata</code></td><td><strong>R-X</strong></td></tr><tr><td>Data Segment (<code>PT_LOAD</code>)</td><td><code>.data</code>, <code>.bss</code></td><td><strong>RW-</strong></td></tr></tbody></table><p>So, a segment is usually a contiguous chunk of the file containing one or more sections that share similar memory attributes.</p><p><strong>Key Facts</strong></p><ul><li><p><strong>A section can exist outside any segment.</strong>
These are used only at link or debug time and are not mapped into memory.
Examples: <code>.symtab</code>, <code>.strtab</code>, <code>.debug_*</code>, <code>.comment</code>.</p></li><li><p><strong>A section can never belong to more than one segment.</strong>
Each section appears in at most one segment, as each piece of data is loaded into a single memory region.</p></li><li><p><strong>A segment can exist without any section.</strong>
Some segments (like <code>PT_INTERP</code>, <code>PT_PHDR</code>, or <code>PT_NOTE</code>) describe runtime structures or metadata not represented as regular sections.</p></li></ul><h2 id=section-header-table>Section Header Table<a hidden class=anchor aria-hidden=true href=#section-header-table>#</a></h2><p>The Section Header Table is an array of section header entries, each describing one section.</p><h3 id=section-header-table-location>Section Header Table Location<a hidden class=anchor aria-hidden=true href=#section-header-table-location>#</a></h3><p>The ELF Header tells us where to find it:</p><ul><li>Location (file offset): <code>e_shoff</code> field in ELF Header</li><li>Entry size: <code>e_shentsize</code> (40 bytes for 32-bit, 64 bytes for 64-bit)</li><li>Number of entries: <code>e_shnum</code></li><li>String table index: <code>e_shstrndx</code> (which section contains section names)</li></ul><p>Total table size = <code>e_shentsize × e_shnum</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep section
</span></span><span style=display:flex><span>  Start of section headers:          <span style=color:#ae81ff>14176</span> <span style=color:#f92672>(</span>bytes into file<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Size of section headers:           <span style=color:#ae81ff>64</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Number of section headers:         <span style=color:#ae81ff>31</span>
</span></span><span style=display:flex><span>  Section header string table index: <span style=color:#ae81ff>30</span>
</span></span></code></pre></div><p>This means:</p><ul><li>Section Header Table starts at offset 0x3760 (14176 bytes)</li><li>Each entry is 64 bytes</li><li>There are 31 entries</li><li>Section #30 contains the string table with section names</li></ul><h3 id=section-header-entry-structure>Section Header Entry Structure<a hidden class=anchor aria-hidden=true href=#section-header-entry-structure>#</a></h3><p>Each entry describes one section. Here&rsquo;s the structure from the Linux kernel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf32_shdr {
</span></span><span style=display:flex><span>  Elf32_Word	sh_name;       <span style=color:#75715e>// Section name (string table offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_type;       <span style=color:#75715e>// Section type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_flags;      <span style=color:#75715e>// Section flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Addr	sh_addr;       <span style=color:#75715e>// Virtual address in memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Off	sh_offset;     <span style=color:#75715e>// File offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_size;       <span style=color:#75715e>// Section size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_link;       <span style=color:#75715e>// Link to another section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_info;       <span style=color:#75715e>// Additional information
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_addralign;  <span style=color:#75715e>// Alignment constraints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_entsize;    <span style=color:#75715e>// Entry size if section holds table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Elf32_Shdr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf64_shdr {
</span></span><span style=display:flex><span>  Elf64_Word	sh_name;       <span style=color:#75715e>// Section name (string table offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Word	sh_type;       <span style=color:#75715e>// Section type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_flags;      <span style=color:#75715e>// Section flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Addr	sh_addr;       <span style=color:#75715e>// Virtual address in memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Off	sh_offset;     <span style=color:#75715e>// File offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_size;       <span style=color:#75715e>// Section size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Word	sh_link;       <span style=color:#75715e>// Link to another section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Word	sh_info;       <span style=color:#75715e>// Additional information
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_addralign;  <span style=color:#75715e>// Alignment constraints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_entsize;    <span style=color:#75715e>// Entry size if section holds table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Elf64_Shdr;
</span></span></code></pre></div><h3 id=section-header-fields-explained>Section Header Fields Explained<a hidden class=anchor aria-hidden=true href=#section-header-fields-explained>#</a></h3><h4 id=1-sh_name---section-name>1. sh_name - Section Name<a hidden class=anchor aria-hidden=true href=#1-sh_name---section-name>#</a></h4><p>This is NOT a string! It&rsquo;s an offset into the section header string table.</p><p>How section names work:</p><p>Step 1: ELF Header&rsquo;s <code>e_shstrndx</code> tells us which section contains names</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep <span style=color:#e6db74>&#34;string table index&#34;</span>
</span></span><span style=display:flex><span>  Section header string table index: <span style=color:#ae81ff>30</span>
</span></span></code></pre></div><p>Step 2: Section #30 is a string table (.shstrtab)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Offset 0:    <span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 1:    .symtab<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 9:    .strtab<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 17:   .text<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 23:   .data<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Step 3: Each section&rsquo;s sh_name is an offset into this table</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Section <span style=color:#75715e>#1: sh_name = 1  → &#34;.symtab&#34;</span>
</span></span><span style=display:flex><span>Section <span style=color:#75715e>#2: sh_name = 9  → &#34;.strtab&#34;</span>
</span></span><span style=display:flex><span>Section <span style=color:#75715e>#3: sh_name = 17 → &#34;.text&#34;</span>
</span></span></code></pre></div><p><strong>ELF String Tables</strong></p><p>In ELF, strings are stored in dedicated tables rather than repeated everywhere. This design keeps the binary compact and makes parsing easier. There are two main types of string tables:</p><p><strong>1. Section Header String Table (.shstrtab)</strong></p><p><code>.shstrtab</code> is also a type of section, it holds the names of other sections, other sections just refer to the index from this table</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .shstrtab
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>28<span style=color:#f92672>]</span> .shstrtab         STRTAB           <span style=color:#ae81ff>0000000000000000</span>  0000303b
</span></span></code></pre></div><p>It means 28th index of section header table is section header string table. ELF header&rsquo;s <code>e_shstrndx</code> also indicates same</p><p>We can inspect the contents of <code>.shstrtab</code> by</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -p .shstrtab main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>String dump of section <span style=color:#e6db74>&#39;.shstrtab&#39;</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>     1<span style=color:#f92672>]</span>  .shstrtab
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>     b<span style=color:#f92672>]</span>  .interp
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    13<span style=color:#f92672>]</span>  .note.gnu.property
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    26<span style=color:#f92672>]</span>  .note.gnu.build-id
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    39<span style=color:#f92672>]</span>  .note.ABI-tag
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    47<span style=color:#f92672>]</span>  .gnu.hash
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    51<span style=color:#f92672>]</span>  .dynsym
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    59<span style=color:#f92672>]</span>  .dynstr
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    61<span style=color:#f92672>]</span>  .gnu.version
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    6e<span style=color:#f92672>]</span>  .gnu.version_r
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    7d<span style=color:#f92672>]</span>  .rela.dyn
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    87<span style=color:#f92672>]</span>  .rela.plt
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    91<span style=color:#f92672>]</span>  .init
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    97<span style=color:#f92672>]</span>  .plt.got
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    a0<span style=color:#f92672>]</span>  .plt.sec
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    a9<span style=color:#f92672>]</span>  .text
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    af<span style=color:#f92672>]</span>  .fini
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    b5<span style=color:#f92672>]</span>  .rodata
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    bd<span style=color:#f92672>]</span>  .eh_frame_hdr
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    cb<span style=color:#f92672>]</span>  .eh_frame
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    d5<span style=color:#f92672>]</span>  .init_array
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    e1<span style=color:#f92672>]</span>  .fini_array
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    ed<span style=color:#f92672>]</span>  .dynamic
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    f6<span style=color:#f92672>]</span>  .data
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    fc<span style=color:#f92672>]</span>  .bss
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>   101<span style=color:#f92672>]</span>  .comment
</span></span></code></pre></div><p><strong>2. Symbol String Table (<code>.strtab</code>)</strong></p><ul><li>Purpose: Stores symbol names used by the linker and debugger.</li><li>Symbols (like function and variable names) in <code>.symtab</code> point to offsets in .strtab.</li><li>This separation of symbols and section names allows the ELF format to handle linking and debugging information efficiently.</li></ul><h4 id=2-sh_type---section-type>2. sh_type - Section Type<a hidden class=anchor aria-hidden=true href=#2-sh_type---section-type>#</a></h4><p>Each section in an ELF file has a type, defined by the <code>sh_type</code> field in its section header.
This tells the linker or loader what kind of data the section holds and how it should be treated.</p><table><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>SHT_NULL</td><td>Inactive section (placeholder)</td></tr><tr><td>1</td><td>SHT_PROGBITS</td><td>Program data (code, data, anything)</td></tr><tr><td>2</td><td>SHT_SYMTAB</td><td>Symbol table (for linking)</td></tr><tr><td>3</td><td>SHT_STRTAB</td><td>String table</td></tr><tr><td>4</td><td>SHT_RELA</td><td>Relocation entries with addends</td></tr><tr><td>5</td><td>SHT_HASH</td><td>Symbol hash table</td></tr><tr><td>6</td><td>SHT_DYNAMIC</td><td>Dynamic linking information</td></tr><tr><td>7</td><td>SHT_NOTE</td><td>Auxiliary information</td></tr><tr><td>8</td><td>SHT_NOBITS</td><td>Section occupies no file space (.bss)</td></tr><tr><td>9</td><td>SHT_REL</td><td>Relocation entries without addends</td></tr><tr><td>11</td><td>SHT_DYNSYM</td><td>Dynamic symbol table</td></tr></tbody></table><h5 id=1-sht_null--inactive-section>1. SHT_NULL — Inactive Section<a hidden class=anchor aria-hidden=true href=#1-sht_null--inactive-section>#</a></h5><p>This is a placeholder entry that marks an unused section header. It has no data and is typically found as the first entry in the section header table (index 0). Every ELF file starts with this null section.</p><h5 id=2-sht_progbits--program-data>2. SHT_PROGBITS — Program Data<a hidden class=anchor aria-hidden=true href=#2-sht_progbits--program-data>#</a></h5><p>This is the most common section type. It holds actual program content — like executable instructions (<code>.text</code>), initialized data (<code>.data</code>), or read-only constants (<code>.rodata</code>). These sections are loaded into memory when the program runs.</p><h5 id=3-sht_symtab--symbol-table>3. SHT_SYMTAB — Symbol Table<a hidden class=anchor aria-hidden=true href=#3-sht_symtab--symbol-table>#</a></h5><p>Contains a full list of symbols defined or referenced in the program.
This table is mainly used by the linker during relocation and symbol resolution.
Each entry describes a symbol’s name, address, size, and type (function, variable, etc.).
It’s usually found in relocatable (<code>.o</code>) files.</p><h5 id=4-sht_strtab--string-table>4. SHT_STRTAB — String Table<a hidden class=anchor aria-hidden=true href=#4-sht_strtab--string-table>#</a></h5><p>Stores strings used by other sections — for example, section names (.shstrtab) or symbol names (<code>.strtab</code>).
Other sections don’t store names directly; instead, they store an offset into this string table.</p><h5 id=5-sht_rela--relocation-entries-with-addends>5. SHT_RELA — Relocation Entries with Addends<a hidden class=anchor aria-hidden=true href=#5-sht_rela--relocation-entries-with-addends>#</a></h5><p>Holds relocation information that includes explicit addends (extra constant values).
Used by the linker to adjust symbol references when combining multiple object files.
You’ll see this in files targeting architectures like x86-64, where addends are stored in the relocation entry itself.</p><h5 id=6-sht_hash--symbol-hash-table>6. SHT_HASH — Symbol Hash Table<a hidden class=anchor aria-hidden=true href=#6-sht_hash--symbol-hash-table>#</a></h5><p>Provides a quick way for the dynamic linker to find symbols at runtime using a hash lookup.
This section speeds up symbol resolution for shared libraries.</p><h5 id=7-sht_dynamic--dynamic-linking-information>7. SHT_DYNAMIC — Dynamic Linking Information<a hidden class=anchor aria-hidden=true href=#7-sht_dynamic--dynamic-linking-information>#</a></h5><p>Contains metadata needed for dynamic linking — such as shared library names, symbol dependencies, and relocation entries.
This section appears only in dynamically linked executables and shared objects (<code>.so</code> files).</p><h5 id=8-sht_note--auxiliary-information>8. SHT_NOTE — Auxiliary Information<a hidden class=anchor aria-hidden=true href=#8-sht_note--auxiliary-information>#</a></h5><p>Stores extra information such as build IDs, ABI tags, or core dump metadata.
Notes are often used by debuggers or by the kernel when generating core dumps.</p><h5 id=9-sht_nobits--no-file-storage-eg-bss>9. SHT_NOBITS — No File Storage (e.g., <code>.bss</code>)<a hidden class=anchor aria-hidden=true href=#9-sht_nobits--no-file-storage-eg-bss>#</a></h5><p>Represents sections that occupy memory at runtime but take no space in the file.
A classic example is <code>.bss</code>, which holds uninitialized global or static variables.
The loader allocates and zero-initializes it in memory.</p><h5 id=10-sht_rel--relocation-entries-without-addends>10. SHT_REL — Relocation Entries without Addends<a hidden class=anchor aria-hidden=true href=#10-sht_rel--relocation-entries-without-addends>#</a></h5><p>Similar to <code>SHT_RELA</code>, but here addends are stored in the section being relocated, not in the relocation entry.
Used on architectures like x86 (32-bit ELF).</p><h5 id=11-sht_dynsym--dynamic-symbol-table>11. SHT_DYNSYM — Dynamic Symbol Table<a hidden class=anchor aria-hidden=true href=#11-sht_dynsym--dynamic-symbol-table>#</a></h5><p>A smaller, optimized version of the symbol table used at runtime by the dynamic linker.
It lists only the symbols needed for dynamic linking, unlike <code>.symtab</code>, which includes all symbols.</p><h4 id=3-sh_flags---section-flags>3. sh_flags - Section Flags<a hidden class=anchor aria-hidden=true href=#3-sh_flags---section-flags>#</a></h4><p>Attributes of the section:</p><table><thead><tr><th>Flag</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>0x1</td><td>Section is writable at runtime</td></tr><tr><td>SHF_ALLOC</td><td>0x2</td><td>Section occupies memory during execution</td></tr><tr><td>SHF_EXECINSTR</td><td>0x4</td><td>Section contains executable code</td></tr><tr><td>SHF_MERGE</td><td>0x10</td><td>Section may be merged</td></tr><tr><td>SHF_STRINGS</td><td>0x20</td><td>Section contains null-terminated strings</td></tr><tr><td>SHF_TLS</td><td>0x400</td><td>Section contains thread-local data</td></tr></tbody></table><p><strong>Flag combinations tell you about the section:</strong></p><ul><li><code>.text</code>: <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX) - loaded, executable</li><li><code>.data</code>: <code>SHF_WRITE | SHF_ALLOC</code> (WA) - loaded, writable</li><li><code>.rodata</code>: <code>SHF_ALLOC</code> (A) - loaded, read-only</li><li><code>.symtab</code>: No flags - not loaded at runtime!</li></ul><p><strong>Important: SHF_ALLOC flag</strong></p><ul><li>Sections WITH <code>SHF_ALLOC</code> are part of segments (loaded to memory)</li><li>Sections WITHOUT <code>SHF_ALLOC</code> are not loaded (debugging/linking only)</li></ul><h4 id=4-sh_addr---virtual-address>4. sh_addr - Virtual Address<a hidden class=anchor aria-hidden=true href=#4-sh_addr---virtual-address>#</a></h4><p>Virtual memory address where the section appears at runtime.</p><ul><li>For sections with <code>SHF_ALLOC</code>: actual runtime address</li><li>For sections without <code>SHF_ALLOC</code>: usually 0 (not loaded)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>Nr<span style=color:#f92672>]</span> Name      Type      Address          Off    Size   Flg
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> .text     PROGBITS  <span style=color:#ae81ff>0000000000001060</span>  <span style=color:#ae81ff>001060</span> <span style=color:#ae81ff>000185</span> AX
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>24<span style=color:#f92672>]</span> .symtab   SYMTAB    <span style=color:#ae81ff>0000000000000000</span>  002c48 <span style=color:#ae81ff>000690</span>
</span></span></code></pre></div><p><code>.text</code> has address <code>0x1060</code> (will be at this address in memory)
<code>.symtab</code> has address <code>0x0</code> (not loaded, address irrelevant)</p><h4 id=5-sh_offset---file-offset>5. sh_offset - File Offset<a hidden class=anchor aria-hidden=true href=#5-sh_offset---file-offset>#</a></h4><p>Byte offset from the beginning of the file where the section&rsquo;s data starts.
Example: <code>sh_offset = 0x1060</code> means section data begins at byte 4192 in the file.</p><h4 id=6-sh_size---section-size>6. sh_size - Section Size<a hidden class=anchor aria-hidden=true href=#6-sh_size---section-size>#</a></h4><p>Size of the section in bytes.
Special case: For <code>SHT_NOBITS</code> sections (like <code>.bss</code>), this is the size in memory, but there are 0 bytes in the file!</p><h4 id=7-sh_link--linking-one-section-to-another>7. sh_link — Linking One Section to Another<a hidden class=anchor aria-hidden=true href=#7-sh_link--linking-one-section-to-another>#</a></h4><p>The <code>sh_link</code> field in a section header holds a reference (index) to another section in the same ELF file.</p><p>But what it points to depends on the type of the section.</p><p>In other words, the ELF spec reuses <code>sh_link</code> for different purposes depending on the <code>sh_type</code>.</p><p><strong>How sh_link is interpreted</strong></p><table><thead><tr><th>Section Type</th><th><code>sh_link</code> Meaning</th></tr></thead><tbody><tr><td><code>SHT_SYMTAB</code> / <code>SHT_DYNSYM</code></td><td>Index of the <strong>string table</strong> section that holds the names of symbols in this symbol table.</td></tr><tr><td><code>SHT_REL</code> / <code>SHT_RELA</code></td><td>Index of the <strong>symbol table</strong> that the relocation entries refer to.</td></tr><tr><td><code>SHT_DYNAMIC</code></td><td>Index of the <strong>string table</strong> used by entries in the <code>.dynamic</code> section.</td></tr><tr><td><code>SHT_HASH</code></td><td>Index of the <strong>symbol table</strong> to which the hash applies.</td></tr></tbody></table><h4 id=8-sh_info---additional-information>8. sh_info - Additional Information<a hidden class=anchor aria-hidden=true href=#8-sh_info---additional-information>#</a></h4><p>Extra information, meaning depends on section type:</p><table><thead><tr><th>Section Type</th><th>sh_info Meaning</th></tr></thead><tbody><tr><td>SHT_SYMTAB / SHT_DYNSYM</td><td>Index of first non-local symbol</td></tr><tr><td>SHT_REL / SHT_RELA</td><td>Section index to which relocations apply</td></tr></tbody></table><h4 id=9-sh_addralign---alignment>9. sh_addralign - Alignment<a hidden class=anchor aria-hidden=true href=#9-sh_addralign---alignment>#</a></h4><p>Alignment constraint for the section.</p><ul><li>Value must be 0 or power of 2</li><li>0 or 1 means no alignment</li><li><code>sh_addr</code> must be aligned: <code>sh_addr % sh_addralign == 0</code></li></ul><p>Example: <code>sh_addralign = 16</code> means section must start at 16-byte boundary.</p><h4 id=10-sh_entsize---entry-size>10. sh_entsize - Entry Size<a hidden class=anchor aria-hidden=true href=#10-sh_entsize---entry-size>#</a></h4><p>If section contains a table of fixed-size entries, this is the size of each entry.</p><ul><li>For .<code>symtab</code>: size of symbol table entry (24 bytes for 64-bit)</li><li>For .<code>rela.text</code>: size of relocation entry</li><li>For non-table sections: 0</li></ul><p>Calculate number of entries:</p><p><code>num_entries = sh_size / sh_entsize</code></p><h2 id=broad-classifications-of-sections>Broad Classifications of Sections<a hidden class=anchor aria-hidden=true href=#broad-classifications-of-sections>#</a></h2><table><thead><tr><th>Category</th><th>Purpose</th><th>Examples</th></tr></thead><tbody><tr><td><strong>Code</strong></td><td>Executable instructions</td><td><code>.text</code>, <code>.plt</code>, <code>.init</code></td></tr><tr><td><strong>Data</strong></td><td>Program variables</td><td><code>.data</code>, <code>.bss</code>, <code>.rodata</code></td></tr><tr><td><strong>Linking / Loader Metadata</strong></td><td>Linking, relocation, symbol info</td><td><code>.symtab</code>, <code>.rel.*</code>, <code>.dynamic</code>, <code>.got</code></td></tr><tr><td><strong>Debugging / Profiling</strong></td><td>Developer tools</td><td><code>.debug_*</code>, <code>.note.*</code></td></tr><tr><td><strong>Special / Misc</strong></td><td>Constructors, ABI info, interpreter</td><td><code>.init_array</code>, <code>.interp</code></td></tr></tbody></table><h2 id=code-sections>Code Sections<a hidden class=anchor aria-hidden=true href=#code-sections>#</a></h2><h3 id=1-text---executable-code>1. .text - Executable Code<a hidden class=anchor aria-hidden=true href=#1-text---executable-code>#</a></h3><p><strong>Type:</strong> <code>SHT_PROGBITS</code>
<strong>Flags:</strong> <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)
<strong>Contains:</strong> Machine code instructions
This is where your compiled functions live:</p><p>Let&rsquo;s inspect the <code>.text</code> section of a simple C program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>greet</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hello, ELF!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>greet</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -g -O0 -o main main.c
</span></span></code></pre></div><ul><li><code>-g</code>: tells compiler to include debugging symbols in the output: variable names, function names, line numbers, file names, etc.</li><li><code>-O0</code>: optimization level 0 means: No optimization (keeps code structure close to source)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .text
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>16<span style=color:#f92672>]</span> .text             PROGBITS         <span style=color:#ae81ff>0000000000001060</span>  <span style=color:#ae81ff>00001060</span>
</span></span></code></pre></div><p>We can see <code>.text</code> section is at offset 1060 bytes.</p><p>To get the raw dump of <code>.text</code> section:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -s -j .text main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Contents of section .text:
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1060</span> f30f1efa 31ed4989 d15e4889 e24883e4  ....1.I..^H..H..
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1070</span> f0505445 31c031c9 488d3de4 000000ff  .PTE1.1.H.<span style=color:#f92672>=</span>.....
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1080</span> 15532f00 00f4662e 0f1f8400 <span style=color:#ae81ff>00000000</span>  .S/...f.........
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1090</span> 488d3d79 2f000048 8d05722f <span style=color:#ae81ff>00004839</span>  H.<span style=color:#f92672>=</span>y/..H..r/..H9
</span></span><span style=display:flex><span> 10a0 f8741548 8b05362f <span style=color:#ae81ff>00004885</span> c07409ff  .t.H..6/..H..t..
</span></span><span style=display:flex><span> 10b0 e00f1f80 <span style=color:#ae81ff>00000000</span> c30f1f80 <span style=color:#ae81ff>00000000</span>  ................
</span></span><span style=display:flex><span> 10c0 488d3d49 2f000048 8d35422f <span style=color:#ae81ff>00004829</span>  H.<span style=color:#f92672>=</span>I/..H.5B/..H<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 10d0 fe4889f0 48c1ee3f 48c1f803 4801c648  .H..H..?H...H..H
</span></span><span style=display:flex><span> 10e0 d1fe7414 488b0505 2f000048 85c07408  ..t.H.../..H..t.
</span></span><span style=display:flex><span> 10f0 ffe0660f 1f440000 c30f1f80 <span style=color:#ae81ff>00000000</span>  ..f..D..........
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1100</span> f30f1efa 803d052f <span style=color:#ae81ff>00000075</span> 2b554883  .....<span style=color:#f92672>=</span>./...u+UH.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1110</span> 3de22e00 <span style=color:#ae81ff>00004889</span> e5740c48 8b3de62e  <span style=color:#f92672>=</span>.....H..t.H.<span style=color:#f92672>=</span>..
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1120</span> 0000e819 ffffffe8 64ffffff c605dd2e  ........d.......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1130</span> 0000015d c30f1f00 c30f1f80 <span style=color:#ae81ff>00000000</span>  ...<span style=color:#f92672>]</span>............
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1140</span> f30f1efa e977ffff fff30f1e fa554889  .....w.......UH.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1150</span> e5488d05 ac0e0000 4889c7e8 f0feffff  .H......H.......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1160</span> 905dc3f3 0f1efa55 4889e5b8 <span style=color:#ae81ff>00000000</span>  .<span style=color:#f92672>]</span>.....UH.......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1170</span> e8d4ffff ffb80000 00005dc3           ..........<span style=color:#f92672>]</span>.
</span></span></code></pre></div><p>(main refers to file name in above command, not the main function)</p><p>To get the disassembled output of <code>.text</code> section:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$  objdump -d -j .text main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001060</span> &lt;_start&gt;:
</span></span><span style=display:flex><span>   1060:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1064:	<span style=color:#ae81ff>31</span> ed                	xor    %ebp,%ebp
</span></span><span style=display:flex><span>   1066:	<span style=color:#ae81ff>49</span> <span style=color:#ae81ff>89</span> d1             	mov    %rdx,%r9
</span></span><span style=display:flex><span>   1069:	5e                   	pop    %rsi
</span></span><span style=display:flex><span>   106a:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e2             	mov    %rsp,%rdx
</span></span><span style=display:flex><span>   106d:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> e4 f0          	and    $0xfffffffffffffff0,%rsp
</span></span><span style=display:flex><span>   1071:	<span style=color:#ae81ff>50</span>                   	push   %rax
</span></span><span style=display:flex><span>   1072:	<span style=color:#ae81ff>54</span>                   	push   %rsp
</span></span><span style=display:flex><span>   1073:	<span style=color:#ae81ff>45</span> <span style=color:#ae81ff>31</span> c0             	xor    %r8d,%r8d
</span></span><span style=display:flex><span>   1076:	<span style=color:#ae81ff>31</span> c9                	xor    %ecx,%ecx
</span></span><span style=display:flex><span>   1078:	<span style=color:#ae81ff>48</span> 8d 3d e4 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0xe4<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 1163 &lt;main&gt;</span>
</span></span><span style=display:flex><span>   107f:	ff <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>53</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	call   *0x2f53<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;</span>
</span></span><span style=display:flex><span>   1085:	f4                   	hlt
</span></span><span style=display:flex><span>   1086:	<span style=color:#ae81ff>66</span> 2e 0f 1f <span style=color:#ae81ff>84</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cs nopw 0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   108d:	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001090</span> &lt;deregister_tm_clones&gt;:
</span></span><span style=display:flex><span>   1090:	<span style=color:#ae81ff>48</span> 8d 3d <span style=color:#ae81ff>79</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f79<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   1097:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>72</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f72<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   109e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>39</span> f8             	cmp    %rdi,%rax
</span></span><span style=display:flex><span>   10a1:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>15</span>                	je     10b8 &lt;deregister_tm_clones+0x28&gt;
</span></span><span style=display:flex><span>   10a3:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>36</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    0x2f36<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 3fe0 &lt;_ITM_deregisterTMCloneTable@Base&gt;</span>
</span></span><span style=display:flex><span>   10aa:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>85</span> c0             	test   %rax,%rax
</span></span><span style=display:flex><span>   10ad:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>09</span>                	je     10b8 &lt;deregister_tm_clones+0x28&gt;
</span></span><span style=display:flex><span>   10af:	ff e0                	jmp    *%rax
</span></span><span style=display:flex><span>   10b1:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   10b8:	c3                   	ret
</span></span><span style=display:flex><span>   10b9:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000010c0 &lt;register_tm_clones&gt;:
</span></span><span style=display:flex><span>   10c0:	<span style=color:#ae81ff>48</span> 8d 3d <span style=color:#ae81ff>49</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f49<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   10c7:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>35</span> <span style=color:#ae81ff>42</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f42<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rsi        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   10ce:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>29</span> fe             	sub    %rdi,%rsi
</span></span><span style=display:flex><span>   10d1:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> f0             	mov    %rsi,%rax
</span></span><span style=display:flex><span>   10d4:	<span style=color:#ae81ff>48</span> c1 ee 3f          	shr    $0x3f,%rsi
</span></span><span style=display:flex><span>   10d8:	<span style=color:#ae81ff>48</span> c1 f8 <span style=color:#ae81ff>03</span>          	sar    $0x3,%rax
</span></span><span style=display:flex><span>   10dc:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>01</span> c6             	add    %rax,%rsi
</span></span><span style=display:flex><span>   10df:	<span style=color:#ae81ff>48</span> d1 fe             	sar    $1,%rsi
</span></span><span style=display:flex><span>   10e2:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>14</span>                	je     10f8 &lt;register_tm_clones+0x38&gt;
</span></span><span style=display:flex><span>   10e4:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>05</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    0x2f05<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 3ff0 &lt;_ITM_registerTMCloneTable@Base&gt;</span>
</span></span><span style=display:flex><span>   10eb:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>85</span> c0             	test   %rax,%rax
</span></span><span style=display:flex><span>   10ee:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>08</span>                	je     10f8 &lt;register_tm_clones+0x38&gt;
</span></span><span style=display:flex><span>   10f0:	ff e0                	jmp    *%rax
</span></span><span style=display:flex><span>   10f2:	<span style=color:#ae81ff>66</span> 0f 1f <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	nopw   0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   10f8:	c3                   	ret
</span></span><span style=display:flex><span>   10f9:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001100</span> &lt;__do_global_dtors_aux&gt;:
</span></span><span style=display:flex><span>   1100:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1104:	<span style=color:#ae81ff>80</span> 3d <span style=color:#ae81ff>05</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cmpb   $0x0,0x2f05<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   110b:	<span style=color:#ae81ff>75</span> 2b                	jne    <span style=color:#ae81ff>1138</span> &lt;__do_global_dtors_aux+0x38&gt;
</span></span><span style=display:flex><span>   110d:	<span style=color:#ae81ff>55</span>                   	push   %rbp
</span></span><span style=display:flex><span>   110e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> 3d e2 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cmpq   $0x0,0x2ee2<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>   1115:	<span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>   1116:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>   1119:	<span style=color:#ae81ff>74</span> 0c                	je     <span style=color:#ae81ff>1127</span> &lt;__do_global_dtors_aux+0x27&gt;
</span></span><span style=display:flex><span>   111b:	<span style=color:#ae81ff>48</span> 8b 3d e6 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    0x2ee6<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 4008 &lt;__dso_handle&gt;</span>
</span></span><span style=display:flex><span>   1122:	e8 <span style=color:#ae81ff>19</span> ff ff ff       	call   <span style=color:#ae81ff>1040</span> &lt;__cxa_finalize@plt&gt;
</span></span><span style=display:flex><span>   1127:	e8 <span style=color:#ae81ff>64</span> ff ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;deregister_tm_clones&gt;
</span></span><span style=display:flex><span>   112c:	c6 <span style=color:#ae81ff>05</span> dd 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> 	movb   $0x1,0x2edd<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   1133:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>   1134:	c3                   	ret
</span></span><span style=display:flex><span>   1135:	0f 1f <span style=color:#ae81ff>00</span>             	nopl   <span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   1138:	c3                   	ret
</span></span><span style=display:flex><span>   1139:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001140</span> &lt;frame_dummy&gt;:
</span></span><span style=display:flex><span>   1140:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1144:	e9 <span style=color:#ae81ff>77</span> ff ff ff       	jmp    10c0 &lt;register_tm_clones&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001149</span> &lt;greet&gt;:
</span></span><span style=display:flex><span>   1149:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   114d:	<span style=color:#ae81ff>55</span>                   	push   %rbp
</span></span><span style=display:flex><span>   114e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>   1151:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> ac 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0xeac<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 2004 &lt;_IO_stdin_used+0x4&gt;</span>
</span></span><span style=display:flex><span>   1158:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    %rax,%rdi
</span></span><span style=display:flex><span>   115b:	e8 f0 fe ff ff       	call   <span style=color:#ae81ff>1050</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>   1160:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>   1161:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>   1162:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001163</span> &lt;main&gt;:
</span></span><span style=display:flex><span>   1163:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1167:	<span style=color:#ae81ff>55</span>                   	push   %rbp
</span></span><span style=display:flex><span>   1168:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>   116b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    $0x0,%eax
</span></span><span style=display:flex><span>   1170:	e8 d4 ff ff ff       	call   <span style=color:#ae81ff>1149</span> &lt;greet&gt;
</span></span><span style=display:flex><span>   1175:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    $0x0,%eax
</span></span><span style=display:flex><span>   117a:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>   117b:	c3                   	ret
</span></span></code></pre></div><p>It converts raw bytes back to assembly mnemonics.</p><p>Each line in the disassembly follows this pattern:</p><pre tabindex=0><code>ADDRESS: MACHINE_CODE    ASSEMBLY_INSTRUCTION    COMMENTS
</code></pre><p>We can see the <code>_start</code> label is at address 1060, which matches with the start address mentioned in ELF header.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep <span style=color:#e6db74>&#34;Entry point address:&#34;</span>
</span></span><span style=display:flex><span>  Entry point address:               0x1060
</span></span></code></pre></div><p>We can see the definitions of <code>main</code> and <code>greet</code> functions in assembly.</p><p>We can see <code>main()</code> calls <code>greet()</code>
<code>1170: call 1149 &lt;greet></code></p><p><code>greet()</code> calls <code>puts@plt</code>
<code>115b: call 1050 &lt;puts@plt></code></p><p><code>puts@plt</code> is in <code>.plt</code> section (dynamic linking)</p><p><code>greet()</code> references string in <code>.rodata</code>
<code>1151: lea 0xeac(%rip),%rax # Points to 0x2004 in .rodata</code></p><p>(%rip) means RIP-relative addressing. RIP-relative addressing means the address is computed relative to the current instruction pointer.</p><pre tabindex=0><code>effective_address = current_instruction_address + displacement
effective_address = 0x1151 + 0xEAC = 0x2004
</code></pre><p>We can verify that address falls in the range of <code>.rodata</code> section.</p><pre tabindex=0><code> [18] .rodata           PROGBITS         0000000000002000  00002000
       0000000000000010  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002010  00002010
       000000000000003c  0000000000000000   A       0     0     4
</code></pre><p>We can also inspect the <code>.rodata</code> section to confirm it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$  readelf -x .rodata main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hex dump of section <span style=color:#e6db74>&#39;.rodata&#39;</span>:
</span></span><span style=display:flex><span>  0x00002000 <span style=color:#ae81ff>01000200</span> 48656c6c 6f2c2045 4c462100 ....Hello, ELF!.
</span></span></code></pre></div><h3 id=2-plt-procedure-linkage-table>2. .plt (Procedure Linkage Table)<a hidden class=anchor aria-hidden=true href=#2-plt-procedure-linkage-table>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_PROGBITS</code></li><li><strong>Flags:</strong> <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)</li><li><strong>Contains:</strong> Stubs for calling shared library functions</li></ul><p>The Procedure Linkage Table (PLT) is a section in ELF executables and shared libraries that enables lazy binding — meaning, external (shared library) functions like printf, puts, or malloc are resolved only when first called, not when the program starts.</p><p>When your program calls <code>puts("hi");</code>, the compiler doesn’t know where puts actually lives — it’s defined in the C library (<code>libc.so.6</code>). So instead of a direct call, it generates a call to a stub in <code>.plt</code>.
This stub is responsible for eventually reaching the real puts function in memory.</p><p>Despite the name &ldquo;Procedure Linkage Table&rdquo;, the PLT is NOT a table - it&rsquo;s continuous executable code (an array of small code stubs).</p><pre tabindex=0><code>.plt section (executable code):
┌─────────────────────────────────┐
│ PLT[0]: Resolver stub (code)    │  ← 16 bytes of code
├─────────────────────────────────┤
│ PLT[1]: printf stub (code)      │  ← 16 bytes of code
├─────────────────────────────────┤
│ PLT[2]: malloc stub (code)      │  ← 16 bytes of code
├─────────────────────────────────┤
│ PLT[3]: free stub (code)        │  ← 16 bytes of code
└─────────────────────────────────┘
</code></pre><p>Each &ldquo;entry&rdquo; is a small function (code snippet), not a data structure.</p><h4 id=plt-entry-format>PLT Entry &ldquo;Format&rdquo;<a hidden class=anchor aria-hidden=true href=#plt-entry-format>#</a></h4><p>Each PLT entry is 16 bytes of x86-64 assembly:</p><pre tabindex=0><code># Generic PLT entry format (16 bytes):
&lt;function@plt&gt;:
   0: endbr64              # 4 bytes - security feature
   4: jmp    *GOT[n]       # 6 bytes - indirect jump through GOT
  10: push   $index        # 5 bytes - push relocation index
  15: jmp    PLT[0]        # 5 bytes - jump to resolver
  (total: 16 bytes, but padding makes them aligned)
</code></pre><p><strong>Why It&rsquo;s Called a &ldquo;Table&rdquo;</strong></p><p>Historical reasons! It&rsquo;s organized like a table:</p><ul><li><strong>Fixed-size entries</strong> (16 bytes each)</li><li><strong>Array-like access</strong> (PLT[0], PLT[1], PLT[2]&mldr;)</li><li><strong>Indexed by relocation number</strong></li></ul><p>Let&rsquo;s take this C program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Before malloc</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Allocated at: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(ptr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;After free</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can get its <code>.plt</code> by</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -j .plt demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>demo:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .plt:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000401020</span> &lt;.plt&gt;:
</span></span><span style=display:flex><span>  401020:	ff <span style=color:#ae81ff>35</span> ca 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	push   0x2fca<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 403ff0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span>
</span></span><span style=display:flex><span>  401026:	ff <span style=color:#ae81ff>25</span> cc 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	jmp    *0x2fcc<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 403ff8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span>
</span></span><span style=display:flex><span>  40102c:	0f 1f <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>          	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  401030:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  401034:	<span style=color:#ae81ff>68</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	push   $0x0
</span></span><span style=display:flex><span>  401039:	e9 e2 ff ff ff       	jmp    <span style=color:#ae81ff>401020</span> &lt;_init+0x20&gt;
</span></span><span style=display:flex><span>  40103e:	<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>90</span>                	xchg   %ax,%ax
</span></span><span style=display:flex><span>  401040:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  401044:	<span style=color:#ae81ff>68</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	push   $0x1
</span></span><span style=display:flex><span>  401049:	e9 d2 ff ff ff       	jmp    <span style=color:#ae81ff>401020</span> &lt;_init+0x20&gt;
</span></span><span style=display:flex><span>  40104e:	<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>90</span>                	xchg   %ax,%ax
</span></span><span style=display:flex><span>  401050:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  401054:	<span style=color:#ae81ff>68</span> <span style=color:#ae81ff>02</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	push   $0x2
</span></span><span style=display:flex><span>  401059:	e9 c2 ff ff ff       	jmp    <span style=color:#ae81ff>401020</span> &lt;_init+0x20&gt;
</span></span><span style=display:flex><span>  40105e:	<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>90</span>                	xchg   %ax,%ax
</span></span><span style=display:flex><span>  401060:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>  401064:	<span style=color:#ae81ff>68</span> <span style=color:#ae81ff>03</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	push   $0x3
</span></span><span style=display:flex><span>  401069:	e9 b2 ff ff ff       	jmp    <span style=color:#ae81ff>401020</span> &lt;_init+0x20&gt;
</span></span><span style=display:flex><span>  40106e:	<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>90</span>                	xchg   %ax,%ax
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ readelf -r demo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Relocation section <span style=color:#e6db74>&#39;.rela.dyn&#39;</span> at offset 0x518 contains <span style=color:#ae81ff>2</span> entries:
</span></span><span style=display:flex><span>  Offset          Info           Type           Sym. Value    Sym. Name + Addend
</span></span><span style=display:flex><span>000000403fd8  <span style=color:#ae81ff>000200000006</span> R_X86_64_GLOB_DAT <span style=color:#ae81ff>0000000000000000</span> __libc_start_main@GLIBC_2.34 + <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>000000403fe0  <span style=color:#ae81ff>000500000006</span> R_X86_64_GLOB_DAT <span style=color:#ae81ff>0000000000000000</span> __gmon_start__ + <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Relocation section <span style=color:#e6db74>&#39;.rela.plt&#39;</span> at offset 0x548 contains <span style=color:#ae81ff>4</span> entries:
</span></span><span style=display:flex><span>  Offset          Info           Type           Sym. Value    Sym. Name + Addend
</span></span><span style=display:flex><span><span style=color:#ae81ff>000000404000</span>  <span style=color:#ae81ff>000100000007</span> R_X86_64_JUMP_SLO <span style=color:#ae81ff>0000000000000000</span> free@GLIBC_2.2.5 + <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>000000404008</span>  <span style=color:#ae81ff>000300000007</span> R_X86_64_JUMP_SLO <span style=color:#ae81ff>0000000000000000</span> puts@GLIBC_2.2.5 + <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>000000404010</span>  <span style=color:#ae81ff>000400000007</span> R_X86_64_JUMP_SLO <span style=color:#ae81ff>0000000000000000</span> printf@GLIBC_2.2.5 + <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>000000404018</span>  <span style=color:#ae81ff>000600000007</span> R_X86_64_JUMP_SLO <span style=color:#ae81ff>0000000000000000</span> malloc@GLIBC_2.2.5 + <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Let&rsquo;s analyze this output</p><pre tabindex=0><code>PLT[0]: Resolver (0x401020)      ← Common trampoline
PLT[1]: free   (0x401030)        
PLT[2]: puts   (0x401040)     
PLT[3]: printf     (0x401050)
PLT[3]: malloc     (0x401050)     
</code></pre><h4 id=plt0---the-resolver-trampoline-0x401020>PLT[0] - The Resolver Trampoline (0x401020)<a hidden class=anchor aria-hidden=true href=#plt0---the-resolver-trampoline-0x401020>#</a></h4><pre tabindex=0><code>0000000000401020 &lt;.plt&gt;:
  401020: ff 35 ca 2f 00 00    push   0x2fca(%rip)    # 403ff0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
  401026: ff 25 cc 2f 00 00    jmp    *0x2fcc(%rip)   # 403ff8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
  40102c: 0f 1f 40 00          nopl   0x0(%rax)
</code></pre><ol><li><code>push 0x2fca(%rip)</code> → Pushes <code>GOT[1]</code> (link_map structure)</li></ol><ul><li>Address: <code>0x401020 + 6 + 0x2fca = 0x403ff0</code></li><li>This is <code>_GLOBAL_OFFSET_TABLE_+0x8</code> (GOT[1])</li><li>Contains runtime info about loaded libraries</li></ul><ol start=2><li><code>jmp *0x2fcc(%rip)</code> → Jumps to <code>GOT[2]</code> (resolver function)</li></ol><ul><li>Address: <code>0x401026 + 6 + 0x2fcc = 0x403ff8</code></li><li>This is <code>_GLOBAL_OFFSET_TABLE_+0x10</code> (GOT[2])</li><li>Contains address of <code>_dl_runtime_resolve</code> in <code>ld.so</code></li></ul><ol start=3><li><code>nopl</code> → Padding/alignment</li></ol><h4 id=the-subsequent-plt-entries-plt1-plt2-etc>The subsequent PLT entries (PLT1, PLT2, etc.)<a hidden class=anchor aria-hidden=true href=#the-subsequent-plt-entries-plt1-plt2-etc>#</a></h4><p>Example: <code>PLT1</code> (for <code>free</code>):</p><pre tabindex=0><code>401030: f3 0f 1e fa           endbr64
401034: 68 00 00 00 00        push   $0x0
401039: e9 e2 ff ff ff        jmp    401020 &lt;.plt&gt;
</code></pre><p>Breakdown:</p><ul><li><code>endbr64</code> - security</li><li><code>push $0x0</code> — push the function index (here 0 → corresponds to first relocation entry).</li><li><code>jmp 401020</code> — jump back to <code>PLT0</code>, which will now use that index to find the corresponding GOT entry (GOT[3] onwards).</li><li><code>xchg %ax,%ax</code> - Padding (2-byte NOP)</li></ul><p>Now let&rsquo;s track the entre process</p><p>If we disassemble the code, we can see the call to printf jumps to address <code>0x401090</code></p><pre tabindex=0><code>  4011d5:	e8 b6 fe ff ff       	call   401090 &lt;printf@plt&gt;
</code></pre><p>The address <code>0x401090</code> falls inside <code>.plt.sec</code> section. Modern GCC uses .plt.sec (PLT secondary) for Intel CET (Control-flow Enforcement Technology).</p><pre tabindex=0><code>sanketh@sanketh-81de:~/assembly/plt$ objdump -d -j .plt.sec demo

demo:     file format elf64-x86-64


Disassembly of section .plt.sec:

0000000000401070 &lt;free@plt&gt;:
  401070:	f3 0f 1e fa          	endbr64
  401074:	ff 25 86 2f 00 00    	jmp    *0x2f86(%rip)        # 404000 &lt;free@GLIBC_2.2.5&gt;
  40107a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401080 &lt;puts@plt&gt;:
  401080:	f3 0f 1e fa          	endbr64
  401084:	ff 25 7e 2f 00 00    	jmp    *0x2f7e(%rip)        # 404008 &lt;puts@GLIBC_2.2.5&gt;
  40108a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401090 &lt;printf@plt&gt;:
  401090:	f3 0f 1e fa          	endbr64
  401094:	ff 25 76 2f 00 00    	jmp    *0x2f76(%rip)        # 404010 &lt;printf@GLIBC_2.2.5&gt;
  40109a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004010a0 &lt;malloc@plt&gt;:
  4010a0:	f3 0f 1e fa          	endbr64
  4010a4:	ff 25 6e 2f 00 00    	jmp    *0x2f6e(%rip)        # 404018 &lt;malloc@GLIBC_2.2.5&gt;
  4010aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
</code></pre><p>Our binary has <strong>two PLT-related sections:</strong></p><p><strong>1. <code>.plt</code> - Lazy binding resolver stubs</strong></p><pre tabindex=0><code>0x401020: PLT[0] - Common resolver
0x401030: PLT[1] - free resolver stub
0x401040: PLT[2] - puts resolver stub  
0x401050: PLT[3] - printf resolver stub
0x401060: PLT[4] - malloc resolver stub
</code></pre><p><strong>2. <code>.plt.sec</code> - Actual PLT entries (with CET security)</strong></p><pre tabindex=0><code>0x401070: free@plt
0x401080: puts@plt
0x401090: printf@plt  ← Your code calls this!
0x4010a0: malloc@plt
</code></pre><h3 id=3-pltgot>3. .plt.got<a hidden class=anchor aria-hidden=true href=#3-pltgot>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)</li><li><strong>Contains</strong>: PLT entries for GOT references</li></ul><p>The <code>.plt.got</code> section is an extension of the traditional <code>.plt</code>, used primarily in position-independent executables (PIE) and shared libraries.</p><p>When the compiler generates smaller or more optimized PLT entries, it sometimes places them in <code>.plt.got</code> instead of <code>.plt</code>.</p><p>These entries rely more directly on the GOT (Global Offset Table) for function address lookups, reducing the indirection and improving performance slightly.</p><p>You’ll usually see <code>.plt.got</code> in binaries built with:</p><ul><li>GCC’s newer toolchains</li><li>PIE (Position Independent Executable) enabled</li><li>Or with RELRO and lazy binding disabled (<code>-Wl,-z,now</code>)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .plt
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>11<span style=color:#f92672>]</span> .rela.plt         RELA             <span style=color:#ae81ff>0000000000000610</span>  <span style=color:#ae81ff>00000610</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>13<span style=color:#f92672>]</span> .plt              PROGBITS         <span style=color:#ae81ff>0000000000001020</span>  <span style=color:#ae81ff>00001020</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> .plt.got          PROGBITS         <span style=color:#ae81ff>0000000000001040</span>  <span style=color:#ae81ff>00001040</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>15<span style=color:#f92672>]</span> .plt.sec          PROGBITS         <span style=color:#ae81ff>0000000000001050</span>  <span style=color:#ae81ff>00001050</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -j .plt.got main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .plt.got:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001040</span> &lt;__cxa_finalize@plt&gt;:
</span></span><span style=display:flex><span>    1040:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1044:	ff <span style=color:#ae81ff>25</span> ae 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	jmp    *0x2fae<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>    104a:	<span style=color:#ae81ff>66</span> 0f 1f <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	nopw   0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>You’ll find shorter stubs, sometimes just a single indirect jump via the GOT — because by this point, all symbols are already resolved.</p><h3 id=4-pltsec>4. .plt.sec<a hidden class=anchor aria-hidden=true href=#4-pltsec>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_PROGBITS</code></li><li><strong>Flags:</strong> <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)</li><li><strong>Contains:</strong> Secure PLT stubs (used in hardened binaries)</li></ul><p>The <code>.plt.sec</code> section is a <strong>security-enhanced variant</strong> of the traditional <code>.plt</code>.
It’s introduced in <strong>modern toolchains</strong> (GCC ≥ 9, binutils ≥ 2.31) to support <strong>Control Flow Integrity (CFI)</strong> and <strong>Intel’s Indirect Branch Tracking (IBT)</strong> features.</p><p>Each entry in <code>.plt.sec</code> is similar to a normal PLT stub, but with additional instructions or metadata to <strong>prevent malicious redirection of function calls</strong> — protecting against attacks like <strong>Return-Oriented Programming (ROP)</strong> or <strong>GOT overwrite exploits</strong>.</p><p>You’ll usually see <code>.plt.sec</code> when your binary is built with flags like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-fpie -fcf-protection<span style=color:#f92672>=</span>full -O2
</span></span></code></pre></div><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .plt
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>13<span style=color:#f92672>]</span> .plt              PROGBITS         <span style=color:#ae81ff>0000000000001030</span>  <span style=color:#ae81ff>00001030</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> .plt.got          PROGBITS         <span style=color:#ae81ff>0000000000001060</span>  <span style=color:#ae81ff>00001060</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>15<span style=color:#f92672>]</span> .plt.sec          PROGBITS         <span style=color:#ae81ff>0000000000001080</span>  <span style=color:#ae81ff>00001080</span>
</span></span></code></pre></div><p>Disassembly (simplified example):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -j .plt.sec main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .plt.sec:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001050</span> &lt;puts@plt&gt;:
</span></span><span style=display:flex><span>    1050:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1054:	ff <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>76</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	jmp    *0x2f76<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3fd0 &lt;puts@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>    105a:	<span style=color:#ae81ff>66</span> 0f 1f <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	nopw   0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The <code>endbr64</code> instruction (added by GCC for IBT) is used to mark safe entry points for indirect jumps — the CPU validates that control flow only transfers to legitimate call targets.</p><h2 id=data-sections>Data Sections<a hidden class=anchor aria-hidden=true href=#data-sections>#</a></h2><h3 id=1-rodata---read-only-data>1. .rodata - Read-Only Data<a hidden class=anchor aria-hidden=true href=#1-rodata---read-only-data>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_ALLOC</code> (A)</li><li><strong>Contains</strong>: Constants, string literals</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>;  <span style=color:#75715e>// String stored in .rodata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> max <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -x .rodata main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hex dump of section <span style=color:#e6db74>&#39;.rodata&#39;</span>:
</span></span><span style=display:flex><span>  0x00002000 <span style=color:#ae81ff>01000200</span> 48656c6c 6f2c2045 4c462100 ....Hello, ELF!.
</span></span></code></pre></div><p>The <code>.rodata</code> section stores data that should never be modified at runtime.
Typical contents include:</p><ul><li>String literals (&ldquo;Hello, ELF!&rdquo;)</li><li>const variables in C/C++</li><li>Floating-point constants</li><li>Lookup or jump tables generated by the compiler</li></ul><p>Because it’s read-only, this section is usually mapped into memory with read-only permissions (R-) by the OS loader.</p><p>This prevents accidental modification and improves security — if a program tries to modify it, it will trigger a segmentation fault.</p><h3 id=2-data---initialized-data>2. .data - Initialized Data<a hidden class=anchor aria-hidden=true href=#2-data---initialized-data>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains</strong>: Initialized global and static variables</li></ul><p>The <code>.data</code> section stores all read–write variables whose initial values are known at compile time.
These variables are part of the executable image — the compiler embeds their initial values directly into the ELF file.
When the program loads into memory, the loader copies these values into writable memory so your program can modify them at runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> global_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;           <span style=color:#75715e>// Stored in .data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> static_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;   <span style=color:#75715e>// Stored in .data
</span></span></span></code></pre></div><h3 id=3-bss--uninitialized-data>3. .bss — Uninitialized Data<a hidden class=anchor aria-hidden=true href=#3-bss--uninitialized-data>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_NOBITS</code></li><li><strong>Flags:</strong> <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains:</strong> Uninitialized global and static variables (default-initialized to zero)</li></ul><p>The <code>.bss</code> section holds <strong>variables that exist for the lifetime of the program</strong> (global or static), but <strong>don’t have explicit initial values</strong> in your source code.
Unlike <code>.data</code>, this section <strong>does not occupy any space in the ELF file itself</strong> — only the <em>size</em> is recorded.
When the program loads, the OS automatically allocates memory for <code>.bss</code> and <strong>fills it with zeros</strong>.</p><hr><p>Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> global_uninit;          <span style=color:#75715e>// Goes into .bss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> static_uninit;   <span style=color:#75715e>// Goes into .bss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> global_uninit;   <span style=color:#75715e>// Initially 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Inspect:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -o main main.c
</span></span><span style=display:flex><span>$ readelf -S main | grep .bss
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>25<span style=color:#f92672>]</span> .bss              NOBITS           <span style=color:#ae81ff>0000000000004000</span>  <span style=color:#ae81ff>00003010</span>
</span></span></code></pre></div><p>Notice the <strong><code>NOBITS</code></strong> type — that means no bytes are actually stored in the file; only the <em>size</em> (number of bytes required) is recorded.</p><p>If you dump it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -x .bss main
</span></span><span style=display:flex><span>readelf: Warning: Section <span style=color:#e6db74>&#39;.bss&#39;</span> has no data to dump.
</span></span></code></pre></div><p>That’s because <code>.bss</code> doesn’t exist in the binary — it’s just a placeholder for the loader.</p><hr><p><strong>What Happens at Runtime</strong></p><ol><li>The loader allocates memory for <code>.bss</code> variables.</li><li>It initializes all bytes to <strong>zero</strong> (per the C standard).</li><li>The variables behave like normal globals at runtime.</li></ol><h2 id=dynamic-linking-sections>Dynamic Linking Sections<a hidden class=anchor aria-hidden=true href=#dynamic-linking-sections>#</a></h2><h3 id=1-got-global-offset-table>1. .got (Global Offset Table)<a hidden class=anchor aria-hidden=true href=#1-got-global-offset-table>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains</strong>: Holds addresses of global variables and dynamically linked functions used by position-independent code (PIC).</li></ul><p>In Position-Independent Code (PIC) — used in shared libraries and ASLR-enabled executables, the compiler cannot assume any fixed address for globals or external functions. Instead of hardcoding addresses, the code goes through an indirect table of addresses called the Global Offset Table (GOT).</p><p>Each GOT entry holds the actual runtime address of a symbol (variable or function). At runtime, the dynamic linker (<code>ld.so</code>) fills in the correct addresses so that your program can access everything correctly no matter where it’s loaded in memory.</p><h4 id=got-entry-format>GOT Entry Format<a hidden class=anchor aria-hidden=true href=#got-entry-format>#</a></h4><p>The GOT is just a contiguous array of addresses.
Each entry is 8 bytes (on x86-64):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    Elf64_Addr address;   <span style=color:#75715e>// The resolved runtime address of the symbol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} GOTEntry;
</span></span></code></pre></div><p>So effectively:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>.got:
</span></span><span style=display:flex><span>  +0x00 -&gt; address of _DYNAMIC
</span></span><span style=display:flex><span>  +0x08 -&gt; address of __libc_start_main
</span></span><span style=display:flex><span>  +0x10 -&gt; address of puts
</span></span><span style=display:flex><span>  ...
</span></span></code></pre></div><p>But logically we can think of GOT as</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>| Symbol              | GOT Entry <span style=color:#f92672>(</span>before relocation<span style=color:#f92672>)</span> | GOT Entry <span style=color:#f92672>(</span>after relocation<span style=color:#f92672>)</span> |
</span></span><span style=display:flex><span>| ------------------- | ----------------------------- | ---------------------------- |
</span></span><span style=display:flex><span>| <span style=color:#e6db74>`</span>puts@GLIBC_2.2.5<span style=color:#e6db74>`</span>  | 0x0000000000000000            | 0x00007ffff7e2e6b0           |
</span></span><span style=display:flex><span>| <span style=color:#e6db74>`</span>__libc_start_main<span style=color:#e6db74>`</span> | 0x0000000000000000            | 0x00007ffff7e1e170           |
</span></span><span style=display:flex><span>| <span style=color:#e6db74>`</span>global_var<span style=color:#e6db74>`</span>        | 0x0000000000000000            | 0x0000555555556020           |
</span></span></code></pre></div><p><strong>If GOT is just a list of addresses, then how does linker know which address maps to which symbol?</strong></p><p>The relocation entries map GOT addresses to symbols.</p><p>Each relocation entry says:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Offset: 0x3fc0          ← GOT entry address
</span></span><span style=display:flex><span>Symbol: malloc          ← What symbol this entry is <span style=color:#66d9ef>for</span>
</span></span><span style=display:flex><span>Type: R_X86_64_JUMP_SLOT
</span></span></code></pre></div><p>So the dynamic linker knows: &ldquo;GOT entry at address 0x3fc0 should contain the address of malloc&rdquo;</p><p>We will dive deep into relocations in later parts.</p><h4 id=how-the-got-gets-filled>How the GOT Gets Filled?<a hidden class=anchor aria-hidden=true href=#how-the-got-gets-filled>#</a></h4><ol><li><strong>Compiler phase:</strong> Generates code with placeholders referring to GOT offsets.</li><li><strong>Linker phase (<code>ld</code>):</strong> Emits relocation entries:<ul><li><code>.rela.dyn</code> → global variables and data symbols</li><li><code>.rela.plt</code> → functions called through the PLT</li></ul></li><li><strong>Runtime (<code>ld.so</code>):</strong> When the program loads:<ul><li>Reads relocations from <code>.rela.dyn</code> and <code>.rela.plt</code></li><li>Writes real addresses into <code>.got</code> and <code>.got.plt</code> entries</li></ul></li></ol><h3 id=2-gotplt--global-offset-table-for-plt>2. .got.plt — Global Offset Table for PLT<a hidden class=anchor aria-hidden=true href=#2-gotplt--global-offset-table-for-plt>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_PROGBITS</code></li><li><strong>Flags:</strong> <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains:</strong> Addresses of dynamically linked functions used by the PLT</li></ul><p>The <code>.got.plt</code> section is a special part of the <strong>Global Offset Table (GOT)</strong> that works hand-in-hand with the <strong>Procedure Linkage Table (PLT)</strong>. When the linker creates a PLT (Procedure Linkage Table), it also allocates a small .got.plt table alongside it.</p><p>When your program calls an external function (like <code>puts</code>, <code>printf</code>, or <code>malloc</code>), it doesn’t know their real addresses at compile time. Instead, it goes through a small trampoline in <code>.plt</code>, which uses the <code>.got.plt</code> entries to eventually reach the actual function in the shared library.</p><p><strong>How It Works</strong></p><ul><li>Each entry in <code>.got.plt</code> holds the <strong>runtime-resolved address</strong> of an external function.</li><li>Initially, these entries point to the <strong>PLT stubs</strong> (so the dynamic linker can intercept the first call).</li><li>After the function is resolved, the dynamic linker <strong>updates the GOT entry</strong> with the real function address — so the next call goes directly there.</li></ul><p>This mechanism enables <strong>lazy binding</strong> — external symbols are resolved only when first used, improving startup performance.</p><p>The first 3 entries in <code>.got.plt</code> are reserved for the dynamic linker’s internal use:</p><table><thead><tr><th>GOT Entry</th><th>Initially Contains</th><th>Purpose / Explanation</th></tr></thead><tbody><tr><td><strong>GOT[0]</strong></td><td>Address of <code>_DYNAMIC</code> section</td><td>Points to the <code>.dynamic</code> section of the current ELF object. This section holds metadata like needed shared libraries, symbol tables, relocation info, etc. The dynamic linker uses this to locate all dynamic linking data for the object being relocated.</td></tr><tr><td><strong>GOT[1]</strong></td><td>Address of the <code>link_map</code> structure (set at runtime by <code>ld.so</code>)</td><td>Each loaded shared object (executable or <code>.so</code>) has a <code>link_map</code> entry describing it — base address, name, dependencies, relocation tables, etc. The dynamic linker uses GOT[1] to know <em>which object’s context</em> it’s resolving symbols for when a lazy PLT call happens.</td></tr><tr><td><strong>GOT[2]</strong></td><td>Address of <code>dl_runtime_resolve</code> (or <code>dl_runtime_resolve_xsave</code> on x86_64)</td><td>This is the resolver function inside <code>ld.so</code>. When a function call through the PLT occurs for the first time, control jumps through PLT[0], which uses GOT[2] to call the resolver. The resolver looks up the symbol, fixes the GOT entry for future calls, and finally jumps to the actual function.</td></tr></tbody></table><p>After these 3, the remaining GOT entries in <code>.got.plt</code> correspond to function symbols (e.g. <code>printf</code>, <code>malloc</code>, etc.), one per PLT entry.</p><h4 id=how-theyre-used-during-lazy-binding>How they’re used during lazy binding<a hidden class=anchor aria-hidden=true href=#how-theyre-used-during-lazy-binding>#</a></h4><p>When a program calls a function (say <code>printf</code>) for the first time:</p><ol><li>The call goes through the <strong>PLT</strong> (Procedure Linkage Table).</li><li>The first PLT entry (<code>PLT[0]</code>) is special — it sets up a call like this (simplified):<pre tabindex=0><code>jmp *GOT[2]          # Jump to the dynamic resolver (ld.so)
pushq $reloc_index   # Index of the relocation to resolve
jmp *GOT[1]          # Linker uses link_map + reloc_index
</code></pre></li><li>The resolver (<code>dl_runtime_resolve</code>) uses:</li></ol><ul><li><strong>GOT[1]</strong> → to find the <code>link_map</code> of the current object</li><li><strong>GOT[0]</strong> → to access <code>_DYNAMIC</code> metadata if needed</li></ul><ol start=4><li>It then patches the GOT entry for <code>printf</code> with its actual address.</li><li>Future calls to <code>printf</code> jump directly to the resolved address — no more resolver overhead.</li></ol><h3 id=3-dynamic>3. .dynamic<a hidden class=anchor aria-hidden=true href=#3-dynamic>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_DYNAMIC</code></li><li><strong>Flags</strong>: <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains</strong>: Dynamic linking information</li></ul><p>When you compile a dynamically linked program (default in Linux), the compiler embeds a <code>.dynamic</code> section in your binary.
This section acts as a directory of pointers and configuration values that tell the dynamic linker:</p><p>Array of <code>Elf64_Dyn</code> structures containing tags like:</p><ul><li><code>DT_NEEDED</code>: Required shared libraries</li><li><code>DT_SYMTAB</code>: Address of symbol table</li><li><code>DT_STRTAB</code>: Address of string table</li><li><code>DT_RELA</code>: Address of relocation table</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>$ readelf -d main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Dynamic section at offset 0x2dc8 contains <span style=color:#ae81ff>27</span> entries:
</span></span><span style=display:flex><span>  Tag        Type                         Name/Value
</span></span><span style=display:flex><span> 0x0000000000000001 <span style=color:#f92672>(</span>NEEDED<span style=color:#f92672>)</span>             Shared library: <span style=color:#f92672>[</span>libc.so.6<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span> 0x000000000000000c <span style=color:#f92672>(</span>INIT<span style=color:#f92672>)</span>               0x1000
</span></span><span style=display:flex><span> 0x000000000000000d <span style=color:#f92672>(</span>FINI<span style=color:#f92672>)</span>               0x117c
</span></span><span style=display:flex><span> 0x0000000000000019 <span style=color:#f92672>(</span>INIT_ARRAY<span style=color:#f92672>)</span>         0x3db8
</span></span><span style=display:flex><span> 0x000000000000001b <span style=color:#f92672>(</span>INIT_ARRAYSZ<span style=color:#f92672>)</span>       <span style=color:#ae81ff>8</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x000000000000001a <span style=color:#f92672>(</span>FINI_ARRAY<span style=color:#f92672>)</span>         0x3dc0
</span></span><span style=display:flex><span> 0x000000000000001c <span style=color:#f92672>(</span>FINI_ARRAYSZ<span style=color:#f92672>)</span>       <span style=color:#ae81ff>8</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x000000006ffffef5 <span style=color:#f92672>(</span>GNU_HASH<span style=color:#f92672>)</span>           0x3b0
</span></span><span style=display:flex><span> 0x0000000000000005 <span style=color:#f92672>(</span>STRTAB<span style=color:#f92672>)</span>             0x480
</span></span><span style=display:flex><span> 0x0000000000000006 <span style=color:#f92672>(</span>SYMTAB<span style=color:#f92672>)</span>             0x3d8
</span></span><span style=display:flex><span> 0x000000000000000a <span style=color:#f92672>(</span>STRSZ<span style=color:#f92672>)</span>              <span style=color:#ae81ff>141</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x000000000000000b <span style=color:#f92672>(</span>SYMENT<span style=color:#f92672>)</span>             <span style=color:#ae81ff>24</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x0000000000000015 <span style=color:#f92672>(</span>DEBUG<span style=color:#f92672>)</span>              0x0
</span></span><span style=display:flex><span> 0x0000000000000003 <span style=color:#f92672>(</span>PLTGOT<span style=color:#f92672>)</span>             0x3fb8
</span></span><span style=display:flex><span> 0x0000000000000002 <span style=color:#f92672>(</span>PLTRELSZ<span style=color:#f92672>)</span>           <span style=color:#ae81ff>24</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x0000000000000014 <span style=color:#f92672>(</span>PLTREL<span style=color:#f92672>)</span>             RELA
</span></span><span style=display:flex><span> 0x0000000000000017 <span style=color:#f92672>(</span>JMPREL<span style=color:#f92672>)</span>             0x610
</span></span><span style=display:flex><span> 0x0000000000000007 <span style=color:#f92672>(</span>RELA<span style=color:#f92672>)</span>               0x550
</span></span><span style=display:flex><span> 0x0000000000000008 <span style=color:#f92672>(</span>RELASZ<span style=color:#f92672>)</span>             <span style=color:#ae81ff>192</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x0000000000000009 <span style=color:#f92672>(</span>RELAENT<span style=color:#f92672>)</span>            <span style=color:#ae81ff>24</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 0x000000000000001e <span style=color:#f92672>(</span>FLAGS<span style=color:#f92672>)</span>              BIND_NOW
</span></span><span style=display:flex><span> 0x000000006ffffffb <span style=color:#f92672>(</span>FLAGS_1<span style=color:#f92672>)</span>            Flags: NOW PIE
</span></span><span style=display:flex><span> 0x000000006ffffffe <span style=color:#f92672>(</span>VERNEED<span style=color:#f92672>)</span>            0x520
</span></span><span style=display:flex><span> 0x000000006fffffff <span style=color:#f92672>(</span>VERNEEDNUM<span style=color:#f92672>)</span>         <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> 0x000000006ffffff0 <span style=color:#f92672>(</span>VERSYM<span style=color:#f92672>)</span>             0x50e
</span></span><span style=display:flex><span> 0x000000006ffffff9 <span style=color:#f92672>(</span>RELACOUNT<span style=color:#f92672>)</span>          <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span> 0x0000000000000000 <span style=color:#f92672>(</span>NULL<span style=color:#f92672>)</span>               0x0
</span></span></code></pre></div><p>At runtime, the loader (<code>ld-linux.so</code>) reads these entries to correctly link your program with shared libraries before it starts executing <code>main()</code>.</p><h2 id=symbol-and-string-tables>Symbol and String Tables<a hidden class=anchor aria-hidden=true href=#symbol-and-string-tables>#</a></h2><h3 id=1-symtab---symbol-table>1. .symtab - Symbol Table<a hidden class=anchor aria-hidden=true href=#1-symtab---symbol-table>#</a></h3><ul><li>Type: <code>SHT_SYMTAB</code></li><li>Flags: None (not loaded)</li><li>Contains: All symbols (functions, global/static variables) used for linking and debugging</li></ul><p>The <code>.symtab</code> section holds a table of symbols that represent every significant entity in your program — functions, variables, and sections.</p><p>Each entry is an <code>Elf64_Sym</code> structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  Elf64_Word    st_name;   <span style=color:#75715e>// Symbol name (string table offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> st_info;   <span style=color:#75715e>// Type and binding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> st_other;  <span style=color:#75715e>// Visibility
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Half    st_shndx;  <span style=color:#75715e>// Section index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Addr    st_value;  <span style=color:#75715e>// Symbol value (address)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword   st_size;   <span style=color:#75715e>// Symbol size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Elf64_Sym;
</span></span></code></pre></div><p><strong>How it’s used</strong></p><ul><li>The linker uses <code>.symtab</code> to match symbol definitions (e.g., <code>int x</code>;) with their references (e.g., <code>extern int x</code>;) across multiple object files.</li><li>Each symbol name in <code>.symtab</code> corresponds to an offset in the <code>.strtab</code> (string table) section, where actual names are stored.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -s main | head
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Symbol table <span style=color:#e6db74>&#39;.dynsym&#39;</span> contains <span style=color:#ae81ff>7</span> entries:
</span></span><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>     0: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> NOTYPE  LOCAL  DEFAULT  UND
</span></span><span style=display:flex><span>     1: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> FUNC    GLOBAL DEFAULT  UND _<span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>@GLIBC_2.34 <span style=color:#f92672>(</span>2<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>     2: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT<span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>     3: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 <span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>     4: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__
</span></span><span style=display:flex><span>     5: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC<span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>     6: <span style=color:#ae81ff>0000000000000000</span>     <span style=color:#ae81ff>0</span> FUNC    WEAK   DEFAULT  UND <span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>@GLIBC_2.2.5 <span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>
</span></span></code></pre></div><p><strong>Interpretation:</strong></p><ul><li><strong>Type</strong>: Describes what the symbol is (FUNC, OBJECT, etc.)</li><li><strong>Bind</strong>: Whether it’s LOCAL (visible only in file) or GLOBAL (visible to linker)</li><li><strong>Ndx</strong>: Section index where the symbol is defined (e.g., .text, .data)</li><li><strong>Value</strong>: Its address (if defined)</li><li><strong>Name</strong>: Symbol name (resolved from .strtab)</li></ul><p>Here’s the detailed explanation for <strong><code>.strtab</code> (String Table)</strong>:</p><h3 id=2-strtab--string-table>2. .strtab – String Table<a hidden class=anchor aria-hidden=true href=#2-strtab--string-table>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_STRTAB</code></li><li><strong>Flags</strong>: <em>(none)</em> (not loaded into memory)</li><li><strong>Contains</strong>: Null-terminated strings used by other sections like <code>.symtab</code> and relocation entries.</li></ul><p>Each symbol in <code>.symtab</code> doesn’t store its name directly — instead, the <code>st_name</code> field holds an <strong>offset</strong> into <code>.strtab</code>, where the actual string (symbol name) is stored.</p><p>Example</p><p>Suppose you have these symbols:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> var;
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>() {}
</span></span></code></pre></div><p>The <code>.symtab</code> entries might look like this:</p><table><thead><tr><th>Symbol</th><th>st_name (offset)</th><th>st_value</th><th>&mldr;</th></tr></thead><tbody><tr><td>var</td><td>0x00</td><td>0x601000</td><td>&mldr;</td></tr><tr><td>func</td><td>0x04</td><td>0x401020</td><td>&mldr;</td></tr></tbody></table><p>And the <code>.strtab</code> will actually contain:</p><pre tabindex=0><code>0x00: &#34;var\0func\0&#34;
</code></pre><p>Notes</p><ul><li><code>.strtab</code> appears <strong>alongside <code>.symtab</code></strong>, used mainly by the <strong>linker and debugger</strong>, not at runtime.</li><li>It’s <strong>not loaded into memory</strong> (unlike <code>.rodata</code> or <code>.data</code>).</li><li>There’s often also a <strong><code>.shstrtab</code></strong> — the <em>section header string table</em>, which stores <strong>section names</strong> (like <code>.text</code>, <code>.data</code>, <code>.bss</code>).</li></ul><h3 id=3-dynstr--dynamic-string-table>3. .dynstr – Dynamic String Table<a hidden class=anchor aria-hidden=true href=#3-dynstr--dynamic-string-table>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_STRTAB</code></li><li><strong>Flags</strong>: <code>SHF_ALLOC</code> (A) — loaded into memory</li><li><strong>Contains</strong>: Null-terminated strings used <strong>by dynamic linking sections</strong> such as <code>.dynsym</code>, <code>.rela.plt</code>, and <code>.dynamic</code>.</li></ul><p><strong>Purpose</strong></p><p><code>.dynstr</code> serves the same purpose as <code>.strtab</code>, but only for <strong>symbols needed at runtime</strong> — i.e., dynamic symbols that the loader (<code>ld.so</code>) must resolve when the program is loaded.</p><p><strong>Example</strong></p><p>If your program uses shared libraries like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hi&#34;</span>);
</span></span></code></pre></div><p>Then the <strong>dynamic symbol table (<code>.dynsym</code>)</strong> will contain an entry for <code>printf</code>,
and its <code>st_name</code> field will point to an offset inside <code>.dynstr</code>:</p><table><thead><tr><th>Symbol</th><th>st_name (offset)</th><th>st_value</th><th>&mldr;</th></tr></thead><tbody><tr><td>printf</td><td>0x00</td><td>0x0000</td><td>&mldr;</td></tr></tbody></table><p>And <code>.dynstr</code> will contain:</p><pre tabindex=0><code>0x00: &#34;printf\0libc.so.6\0&#34;
</code></pre><p>Comparison</p><table><thead><tr><th>Section</th><th>Used By</th><th>Loaded?</th><th>Contains</th><th>Purpose</th></tr></thead><tbody><tr><td><code>.strtab</code></td><td>Linker / Debugger</td><td>❌</td><td>All symbols</td><td>For static linking and debugging</td></tr><tr><td><code>.dynstr</code></td><td>Runtime linker (<code>ld.so</code>)</td><td>✅</td><td>Dynamic symbols</td><td>For dynamic linking</td></tr></tbody></table><h2 id=relocations>Relocations<a hidden class=anchor aria-hidden=true href=#relocations>#</a></h2><p>Relocation sections follow the pattern:<code> .rela.&lt;target_section></code> or <code>.rel.&lt;target_section></code></p><p>Each <code>.rela.*</code> section contains relocations that need to be applied to a specific target section. However, relocations serve different purposes depending on when and how they&rsquo;re resolved.</p><p><strong>Why do we need them?</strong></p><p>When compiling a single <code>.o</code> file, the compiler doesn&rsquo;t know:</p><ul><li>Where other functions will be located (like <code>printf</code>, <code>helper_function</code>)</li><li>Where data from other files will be</li><li>What the final memory layout will be after linking</li><li>Where the code itself will be loaded in memory</li></ul><p>So the compiler:</p><ol><li>Puts placeholder values (usually zeros) in the machine code</li><li>Creates relocation entries that tell the linker how to fix these placeholders</li></ol><h3 id=anatomy-of-a-relocation-entry>Anatomy of a relocation entry<a hidden class=anchor aria-hidden=true href=#anatomy-of-a-relocation-entry>#</a></h3><p>Each entry has these fields:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Offset: 0x000000002f
</span></span><span style=display:flex><span>Info: <span style=color:#ae81ff>000600000004</span>
</span></span><span style=display:flex><span>Type: R_X86_64_PLT32
</span></span><span style=display:flex><span>Sym. Value: <span style=color:#ae81ff>0000000000000000</span>
</span></span><span style=display:flex><span>Sym. Name: add_numbers
</span></span><span style=display:flex><span>Addend: -4
</span></span></code></pre></div><p><strong>1. Offset</strong></p><ul><li><strong>Where</strong> in the target section to apply the patch</li><li>For <code>.rela.text</code>: offset within <code>.text</code> section</li><li>This is the location of the placeholder bytes</li></ul><p><strong>2. Type</strong></p><ul><li><strong>How</strong> to calculate the patch value</li><li>Different types = different formulas</li></ul><p>Common types</p><table><thead><tr><th>Relocation</th><th>Description</th><th>Typical Use</th></tr></thead><tbody><tr><td><code>R_X86_64_64</code></td><td>Absolute 64-bit address</td><td>Global/static data, function pointers</td></tr><tr><td><code>R_X86_64_PC32</code></td><td>32-bit PC-relative address</td><td>References to globals or functions (when in same module)</td></tr><tr><td><code>R_X86_64_PLT32</code></td><td>32-bit PC-relative address to PLT entry</td><td>Function calls to external symbols</td></tr><tr><td><code>R_X86_64_GOT32</code></td><td>32-bit offset to GOT entry</td><td>Access via GOT (rare now, replaced by <code>GOTPCREL</code>)</td></tr><tr><td><code>R_X86_64_GOTPCREL</code></td><td>32-bit PC-relative offset to GOT entry</td><td>Access to globals through GOT (PIC/PIE code)</td></tr><tr><td><code>R_X86_64_GLOB_DAT</code></td><td>Set GOT entry to absolute address</td><td>Used in dynamic linking (e.g. for globals)</td></tr><tr><td><code>R_X86_64_JUMP_SLOT</code></td><td>Set PLT entry to function address</td><td>Used by dynamic linker for function calls</td></tr><tr><td><code>R_X86_64_RELATIVE</code></td><td>Adjust by base address</td><td>Used by dynamic loader for position-independent executables</td></tr><tr><td><code>R_X86_64_COPY</code></td><td>Copy data from shared object</td><td>Used for global variables defined in executable and shared in libraries</td></tr></tbody></table><p><strong>3. Symbol Name</strong></p><ul><li><strong>What</strong> symbol this relocation refers to</li><li>Could be a function name, section name, or variable name</li><li>Linker looks up where this symbol ended up</li></ul><p><strong>4. Addend</strong></p><ul><li><strong>Extra offset</strong> to add to the calculation</li><li>Often <code>-4</code> for PC-relative calls (compensates for instruction size)</li></ul><p><strong>5. Info</strong> (encoded field)</p><ul><li>Contains both the symbol table index and type</li><li>You usually ignore this - <code>readelf</code> decodes it for you</li></ul><h3 id=relocation-categories>Relocation Categories<a hidden class=anchor aria-hidden=true href=#relocation-categories>#</a></h3><h4 id=1-staticlink-time-relocations>1. Static/Link-Time Relocations<a hidden class=anchor aria-hidden=true href=#1-staticlink-time-relocations>#</a></h4><p>Resolved by the static linker (<code>ld</code>) when creating the executable.</p><p>These appear in <code>.o</code> (object) files and are resolved during the linking phase. Once linking is complete, these sections are removed from the final executable.</p><table><thead><tr><th>Relocation Section</th><th>Applies To</th><th>Contains Relocations For</th><th>When Resolved</th></tr></thead><tbody><tr><td><code>.rela.text</code></td><td><code>.text</code> section</td><td>Function calls, data references in code</td><td>Link time</td></tr><tr><td><code>.rela.data</code></td><td><code>.data</code> section</td><td>Pointers in initialized global variables</td><td>Link time</td></tr><tr><td><code>.rela.rodata</code></td><td><code>.rodata</code> section</td><td>Pointers in constant data (e.g., string arrays)</td><td>Link time</td></tr><tr><td><code>.rela.eh_frame</code></td><td><code>.eh_frame</code> section</td><td>Exception handling metadata, stack unwinding</td><td>Link time</td></tr><tr><td><code>.rela.init_array</code></td><td><code>.init_array</code> section</td><td>Constructor function pointers</td><td>Link time</td></tr><tr><td><code>.rela.fini_array</code></td><td><code>.fini_array</code> section</td><td>Destructor function pointers</td><td>Link time</td></tr></tbody></table><p><strong>What happens:</strong></p><ul><li>Compiler creates these when generating <code>.o</code> files</li><li>Static linker (<code>ld</code>) reads these relocations</li><li>Patches the placeholder bytes with calculated addresses</li><li>Removes these sections from the final executable</li></ul><h4 id=2-runtimedynamic-relocations>2. Runtime/Dynamic Relocations<a hidden class=anchor aria-hidden=true href=#2-runtimedynamic-relocations>#</a></h4><p>Resolved by the dynamic linker (<code>ld.so</code>) when loading the program</p><p>These appear in dynamically linked executables and shared libraries. They are kept in the binary because they must be processed every time the program runs (due to ASLR and shared library loading).</p><table><thead><tr><th>Relocation Section</th><th>Applies To</th><th>Contains Relocations For</th><th>When Resolved</th></tr></thead><tbody><tr><td><code>.rela.dyn</code></td><td><code>.got</code>, <code>.data</code>, <code>.bss</code></td><td>Global variables, data pointers, GOT entries</td><td>Program startup</td></tr><tr><td><code>.rela.plt</code></td><td><code>.got.plt</code> (or merged <code>.got</code>)</td><td>Function calls through PLT/GOT</td><td>Lazy binding (on first call) or at startup</td></tr></tbody></table><p><strong>What happens:</strong></p><ul><li>Present in the final executable</li><li>Dynamic linker (<code>ld.so</code>) processes them at runtime</li><li>Adjusts for ASLR (random base address)</li><li>Resolves symbols from shared libraries</li><li><strong>Sections remain</strong> (needed for every program execution)</li></ul><h4 id=3-complete-relocation-process>3. Complete Relocation Process<a hidden class=anchor aria-hidden=true href=#3-complete-relocation-process>#</a></h4><p><strong>Initial State (After Loading, Before Any Calls)</strong></p><ul><li>Each external function has three related components:<ul><li>A <code>.plt.sec</code> entry (small code stub)</li><li>A <code>.plt</code> resolver stub (fallback code)</li><li>A <code>.got.plt</code> entry (8-byte address slot)</li></ul></li><li>All GOT entries initially point to the <code>.plt</code> (<code>PLT[0]</code>) resolver stubs, not to real functions
The dynamic linker has filled <code>GOT[1]</code> (link_map) and <code>GOT[2]</code> (<code>_dl_runtime_resolve</code>)</li></ul><p><strong>First Call to an External Function</strong></p><ol><li>Code calls <code>printf@plt</code> (jumps to <code>.plt.sec</code> entry)</li><li><code>.plt.sec</code> stub contains the jump to <code>.got.plt</code> entry for that function (address in <code>.got.plt</code> is present in relocation for that function)</li><li><code>.got.plt</code> still contains stub which takes it to the corresponding entry for that function in <code>.plt</code></li><li><code>.plt</code> entry will push the relocation index for that function and jump to PLT resolver at PLT[0]</li><li>Resolver stub pushes relocation index (identifies which function) and jumps to <code>PLT[0]</code> (common resolver trampoline)</li><li><code>PLT[0]</code> pushes <code>GOT[1]</code> (context) and jumps through <code>GOT[2]</code> (to dynamic linker)</li><li>Dynamic linker receives control with relocation index and context</li><li>Dynamic linker looks up the function symbol in loaded shared libraries</li><li>Dynamic linker finds function address in appropriate library (e.g., libc.so)</li><li>Dynamic linker writes real function address into the <code>.got.plt</code> entry (key step!)</li><li>Dynamic linker jumps to the real function and returns to caller</li></ol><p><strong>Subsequent Calls to Same function</strong></p><ol><li>Code calls <code>printf@plt</code> (jumps to <code>.plt.sec</code> entry)</li><li><code>.plt.sec</code> stub jumps to the entry in <code>.got.plt</code></li><li><code>.got.plt</code> now contains real function address → lands directly in the function</li><li>Function executes and returns to call</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// demo.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Before malloc</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Allocated at: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(ptr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;After free</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is the section header table</p><pre tabindex=0><code>$ readelf -S demo
There are 31 section headers, starting at offset 0x36d0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400318  00000318
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.gnu.pr[...] NOTE             0000000000400338  00000338
       0000000000000030  0000000000000000   A       0     0     8
  [ 3] .note.gnu.bu[...] NOTE             0000000000400368  00000368
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .note.ABI-tag     NOTE             000000000040038c  0000038c
       0000000000000020  0000000000000000   A       0     0     4
  [ 5] .gnu.hash         GNU_HASH         00000000004003b0  000003b0
       000000000000001c  0000000000000000   A       6     0     8
  [ 6] .dynsym           DYNSYM           00000000004003d0  000003d0
       00000000000000a8  0000000000000018   A       7     1     8
  [ 7] .dynstr           STRTAB           0000000000400478  00000478
       000000000000005b  0000000000000000   A       0     0     1
  [ 8] .gnu.version      VERSYM           00000000004004d4  000004d4
       000000000000000e  0000000000000002   A       6     0     2
  [ 9] .gnu.version_r    VERNEED          00000000004004e8  000004e8
       0000000000000030  0000000000000000   A       7     1     8
  [10] .rela.dyn         RELA             0000000000400518  00000518
       0000000000000030  0000000000000018   A       6     0     8
  [11] .rela.plt         RELA             0000000000400548  00000548
       0000000000000060  0000000000000018  AI       6    24     8
  [12] .init             PROGBITS         0000000000401000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000401020  00001020
       0000000000000050  0000000000000010  AX       0     0     16
  [14] .plt.sec          PROGBITS         0000000000401070  00001070
       0000000000000040  0000000000000010  AX       0     0     16
  [15] .text             PROGBITS         00000000004010b0  000010b0
       000000000000014c  0000000000000000  AX       0     0     16
  [16] .fini             PROGBITS         00000000004011fc  000011fc
       000000000000000d  0000000000000000  AX       0     0     4
  [17] .rodata           PROGBITS         0000000000402000  00002000
       000000000000002f  0000000000000000   A       0     0     4
  [18] .eh_frame_hdr     PROGBITS         0000000000402030  00002030
       0000000000000034  0000000000000000   A       0     0     4
  [19] .eh_frame         PROGBITS         0000000000402068  00002068
       00000000000000a4  0000000000000000   A       0     0     8
  [20] .init_array       INIT_ARRAY       0000000000403df8  00002df8
       0000000000000008  0000000000000008  WA       0     0     8
  [21] .fini_array       FINI_ARRAY       0000000000403e00  00002e00
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .dynamic          DYNAMIC          0000000000403e08  00002e08
       00000000000001d0  0000000000000010  WA       7     0     8
  [23] .got              PROGBITS         0000000000403fd8  00002fd8
       0000000000000010  0000000000000008  WA       0     0     8
  [24] .got.plt          PROGBITS         0000000000403fe8  00002fe8
       0000000000000038  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000404020  00003020
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000404030  00003030
       0000000000000008  0000000000000000  WA       0     0     1
  [27] .comment          PROGBITS         0000000000000000  00003030
       000000000000002b  0000000000000001  MS       0     0     1
  [28] .symtab           SYMTAB           0000000000000000  00003060
       0000000000000378  0000000000000018          29    18     8
  [29] .strtab           STRTAB           0000000000000000  000033d8
       00000000000001d7  0000000000000000           0     0     1
  [30] .shstrtab         STRTAB           0000000000000000  000035af
       000000000000011f  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
</code></pre><p>We can see relocation entries for <code>free</code>, <code>puts</code>, <code>printf</code> and <code>malloc</code>.</p><pre tabindex=0><code>$ readelf -r demo

Relocation section &#39;.rela.dyn&#39; at offset 0x518 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000403fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0
000000403fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

Relocation section &#39;.rela.plt&#39; at offset 0x548 contains 4 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000404000  000100000007 R_X86_64_JUMP_SLO 0000000000000000 free@GLIBC_2.2.5 + 0
000000404008  000300000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
000000404010  000400000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
000000404018  000600000007 R_X86_64_JUMP_SLO 0000000000000000 malloc@GLIBC_2.2.5 + 0
</code></pre><p>Let&rsquo;s dosassemble the <code>.text</code> section</p><pre tabindex=0><code>$ objdump -d -j .text demo

demo:     file format elf64-x86-64


Disassembly of section .text:

00000000004010b0 &lt;_start&gt;:
  4010b0:	f3 0f 1e fa          	endbr64
  4010b4:	31 ed                	xor    %ebp,%ebp
  4010b6:	49 89 d1             	mov    %rdx,%r9
  4010b9:	5e                   	pop    %rsi
  4010ba:	48 89 e2             	mov    %rsp,%rdx
  4010bd:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4010c1:	50                   	push   %rax
  4010c2:	54                   	push   %rsp
  4010c3:	45 31 c0             	xor    %r8d,%r8d
  4010c6:	31 c9                	xor    %ecx,%ecx
  4010c8:	48 c7 c7 96 11 40 00 	mov    $0x401196,%rdi
  4010cf:	ff 15 03 2f 00 00    	call   *0x2f03(%rip)        # 403fd8 &lt;__libc_start_main@GLIBC_2.34&gt;
  4010d5:	f4                   	hlt
  4010d6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
  4010dd:	00 00 00

00000000004010e0 &lt;_dl_relocate_static_pie&gt;:
  4010e0:	f3 0f 1e fa          	endbr64
  4010e4:	c3                   	ret
  4010e5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
  4010ec:	00 00 00
  4010ef:	90                   	nop

00000000004010f0 &lt;deregister_tm_clones&gt;:
  4010f0:	b8 30 40 40 00       	mov    $0x404030,%eax
  4010f5:	48 3d 30 40 40 00    	cmp    $0x404030,%rax
  4010fb:	74 13                	je     401110 &lt;deregister_tm_clones+0x20&gt;
  4010fd:	b8 00 00 00 00       	mov    $0x0,%eax
  401102:	48 85 c0             	test   %rax,%rax
  401105:	74 09                	je     401110 &lt;deregister_tm_clones+0x20&gt;
  401107:	bf 30 40 40 00       	mov    $0x404030,%edi
  40110c:	ff e0                	jmp    *%rax
  40110e:	66 90                	xchg   %ax,%ax
  401110:	c3                   	ret
  401111:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
  401118:	00 00 00 00
  40111c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401120 &lt;register_tm_clones&gt;:
  401120:	be 30 40 40 00       	mov    $0x404030,%esi
  401125:	48 81 ee 30 40 40 00 	sub    $0x404030,%rsi
  40112c:	48 89 f0             	mov    %rsi,%rax
  40112f:	48 c1 ee 3f          	shr    $0x3f,%rsi
  401133:	48 c1 f8 03          	sar    $0x3,%rax
  401137:	48 01 c6             	add    %rax,%rsi
  40113a:	48 d1 fe             	sar    $1,%rsi
  40113d:	74 11                	je     401150 &lt;register_tm_clones+0x30&gt;
  40113f:	b8 00 00 00 00       	mov    $0x0,%eax
  401144:	48 85 c0             	test   %rax,%rax
  401147:	74 07                	je     401150 &lt;register_tm_clones+0x30&gt;
  401149:	bf 30 40 40 00       	mov    $0x404030,%edi
  40114e:	ff e0                	jmp    *%rax
  401150:	c3                   	ret
  401151:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
  401158:	00 00 00 00
  40115c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401160 &lt;__do_global_dtors_aux&gt;:
  401160:	f3 0f 1e fa          	endbr64
  401164:	80 3d c5 2e 00 00 00 	cmpb   $0x0,0x2ec5(%rip)        # 404030 &lt;__TMC_END__&gt;
  40116b:	75 13                	jne    401180 &lt;__do_global_dtors_aux+0x20&gt;
  40116d:	55                   	push   %rbp
  40116e:	48 89 e5             	mov    %rsp,%rbp
  401171:	e8 7a ff ff ff       	call   4010f0 &lt;deregister_tm_clones&gt;
  401176:	c6 05 b3 2e 00 00 01 	movb   $0x1,0x2eb3(%rip)        # 404030 &lt;__TMC_END__&gt;
  40117d:	5d                   	pop    %rbp
  40117e:	c3                   	ret
  40117f:	90                   	nop
  401180:	c3                   	ret
  401181:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
  401188:	00 00 00 00
  40118c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401190 &lt;frame_dummy&gt;:
  401190:	f3 0f 1e fa          	endbr64
  401194:	eb 8a                	jmp    401120 &lt;register_tm_clones&gt;

0000000000401196 &lt;main&gt;:
  401196:	f3 0f 1e fa          	endbr64
  40119a:	55                   	push   %rbp
  40119b:	48 89 e5             	mov    %rsp,%rbp
  40119e:	48 83 ec 10          	sub    $0x10,%rsp
  4011a2:	48 8d 05 5b 0e 00 00 	lea    0xe5b(%rip),%rax        # 402004 &lt;_IO_stdin_used+0x4&gt;
  4011a9:	48 89 c7             	mov    %rax,%rdi
  4011ac:	e8 cf fe ff ff       	call   401080 &lt;puts@plt&gt;
  4011b1:	bf 64 00 00 00       	mov    $0x64,%edi
  4011b6:	e8 e5 fe ff ff       	call   4010a0 &lt;malloc@plt&gt;
  4011bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4011bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4011c3:	48 89 c6             	mov    %rax,%rsi
  4011c6:	48 8d 05 45 0e 00 00 	lea    0xe45(%rip),%rax        # 402012 &lt;_IO_stdin_used+0x12&gt;
  4011cd:	48 89 c7             	mov    %rax,%rdi
  4011d0:	b8 00 00 00 00       	mov    $0x0,%eax
  4011d5:	e8 b6 fe ff ff       	call   401090 &lt;printf@plt&gt;
  4011da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4011de:	48 89 c7             	mov    %rax,%rdi
  4011e1:	e8 8a fe ff ff       	call   401070 &lt;free@plt&gt;
  4011e6:	48 8d 05 37 0e 00 00 	lea    0xe37(%rip),%rax        # 402024 &lt;_IO_stdin_used+0x24&gt;
  4011ed:	48 89 c7             	mov    %rax,%rdi
  4011f0:	e8 8b fe ff ff       	call   401080 &lt;puts@plt&gt;
  4011f5:	b8 00 00 00 00       	mov    $0x0,%eax
  4011fa:	c9                   	leave
  4011fb:	c3                   	ret
</code></pre><p>We can see calls to</p><pre tabindex=0><code>call   401080 &lt;puts@plt&gt;
call   401090 &lt;printf@plt&gt;
call   401070 &lt;free@plt&gt;
call   401080 &lt;puts@plt&gt;
</code></pre><p>We can see these addresses match to their corresponding stubs in <code>.plt.sec</code> section</p><pre tabindex=0><code>$ objdump -d -j .plt.sec demo

demo:     file format elf64-x86-64


Disassembly of section .plt.sec:

0000000000401070 &lt;free@plt&gt;:
  401070:	f3 0f 1e fa          	endbr64
  401074:	ff 25 86 2f 00 00    	jmp    *0x2f86(%rip)        # 404000 &lt;free@GLIBC_2.2.5&gt;
  40107a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401080 &lt;puts@plt&gt;:
  401080:	f3 0f 1e fa          	endbr64
  401084:	ff 25 7e 2f 00 00    	jmp    *0x2f7e(%rip)        # 404008 &lt;puts@GLIBC_2.2.5&gt;
  40108a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000401090 &lt;printf@plt&gt;:
  401090:	f3 0f 1e fa          	endbr64
  401094:	ff 25 76 2f 00 00    	jmp    *0x2f76(%rip)        # 404010 &lt;printf@GLIBC_2.2.5&gt;
  40109a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000004010a0 &lt;malloc@plt&gt;:
  4010a0:	f3 0f 1e fa          	endbr64
  4010a4:	ff 25 6e 2f 00 00    	jmp    *0x2f6e(%rip)        # 404018 &lt;malloc@GLIBC_2.2.5&gt;
  4010aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
</code></pre><p>PLT section</p><pre tabindex=0><code>$ objdump -d -j .plt demo

demo:     file format elf64-x86-64


Disassembly of section .plt:

0000000000401020 &lt;.plt&gt;:
  401020:	ff 35 ca 2f 00 00    	push   0x2fca(%rip)        # 403ff0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
  401026:	ff 25 cc 2f 00 00    	jmp    *0x2fcc(%rip)        # 403ff8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
  40102c:	0f 1f 40 00          	nopl   0x0(%rax)
  401030:	f3 0f 1e fa          	endbr64
  401034:	68 00 00 00 00       	push   $0x0
  401039:	e9 e2 ff ff ff       	jmp    401020 &lt;_init+0x20&gt;
  40103e:	66 90                	xchg   %ax,%ax
  401040:	f3 0f 1e fa          	endbr64
  401044:	68 01 00 00 00       	push   $0x1
  401049:	e9 d2 ff ff ff       	jmp    401020 &lt;_init+0x20&gt;
  40104e:	66 90                	xchg   %ax,%ax
  401050:	f3 0f 1e fa          	endbr64
  401054:	68 02 00 00 00       	push   $0x2
  401059:	e9 c2 ff ff ff       	jmp    401020 &lt;_init+0x20&gt;
  40105e:	66 90                	xchg   %ax,%ax
  401060:	f3 0f 1e fa          	endbr64
  401064:	68 03 00 00 00       	push   $0x3
  401069:	e9 b2 ff ff ff       	jmp    401020 &lt;_init+0x20&gt;
  40106e:	66 90                	xchg   %ax,%ax
</code></pre><p>We can verify the initial addresses stored in <code>.got.plt</code> entries are references to corresponding entries in <code>.plt</code> (addresses are in little endian)</p><pre tabindex=0><code>$ readelf -x .got.plt demo

Hex dump of section &#39;.got.plt&#39;:
 NOTE: This section has relocations against it, but these have NOT been applied to this dump.
  0x00403fe8 083e4000 00000000 00000000 00000000 .&gt;@.............
  0x00403ff8 00000000 00000000 30104000 00000000 ........0.@.....
  0x00404008 40104000 00000000 50104000 00000000 @.@.....P.@.....
  0x00404018 60104000 00000000                   `.@.....
</code></pre><p>Eg <code>404000</code> maps to <code>401030</code> (PLT[1]), <code>404008</code> maps to <code>401040</code> (PLT[2]), etc.</p><p>Let&rsquo;s run the program and see the addresses in <code>.got.plt</code> getting updated to actual values. I have disabled ASLR and compiled the binary as no-pie executable for simplicity.</p><pre tabindex=0><code>$ gdb ./demo

(gdb) break main
Breakpoint 1 at 0x40119e
(gdb) run
Starting program: /home/sanketh/assembly/plt/demo
Downloading separate debug info for system-supplied DSO at 0x7ffff7fc3000
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.

Breakpoint 1, 0x000000000040119e in main ()

(initial got entries, its not showing puts and malloc as they don&#39;t span new rows)

(gdb) x/4gx 0x404000
0x404000 &lt;free@got.plt&gt;:	0x0000000000401030	0x0000000000401040
0x404010 &lt;printf@got.plt&gt;:	0x0000000000401050	0x0000000000401060

(gdb) next
Single stepping until exit from function main,

(gdb) x/4gx 0x404000
0x404000 &lt;free@got.plt&gt;:	0x00007ffff7cadd30	0x00007ffff7c87be0
0x404010 &lt;printf@got.plt&gt;:	0x00007ffff7c60100	0x00007ffff7cad650
</code></pre><p>We can see <code>.got.plt</code> section got updated with actual values.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/elf/>Elf</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>