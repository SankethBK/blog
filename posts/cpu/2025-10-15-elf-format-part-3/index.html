<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ELF Format: Part 3 | Sanketh's Blog</title><meta name=keywords content="elf,reverse engineering"><meta name=description content="ELF Format: Sections and Section Header Table
In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&rsquo;ll look at Section Headers and Sections - the link-time and debugging view.
What Are Sections?
Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&rsquo;s contents for:"><meta name=author content="Sanketh"><link rel=canonical href=https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="ELF Format: Part 3"><meta property="og:description" content="ELF Format: Sections and Section Header Table In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we’ll look at Section Headers and Sections - the link-time and debugging view.
What Are Sections? Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file’s contents for:"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-15T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-15T00:00:00+00:00"><meta property="article:tag" content="Elf"><meta property="article:tag" content="Reverse Engineering"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELF Format: Part 3"><meta name=twitter:description content="ELF Format: Sections and Section Header Table
In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&rsquo;ll look at Section Headers and Sections - the link-time and debugging view.
What Are Sections?
Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&rsquo;s contents for:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sankethbk.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"ELF Format: Part 3","item":"https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ELF Format: Part 3","name":"ELF Format: Part 3","description":"ELF Format: Sections and Section Header Table In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we\u0026rsquo;ll look at Section Headers and Sections - the link-time and debugging view.\nWhat Are Sections? Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file\u0026rsquo;s contents for:\n","keywords":["elf","reverse engineering"],"articleBody":"ELF Format: Sections and Section Header Table In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we’ll look at Section Headers and Sections - the link-time and debugging view.\nWhat Are Sections? Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file’s contents for:\nLinkers - combining object files into executables Debuggers - finding symbols, source code mappings Analysis tools - examining specific parts of the binary Key distinction from segments:\nSegments = Required at runtime (OS needs them to execute) Sections = Optional at runtime (can be stripped from executables)\nYou can strip all section headers and the program will still run:\n$ readelf -S main | wc -l 68 $ objcopy --strip-section-headers main main2 $ readelf -S main2 There are no sections in this file. $ ./main2 Hi there! Sections vs Segments: The Relationship Sections (like .text, .data, .bss, .rodata) Represent logical divisions of code and data within the file. Used by linkers and debuggers — they organize how functions, variables, and symbols are stored in the file.\nSegments (PT_LOAD, PT_DYNAMIC, PT_INTERP, etc.) Represent runtime mappings — how parts of the file are placed into memory by the OS loader when the program runs.\nHow They Relate\nDuring linking, the linker groups related sections into loadable segments based on their flags (R, W, X) and alignment requirements.\nSegment (Type) Typical Sections Permissions Text Segment (PT_LOAD) .interp, .text, .rodata R-X Data Segment (PT_LOAD) .data, .bss RW- So, a segment is usually a contiguous chunk of the file containing one or more sections that share similar memory attributes.\nKey Facts\nA section can exist outside any segment. These are used only at link or debug time and are not mapped into memory. Examples: .symtab, .strtab, .debug_*, .comment.\nA section can never belong to more than one segment. Each section appears in at most one segment, as each piece of data is loaded into a single memory region.\nA segment can exist without any section. Some segments (like PT_INTERP, PT_PHDR, or PT_NOTE) describe runtime structures or metadata not represented as regular sections.\nSection Header Table The Section Header Table is an array of section header entries, each describing one section.\nSection Header Table Location The ELF Header tells us where to find it:\nLocation (file offset): e_shoff field in ELF Header Entry size: e_shentsize (40 bytes for 32-bit, 64 bytes for 64-bit) Number of entries: e_shnum String table index: e_shstrndx (which section contains section names) Total table size = e_shentsize × e_shnum\n$ readelf -h main | grep section Start of section headers: 14176 (bytes into file) Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 This means:\nSection Header Table starts at offset 0x3760 (14176 bytes) Each entry is 64 bytes There are 31 entries Section #30 contains the string table with section names Section Header Entry Structure Each entry describes one section. Here’s the structure from the Linux kernel:\ntypedef struct elf32_shdr { Elf32_Word\tsh_name; // Section name (string table offset) Elf32_Word\tsh_type; // Section type Elf32_Word\tsh_flags; // Section flags Elf32_Addr\tsh_addr; // Virtual address in memory Elf32_Off\tsh_offset; // File offset Elf32_Word\tsh_size; // Section size Elf32_Word\tsh_link; // Link to another section Elf32_Word\tsh_info; // Additional information Elf32_Word\tsh_addralign; // Alignment constraints Elf32_Word\tsh_entsize; // Entry size if section holds table } Elf32_Shdr; typedef struct elf64_shdr { Elf64_Word\tsh_name; // Section name (string table offset) Elf64_Word\tsh_type; // Section type Elf64_Xword\tsh_flags; // Section flags Elf64_Addr\tsh_addr; // Virtual address in memory Elf64_Off\tsh_offset; // File offset Elf64_Xword\tsh_size; // Section size Elf64_Word\tsh_link; // Link to another section Elf64_Word\tsh_info; // Additional information Elf64_Xword\tsh_addralign; // Alignment constraints Elf64_Xword\tsh_entsize; // Entry size if section holds table } Elf64_Shdr; Section Header Fields Explained 1. sh_name - Section Name This is NOT a string! It’s an offset into the section header string table.\nHow section names work:\nStep 1: ELF Header’s e_shstrndx tells us which section contains names\n$ readelf -h main | grep \"string table index\" Section header string table index: 30 Step 2: Section #30 is a string table (.shstrtab)\nOffset 0: \\0 Offset 1: .symtab\\0 Offset 9: .strtab\\0 Offset 17: .text\\0 Offset 23: .data\\0 ... Step 3: Each section’s sh_name is an offset into this table\nSection #1: sh_name = 1 → \".symtab\" Section #2: sh_name = 9 → \".strtab\" Section #3: sh_name = 17 → \".text\" ELF String Tables\nIn ELF, strings are stored in dedicated tables rather than repeated everywhere. This design keeps the binary compact and makes parsing easier. There are two main types of string tables:\n1. Section Header String Table (.shstrtab)\n.shstrtab is also a type of section, it holds the names of other sections, other sections just refer to the index from this table\n$ readelf -S main | grep .shstrtab [28] .shstrtab STRTAB 0000000000000000 0000303b It means 28th index of section header table is section header string table. ELF header’s e_shstrndx also indicates same\nWe can inspect the contents of .shstrtab by\n$ readelf -p .shstrtab main String dump of section '.shstrtab': [ 1] .shstrtab [ b] .interp [ 13] .note.gnu.property [ 26] .note.gnu.build-id [ 39] .note.ABI-tag [ 47] .gnu.hash [ 51] .dynsym [ 59] .dynstr [ 61] .gnu.version [ 6e] .gnu.version_r [ 7d] .rela.dyn [ 87] .rela.plt [ 91] .init [ 97] .plt.got [ a0] .plt.sec [ a9] .text [ af] .fini [ b5] .rodata [ bd] .eh_frame_hdr [ cb] .eh_frame [ d5] .init_array [ e1] .fini_array [ ed] .dynamic [ f6] .data [ fc] .bss [ 101] .comment 2. Symbol String Table (.strtab)\nPurpose: Stores symbol names used by the linker and debugger. Symbols (like function and variable names) in .symtab point to offsets in .strtab. This separation of symbols and section names allows the ELF format to handle linking and debugging information efficiently. 2. sh_type - Section Type Each section in an ELF file has a type, defined by the sh_type field in its section header. This tells the linker or loader what kind of data the section holds and how it should be treated.\nValue Name Description 0 SHT_NULL Inactive section (placeholder) 1 SHT_PROGBITS Program data (code, data, anything) 2 SHT_SYMTAB Symbol table (for linking) 3 SHT_STRTAB String table 4 SHT_RELA Relocation entries with addends 5 SHT_HASH Symbol hash table 6 SHT_DYNAMIC Dynamic linking information 7 SHT_NOTE Auxiliary information 8 SHT_NOBITS Section occupies no file space (.bss) 9 SHT_REL Relocation entries without addends 11 SHT_DYNSYM Dynamic symbol table 1. SHT_NULL — Inactive Section This is a placeholder entry that marks an unused section header. It has no data and is typically found as the first entry in the section header table (index 0). Every ELF file starts with this null section.\n2. SHT_PROGBITS — Program Data This is the most common section type. It holds actual program content — like executable instructions (.text), initialized data (.data), or read-only constants (.rodata). These sections are loaded into memory when the program runs.\n3. SHT_SYMTAB — Symbol Table Contains a full list of symbols defined or referenced in the program. This table is mainly used by the linker during relocation and symbol resolution. Each entry describes a symbol’s name, address, size, and type (function, variable, etc.). It’s usually found in relocatable (.o) files.\n4. SHT_STRTAB — String Table Stores strings used by other sections — for example, section names (.shstrtab) or symbol names (.strtab). Other sections don’t store names directly; instead, they store an offset into this string table.\n5. SHT_RELA — Relocation Entries with Addends Holds relocation information that includes explicit addends (extra constant values). Used by the linker to adjust symbol references when combining multiple object files. You’ll see this in files targeting architectures like x86-64, where addends are stored in the relocation entry itself.\n6. SHT_HASH — Symbol Hash Table Provides a quick way for the dynamic linker to find symbols at runtime using a hash lookup. This section speeds up symbol resolution for shared libraries.\n7. SHT_DYNAMIC — Dynamic Linking Information Contains metadata needed for dynamic linking — such as shared library names, symbol dependencies, and relocation entries. This section appears only in dynamically linked executables and shared objects (.so files).\n8. SHT_NOTE — Auxiliary Information Stores extra information such as build IDs, ABI tags, or core dump metadata. Notes are often used by debuggers or by the kernel when generating core dumps.\n9. SHT_NOBITS — No File Storage (e.g., .bss) Represents sections that occupy memory at runtime but take no space in the file. A classic example is .bss, which holds uninitialized global or static variables. The loader allocates and zero-initializes it in memory.\n10. SHT_REL — Relocation Entries without Addends Similar to SHT_RELA, but here addends are stored in the section being relocated, not in the relocation entry. Used on architectures like x86 (32-bit ELF).\n11. SHT_DYNSYM — Dynamic Symbol Table A smaller, optimized version of the symbol table used at runtime by the dynamic linker. It lists only the symbols needed for dynamic linking, unlike .symtab, which includes all symbols.\n3. sh_flags - Section Flags Attributes of the section:\nFlag Value Meaning SHF_WRITE 0x1 Section is writable at runtime SHF_ALLOC 0x2 Section occupies memory during execution SHF_EXECINSTR 0x4 Section contains executable code SHF_MERGE 0x10 Section may be merged SHF_STRINGS 0x20 Section contains null-terminated strings SHF_TLS 0x400 Section contains thread-local data Flag combinations tell you about the section:\n.text: SHF_ALLOC | SHF_EXECINSTR (AX) - loaded, executable .data: SHF_WRITE | SHF_ALLOC (WA) - loaded, writable .rodata: SHF_ALLOC (A) - loaded, read-only .symtab: No flags - not loaded at runtime! Important: SHF_ALLOC flag\nSections WITH SHF_ALLOC are part of segments (loaded to memory) Sections WITHOUT SHF_ALLOC are not loaded (debugging/linking only) 4. sh_addr - Virtual Address Virtual memory address where the section appears at runtime.\nFor sections with SHF_ALLOC: actual runtime address For sections without SHF_ALLOC: usually 0 (not loaded) $ readelf -S main [Nr] Name Type Address Off Size Flg [14] .text PROGBITS 0000000000001060 001060 000185 AX [24] .symtab SYMTAB 0000000000000000 002c48 000690 .text has address 0x1060 (will be at this address in memory) .symtab has address 0x0 (not loaded, address irrelevant)\n5. sh_offset - File Offset Byte offset from the beginning of the file where the section’s data starts. Example: sh_offset = 0x1060 means section data begins at byte 4192 in the file.\n6. sh_size - Section Size Size of the section in bytes. Special case: For SHT_NOBITS sections (like .bss), this is the size in memory, but there are 0 bytes in the file!\n7. sh_link — Linking One Section to Another The sh_link field in a section header holds a reference (index) to another section in the same ELF file.\nBut what it points to depends on the type of the section.\nIn other words, the ELF spec reuses sh_link for different purposes depending on the sh_type.\nHow sh_link is interpreted\nSection Type sh_link Meaning SHT_SYMTAB / SHT_DYNSYM Index of the string table section that holds the names of symbols in this symbol table. SHT_REL / SHT_RELA Index of the symbol table that the relocation entries refer to. SHT_DYNAMIC Index of the string table used by entries in the .dynamic section. SHT_HASH Index of the symbol table to which the hash applies. 8. sh_info - Additional Information Extra information, meaning depends on section type:\nSection Type sh_info Meaning SHT_SYMTAB / SHT_DYNSYM Index of first non-local symbol SHT_REL / SHT_RELA Section index to which relocations apply 9. sh_addralign - Alignment Alignment constraint for the section.\nValue must be 0 or power of 2 0 or 1 means no alignment sh_addr must be aligned: sh_addr % sh_addralign == 0 Example: sh_addralign = 16 means section must start at 16-byte boundary.\n10. sh_entsize - Entry Size If section contains a table of fixed-size entries, this is the size of each entry.\nFor .symtab: size of symbol table entry (24 bytes for 64-bit) For .rela.text: size of relocation entry For non-table sections: 0 Calculate number of entries:\nnum_entries = sh_size / sh_entsize\nBroad Classifications of Sections Category Purpose Examples Code Executable instructions .text, .plt, .init Data Program variables .data, .bss, .rodata Linking / Loader Metadata Linking, relocation, symbol info .symtab, .rel.*, .dynamic, .got Debugging / Profiling Developer tools .debug_*, .note.* Special / Misc Constructors, ABI info, interpreter .init_array, .interp Code Sections 1. .text - Executable Code Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: Machine code instructions This is where your compiled functions live:\nLet’s inspect the .text section of a simple C program\n// main.c #include void greet() { printf(\"Hello, ELF!\\n\"); } int main() { greet(); return 0; } $ gcc -g -O0 -o main main.c -g: tells compiler to include debugging symbols in the output: variable names, function names, line numbers, file names, etc. -O0: optimization level 0 means: No optimization (keeps code structure close to source) $ readelf -S main | grep .text [16] .text PROGBITS 0000000000001060 00001060 We can see .text section is at offset 1060 bytes.\nTo get the raw dump of .text section:\n$ objdump -s -j .text main main: file format elf64-x86-64 Contents of section .text: 1060 f30f1efa 31ed4989 d15e4889 e24883e4 ....1.I..^H..H.. 1070 f0505445 31c031c9 488d3de4 000000ff .PTE1.1.H.=..... 1080 15532f00 00f4662e 0f1f8400 00000000 .S/...f......... 1090 488d3d79 2f000048 8d05722f 00004839 H.=y/..H..r/..H9 10a0 f8741548 8b05362f 00004885 c07409ff .t.H..6/..H..t.. 10b0 e00f1f80 00000000 c30f1f80 00000000 ................ 10c0 488d3d49 2f000048 8d35422f 00004829 H.=I/..H.5B/..H) 10d0 fe4889f0 48c1ee3f 48c1f803 4801c648 .H..H..?H...H..H 10e0 d1fe7414 488b0505 2f000048 85c07408 ..t.H.../..H..t. 10f0 ffe0660f 1f440000 c30f1f80 00000000 ..f..D.......... 1100 f30f1efa 803d052f 00000075 2b554883 .....=./...u+UH. 1110 3de22e00 00004889 e5740c48 8b3de62e =.....H..t.H.=.. 1120 0000e819 ffffffe8 64ffffff c605dd2e ........d....... 1130 0000015d c30f1f00 c30f1f80 00000000 ...]............ 1140 f30f1efa e977ffff fff30f1e fa554889 .....w.......UH. 1150 e5488d05 ac0e0000 4889c7e8 f0feffff .H......H....... 1160 905dc3f3 0f1efa55 4889e5b8 00000000 .].....UH....... 1170 e8d4ffff ffb80000 00005dc3 ..........]. (main refers to file name in above command, not the main function)\nTo get the disassembled output of .text section:\n$ objdump -d -j .text main main: file format elf64-x86-64 Disassembly of section .text: 0000000000001060 \u003c_start\u003e: 1060:\tf3 0f 1e fa endbr64 1064:\t31 ed xor %ebp,%ebp 1066:\t49 89 d1 mov %rdx,%r9 1069:\t5e pop %rsi 106a:\t48 89 e2 mov %rsp,%rdx 106d:\t48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1071:\t50 push %rax 1072:\t54 push %rsp 1073:\t45 31 c0 xor %r8d,%r8d 1076:\t31 c9 xor %ecx,%ecx 1078:\t48 8d 3d e4 00 00 00 lea 0xe4(%rip),%rdi # 1163 107f:\tff 15 53 2f 00 00 call *0x2f53(%rip) # 3fd8 \u003c__libc_start_main@GLIBC_2.34\u003e 1085:\tf4 hlt 1086:\t66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 108d:\t00 00 00 0000000000001090 : 1090:\t48 8d 3d 79 2f 00 00 lea 0x2f79(%rip),%rdi # 4010 \u003c__TMC_END__\u003e 1097:\t48 8d 05 72 2f 00 00 lea 0x2f72(%rip),%rax # 4010 \u003c__TMC_END__\u003e 109e:\t48 39 f8 cmp %rdi,%rax 10a1:\t74 15 je 10b8 10a3:\t48 8b 05 36 2f 00 00 mov 0x2f36(%rip),%rax # 3fe0 \u003c_ITM_deregisterTMCloneTable@Base\u003e 10aa:\t48 85 c0 test %rax,%rax 10ad:\t74 09 je 10b8 10af:\tff e0 jmp *%rax 10b1:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 10b8:\tc3 ret 10b9:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 00000000000010c0 : 10c0:\t48 8d 3d 49 2f 00 00 lea 0x2f49(%rip),%rdi # 4010 \u003c__TMC_END__\u003e 10c7:\t48 8d 35 42 2f 00 00 lea 0x2f42(%rip),%rsi # 4010 \u003c__TMC_END__\u003e 10ce:\t48 29 fe sub %rdi,%rsi 10d1:\t48 89 f0 mov %rsi,%rax 10d4:\t48 c1 ee 3f shr $0x3f,%rsi 10d8:\t48 c1 f8 03 sar $0x3,%rax 10dc:\t48 01 c6 add %rax,%rsi 10df:\t48 d1 fe sar $1,%rsi 10e2:\t74 14 je 10f8 10e4:\t48 8b 05 05 2f 00 00 mov 0x2f05(%rip),%rax # 3ff0 \u003c_ITM_registerTMCloneTable@Base\u003e 10eb:\t48 85 c0 test %rax,%rax 10ee:\t74 08 je 10f8 10f0:\tff e0 jmp *%rax 10f2:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 10f8:\tc3 ret 10f9:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001100 \u003c__do_global_dtors_aux\u003e: 1100:\tf3 0f 1e fa endbr64 1104:\t80 3d 05 2f 00 00 00 cmpb $0x0,0x2f05(%rip) # 4010 \u003c__TMC_END__\u003e 110b:\t75 2b jne 1138 \u003c__do_global_dtors_aux+0x38\u003e 110d:\t55 push %rbp 110e:\t48 83 3d e2 2e 00 00 cmpq $0x0,0x2ee2(%rip) # 3ff8 \u003c__cxa_finalize@GLIBC_2.2.5\u003e 1115:\t00 1116:\t48 89 e5 mov %rsp,%rbp 1119:\t74 0c je 1127 \u003c__do_global_dtors_aux+0x27\u003e 111b:\t48 8b 3d e6 2e 00 00 mov 0x2ee6(%rip),%rdi # 4008 \u003c__dso_handle\u003e 1122:\te8 19 ff ff ff call 1040 \u003c__cxa_finalize@plt\u003e 1127:\te8 64 ff ff ff call 1090 112c:\tc6 05 dd 2e 00 00 01 movb $0x1,0x2edd(%rip) # 4010 \u003c__TMC_END__\u003e 1133:\t5d pop %rbp 1134:\tc3 ret 1135:\t0f 1f 00 nopl (%rax) 1138:\tc3 ret 1139:\t0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001140 : 1140:\tf3 0f 1e fa endbr64 1144:\te9 77 ff ff ff jmp 10c0 0000000000001149 : 1149:\tf3 0f 1e fa endbr64 114d:\t55 push %rbp 114e:\t48 89 e5 mov %rsp,%rbp 1151:\t48 8d 05 ac 0e 00 00 lea 0xeac(%rip),%rax # 2004 \u003c_IO_stdin_used+0x4\u003e 1158:\t48 89 c7 mov %rax,%rdi 115b:\te8 f0 fe ff ff call 1050 1160:\t90 nop 1161:\t5d pop %rbp 1162:\tc3 ret 0000000000001163 : 1163:\tf3 0f 1e fa endbr64 1167:\t55 push %rbp 1168:\t48 89 e5 mov %rsp,%rbp 116b:\tb8 00 00 00 00 mov $0x0,%eax 1170:\te8 d4 ff ff ff call 1149 1175:\tb8 00 00 00 00 mov $0x0,%eax 117a:\t5d pop %rbp 117b:\tc3 ret It converts raw bytes back to assembly mnemonics.\nEach line in the disassembly follows this pattern:\nADDRESS: MACHINE_CODE ASSEMBLY_INSTRUCTION COMMENTS We can see the _start label is at address 1060, which matches with the start address mentioned in ELF header.\n$ readelf -h main | grep \"Entry point address:\" Entry point address: 0x1060 We can see the definitions of main and greet functions in assembly.\nWe can see main() calls greet() 1170: call 1149 greet() calls puts@plt 115b: call 1050 puts@plt is in .plt section (dynamic linking)\ngreet() references string in .rodata 1151: lea 0xeac(%rip),%rax # Points to 0x2004 in .rodata\n(%rip) means RIP-relative addressing. RIP-relative addressing means the address is computed relative to the current instruction pointer.\neffective_address = current_instruction_address + displacement effective_address = 0x1151 + 0xEAC = 0x2004 We can verify that address falls in the range of .rodata section.\n[18] .rodata PROGBITS 0000000000002000 00002000 0000000000000010 0000000000000000 A 0 0 4 [19] .eh_frame_hdr PROGBITS 0000000000002010 00002010 000000000000003c 0000000000000000 A 0 0 4 We can also inspect the .rodata section to confirm it\n$ readelf -x .rodata main Hex dump of section '.rodata': 0x00002000 01000200 48656c6c 6f2c2045 4c462100 ....Hello, ELF!. 2. .plt (Procedure Linkage Table) Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: Stubs for calling shared library functions The Procedure Linkage Table (PLT) is a section in ELF executables and shared libraries that enables lazy binding — meaning, external (shared library) functions like printf, puts, or malloc are resolved only when first called, not when the program starts.\nWhen your program calls puts(“hi”);, the compiler doesn’t know where puts actually lives — it’s defined in the C library (libc.so.6). So instead of a direct call, it generates a call to a stub in .plt. This stub is responsible for eventually reaching the real puts function in memory.\nTo inspect the PLT of our program\n$ objdump -d -j .plt main main: file format elf64-x86-64 Disassembly of section .plt: 0000000000001020 \u003c.plt\u003e: 1020:\tff 35 9a 2f 00 00 push 0x2f9a(%rip) # 3fc0 \u003c_GLOBAL_OFFSET_TABLE_+0x8\u003e 1026:\tff 25 9c 2f 00 00 jmp *0x2f9c(%rip) # 3fc8 \u003c_GLOBAL_OFFSET_TABLE_+0x10\u003e 102c:\t0f 1f 40 00 nopl 0x0(%rax) 1030:\tf3 0f 1e fa endbr64 1034:\t68 00 00 00 00 push $0x0 1039:\te9 e2 ff ff ff jmp 1020 \u003c_init+0x20\u003e 103e:\t66 90 xchg %ax,%ax The first instruction jumps via the GOT (Global Offset Table). The push+jump sequence helps the dynamic linker resolve the symbol the first time it’s used 3. .plt.got Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: PLT entries for GOT references The .plt.got section is an extension of the traditional .plt, used primarily in position-independent executables (PIE) and shared libraries.\nWhen the compiler generates smaller or more optimized PLT entries, it sometimes places them in .plt.got instead of .plt.\nThese entries rely more directly on the GOT (Global Offset Table) for function address lookups, reducing the indirection and improving performance slightly.\nYou’ll usually see .plt.got in binaries built with:\nGCC’s newer toolchains PIE (Position Independent Executable) enabled Or with RELRO and lazy binding disabled (-Wl,-z,now) $ readelf -S main | grep .plt [11] .rela.plt RELA 0000000000000610 00000610 [13] .plt PROGBITS 0000000000001020 00001020 [14] .plt.got PROGBITS 0000000000001040 00001040 [15] .plt.sec PROGBITS 0000000000001050 00001050 $ objdump -d -j .plt.got main main: file format elf64-x86-64 Disassembly of section .plt.got: 0000000000001040 \u003c__cxa_finalize@plt\u003e: 1040:\tf3 0f 1e fa endbr64 1044:\tff 25 ae 2f 00 00 jmp *0x2fae(%rip) # 3ff8 \u003c__cxa_finalize@GLIBC_2.2.5\u003e 104a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) You’ll find shorter stubs, sometimes just a single indirect jump via the GOT — because by this point, all symbols are already resolved.\n4. .plt.sec Type: SHT_PROGBITS Flags: SHF_ALLOC | SHF_EXECINSTR (AX) Contains: Secure PLT stubs (used in hardened binaries) The .plt.sec section is a security-enhanced variant of the traditional .plt. It’s introduced in modern toolchains (GCC ≥ 9, binutils ≥ 2.31) to support Control Flow Integrity (CFI) and Intel’s Indirect Branch Tracking (IBT) features.\nEach entry in .plt.sec is similar to a normal PLT stub, but with additional instructions or metadata to prevent malicious redirection of function calls — protecting against attacks like Return-Oriented Programming (ROP) or GOT overwrite exploits.\nYou’ll usually see .plt.sec when your binary is built with flags like:\n-fpie -fcf-protection=full -O2 $ readelf -S main | grep .plt [13] .plt PROGBITS 0000000000001030 00001030 [14] .plt.got PROGBITS 0000000000001060 00001060 [15] .plt.sec PROGBITS 0000000000001080 00001080 Disassembly (simplified example):\n$ objdump -d -j .plt.sec main main: file format elf64-x86-64 Disassembly of section .plt.sec: 0000000000001050 : 1050:\tf3 0f 1e fa endbr64 1054:\tff 25 76 2f 00 00 jmp *0x2f76(%rip) # 3fd0 105a:\t66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) The endbr64 instruction (added by GCC for IBT) is used to mark safe entry points for indirect jumps — the CPU validates that control flow only transfers to legitimate call targets.\nData Sections 1. .rodata - Read-Only Data Type: SHT_PROGBITS Flags: SHF_ALLOC (A) Contains: Constants, string literals const char *msg = \"Hello, World!\"; // String stored in .rodata const int max = 100; $ readelf -x .rodata main Hex dump of section '.rodata': 0x00002000 01000200 48656c6c 6f2c2045 4c462100 ....Hello, ELF!. The .rodata section stores data that should never be modified at runtime. Typical contents include:\nString literals (“Hello, ELF!”) const variables in C/C++ Floating-point constants Lookup or jump tables generated by the compiler Because it’s read-only, this section is usually mapped into memory with read-only permissions (R-) by the OS loader.\nThis prevents accidental modification and improves security — if a program tries to modify it, it will trigger a segmentation fault.\n2. .data - Initialized Data Type: SHT_PROGBITS Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Initialized global and static variables The .data section stores all read–write variables whose initial values are known at compile time. These variables are part of the executable image — the compiler embeds their initial values directly into the ELF file. When the program loads into memory, the loader copies these values into writable memory so your program can modify them at runtime.\nint global_var = 42; // Stored in .data static int static_var = 100; // Stored in .data 3. .bss — Uninitialized Data Type: SHT_NOBITS Flags: SHF_WRITE | SHF_ALLOC (WA) Contains: Uninitialized global and static variables (default-initialized to zero) The .bss section holds variables that exist for the lifetime of the program (global or static), but don’t have explicit initial values in your source code. Unlike .data, this section does not occupy any space in the ELF file itself — only the size is recorded. When the program loads, the OS automatically allocates memory for .bss and fills it with zeros.\nExample\nint global_uninit; // Goes into .bss static int static_uninit; // Goes into .bss int main() { return global_uninit; // Initially 0 } Inspect:\n$ gcc -o main main.c $ readelf -S main | grep .bss [25] .bss NOBITS 0000000000004000 00003010 Notice the NOBITS type — that means no bytes are actually stored in the file; only the size (number of bytes required) is recorded.\nIf you dump it:\n$ readelf -x .bss main readelf: Warning: Section '.bss' has no data to dump. That’s because .bss doesn’t exist in the binary — it’s just a placeholder for the loader.\nWhat Happens at Runtime\nThe loader allocates memory for .bss variables. It initializes all bytes to zero (per the C standard). The variables behave like normal globals at runtime. ","wordCount":"4130","inLanguage":"en","datePublished":"2025-10-15T00:00:00Z","dateModified":"2025-10-15T00:00:00Z","author":{"@type":"Person","name":"Sanketh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/posts/cpu/2025-10-15-elf-format-part-3/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ELF Format: Part 3</h1><div class=post-meta><span title='2025-10-15 00:00:00 +0000 UTC'>October 15, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Sanketh&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/posts/cpu/2025-10-15-elf-format-part-3.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elf-format-sections-and-section-header-table aria-label="ELF Format: Sections and Section Header Table">ELF Format: Sections and Section Header Table</a><ul><li><a href=#what-are-sections aria-label="What Are Sections?">What Are Sections?</a></li><li><a href=#sections-vs-segments-the-relationship aria-label="Sections vs Segments: The Relationship">Sections vs Segments: The Relationship</a></li><li><a href=#section-header-table aria-label="Section Header Table">Section Header Table</a><ul><li><a href=#section-header-table-location aria-label="Section Header Table Location">Section Header Table Location</a></li><li><a href=#section-header-entry-structure aria-label="Section Header Entry Structure">Section Header Entry Structure</a></li><li><a href=#section-header-fields-explained aria-label="Section Header Fields Explained">Section Header Fields Explained</a><ul><li><a href=#1-sh_name---section-name aria-label="1. sh_name - Section Name">1. sh_name - Section Name</a></li><li><a href=#2-sh_type---section-type aria-label="2. sh_type - Section Type">2. sh_type - Section Type</a><ul><li><a href=#1-sht_null--inactive-section aria-label="1. SHT_NULL — Inactive Section">1. SHT_NULL — Inactive Section</a></li><li><a href=#2-sht_progbits--program-data aria-label="2. SHT_PROGBITS — Program Data">2. SHT_PROGBITS — Program Data</a></li><li><a href=#3-sht_symtab--symbol-table aria-label="3. SHT_SYMTAB — Symbol Table">3. SHT_SYMTAB — Symbol Table</a></li><li><a href=#4-sht_strtab--string-table aria-label="4. SHT_STRTAB — String Table">4. SHT_STRTAB — String Table</a></li><li><a href=#5-sht_rela--relocation-entries-with-addends aria-label="5. SHT_RELA — Relocation Entries with Addends">5. SHT_RELA — Relocation Entries with Addends</a></li><li><a href=#6-sht_hash--symbol-hash-table aria-label="6. SHT_HASH — Symbol Hash Table">6. SHT_HASH — Symbol Hash Table</a></li><li><a href=#7-sht_dynamic--dynamic-linking-information aria-label="7. SHT_DYNAMIC — Dynamic Linking Information">7. SHT_DYNAMIC — Dynamic Linking Information</a></li><li><a href=#8-sht_note--auxiliary-information aria-label="8. SHT_NOTE — Auxiliary Information">8. SHT_NOTE — Auxiliary Information</a></li><li><a href=#9-sht_nobits--no-file-storage-eg-bss aria-label="9. SHT_NOBITS — No File Storage (e.g., .bss)">9. SHT_NOBITS — No File Storage (e.g., .bss)</a></li><li><a href=#10-sht_rel--relocation-entries-without-addends aria-label="10. SHT_REL — Relocation Entries without Addends">10. SHT_REL — Relocation Entries without Addends</a></li><li><a href=#11-sht_dynsym--dynamic-symbol-table aria-label="11. SHT_DYNSYM — Dynamic Symbol Table">11. SHT_DYNSYM — Dynamic Symbol Table</a></li></ul></li><li><a href=#3-sh_flags---section-flags aria-label="3. sh_flags - Section Flags">3. sh_flags - Section Flags</a></li><li><a href=#4-sh_addr---virtual-address aria-label="4. sh_addr - Virtual Address">4. sh_addr - Virtual Address</a></li><li><a href=#5-sh_offset---file-offset aria-label="5. sh_offset - File Offset">5. sh_offset - File Offset</a></li><li><a href=#6-sh_size---section-size aria-label="6. sh_size - Section Size">6. sh_size - Section Size</a></li><li><a href=#7-sh_link--linking-one-section-to-another aria-label="7. sh_link — Linking One Section to Another">7. sh_link — Linking One Section to Another</a></li><li><a href=#8-sh_info---additional-information aria-label="8. sh_info - Additional Information">8. sh_info - Additional Information</a></li><li><a href=#9-sh_addralign---alignment aria-label="9. sh_addralign - Alignment">9. sh_addralign - Alignment</a></li><li><a href=#10-sh_entsize---entry-size aria-label="10. sh_entsize - Entry Size">10. sh_entsize - Entry Size</a></li></ul></li></ul></li><li><a href=#broad-classifications-of-sections aria-label="Broad Classifications of Sections">Broad Classifications of Sections</a></li><li><a href=#code-sections aria-label="Code Sections">Code Sections</a><ul><li><a href=#1-text---executable-code aria-label="1. .text - Executable Code">1. .text - Executable Code</a></li><li><a href=#2-plt-procedure-linkage-table aria-label="2. .plt (Procedure Linkage Table)">2. .plt (Procedure Linkage Table)</a></li><li><a href=#3-pltgot aria-label="3. .plt.got">3. .plt.got</a></li><li><a href=#4-pltsec aria-label="4. .plt.sec">4. .plt.sec</a></li></ul></li><li><a href=#data-sections aria-label="Data Sections">Data Sections</a><ul><li><a href=#1-rodata---read-only-data aria-label="1. .rodata - Read-Only Data">1. .rodata - Read-Only Data</a></li><li><a href=#2-data---initialized-data aria-label="2. .data - Initialized Data">2. .data - Initialized Data</a></li><li><a href=#3-bss--uninitialized-data aria-label="3. .bss — Uninitialized Data">3. .bss — Uninitialized Data</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=elf-format-sections-and-section-header-table>ELF Format: Sections and Section Header Table<a hidden class=anchor aria-hidden=true href=#elf-format-sections-and-section-header-table>#</a></h1><p>In the previous post, we explored Program Headers and Segments - the runtime view of an ELF file. Now we&rsquo;ll look at Section Headers and Sections - the link-time and debugging view.</p><h2 id=what-are-sections>What Are Sections?<a hidden class=anchor aria-hidden=true href=#what-are-sections>#</a></h2><p>Sections are the link-time view of an ELF file. While segments tell the operating system how to load and execute a program, sections organize the file&rsquo;s contents for:</p><ul><li><strong>Linkers</strong> - combining object files into executables</li><li><strong>Debuggers</strong> - finding symbols, source code mappings</li><li><strong>Analysis tools</strong> - examining specific parts of the binary</li></ul><p><strong>Key distinction from segments:</strong></p><p>Segments = Required at runtime (OS needs them to execute)
Sections = Optional at runtime (can be stripped from executables)</p><p>You can strip all section headers and the program will still run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | wc -l
</span></span><span style=display:flex><span><span style=color:#ae81ff>68</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ objcopy --strip-section-headers main  main2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ readelf -S main2
</span></span><span style=display:flex><span>There are no sections in this file.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./main2
</span></span><span style=display:flex><span>Hi there!
</span></span></code></pre></div><h2 id=sections-vs-segments-the-relationship>Sections vs Segments: The Relationship<a hidden class=anchor aria-hidden=true href=#sections-vs-segments-the-relationship>#</a></h2><ul><li><p>Sections (like <code>.text</code>, <code>.data</code>, <code>.bss</code>, <code>.rodata</code>)
Represent logical divisions of code and data within the file.
Used by linkers and debuggers — they organize how functions, variables, and symbols are stored in the file.</p></li><li><p>Segments (<code>PT_LOAD</code>, <code>PT_DYNAMIC</code>, <code>PT_INTERP</code>, etc.)
Represent runtime mappings — how parts of the file are placed into memory by the OS loader when the program runs.</p></li></ul><p><strong>How They Relate</strong></p><p>During linking, the linker groups related sections into loadable segments based on their flags (<code>R</code>, <code>W</code>, <code>X</code>) and alignment requirements.</p><table><thead><tr><th>Segment (Type)</th><th>Typical Sections</th><th>Permissions</th></tr></thead><tbody><tr><td>Text Segment (<code>PT_LOAD</code>)</td><td><code>.interp</code>, <code>.text</code>, <code>.rodata</code></td><td><strong>R-X</strong></td></tr><tr><td>Data Segment (<code>PT_LOAD</code>)</td><td><code>.data</code>, <code>.bss</code></td><td><strong>RW-</strong></td></tr></tbody></table><p>So, a segment is usually a contiguous chunk of the file containing one or more sections that share similar memory attributes.</p><p><strong>Key Facts</strong></p><ul><li><p><strong>A section can exist outside any segment.</strong>
These are used only at link or debug time and are not mapped into memory.
Examples: <code>.symtab</code>, <code>.strtab</code>, <code>.debug_*</code>, <code>.comment</code>.</p></li><li><p><strong>A section can never belong to more than one segment.</strong>
Each section appears in at most one segment, as each piece of data is loaded into a single memory region.</p></li><li><p><strong>A segment can exist without any section.</strong>
Some segments (like <code>PT_INTERP</code>, <code>PT_PHDR</code>, or <code>PT_NOTE</code>) describe runtime structures or metadata not represented as regular sections.</p></li></ul><h2 id=section-header-table>Section Header Table<a hidden class=anchor aria-hidden=true href=#section-header-table>#</a></h2><p>The Section Header Table is an array of section header entries, each describing one section.</p><h3 id=section-header-table-location>Section Header Table Location<a hidden class=anchor aria-hidden=true href=#section-header-table-location>#</a></h3><p>The ELF Header tells us where to find it:</p><ul><li>Location (file offset): <code>e_shoff</code> field in ELF Header</li><li>Entry size: <code>e_shentsize</code> (40 bytes for 32-bit, 64 bytes for 64-bit)</li><li>Number of entries: <code>e_shnum</code></li><li>String table index: <code>e_shstrndx</code> (which section contains section names)</li></ul><p>Total table size = <code>e_shentsize × e_shnum</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep section
</span></span><span style=display:flex><span>  Start of section headers:          <span style=color:#ae81ff>14176</span> <span style=color:#f92672>(</span>bytes into file<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Size of section headers:           <span style=color:#ae81ff>64</span> <span style=color:#f92672>(</span>bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Number of section headers:         <span style=color:#ae81ff>31</span>
</span></span><span style=display:flex><span>  Section header string table index: <span style=color:#ae81ff>30</span>
</span></span></code></pre></div><p>This means:</p><ul><li>Section Header Table starts at offset 0x3760 (14176 bytes)</li><li>Each entry is 64 bytes</li><li>There are 31 entries</li><li>Section #30 contains the string table with section names</li></ul><h3 id=section-header-entry-structure>Section Header Entry Structure<a hidden class=anchor aria-hidden=true href=#section-header-entry-structure>#</a></h3><p>Each entry describes one section. Here&rsquo;s the structure from the Linux kernel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf32_shdr {
</span></span><span style=display:flex><span>  Elf32_Word	sh_name;       <span style=color:#75715e>// Section name (string table offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_type;       <span style=color:#75715e>// Section type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_flags;      <span style=color:#75715e>// Section flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Addr	sh_addr;       <span style=color:#75715e>// Virtual address in memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Off	sh_offset;     <span style=color:#75715e>// File offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_size;       <span style=color:#75715e>// Section size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_link;       <span style=color:#75715e>// Link to another section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_info;       <span style=color:#75715e>// Additional information
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_addralign;  <span style=color:#75715e>// Alignment constraints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf32_Word	sh_entsize;    <span style=color:#75715e>// Entry size if section holds table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Elf32_Shdr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> elf64_shdr {
</span></span><span style=display:flex><span>  Elf64_Word	sh_name;       <span style=color:#75715e>// Section name (string table offset)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Word	sh_type;       <span style=color:#75715e>// Section type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_flags;      <span style=color:#75715e>// Section flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Addr	sh_addr;       <span style=color:#75715e>// Virtual address in memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Off	sh_offset;     <span style=color:#75715e>// File offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_size;       <span style=color:#75715e>// Section size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Word	sh_link;       <span style=color:#75715e>// Link to another section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Word	sh_info;       <span style=color:#75715e>// Additional information
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_addralign;  <span style=color:#75715e>// Alignment constraints
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Elf64_Xword	sh_entsize;    <span style=color:#75715e>// Entry size if section holds table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Elf64_Shdr;
</span></span></code></pre></div><h3 id=section-header-fields-explained>Section Header Fields Explained<a hidden class=anchor aria-hidden=true href=#section-header-fields-explained>#</a></h3><h4 id=1-sh_name---section-name>1. sh_name - Section Name<a hidden class=anchor aria-hidden=true href=#1-sh_name---section-name>#</a></h4><p>This is NOT a string! It&rsquo;s an offset into the section header string table.</p><p>How section names work:</p><p>Step 1: ELF Header&rsquo;s <code>e_shstrndx</code> tells us which section contains names</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep <span style=color:#e6db74>&#34;string table index&#34;</span>
</span></span><span style=display:flex><span>  Section header string table index: <span style=color:#ae81ff>30</span>
</span></span></code></pre></div><p>Step 2: Section #30 is a string table (.shstrtab)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Offset 0:    <span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 1:    .symtab<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 9:    .strtab<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 17:   .text<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>Offset 23:   .data<span style=color:#ae81ff>\0</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Step 3: Each section&rsquo;s sh_name is an offset into this table</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Section <span style=color:#75715e>#1: sh_name = 1  → &#34;.symtab&#34;</span>
</span></span><span style=display:flex><span>Section <span style=color:#75715e>#2: sh_name = 9  → &#34;.strtab&#34;</span>
</span></span><span style=display:flex><span>Section <span style=color:#75715e>#3: sh_name = 17 → &#34;.text&#34;</span>
</span></span></code></pre></div><p><strong>ELF String Tables</strong></p><p>In ELF, strings are stored in dedicated tables rather than repeated everywhere. This design keeps the binary compact and makes parsing easier. There are two main types of string tables:</p><p><strong>1. Section Header String Table (.shstrtab)</strong></p><p><code>.shstrtab</code> is also a type of section, it holds the names of other sections, other sections just refer to the index from this table</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .shstrtab
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>28<span style=color:#f92672>]</span> .shstrtab         STRTAB           <span style=color:#ae81ff>0000000000000000</span>  0000303b
</span></span></code></pre></div><p>It means 28th index of section header table is section header string table. ELF header&rsquo;s <code>e_shstrndx</code> also indicates same</p><p>We can inspect the contents of <code>.shstrtab</code> by</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -p .shstrtab main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>String dump of section <span style=color:#e6db74>&#39;.shstrtab&#39;</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>     1<span style=color:#f92672>]</span>  .shstrtab
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>     b<span style=color:#f92672>]</span>  .interp
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    13<span style=color:#f92672>]</span>  .note.gnu.property
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    26<span style=color:#f92672>]</span>  .note.gnu.build-id
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    39<span style=color:#f92672>]</span>  .note.ABI-tag
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    47<span style=color:#f92672>]</span>  .gnu.hash
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    51<span style=color:#f92672>]</span>  .dynsym
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    59<span style=color:#f92672>]</span>  .dynstr
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    61<span style=color:#f92672>]</span>  .gnu.version
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    6e<span style=color:#f92672>]</span>  .gnu.version_r
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    7d<span style=color:#f92672>]</span>  .rela.dyn
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    87<span style=color:#f92672>]</span>  .rela.plt
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    91<span style=color:#f92672>]</span>  .init
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    97<span style=color:#f92672>]</span>  .plt.got
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    a0<span style=color:#f92672>]</span>  .plt.sec
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    a9<span style=color:#f92672>]</span>  .text
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    af<span style=color:#f92672>]</span>  .fini
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    b5<span style=color:#f92672>]</span>  .rodata
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    bd<span style=color:#f92672>]</span>  .eh_frame_hdr
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    cb<span style=color:#f92672>]</span>  .eh_frame
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    d5<span style=color:#f92672>]</span>  .init_array
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    e1<span style=color:#f92672>]</span>  .fini_array
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    ed<span style=color:#f92672>]</span>  .dynamic
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    f6<span style=color:#f92672>]</span>  .data
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>    fc<span style=color:#f92672>]</span>  .bss
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>   101<span style=color:#f92672>]</span>  .comment
</span></span></code></pre></div><p><strong>2. Symbol String Table (<code>.strtab</code>)</strong></p><ul><li>Purpose: Stores symbol names used by the linker and debugger.</li><li>Symbols (like function and variable names) in <code>.symtab</code> point to offsets in .strtab.</li><li>This separation of symbols and section names allows the ELF format to handle linking and debugging information efficiently.</li></ul><h4 id=2-sh_type---section-type>2. sh_type - Section Type<a hidden class=anchor aria-hidden=true href=#2-sh_type---section-type>#</a></h4><p>Each section in an ELF file has a type, defined by the <code>sh_type</code> field in its section header.
This tells the linker or loader what kind of data the section holds and how it should be treated.</p><table><thead><tr><th>Value</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>SHT_NULL</td><td>Inactive section (placeholder)</td></tr><tr><td>1</td><td>SHT_PROGBITS</td><td>Program data (code, data, anything)</td></tr><tr><td>2</td><td>SHT_SYMTAB</td><td>Symbol table (for linking)</td></tr><tr><td>3</td><td>SHT_STRTAB</td><td>String table</td></tr><tr><td>4</td><td>SHT_RELA</td><td>Relocation entries with addends</td></tr><tr><td>5</td><td>SHT_HASH</td><td>Symbol hash table</td></tr><tr><td>6</td><td>SHT_DYNAMIC</td><td>Dynamic linking information</td></tr><tr><td>7</td><td>SHT_NOTE</td><td>Auxiliary information</td></tr><tr><td>8</td><td>SHT_NOBITS</td><td>Section occupies no file space (.bss)</td></tr><tr><td>9</td><td>SHT_REL</td><td>Relocation entries without addends</td></tr><tr><td>11</td><td>SHT_DYNSYM</td><td>Dynamic symbol table</td></tr></tbody></table><h5 id=1-sht_null--inactive-section>1. SHT_NULL — Inactive Section<a hidden class=anchor aria-hidden=true href=#1-sht_null--inactive-section>#</a></h5><p>This is a placeholder entry that marks an unused section header. It has no data and is typically found as the first entry in the section header table (index 0). Every ELF file starts with this null section.</p><h5 id=2-sht_progbits--program-data>2. SHT_PROGBITS — Program Data<a hidden class=anchor aria-hidden=true href=#2-sht_progbits--program-data>#</a></h5><p>This is the most common section type. It holds actual program content — like executable instructions (<code>.text</code>), initialized data (<code>.data</code>), or read-only constants (<code>.rodata</code>). These sections are loaded into memory when the program runs.</p><h5 id=3-sht_symtab--symbol-table>3. SHT_SYMTAB — Symbol Table<a hidden class=anchor aria-hidden=true href=#3-sht_symtab--symbol-table>#</a></h5><p>Contains a full list of symbols defined or referenced in the program.
This table is mainly used by the linker during relocation and symbol resolution.
Each entry describes a symbol’s name, address, size, and type (function, variable, etc.).
It’s usually found in relocatable (<code>.o</code>) files.</p><h5 id=4-sht_strtab--string-table>4. SHT_STRTAB — String Table<a hidden class=anchor aria-hidden=true href=#4-sht_strtab--string-table>#</a></h5><p>Stores strings used by other sections — for example, section names (.shstrtab) or symbol names (<code>.strtab</code>).
Other sections don’t store names directly; instead, they store an offset into this string table.</p><h5 id=5-sht_rela--relocation-entries-with-addends>5. SHT_RELA — Relocation Entries with Addends<a hidden class=anchor aria-hidden=true href=#5-sht_rela--relocation-entries-with-addends>#</a></h5><p>Holds relocation information that includes explicit addends (extra constant values).
Used by the linker to adjust symbol references when combining multiple object files.
You’ll see this in files targeting architectures like x86-64, where addends are stored in the relocation entry itself.</p><h5 id=6-sht_hash--symbol-hash-table>6. SHT_HASH — Symbol Hash Table<a hidden class=anchor aria-hidden=true href=#6-sht_hash--symbol-hash-table>#</a></h5><p>Provides a quick way for the dynamic linker to find symbols at runtime using a hash lookup.
This section speeds up symbol resolution for shared libraries.</p><h5 id=7-sht_dynamic--dynamic-linking-information>7. SHT_DYNAMIC — Dynamic Linking Information<a hidden class=anchor aria-hidden=true href=#7-sht_dynamic--dynamic-linking-information>#</a></h5><p>Contains metadata needed for dynamic linking — such as shared library names, symbol dependencies, and relocation entries.
This section appears only in dynamically linked executables and shared objects (<code>.so</code> files).</p><h5 id=8-sht_note--auxiliary-information>8. SHT_NOTE — Auxiliary Information<a hidden class=anchor aria-hidden=true href=#8-sht_note--auxiliary-information>#</a></h5><p>Stores extra information such as build IDs, ABI tags, or core dump metadata.
Notes are often used by debuggers or by the kernel when generating core dumps.</p><h5 id=9-sht_nobits--no-file-storage-eg-bss>9. SHT_NOBITS — No File Storage (e.g., <code>.bss</code>)<a hidden class=anchor aria-hidden=true href=#9-sht_nobits--no-file-storage-eg-bss>#</a></h5><p>Represents sections that occupy memory at runtime but take no space in the file.
A classic example is <code>.bss</code>, which holds uninitialized global or static variables.
The loader allocates and zero-initializes it in memory.</p><h5 id=10-sht_rel--relocation-entries-without-addends>10. SHT_REL — Relocation Entries without Addends<a hidden class=anchor aria-hidden=true href=#10-sht_rel--relocation-entries-without-addends>#</a></h5><p>Similar to <code>SHT_RELA</code>, but here addends are stored in the section being relocated, not in the relocation entry.
Used on architectures like x86 (32-bit ELF).</p><h5 id=11-sht_dynsym--dynamic-symbol-table>11. SHT_DYNSYM — Dynamic Symbol Table<a hidden class=anchor aria-hidden=true href=#11-sht_dynsym--dynamic-symbol-table>#</a></h5><p>A smaller, optimized version of the symbol table used at runtime by the dynamic linker.
It lists only the symbols needed for dynamic linking, unlike <code>.symtab</code>, which includes all symbols.</p><h4 id=3-sh_flags---section-flags>3. sh_flags - Section Flags<a hidden class=anchor aria-hidden=true href=#3-sh_flags---section-flags>#</a></h4><p>Attributes of the section:</p><table><thead><tr><th>Flag</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>SHF_WRITE</td><td>0x1</td><td>Section is writable at runtime</td></tr><tr><td>SHF_ALLOC</td><td>0x2</td><td>Section occupies memory during execution</td></tr><tr><td>SHF_EXECINSTR</td><td>0x4</td><td>Section contains executable code</td></tr><tr><td>SHF_MERGE</td><td>0x10</td><td>Section may be merged</td></tr><tr><td>SHF_STRINGS</td><td>0x20</td><td>Section contains null-terminated strings</td></tr><tr><td>SHF_TLS</td><td>0x400</td><td>Section contains thread-local data</td></tr></tbody></table><p><strong>Flag combinations tell you about the section:</strong></p><ul><li><code>.text</code>: <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX) - loaded, executable</li><li><code>.data</code>: <code>SHF_WRITE | SHF_ALLOC</code> (WA) - loaded, writable</li><li><code>.rodata</code>: <code>SHF_ALLOC</code> (A) - loaded, read-only</li><li><code>.symtab</code>: No flags - not loaded at runtime!</li></ul><p><strong>Important: SHF_ALLOC flag</strong></p><ul><li>Sections WITH <code>SHF_ALLOC</code> are part of segments (loaded to memory)</li><li>Sections WITHOUT <code>SHF_ALLOC</code> are not loaded (debugging/linking only)</li></ul><h4 id=4-sh_addr---virtual-address>4. sh_addr - Virtual Address<a hidden class=anchor aria-hidden=true href=#4-sh_addr---virtual-address>#</a></h4><p>Virtual memory address where the section appears at runtime.</p><ul><li>For sections with <code>SHF_ALLOC</code>: actual runtime address</li><li>For sections without <code>SHF_ALLOC</code>: usually 0 (not loaded)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>Nr<span style=color:#f92672>]</span> Name      Type      Address          Off    Size   Flg
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> .text     PROGBITS  <span style=color:#ae81ff>0000000000001060</span>  <span style=color:#ae81ff>001060</span> <span style=color:#ae81ff>000185</span> AX
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>24<span style=color:#f92672>]</span> .symtab   SYMTAB    <span style=color:#ae81ff>0000000000000000</span>  002c48 <span style=color:#ae81ff>000690</span>
</span></span></code></pre></div><p><code>.text</code> has address <code>0x1060</code> (will be at this address in memory)
<code>.symtab</code> has address <code>0x0</code> (not loaded, address irrelevant)</p><h4 id=5-sh_offset---file-offset>5. sh_offset - File Offset<a hidden class=anchor aria-hidden=true href=#5-sh_offset---file-offset>#</a></h4><p>Byte offset from the beginning of the file where the section&rsquo;s data starts.
Example: <code>sh_offset = 0x1060</code> means section data begins at byte 4192 in the file.</p><h4 id=6-sh_size---section-size>6. sh_size - Section Size<a hidden class=anchor aria-hidden=true href=#6-sh_size---section-size>#</a></h4><p>Size of the section in bytes.
Special case: For <code>SHT_NOBITS</code> sections (like <code>.bss</code>), this is the size in memory, but there are 0 bytes in the file!</p><h4 id=7-sh_link--linking-one-section-to-another>7. sh_link — Linking One Section to Another<a hidden class=anchor aria-hidden=true href=#7-sh_link--linking-one-section-to-another>#</a></h4><p>The <code>sh_link</code> field in a section header holds a reference (index) to another section in the same ELF file.</p><p>But what it points to depends on the type of the section.</p><p>In other words, the ELF spec reuses <code>sh_link</code> for different purposes depending on the <code>sh_type</code>.</p><p><strong>How sh_link is interpreted</strong></p><table><thead><tr><th>Section Type</th><th><code>sh_link</code> Meaning</th></tr></thead><tbody><tr><td><code>SHT_SYMTAB</code> / <code>SHT_DYNSYM</code></td><td>Index of the <strong>string table</strong> section that holds the names of symbols in this symbol table.</td></tr><tr><td><code>SHT_REL</code> / <code>SHT_RELA</code></td><td>Index of the <strong>symbol table</strong> that the relocation entries refer to.</td></tr><tr><td><code>SHT_DYNAMIC</code></td><td>Index of the <strong>string table</strong> used by entries in the <code>.dynamic</code> section.</td></tr><tr><td><code>SHT_HASH</code></td><td>Index of the <strong>symbol table</strong> to which the hash applies.</td></tr></tbody></table><h4 id=8-sh_info---additional-information>8. sh_info - Additional Information<a hidden class=anchor aria-hidden=true href=#8-sh_info---additional-information>#</a></h4><p>Extra information, meaning depends on section type:</p><table><thead><tr><th>Section Type</th><th>sh_info Meaning</th></tr></thead><tbody><tr><td>SHT_SYMTAB / SHT_DYNSYM</td><td>Index of first non-local symbol</td></tr><tr><td>SHT_REL / SHT_RELA</td><td>Section index to which relocations apply</td></tr></tbody></table><h4 id=9-sh_addralign---alignment>9. sh_addralign - Alignment<a hidden class=anchor aria-hidden=true href=#9-sh_addralign---alignment>#</a></h4><p>Alignment constraint for the section.</p><ul><li>Value must be 0 or power of 2</li><li>0 or 1 means no alignment</li><li><code>sh_addr</code> must be aligned: <code>sh_addr % sh_addralign == 0</code></li></ul><p>Example: <code>sh_addralign = 16</code> means section must start at 16-byte boundary.</p><h4 id=10-sh_entsize---entry-size>10. sh_entsize - Entry Size<a hidden class=anchor aria-hidden=true href=#10-sh_entsize---entry-size>#</a></h4><p>If section contains a table of fixed-size entries, this is the size of each entry.</p><ul><li>For .<code>symtab</code>: size of symbol table entry (24 bytes for 64-bit)</li><li>For .<code>rela.text</code>: size of relocation entry</li><li>For non-table sections: 0</li></ul><p>Calculate number of entries:</p><p><code>num_entries = sh_size / sh_entsize</code></p><h2 id=broad-classifications-of-sections>Broad Classifications of Sections<a hidden class=anchor aria-hidden=true href=#broad-classifications-of-sections>#</a></h2><table><thead><tr><th>Category</th><th>Purpose</th><th>Examples</th></tr></thead><tbody><tr><td><strong>Code</strong></td><td>Executable instructions</td><td><code>.text</code>, <code>.plt</code>, <code>.init</code></td></tr><tr><td><strong>Data</strong></td><td>Program variables</td><td><code>.data</code>, <code>.bss</code>, <code>.rodata</code></td></tr><tr><td><strong>Linking / Loader Metadata</strong></td><td>Linking, relocation, symbol info</td><td><code>.symtab</code>, <code>.rel.*</code>, <code>.dynamic</code>, <code>.got</code></td></tr><tr><td><strong>Debugging / Profiling</strong></td><td>Developer tools</td><td><code>.debug_*</code>, <code>.note.*</code></td></tr><tr><td><strong>Special / Misc</strong></td><td>Constructors, ABI info, interpreter</td><td><code>.init_array</code>, <code>.interp</code></td></tr></tbody></table><h2 id=code-sections>Code Sections<a hidden class=anchor aria-hidden=true href=#code-sections>#</a></h2><h3 id=1-text---executable-code>1. .text - Executable Code<a hidden class=anchor aria-hidden=true href=#1-text---executable-code>#</a></h3><p><strong>Type:</strong> <code>SHT_PROGBITS</code>
<strong>Flags:</strong> <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)
<strong>Contains:</strong> Machine code instructions
This is where your compiled functions live:</p><p>Let&rsquo;s inspect the <code>.text</code> section of a simple C program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>greet</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Hello, ELF!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>greet</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -g -O0 -o main main.c
</span></span></code></pre></div><ul><li><code>-g</code>: tells compiler to include debugging symbols in the output: variable names, function names, line numbers, file names, etc.</li><li><code>-O0</code>: optimization level 0 means: No optimization (keeps code structure close to source)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .text
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>16<span style=color:#f92672>]</span> .text             PROGBITS         <span style=color:#ae81ff>0000000000001060</span>  <span style=color:#ae81ff>00001060</span>
</span></span></code></pre></div><p>We can see <code>.text</code> section is at offset 1060 bytes.</p><p>To get the raw dump of <code>.text</code> section:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -s -j .text main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Contents of section .text:
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1060</span> f30f1efa 31ed4989 d15e4889 e24883e4  ....1.I..^H..H..
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1070</span> f0505445 31c031c9 488d3de4 000000ff  .PTE1.1.H.<span style=color:#f92672>=</span>.....
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1080</span> 15532f00 00f4662e 0f1f8400 <span style=color:#ae81ff>00000000</span>  .S/...f.........
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1090</span> 488d3d79 2f000048 8d05722f <span style=color:#ae81ff>00004839</span>  H.<span style=color:#f92672>=</span>y/..H..r/..H9
</span></span><span style=display:flex><span> 10a0 f8741548 8b05362f <span style=color:#ae81ff>00004885</span> c07409ff  .t.H..6/..H..t..
</span></span><span style=display:flex><span> 10b0 e00f1f80 <span style=color:#ae81ff>00000000</span> c30f1f80 <span style=color:#ae81ff>00000000</span>  ................
</span></span><span style=display:flex><span> 10c0 488d3d49 2f000048 8d35422f <span style=color:#ae81ff>00004829</span>  H.<span style=color:#f92672>=</span>I/..H.5B/..H<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> 10d0 fe4889f0 48c1ee3f 48c1f803 4801c648  .H..H..?H...H..H
</span></span><span style=display:flex><span> 10e0 d1fe7414 488b0505 2f000048 85c07408  ..t.H.../..H..t.
</span></span><span style=display:flex><span> 10f0 ffe0660f 1f440000 c30f1f80 <span style=color:#ae81ff>00000000</span>  ..f..D..........
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1100</span> f30f1efa 803d052f <span style=color:#ae81ff>00000075</span> 2b554883  .....<span style=color:#f92672>=</span>./...u+UH.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1110</span> 3de22e00 <span style=color:#ae81ff>00004889</span> e5740c48 8b3de62e  <span style=color:#f92672>=</span>.....H..t.H.<span style=color:#f92672>=</span>..
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1120</span> 0000e819 ffffffe8 64ffffff c605dd2e  ........d.......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1130</span> 0000015d c30f1f00 c30f1f80 <span style=color:#ae81ff>00000000</span>  ...<span style=color:#f92672>]</span>............
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1140</span> f30f1efa e977ffff fff30f1e fa554889  .....w.......UH.
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1150</span> e5488d05 ac0e0000 4889c7e8 f0feffff  .H......H.......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1160</span> 905dc3f3 0f1efa55 4889e5b8 <span style=color:#ae81ff>00000000</span>  .<span style=color:#f92672>]</span>.....UH.......
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1170</span> e8d4ffff ffb80000 00005dc3           ..........<span style=color:#f92672>]</span>.
</span></span></code></pre></div><p>(main refers to file name in above command, not the main function)</p><p>To get the disassembled output of <code>.text</code> section:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$  objdump -d -j .text main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001060</span> &lt;_start&gt;:
</span></span><span style=display:flex><span>   1060:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1064:	<span style=color:#ae81ff>31</span> ed                	xor    %ebp,%ebp
</span></span><span style=display:flex><span>   1066:	<span style=color:#ae81ff>49</span> <span style=color:#ae81ff>89</span> d1             	mov    %rdx,%r9
</span></span><span style=display:flex><span>   1069:	5e                   	pop    %rsi
</span></span><span style=display:flex><span>   106a:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e2             	mov    %rsp,%rdx
</span></span><span style=display:flex><span>   106d:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> e4 f0          	and    $0xfffffffffffffff0,%rsp
</span></span><span style=display:flex><span>   1071:	<span style=color:#ae81ff>50</span>                   	push   %rax
</span></span><span style=display:flex><span>   1072:	<span style=color:#ae81ff>54</span>                   	push   %rsp
</span></span><span style=display:flex><span>   1073:	<span style=color:#ae81ff>45</span> <span style=color:#ae81ff>31</span> c0             	xor    %r8d,%r8d
</span></span><span style=display:flex><span>   1076:	<span style=color:#ae81ff>31</span> c9                	xor    %ecx,%ecx
</span></span><span style=display:flex><span>   1078:	<span style=color:#ae81ff>48</span> 8d 3d e4 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0xe4<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 1163 &lt;main&gt;</span>
</span></span><span style=display:flex><span>   107f:	ff <span style=color:#ae81ff>15</span> <span style=color:#ae81ff>53</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	call   *0x2f53<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;</span>
</span></span><span style=display:flex><span>   1085:	f4                   	hlt
</span></span><span style=display:flex><span>   1086:	<span style=color:#ae81ff>66</span> 2e 0f 1f <span style=color:#ae81ff>84</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cs nopw 0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   108d:	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001090</span> &lt;deregister_tm_clones&gt;:
</span></span><span style=display:flex><span>   1090:	<span style=color:#ae81ff>48</span> 8d 3d <span style=color:#ae81ff>79</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f79<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   1097:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>72</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f72<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   109e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>39</span> f8             	cmp    %rdi,%rax
</span></span><span style=display:flex><span>   10a1:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>15</span>                	je     10b8 &lt;deregister_tm_clones+0x28&gt;
</span></span><span style=display:flex><span>   10a3:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>36</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    0x2f36<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 3fe0 &lt;_ITM_deregisterTMCloneTable@Base&gt;</span>
</span></span><span style=display:flex><span>   10aa:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>85</span> c0             	test   %rax,%rax
</span></span><span style=display:flex><span>   10ad:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>09</span>                	je     10b8 &lt;deregister_tm_clones+0x28&gt;
</span></span><span style=display:flex><span>   10af:	ff e0                	jmp    *%rax
</span></span><span style=display:flex><span>   10b1:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   10b8:	c3                   	ret
</span></span><span style=display:flex><span>   10b9:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>00000000000010c0 &lt;register_tm_clones&gt;:
</span></span><span style=display:flex><span>   10c0:	<span style=color:#ae81ff>48</span> 8d 3d <span style=color:#ae81ff>49</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f49<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   10c7:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>35</span> <span style=color:#ae81ff>42</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0x2f42<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rsi        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   10ce:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>29</span> fe             	sub    %rdi,%rsi
</span></span><span style=display:flex><span>   10d1:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> f0             	mov    %rsi,%rax
</span></span><span style=display:flex><span>   10d4:	<span style=color:#ae81ff>48</span> c1 ee 3f          	shr    $0x3f,%rsi
</span></span><span style=display:flex><span>   10d8:	<span style=color:#ae81ff>48</span> c1 f8 <span style=color:#ae81ff>03</span>          	sar    $0x3,%rax
</span></span><span style=display:flex><span>   10dc:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>01</span> c6             	add    %rax,%rsi
</span></span><span style=display:flex><span>   10df:	<span style=color:#ae81ff>48</span> d1 fe             	sar    $1,%rsi
</span></span><span style=display:flex><span>   10e2:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>14</span>                	je     10f8 &lt;register_tm_clones+0x38&gt;
</span></span><span style=display:flex><span>   10e4:	<span style=color:#ae81ff>48</span> 8b <span style=color:#ae81ff>05</span> <span style=color:#ae81ff>05</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    0x2f05<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 3ff0 &lt;_ITM_registerTMCloneTable@Base&gt;</span>
</span></span><span style=display:flex><span>   10eb:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>85</span> c0             	test   %rax,%rax
</span></span><span style=display:flex><span>   10ee:	<span style=color:#ae81ff>74</span> <span style=color:#ae81ff>08</span>                	je     10f8 &lt;register_tm_clones+0x38&gt;
</span></span><span style=display:flex><span>   10f0:	ff e0                	jmp    *%rax
</span></span><span style=display:flex><span>   10f2:	<span style=color:#ae81ff>66</span> 0f 1f <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	nopw   0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   10f8:	c3                   	ret
</span></span><span style=display:flex><span>   10f9:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001100</span> &lt;__do_global_dtors_aux&gt;:
</span></span><span style=display:flex><span>   1100:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1104:	<span style=color:#ae81ff>80</span> 3d <span style=color:#ae81ff>05</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cmpb   $0x0,0x2f05<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   110b:	<span style=color:#ae81ff>75</span> 2b                	jne    <span style=color:#ae81ff>1138</span> &lt;__do_global_dtors_aux+0x38&gt;
</span></span><span style=display:flex><span>   110d:	<span style=color:#ae81ff>55</span>                   	push   %rbp
</span></span><span style=display:flex><span>   110e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>83</span> 3d e2 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	cmpq   $0x0,0x2ee2<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>   1115:	<span style=color:#ae81ff>00</span>
</span></span><span style=display:flex><span>   1116:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>   1119:	<span style=color:#ae81ff>74</span> 0c                	je     <span style=color:#ae81ff>1127</span> &lt;__do_global_dtors_aux+0x27&gt;
</span></span><span style=display:flex><span>   111b:	<span style=color:#ae81ff>48</span> 8b 3d e6 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	mov    0x2ee6<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rdi        <span style=color:#75715e># 4008 &lt;__dso_handle&gt;</span>
</span></span><span style=display:flex><span>   1122:	e8 <span style=color:#ae81ff>19</span> ff ff ff       	call   <span style=color:#ae81ff>1040</span> &lt;__cxa_finalize@plt&gt;
</span></span><span style=display:flex><span>   1127:	e8 <span style=color:#ae81ff>64</span> ff ff ff       	call   <span style=color:#ae81ff>1090</span> &lt;deregister_tm_clones&gt;
</span></span><span style=display:flex><span>   112c:	c6 <span style=color:#ae81ff>05</span> dd 2e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> 	movb   $0x1,0x2edd<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 4010 &lt;__TMC_END__&gt;</span>
</span></span><span style=display:flex><span>   1133:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>   1134:	c3                   	ret
</span></span><span style=display:flex><span>   1135:	0f 1f <span style=color:#ae81ff>00</span>             	nopl   <span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>   1138:	c3                   	ret
</span></span><span style=display:flex><span>   1139:	0f 1f <span style=color:#ae81ff>80</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001140</span> &lt;frame_dummy&gt;:
</span></span><span style=display:flex><span>   1140:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1144:	e9 <span style=color:#ae81ff>77</span> ff ff ff       	jmp    10c0 &lt;register_tm_clones&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001149</span> &lt;greet&gt;:
</span></span><span style=display:flex><span>   1149:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   114d:	<span style=color:#ae81ff>55</span>                   	push   %rbp
</span></span><span style=display:flex><span>   114e:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>   1151:	<span style=color:#ae81ff>48</span> 8d <span style=color:#ae81ff>05</span> ac 0e <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 	lea    0xeac<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>,%rax        <span style=color:#75715e># 2004 &lt;_IO_stdin_used+0x4&gt;</span>
</span></span><span style=display:flex><span>   1158:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> c7             	mov    %rax,%rdi
</span></span><span style=display:flex><span>   115b:	e8 f0 fe ff ff       	call   <span style=color:#ae81ff>1050</span> &lt;puts@plt&gt;
</span></span><span style=display:flex><span>   1160:	<span style=color:#ae81ff>90</span>                   	nop
</span></span><span style=display:flex><span>   1161:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>   1162:	c3                   	ret
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001163</span> &lt;main&gt;:
</span></span><span style=display:flex><span>   1163:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>   1167:	<span style=color:#ae81ff>55</span>                   	push   %rbp
</span></span><span style=display:flex><span>   1168:	<span style=color:#ae81ff>48</span> <span style=color:#ae81ff>89</span> e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>   116b:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    $0x0,%eax
</span></span><span style=display:flex><span>   1170:	e8 d4 ff ff ff       	call   <span style=color:#ae81ff>1149</span> &lt;greet&gt;
</span></span><span style=display:flex><span>   1175:	b8 <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	mov    $0x0,%eax
</span></span><span style=display:flex><span>   117a:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>   117b:	c3                   	ret
</span></span></code></pre></div><p>It converts raw bytes back to assembly mnemonics.</p><p>Each line in the disassembly follows this pattern:</p><pre tabindex=0><code>ADDRESS: MACHINE_CODE    ASSEMBLY_INSTRUCTION    COMMENTS
</code></pre><p>We can see the <code>_start</code> label is at address 1060, which matches with the start address mentioned in ELF header.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -h main | grep <span style=color:#e6db74>&#34;Entry point address:&#34;</span>
</span></span><span style=display:flex><span>  Entry point address:               0x1060
</span></span></code></pre></div><p>We can see the definitions of <code>main</code> and <code>greet</code> functions in assembly.</p><p>We can see <code>main()</code> calls <code>greet()</code>
<code>1170: call 1149 &lt;greet></code></p><p><code>greet()</code> calls <code>puts@plt</code>
<code>115b: call 1050 &lt;puts@plt></code></p><p><code>puts@plt</code> is in <code>.plt</code> section (dynamic linking)</p><p><code>greet()</code> references string in <code>.rodata</code>
<code>1151: lea 0xeac(%rip),%rax # Points to 0x2004 in .rodata</code></p><p>(%rip) means RIP-relative addressing. RIP-relative addressing means the address is computed relative to the current instruction pointer.</p><pre tabindex=0><code>effective_address = current_instruction_address + displacement
effective_address = 0x1151 + 0xEAC = 0x2004
</code></pre><p>We can verify that address falls in the range of <code>.rodata</code> section.</p><pre tabindex=0><code> [18] .rodata           PROGBITS         0000000000002000  00002000
       0000000000000010  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002010  00002010
       000000000000003c  0000000000000000   A       0     0     4
</code></pre><p>We can also inspect the <code>.rodata</code> section to confirm it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$  readelf -x .rodata main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hex dump of section <span style=color:#e6db74>&#39;.rodata&#39;</span>:
</span></span><span style=display:flex><span>  0x00002000 <span style=color:#ae81ff>01000200</span> 48656c6c 6f2c2045 4c462100 ....Hello, ELF!.
</span></span></code></pre></div><h3 id=2-plt-procedure-linkage-table>2. .plt (Procedure Linkage Table)<a hidden class=anchor aria-hidden=true href=#2-plt-procedure-linkage-table>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_PROGBITS</code></li><li><strong>Flags:</strong> <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)</li><li><strong>Contains:</strong> Stubs for calling shared library functions</li></ul><p>The Procedure Linkage Table (PLT) is a section in ELF executables and shared libraries that enables lazy binding — meaning, external (shared library) functions like printf, puts, or malloc are resolved only when first called, not when the program starts.</p><p>When your program calls puts(&ldquo;hi&rdquo;);, the compiler doesn’t know where puts actually lives — it’s defined in the C library (libc.so.6).
So instead of a direct call, it generates a call to a stub in <code>.plt</code>.
This stub is responsible for eventually reaching the real puts function in memory.</p><p>To inspect the PLT of our program</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -j .plt main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .plt:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001020</span> &lt;.plt&gt;:
</span></span><span style=display:flex><span>    1020:	ff <span style=color:#ae81ff>35</span> 9a 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	push   0x2f9a<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span>
</span></span><span style=display:flex><span>    1026:	ff <span style=color:#ae81ff>25</span> 9c 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	jmp    *0x2f9c<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span>
</span></span><span style=display:flex><span>    102c:	0f 1f <span style=color:#ae81ff>40</span> <span style=color:#ae81ff>00</span>          	nopl   0x0<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    1030:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1034:	<span style=color:#ae81ff>68</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>       	push   $0x0
</span></span><span style=display:flex><span>    1039:	e9 e2 ff ff ff       	jmp    <span style=color:#ae81ff>1020</span> &lt;_init+0x20&gt;
</span></span><span style=display:flex><span>    103e:	<span style=color:#ae81ff>66</span> <span style=color:#ae81ff>90</span>                	xchg   %ax,%ax
</span></span></code></pre></div><ul><li>The first instruction jumps via the GOT (Global Offset Table).</li><li>The push+jump sequence helps the dynamic linker resolve the symbol the first time it’s used</li></ul><h3 id=3-pltgot>3. .plt.got<a hidden class=anchor aria-hidden=true href=#3-pltgot>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)</li><li><strong>Contains</strong>: PLT entries for GOT references</li></ul><p>The <code>.plt.got</code> section is an extension of the traditional <code>.plt</code>, used primarily in position-independent executables (PIE) and shared libraries.</p><p>When the compiler generates smaller or more optimized PLT entries, it sometimes places them in <code>.plt.got</code> instead of <code>.plt</code>.</p><p>These entries rely more directly on the GOT (Global Offset Table) for function address lookups, reducing the indirection and improving performance slightly.</p><p>You’ll usually see <code>.plt.got</code> in binaries built with:</p><ul><li>GCC’s newer toolchains</li><li>PIE (Position Independent Executable) enabled</li><li>Or with RELRO and lazy binding disabled (<code>-Wl,-z,now</code>)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .plt
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>11<span style=color:#f92672>]</span> .rela.plt         RELA             <span style=color:#ae81ff>0000000000000610</span>  <span style=color:#ae81ff>00000610</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>13<span style=color:#f92672>]</span> .plt              PROGBITS         <span style=color:#ae81ff>0000000000001020</span>  <span style=color:#ae81ff>00001020</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> .plt.got          PROGBITS         <span style=color:#ae81ff>0000000000001040</span>  <span style=color:#ae81ff>00001040</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>15<span style=color:#f92672>]</span> .plt.sec          PROGBITS         <span style=color:#ae81ff>0000000000001050</span>  <span style=color:#ae81ff>00001050</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -j .plt.got main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .plt.got:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001040</span> &lt;__cxa_finalize@plt&gt;:
</span></span><span style=display:flex><span>    1040:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1044:	ff <span style=color:#ae81ff>25</span> ae 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	jmp    *0x2fae<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>    104a:	<span style=color:#ae81ff>66</span> 0f 1f <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	nopw   0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>You’ll find shorter stubs, sometimes just a single indirect jump via the GOT — because by this point, all symbols are already resolved.</p><h3 id=4-pltsec>4. .plt.sec<a hidden class=anchor aria-hidden=true href=#4-pltsec>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_PROGBITS</code></li><li><strong>Flags:</strong> <code>SHF_ALLOC | SHF_EXECINSTR</code> (AX)</li><li><strong>Contains:</strong> Secure PLT stubs (used in hardened binaries)</li></ul><p>The <code>.plt.sec</code> section is a <strong>security-enhanced variant</strong> of the traditional <code>.plt</code>.
It’s introduced in <strong>modern toolchains</strong> (GCC ≥ 9, binutils ≥ 2.31) to support <strong>Control Flow Integrity (CFI)</strong> and <strong>Intel’s Indirect Branch Tracking (IBT)</strong> features.</p><p>Each entry in <code>.plt.sec</code> is similar to a normal PLT stub, but with additional instructions or metadata to <strong>prevent malicious redirection of function calls</strong> — protecting against attacks like <strong>Return-Oriented Programming (ROP)</strong> or <strong>GOT overwrite exploits</strong>.</p><p>You’ll usually see <code>.plt.sec</code> when your binary is built with flags like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-fpie -fcf-protection<span style=color:#f92672>=</span>full -O2
</span></span></code></pre></div><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -S main | grep .plt
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>13<span style=color:#f92672>]</span> .plt              PROGBITS         <span style=color:#ae81ff>0000000000001030</span>  <span style=color:#ae81ff>00001030</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>14<span style=color:#f92672>]</span> .plt.got          PROGBITS         <span style=color:#ae81ff>0000000000001060</span>  <span style=color:#ae81ff>00001060</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>15<span style=color:#f92672>]</span> .plt.sec          PROGBITS         <span style=color:#ae81ff>0000000000001080</span>  <span style=color:#ae81ff>00001080</span>
</span></span></code></pre></div><p>Disassembly (simplified example):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ objdump -d -j .plt.sec main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .plt.sec:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000001050</span> &lt;puts@plt&gt;:
</span></span><span style=display:flex><span>    1050:	f3 0f 1e fa          	endbr64
</span></span><span style=display:flex><span>    1054:	ff <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>76</span> 2f <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	jmp    *0x2f76<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        <span style=color:#75715e># 3fd0 &lt;puts@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>    105a:	<span style=color:#ae81ff>66</span> 0f 1f <span style=color:#ae81ff>44</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>    	nopw   0x0<span style=color:#f92672>(</span>%rax,%rax,1<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The <code>endbr64</code> instruction (added by GCC for IBT) is used to mark safe entry points for indirect jumps — the CPU validates that control flow only transfers to legitimate call targets.</p><h2 id=data-sections>Data Sections<a hidden class=anchor aria-hidden=true href=#data-sections>#</a></h2><h3 id=1-rodata---read-only-data>1. .rodata - Read-Only Data<a hidden class=anchor aria-hidden=true href=#1-rodata---read-only-data>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_ALLOC</code> (A)</li><li><strong>Contains</strong>: Constants, string literals</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>;  <span style=color:#75715e>// String stored in .rodata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> max <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -x .rodata main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hex dump of section <span style=color:#e6db74>&#39;.rodata&#39;</span>:
</span></span><span style=display:flex><span>  0x00002000 <span style=color:#ae81ff>01000200</span> 48656c6c 6f2c2045 4c462100 ....Hello, ELF!.
</span></span></code></pre></div><p>The <code>.rodata</code> section stores data that should never be modified at runtime.
Typical contents include:</p><ul><li>String literals (&ldquo;Hello, ELF!&rdquo;)</li><li>const variables in C/C++</li><li>Floating-point constants</li><li>Lookup or jump tables generated by the compiler</li></ul><p>Because it’s read-only, this section is usually mapped into memory with read-only permissions (R-) by the OS loader.</p><p>This prevents accidental modification and improves security — if a program tries to modify it, it will trigger a segmentation fault.</p><h3 id=2-data---initialized-data>2. .data - Initialized Data<a hidden class=anchor aria-hidden=true href=#2-data---initialized-data>#</a></h3><ul><li><strong>Type</strong>: <code>SHT_PROGBITS</code></li><li><strong>Flags</strong>: <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains</strong>: Initialized global and static variables</li></ul><p>The <code>.data</code> section stores all read–write variables whose initial values are known at compile time.
These variables are part of the executable image — the compiler embeds their initial values directly into the ELF file.
When the program loads into memory, the loader copies these values into writable memory so your program can modify them at runtime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> global_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;           <span style=color:#75715e>// Stored in .data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> static_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;   <span style=color:#75715e>// Stored in .data
</span></span></span></code></pre></div><h3 id=3-bss--uninitialized-data>3. .bss — Uninitialized Data<a hidden class=anchor aria-hidden=true href=#3-bss--uninitialized-data>#</a></h3><ul><li><strong>Type:</strong> <code>SHT_NOBITS</code></li><li><strong>Flags:</strong> <code>SHF_WRITE | SHF_ALLOC</code> (WA)</li><li><strong>Contains:</strong> Uninitialized global and static variables (default-initialized to zero)</li></ul><p>The <code>.bss</code> section holds <strong>variables that exist for the lifetime of the program</strong> (global or static), but <strong>don’t have explicit initial values</strong> in your source code.
Unlike <code>.data</code>, this section <strong>does not occupy any space in the ELF file itself</strong> — only the <em>size</em> is recorded.
When the program loads, the OS automatically allocates memory for <code>.bss</code> and <strong>fills it with zeros</strong>.</p><hr><p>Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> global_uninit;          <span style=color:#75715e>// Goes into .bss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> static_uninit;   <span style=color:#75715e>// Goes into .bss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> global_uninit;   <span style=color:#75715e>// Initially 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Inspect:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gcc -o main main.c
</span></span><span style=display:flex><span>$ readelf -S main | grep .bss
</span></span><span style=display:flex><span>  <span style=color:#f92672>[</span>25<span style=color:#f92672>]</span> .bss              NOBITS           <span style=color:#ae81ff>0000000000004000</span>  <span style=color:#ae81ff>00003010</span>
</span></span></code></pre></div><p>Notice the <strong><code>NOBITS</code></strong> type — that means no bytes are actually stored in the file; only the <em>size</em> (number of bytes required) is recorded.</p><p>If you dump it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ readelf -x .bss main
</span></span><span style=display:flex><span>readelf: Warning: Section <span style=color:#e6db74>&#39;.bss&#39;</span> has no data to dump.
</span></span></code></pre></div><p>That’s because <code>.bss</code> doesn’t exist in the binary — it’s just a placeholder for the loader.</p><hr><p><strong>What Happens at Runtime</strong></p><ol><li>The loader allocates memory for <code>.bss</code> variables.</li><li>It initializes all bytes to <strong>zero</strong> (per the C standard).</li><li>The variables behave like normal globals at runtime.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/elf/>Elf</a></li><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse Engineering</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>