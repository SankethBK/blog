---
title: "GDB x Command"
date: 2025-11-04
categories: ["cheatsheet", "ctf"]
tags: ["reverse-engineering", "gdb"]
author: "Sanketh"
---


# GDB x Command (Examine Memory)

Format: `x/[count][format][size] address`

- count = how many units to display
- format = how to display (x=hex, d=decimal, s=string, i=instruction, etc.)
- size = size of each unit (b=byte, h=halfword, w=word, g=giant/8bytes)

**Command 1: x/8gx $rsi**

```
(gdb) x/8gx $rsi
0x7fffffffdf80: 0x000055555555601c 0x00007fffffffe3fa
0x7fffffffdf90: 0x00007fffffffe080 0x4e39f1740a528200
0x7fffffffdfa0: 0x00007fffffffe040 0x00007ffff7c2a1ca
0x7fffffffdfb0: 0x00007fffffffdff0 0x00007fffffffe0c8
```

Breakdown:

- x/ = examine command
- 8 = show 8 units
- g = each unit is giant (8 bytes = 64 bits)
- x = display in hexadecimal
- $rsi = starting address (0x7fffffffdf80)


This displays the argv array as 8 pointers (each 8 bytes on x86-64):

```c
char *argv[] = {
    0x000055555555601c,  // argv[0]
    0x00007fffffffe3fa,  // argv[1]
    0x00007fffffffe080,  // argv[2]
    0x4e39f1740a528200,  // argv[3] ← GARBAGE!
    0x00007fffffffe040,  // argv[4]
    0x00007ffff7c2a1ca,  // argv[5]
    0x00007fffffffdff0,  // argv[6]
    0x00007fffffffe0c8   // argv[7]
};
```

**Command 2: x/32bx $rsi**

```
(gdb) x/32bx $rsi       
0x7fffffffdf80: 0x1c 0x60 0x55 0x55 0x55 0x55 0x00 0x00
0x7fffffffdf88: 0xfa 0xe3 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdf90: 0x80 0xe0 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdf98: 0x00 0x82 0x52 0x0a 0x74 0xf1 0x39 0x4e
```

**Breakdown:**
- `32` = show **32 units**
- `b` = each unit is **byte** (1 byte = 8 bits)
- `x` = display in **hexadecimal**

**What it shows:**
The **same data** but displayed as individual bytes (little-endian format):
```
Bytes:    0x1c 0x60 0x55 0x55 0x55 0x55 0x00 0x00
          └────────────────────────────────────┘
          Becomes: 0x000055555555601c (pointer)

Bytes:    0xfa 0xe3 0xff 0xff 0xff 0x7f 0x00 0x00
          └────────────────────────────────────┘
          Becomes: 0x00007fffffffe3fa (pointer)
```

**Command 3: x/s <address>**

```c
(gdb) x/s 0x000055555555601c
0x55555555601c: ""

(gdb) x/s 0x00007fffffffe3fa
0x7fffffffe3fa: ""
```

**Breakdown:**
- `s` = display as **string** (null-terminated)
- Reads bytes until it hits `\0`

**What it shows:**
- Follow the pointer to see **what string it points to**
- `0x000055555555601c` → points to empty string `""`
- `0x00007fffffffe3fa` → also points to empty string `""`
