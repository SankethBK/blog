---
title: "GDB print Command"
date: 2025-11-09
categories: ["cheatsheet", "ctf"]
tags: ["reverse-engineering", "gdb"]
author: "Sanketh"
---

# GDB Print Command Reference Guide

## Basic Print Command

```gdb
print variable_name
p variable_name          # Short form
```

---

## Print with Format Specifiers

Use `/format` after print to specify output format:

### Hexadecimal
```gdb
print/x variable         # Hex (lowercase)
print/x value           # Example: 0x5
p/x 255                 # Output: 0xff
```

### Decimal
```gdb
print/d variable         # Signed decimal
print/u variable         # Unsigned decimal
p/d 0xff                # Output: 255
```

### Octal
```gdb
print/o variable         # Octal format
p/o 64                  # Output: 0100
```

### Binary
```gdb
print/t variable         # Binary (t = "two")
p/t 5                   # Output: 101
```

### Character
```gdb
print/c variable         # As ASCII character
p/c 65                  # Output: 'A'
```

### Floating Point
```gdb
print/f variable         # Floating point
p/f 3.14159
```

### Address/Pointer
```gdb
print/a variable         # As address
p/a 0x555555555189      # Shows as address
```

### String
```gdb
print/s pointer          # Interpret as C string
p/s argv[1]
```

---

## Working with Pointers

```gdb
print pointer            # Shows address
print *pointer           # Dereference (shows value)
print &variable          # Shows address of variable

# Example
print argv               # Address of argv array
print *argv              # First element (argv[0])
print argv[1]            # Second element
print *argv[1]           # First char of argv[1]
```

---

## Array and String Operations

```gdb
# Print entire array
print buffer_one
print buffer_two

# Print specific elements
print buffer_one[0]
print buffer_one[3]

# Print array slice (if supported)
print buffer_one@8       # Print 8 elements starting at buffer_one

# View string with length
x/8c buffer_one          # First 8 chars
x/s buffer_one           # Until null terminator
```

---

## Type Casting

```gdb
# Cast to different types
print (int *)buffer_one          # Treat as int pointer
print *(int *)buffer_one         # Dereference as int
print (unsigned char)value       # Cast to unsigned char

# Example: View buffer as integers
print *(int *)&buffer_one
print *(long *)&buffer_two
```

---

## Expressions and Calculations

```gdb
# Arithmetic
print value + 10
print sizeof(buffer_one)
print strlen(buffer_one)

# Address calculations
print &buffer_one - &buffer_two
print (long)&value - (long)&buffer_one

# Pointer arithmetic
print argv[0]
print *(argv + 1)
```

---

## Display Commands (Auto-Print)

Set up variables to display automatically after each step:

```gdb
display variable         # Auto-print after each command
display/x value          # Auto-print in hex
display/8xb buffer_one   # Auto-print 8 bytes in hex

# Manage displays
info display             # List all displays
delete display 1         # Remove display #1
disable display 2        # Temporarily disable
enable display 2         # Re-enable
```

---

## Useful Combinations

### Stack Analysis
```gdb
# View stack pointer and nearby memory
print $rsp
x/32xw $rsp              # 32 words from stack pointer
x/64xb $rsp              # 64 bytes from stack pointer
```

### Registers
```gdb
print $rax               # Print register value
print/x $rip             # Instruction pointer in hex
info registers           # All registers
info registers rax rbx   # Specific registers
```

### Function Arguments
```gdb
print argc
print argv
print argv[0]
print argv[1]
x/s argv[0]              # Program name as string
x/s argv[1]              # First argument as string
```

---


### Side-by-Side Memory View
```gdb
# Define a custom command
define show_buffers
    echo \n=== BUFFER_TWO ===\n
    x/8xb &buffer_two
    echo \n=== BUFFER_ONE ===\n
    x/8xb &buffer_one
    echo \n=== VALUE ===\n
    print/x value
    echo \n
end

# Use it
show_buffers
```

---

## Advanced: Pretty Printing Structures

```gdb
# Enable pretty printing
set print pretty on
set print array on
set print array-indexes on

# Print structure
print my_struct

# Print specific field
print my_struct.field_name
```

---

## Quick Reference Table

| Command | Purpose | Example |
|---------|---------|---------|
| `p var` | Print variable | `p value` |
| `p/x var` | Print in hex | `p/x value` |
| `p/d var` | Print in decimal | `p/d 0xff` |
| `p/t var` | Print in binary | `p/t 5` |
| `p/c var` | Print as char | `p/c 65` |
| `p &var` | Print address | `p &value` |
| `p *ptr` | Dereference pointer | `p *argv` |
| `x/8xb addr` | 8 bytes in hex | `x/8xb &buffer` |
| `x/4xw addr` | 4 words in hex | `x/4xw $rsp` |
| `x/s addr` | String at address | `x/s buffer_one` |
| `x/10i addr` | 10 instructions | `x/10i main` |
| `display var` | Auto-display | `display/x value` |

---

## Pro Tips

1. **Use tab completion**: Type `p buf` then press TAB to complete variable names
2. **Repeat last command**: Press ENTER to repeat the last command
3. **Command history**: Use UP/DOWN arrows to navigate command history
4. **Save typing**: Use `p` instead of `print`, `x` instead of `examine`
5. **Combine with info**: `info locals`, `info args`, `info registers`
6. **Set convenience variables**: `set $myvar = value` then `print $myvar`

---

## Troubleshooting Print Issues

### Variable not accessible
```
Error: No symbol "var" in current context
```
**Solution**: Make sure you're at the right scope/breakpoint and compiled with `-g`

### Optimized out
```
value = <optimized out>
```
**Solution**: Compile with `-O0` flag (no optimization)

### Address not mapped
```
Cannot access memory at address 0x0
```
**Solution**: Check if pointer is NULL or invalid

