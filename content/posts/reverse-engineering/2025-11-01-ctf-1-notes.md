---
title:  "CTF - 1"
date:   2025-11-01
categories: ["ctf"]
tags: ["ctf", "reverse engineering", "notes"]
author: Sanketh
draft: true
references:
  - title: Matryoshka
    url: https://crackmes.one/crackme/68ff42b82d267f28f69b78c8
---
 
# Solving CTF Challenges (1) (My Notes)

Reverse enginnering is a processes of understanding the working of a software without the knowledge of how it was built. Here we will specifically take compiled binaries and understand their working. Capture the Flag (CTF) challenges involve answering a specific question about the binary, in order to achieve that we need to deconstruct it in various steps and understand its working model. 

Since i spent some time learning about ELF format, solving some of these problems seems like a natural next step towards learning about low level systems. My goal is not just to solve these challenges, but gain deeper insight about OS and CPU topics that each challenge makes use of. 

## 1. Static Analysis

Static analysis involves gathering information about the binary without executing it.

```bash
file ./binary           # Type, architecture, stripped/not stripped
strings ./binary        # Human-readable text
checksec ./binary       # Security features (PIE, NX, canaries, RELRO)
```


We can start by looking at the ELF header of this file

```bash
$ readelf -h matryoshka
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x10d0
  Start of program headers:          64 (bytes into file)
  Start of section headers:          56200 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         14
  Size of section headers:           64 (bytes)
  Number of section headers:         28
  Section header string table index: 27
```

We can see Type is **ET_DYN** which means this is either a shared object file (.so) or a PIE executable. The presence of `INTERP` segment confirms its an executable not a shared object. 

```bash
$ readelf -l matryoshka | grep -i interp
  INTERP         0x00000000000003b4 0x00000000000003b4 0x00000000000003b4
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

A more convinient command is `file`, it fetches all these useful info from different places of ELF and ddisplays it in short readable way

```bash
$ file matryoshka
matryoshka: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a005b965dcf1c71f7432d65f469dc77b292c6347, for GNU/Linux 4.4.0, stripped
```

**Stripped** means `.symtab` section has been removed from the file, which makes producing the exact C program via decompilation impossible as we will never know the exact variable names.

**strings** program helps to view all raw strings baked into the binary. For CTF challenges, we can goin important insights about the binary by looking at its raw strings, although its unlikely that we find the actual flag here. 

```bash
$ strings ./matryoshka
{),cG/lib64/ld-linux-x86-64.so.2
rewind
puts
__stack_chk_fail
ftruncate
execve
```

- strings finds runs of printable characters in a file and prints each run whose length ≥ a minimum (default 4).
- For plain files it scans the whole file. For object files / executables it usually scans only the data-like sections (e.g. .rodata, .data, other non-executable PROGBITS) — it uses libbfd (binutils) to discover those sections.
- “Printable” is determined by the C locale isprint() or by Unicode/UTF-16 detection when you use -e (encoding) options.
- It does not need a NUL terminator — it just finds consecutive printable bytes terminated by a non-printable byte.

We can also find the strings with say greater than 10 chars to see more interesting strings. 

```bash
$ strings -n 10 matryoshka
{),cG/lib64/ld-linux-x86-64.so.2
__stack_chk_fail
__libc_start_main
memfd_create
__cxa_finalize
GLIBC_2.2.5
GLIBC_2.27
GLIBC_2.34
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
usage: ./matryoshka key
/proc/self/fd/%d
 cfm9; ck"cfazw"w79"9;!|`!=
PP|{nldPlgdPinfc
PPcfmlP|{n}{Pbnfa
bjbikPl}jn{j
PPlwnPifancfuj
```

We can also pipe the output of strings to less program to prevent flooding of our terminal. 

Next we can run checksec program

```bash
f$ checksec --file=./matryoshka
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   No Symbols	  No	0		1		./matryoshka
```

| Feature | Status | Meaning | 
|---------|--------|---------|
| Partial RELRO | ✓ | Some memory sections are read-only (makes exploitation harder)
| Stack Canary | ✓ | Detects stack buffer overflows (we can see with __stack_chk_fail)
| NX enabled | ✓ | Stack is not executable (can't run shellcode on stack)
| PIE enabled | ✓ | Position Independent Executable (randomized addresses)
| No Symbols | ✓ | Stripped! (That's why no main symbol)

Next we can see relocations

```bash
$ readelf -r matryoshka

Relocation section '.rela.dyn' at offset 0x6d8 contains 8 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000003dd0  000000000008 R_X86_64_RELATIVE                    11c0
000000003dd8  000000000008 R_X86_64_RELATIVE                    1170
000000004068  000000000008 R_X86_64_RELATIVE                    4068
000000003fc0  000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.34 + 0
000000003fc8  000300000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0
000000003fd0  000900000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000003fd8  000e00000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0
000000003fe0  000f00000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0

Relocation section '.rela.plt' at offset 0x798 contains 10 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000004000  000200000007 R_X86_64_JUMP_SLO 0000000000000000 memfd_create@GLIBC_2.27 + 0
000000004008  000400000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
000000004010  000500000007 R_X86_64_JUMP_SLO 0000000000000000 __stack_chk_fail@GLIBC_2.4 + 0
000000004018  000600000007 R_X86_64_JUMP_SLO 0000000000000000 rewind@GLIBC_2.2.5 + 0
000000004020  000700000007 R_X86_64_JUMP_SLO 0000000000000000 ftruncate@GLIBC_2.2.5 + 0
000000004028  000800000007 R_X86_64_JUMP_SLO 0000000000000000 execve@GLIBC_2.2.5 + 0
000000004030  000a00000007 R_X86_64_JUMP_SLO 0000000000000000 fileno@GLIBC_2.2.5 + 0
000000004038  000b00000007 R_X86_64_JUMP_SLO 0000000000000000 fdopen@GLIBC_2.2.5 + 0
000000004040  000c00000007 R_X86_64_JUMP_SLO 0000000000000000 sprintf@GLIBC_2.2.5 + 0
000000004048  000d00000007 R_X86_64_JUMP_SLO 0000000000000000 fwrite@GLIBC_2.2.5 + 0
```

This will give an idea of what are the calls to libc this binary is making. 

`memfd_create` is one of the unique system calls here.

> memfd_create() creates an anonymous file and returns a file
       descriptor that refers to it.  The file behaves like a regular
       file, and so can be modified, truncated, memory-mapped, and so on.
       However, unlike a regular file, it lives in RAM and has a volatile
       backing storage.  Once all references to the file are dropped, it
       is automatically released.  Anonymous memory is used for all
       backing pages of the file. 
       The name supplied in name is used as a filename and will be
       displayed as the target of the corresponding symbolic link in the
       directory /proc/self/fd/.  The displayed name is always prefixed
       with memfd: and serves only for debugging purposes.  Names do not
       affect the behavior of the file descriptor, and as such multiple
       files can have the same name without any side effects.

Now this is as far we can go with static analysis. Even if we can somehow understand the raw x86 assembly code, we don't have the code of libc functions which will be plugged by dynamic linker. 

## 2. Decompilation

Decompilation is the process of converting compiled computer code, such as machine code or bytecode, back into a higher-level programming language

### How Decompilers work?

Decompilers reverse the work of compilers:
**assembly → high-level code (C-like)**.
This is difficult because compilation destroys information such as local variable names, comments, struct names, and exact types.

Decompilers use a multi-stage process to reconstruct higher-level meaning.

### 1. Disassembly

* Parse the binary format (ELF, Mach-O, PE)
* Identify code vs data regions
* Decode instructions into machine-level operations
* Build **basic blocks**
* Build a **control-flow graph (CFG)**

This gives the structure of the program at a low level.

### 2. Instruction Lifting to IR (Intermediate Representation)

Most decompilers translate raw assembly into a simplified, uniform IR.

* Ghidra uses **P-code**
* Binary Ninja uses **MLIL**
* IDA Pro uses **microcode**

IR is easier to analyze than raw x86.

Example transformation:

```asm
mov eax, [ebp-4]
add eax, 1
```

becomes (P-code-like):

```
eax = *(ebp-4)
eax = eax + 1
```

IR normalizes away architecture-specific quirks.

### 3. Data-Flow Analysis

Goal: Reconstruct *variables* from registers & stack slots.

* Track where values are defined and used
* Follow register lifetimes
* Track stack offsets (e.g., `[ebp-0x10]`)
* Identify memory accesses belonging to the same logical variable

Results:

* Local variables created
* Temporary SSA variables
* Propagation of constants
* Identification of dead code

### 4. Type Recovery

Types are not preserved in machine code, so decompilers infer them:

* Size of loads/stores (1, 2, 4, 8 bytes → char, short, int, long)
* Pointer arithmetic patterns
* Function signatures (from symbol tables or calling conventions)
* Comparisons (e.g., pointer vs integer)
* Struct field offsets

Type recovery is heuristic and imperfect.

### 5. Control-Flow Recovery

Assembly has only jumps; high-level languages have structured flow.

The decompiler analyzes the CFG and matches patterns to rebuild:

* `if` / `else`
* `while` / `do` / `for`
* `switch`
* Conditional operators
* Short-circuit boolean logic

Jump patterns → loop patterns
Jump tables → switch statements

### 6. High-Level Structure Reconstruction

Using IR, data flow, and control-flow results:

* Produce a tree-like representation of the function
* Identify expressions and subexpressions
* Recognize function-call patterns
* Combine instructions into C operations (e.g., `a = b + c * d`)
* Handle SSA → normal variable rewriting

This is where messy machine-level operations begin resembling readable C.

### 7. C-like Code Generation

Finally the decompiler outputs human-readable code:

* Emit variables (`local_10`, `iVar3`, etc.)
* Reconstruct control structures
* Insert inferred types
* Reconstruct array or struct access when possible
* Rename variables (if debug symbols exist, use real names)

This code is **not** the original C but *functionally equivalent*.

## Accuracy: What Decompilers Can and Cannot Recover

### sually accurate:

* Logic and branching
* Arithmetic and expressions
* Loops and conditionals
* Function calls
* Memory access patterns
* Global variable usage

### Impossible to recover without debug info:

* Comments
* Exact variable names
* Exact type names
* Macros
* Original formatting
* Inlined function boundaries
* Template/generic information

The decompiler reconstructs meaning, not the original source.

I will use two tools **Ghidra** and **Radare2** for decompilation, although r2 uses ghidra's decompilation plugin for decompilation, i want to use them to get familiar with the tools. 

To load a program into r2:

```bash
$ r2 matryoshka 
WARN: Relocs has not been applied. Please use `-e bin.relocs.apply=true` or `-e bin.cache=true` next time
 -- Temporally drop the verbosity prefixing the commands with ':'
[0x000010d0]> 
```

From ELF header we previously saw 0x000010d0 was the entrypoint of the program

We can use `aaa` command to analyze all and `afl` to list all functions.

```bash
[0x000010d0]> aaa
INFO: Analyze all flags starting with sym. and entry0 (aa)
INFO: Analyze imports (af@@@i)
INFO: Analyze entrypoint (af@ entry0)
INFO: Analyze symbols (af@@@s)
INFO: Analyze all functions arguments/locals (afva@@@F)
INFO: Analyze function calls (aac)
INFO: Analyze len bytes of instructions for references (aar)
INFO: Finding and parsing C++ vtables (avrr)
INFO: Analyzing methods (af @@ method.*)
INFO: Recovering local variables (afva@@@F)
INFO: Type matching analysis for all functions (aaft)
INFO: Propagate noreturn information (aanr)
INFO: Use -AA or aaaa to perform additional experimental analysis
[0x000010d0]> afl
0x00001030    1      6 sym.imp.memfd_create
0x00001040    1      6 sym.imp.puts
0x00001050    1      6 sym.imp.__stack_chk_fail
0x00001060    1      6 sym.imp.rewind
0x00001070    1      6 sym.imp.ftruncate
0x00001080    1      6 sym.imp.execve
0x00001090    1      6 sym.imp.fileno
0x000010a0    1      6 sym.imp.fdopen
0x000010b0    1      6 sym.imp.sprintf
0x000010c0    1      6 sym.imp.fwrite
0x000010d0    1     37 entry0
0x000011c9    8    176 main
0x000011c0    5     60 entry.init0
0x00001170    5     55 entry.fini0
0x00001100    4     34 fcn.00001100
0x00001344    1     99 fcn.00001344
0x000012f4    4     80 fcn.000012f4
0x00001279    1    123 fcn.00001279
0x000013a7    3    133 fcn.000013a7
0x0000142c    1      7 fcn.0000142c
```

We can see `afl` is listing all functions and their addresses as well. Here ghidra is smart to figure out the patterns of function calls from assembly, it would probably looking for things like `call`, `leave`, `ret`. 

Now we know the entrypoint is at `entry0`, let's look at the corresponding C code for it.

`pdf` means print function definition, it prints the raw assembly for that function

```bash
[0x000010d0]> pdf @ entry0
            ;-- section..text:
            ;-- rip:
┌ 37: entry0 (int64_t arg3);
│ `- args(rdx)
│           0x000010d0      f30f1efa       endbr64                     ; [13] -r-x section size 867 named .text
│           0x000010d4      31ed           xor ebp, ebp
│           0x000010d6      4989d1         mov r9, rdx                 ; arg3
│           0x000010d9      5e             pop rsi
│           0x000010da      4889e2         mov rdx, rsp
│           0x000010dd      4883e4f0       and rsp, 0xfffffffffffffff0
│           0x000010e1      50             push rax
│           0x000010e2      54             push rsp
│           0x000010e3      4531c0         xor r8d, r8d
│           0x000010e6      31c9           xor ecx, ecx
│           0x000010e8      488d3dda00..   lea rdi, [main]             ; 0x11c9
└           0x000010ef      ff15cb2e0000   call qword [reloc.__libc_start_main] ; [0x3fc0:8]=0
```

`pdg` command will print the decompiled C code for that function

```c
[0x000010d0]> pdg @ entry0

void entry0(ulong param_1,ulong param_2,ulong param_3)

{
    ulong unaff_retaddr;
    uchar auStack_8 [8];
    
    (*_reloc.__libc_start_main)(main,unaff_retaddr,&stack0x00000008,0,0,param_3,auStack_8);
    do {
    //WARNING: Do nothing block with infinite loop
    } while( true );
}
```

This is Ghidra's decompiled function for `entry0`

```c
void processEntry entry(undefined8 param_1,undefined8 param_2)
{
  undefined1 auStack_8 [8];

  __libc_start_main(FUN_001011c9,param_2,&stack0x00000008,0,0,param_1,auStack_8);
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}
```

We can notice `main` is not the first thing that is getting called, but its `__libc_start_main`. `__libc_start_main` is defined in `libc.so.6` and it takes care of linking all the external functions. 

Both statically and dynamically linked C programs use `__libc_start_main`. Because it is part of the C runtime startup code that handles the transition from the operating system to your main function, regardless of whether the program is linked statically or dynamically. The difference is that in a statically linked executable, the entire C runtime library, including __libc_start_main, is copied and bundled directly into the final executable. In contrast, a dynamically linked program links to a shared C library at runtime.

But if the program doesn't depend on libc at all, then there won't be any `__libc_start_main`, `_start` will directly point to `_main`, these types of programs can be run directly on bare metal without any OS, we can see `_start` in Linux kernel's sttart point as well. 

What `__libc_start_main` Does?

```c
__libc_start_main(
    main,              // Your main() function
    argc,              // Argument count
    argv,              // Argument vector
    init,              // Initialization function
    fini,              // Cleanup function
    rtld_fini,         // Runtime linker cleanup
    stack_end          // End of stack
);
```



1. Sets up the C runtime environment
2. Initializes global variables
3. Runs constructors (`.init_array`)
4. Calls m`ain(argc, argv)`
5. Calls `exit()` with main's return value
6. Runs destructors (`.fini_array`)

We can jump to `main` function using `seek` command and check its decompiled code. 

```c
[0x000012ad]> s main

ulong main(int param_1,int64_t param_2)

{
    int iVar1;
    int64_t in_FS_OFFSET;
    ulong uStack_28;
    int64_t iStack_20;
    int64_t iStack_10;
    
    iStack_10 = *(in_FS_OFFSET + 0x28);
    if (param_1 == 2) {
        uStack_28 = 0x201c;
        iStack_20 = *(param_2 + 8) + 1;
        iVar1 = fcn.00001344(str.pJCI_r,*0xea60,**(param_2 + 8) + -0x57,&uStack_28);
        if (iVar1 == -1) {
            fcn.0000142c();
        }
    }
    else {
        sym.imp.puts("usage: ./matryoshka key");
    }
    if (iStack_10 == *(in_FS_OFFSET + 0x28)) {
        return 0;
    }
    //WARNING: Subroutine does not return
    sym.imp.__stack_chk_fail();
}
```

We can also analyze the variables for the function we're in using the `afvn` command.

```bash
[0x000011c9]> afv
arg uint32_t argc @ rdi
arg char ** argv @ rsi
var int64_t canary @ rbp-0x8
var int64_t var_18h @ rbp-0x18
var int64_t var_20h @ rbp-0x20
var int64_t var_21h @ rbp-0x21
var uint32_t var_34h @ rbp-0x34
var char ** var_40h @ rbp-0x40
```

We can see r2 has figured better variable names for some of them. We can also see their location on their stack `rbp` indicates the base of the current function's stack frame, it will start allocating memory for its variables from `rbp` and top is indicated by `rsp`.

We can see first 2 parameters of `main` functions `argc` and `argv`, but the correct signature is `int main(int argc, char **argv);`. This is the best guess made by decompiler since it doesn't know the second parameter is pointer to which type. 

The actual parameters are passed like this for main

When we run `./program hello world`

In memory

```
argc = 3
argv = ─┬─► [0] → "./program\0"
        ├─► [1] → "hello\0"
        ├─► [2] → "world\0"
        └─► [3] → NULL
```

- `argv` itself is a pointer (→ array of addresses)
- each `argv[i]` is a pointer to a null-terminated string (char *)
- and `argv[argc]` is always NULL


Disassembled code from Ghidra

```c

undefined8 main(int param_1,long param_2)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined *local_28;
  long local_20;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 == 2) {
    local_28 = &DAT_0010201c;
    local_20 = *(long *)(param_2 + 8) + 1;
    iVar1 = FUN_00101344(&DAT_00104080,DAT_0010ea60,**(char **)(param_2 + 8) + -0x57,&local_28);
    if (iVar1 == -1) {
      FUN_0010142c();
    }
  }
  else {
    puts("usage: ./matryoshka key");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}
```

Now let's understand some of the lines


```c
local_28 = &DAT_0010201c;
```

- `DAT_0010201c` is supposed to be a global variable defined at `0x0010201c` in `.data` section. We can see its actual value is `00h` from Ghidra. 
- But `local_28` refers to address of `DAT_0010201c`, since this binary is a PIE executable, a constant offset will be added to the current address i.e., `0x0010201c`, so we cannot conclude the value of `local_28` as of now.
- So let's rename it to `local_28_null_array` as of now.

```c
local_20 = *(long *)(param_2 + 8) + 1;
```
- `param_2` (`argv`) holds the address of first element of array of pointers, where each of the pointers point to a string passed to input program.
- `param_2 + 8` will move the pointer from `argv[0]` to `argv[1]` (Sometimes decompilers interpret pointer arithmetic as byte offset, its actually meaning to say `param_2 + 1`, clue here is we don't expect 8 user arguments to the program). Now when we use dereference operator `*`, the pointer moves from pointing to address of `argv[1]` to pointing to first character of `argv[1]`. 
- Now since `param_2` is pointing to first character of `argv[1]`, adding 1 will advance the pointer to second character of `argv[1]` (This is because of how pointer arithmetic works in C).
- So it makes sense to rename `local_20` to `second_char_of_input`.
- But this variable is not used anywhere.

```c
    iVar1 = FUN_00101344(&DAT_00104080,DAT_0010ea60,**(char **)(param_2 + 8) + -0x57,&local_28);
```

- If we look up value of `DAT_00104080` global variable, we will see a hardcoded string `pJCI`, so we can rename it to `magicString_pJCI`
- `DAT_0010ea60` has value `0xA9E0` or `43488` in integer.
- `**(char **)(param_2 + 8) + -0x57` means `argv[1][0] - 'W'` . Let's name it `input_character_of_interest`. 


Now if we rename the corresponding parameters in `FUN_00101344` we get

```c

void FUN_00101344(undefined8 magicString_pJCI,undefined4 magic_int_43488,
                 undefined1 input_character_of_interest,undefined8 local_28_null_array)

{
  undefined8 uVar1;
  
  FUN_001012f4(magicString_pJCI,magic_int_43488,input_character_of_interest);
  uVar1 = FUN_00101279(magicString_pJCI,magic_int_43488,1);
  FUN_001013a7(uVar1,&DAT_0010201d,local_28_null_array);
  return;
}
```

After examining the code and renaming, this is the updated code:

```c

undefined8 main(int argc,long argv)

{
  int iVar1;
  long in_FS_OFFSET;
  undefined *local_28_null_array;
  long second_char_of_input;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (argc == 2) {
    local_28_null_array = &DAT_0010201c;
    second_char_of_input = *(long *)(argv + 8) + 1;
    iVar1 = operation(&magicString_pJCI,magic_int_43488,**(char **)(argv + 8) + -0x57,
                      &local_28_null_array);
    if (iVar1 == -1) {
      FUN_0010142c();
    }
  }
  else {
    puts("usage: ./matryoshka key");
  }
  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}




void operation(undefined8 magicString_pJCI,undefined4 magic_int_43488,
              undefined1 input_character_of_interest,undefined8 local_28_null_array)

{
  undefined8 file_stream;
  
  xor_cypher(magicString_pJCI,magic_int_43488,input_character_of_interest);
  file_stream = write_magicString_to_in_memory_file_and_return_stream
                          (magicString_pJCI,magic_int_43488,1);
  exec_memfd_stream(file_stream,&zero,local_28_null_array);
  return;
}


void xor_cypher(long magicString_pJCI,uint magic_int_43488,byte input_character_of_interest)

{
  undefined4 local_c;
  
  for (local_c = 0; local_c < magic_int_43488; local_c = local_c + 1) {
    *(byte *)(magicString_pJCI + (int)local_c) =
         *(byte *)(magicString_pJCI + (int)local_c) ^ input_character_of_interest;
  }
  return;
}



FILE * write_magicString_to_in_memory_file_and_return_stream
                 (void *magicString_pJCI,uint magic_int_43488,undefined4 one)

{
  int __fd;
  FILE *__s;
  
  __fd = memfd_create(&zero,one);
  ftruncate(__fd,(ulong)magic_int_43488);
  __s = fdopen(__fd,"r+");
  fwrite(magicString_pJCI,1,(ulong)magic_int_43488,__s);
  rewind(__s);
  return __s;
}

void exec_memfd_stream(FILE *file_stream,undefined8 param_2,char **local_28_null_array)

{
  uint uVar1;
  long in_FS_OFFSET;
  char *local_60;
  char local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  uVar1 = fileno(file_stream);
  sprintf(local_58,"/proc/self/fd/%d",(ulong)uVar1);
  local_60 = (char *)0x0;
  execve(local_58,local_28_null_array,&local_60);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

```

So `magicString_pJCI` is a long string of `43488` bytes. Its content is xor'd with some character, then the cyphered binary is written to an in-memory file and its passed to `execve`. Since its passed to `execve` we know that the content of `magicString_pJCI` should be valid ELF file in itself. The input character we pass will unlock the cypher if its correct, otherwise it will be some garbage text. 

Fortunately we know that all ELF files should start with a magic string `7f 45 4c 46 02 01 01`, let's consider only first 16 bytes for now `7f 45 4c 46`. We can inspect the binary to get first 16 bytes of `magicString_pJCI` is `70h 4Ah 43h 49h`. Since xor is a symmetrical encryption, the puzzle we need to solve is `70 4A 43 49` xor `unknown_key` = `7f 45 4c 46`. This is quite straightforward math, we know a ^ a = 0, so we just multiply both sides with `70 4A 43 49`, it becomes `unknown_key` = `7f 45 4c 46` ^ `70 4A 43 49`.

We will get the xor key as `0x0f` (15 in decinal). Since we are subtracting `-0x57` from original input `**(char **)(param_2 + 8) + -0x57 `, we need to add it back. 

But on executing `./matryoshka f` the program shows no output!

We can take a closer look at what's happening using `strace` command

```bash
$ strace -f -s 200 -o run2.strace ./matryoshka f
```

strace = System call trace

It intercepts and logs every system call a program makes to the kernel.


- `-f` = **Follow forks** (trace child processes too)
- `-s 200` = Show up to **200 characters** of string arguments (default is 32)
- `-o run2.strace` = Write output to file instead of stderr
- `./matryoshka f` = The program to trace

In the strace calls we can see one of the calls to `execve` failed!

```bash
sanketh@sanketh-81de:~/ctf/matryoshka_ctf$ cat run2.strace | grep execve
39319 execve("./matryoshka", ["./matryoshka", "f"], 0x7ffdec584f10 /* 40 vars */) = 0
39319 execve("/proc/self/fd/3", ["", "", "\320\260\240\4\303c", 0xa4428175daf0c00, "@\276`M\377\177", "\211\307\350\317\331\1", "\330\335\240\4\303c", "\274\323`M\377\177", 0x204a0a040, "UH\211\345H\203\354@\211}\314H\211u\300dH\213\4%(", "\274\323`M\377\177", 0x454b2a22a759610c, 0x2], 0x7fff4d60bc58 /* 0 vars */) = -1 EFAULT (Bad address)
```

Understanding the Output

### Line 1: First execve (Normal)
```
1:44640 execve("./matryoshka", ["./matryoshka", "f"], 0x7ffccdfcfa70 /* 39 vars */) = 0
```

**Breakdown:**
- `1:` = Line number
- `44640` = Process ID (PID)
- `execve(...)` = System call name
- `"./matryoshka"` = **Path** to execute
- `["./matryoshka", "f"]` = **argv** array (looks good!)
- `0x7ffccdfcfa70 /* 39 vars */` = **envp** (environment variables)
- `= 0` = **Success!** (return code 0)


Line 2: Second execve (FAILURE!)

```
40:44640 execve("/proc/self/fd/3", 
                ["", "", "\320", 0x9b8f1b87c1933b00, ...], 
                0x7ffe91701e28 /* 0 vars */) 
         = -1 EFAULT (Bad address)
```

- `40:` = Line 40 in strace output
- `"/proc/self/fd/3"` = Path to in-memory file ✓ (this is correct!)
- `["", "", "\320", 0x9b8f1b87c1933b00, ...]` = argv array ⚠️ PROBLEM!
- `= -1 EFAULT` = FAILURE! "Bad address" error

We can see the argv array is not null terminated and its showing all addresses from stack.

Valid `argv` should look like:

```c
char *argv[] = {
    "program_name",   // argv[0]
    "arg1",           // argv[1]
    "arg2",           // argv[2]
    NULL              // Terminator
};
```

But we see:

```c
argv = {
    "",                    // Empty string
    "",                    // Empty string  
    "\320",                // Partial garbage
    0x9b8f1b87c1933b00,   // INVALID POINTER!
    ...
}
```

Let's take a more deeper look at what happened during runtime using **GDB**

Before that, let's see what is the ABI of `execve` for x86 (means where does this functions expects its parameters)

```c
execve(const char *path, char *const argv[], char *const envp[]);
//     rdi = arg1       rsi = arg2          rdx = arg3
```

- `$rdi` = pointer to path string (`"/proc/self/fd/3"`)
- `$rsi` = pointer to argv array (`char **argv`)
- `$rdx` = pointer to envp array

Now let's see what's actually happening

```bash
$ gdb matryoshka 

(gdb) break execve
Breakpoint 1 at 0x1080 

(gdb) run f  # Run with parameter f
```

Earlier we noticed 2 calls to `execve` 

```
Call 1: Shell executes ./matryoshka (happens BEFORE gdb attaches)
Call 2: matryoshka calls execve() for nested binary (this is what we want!)
```

Our breakpoint at `0x1080` is in the PLT (Procedure Linkage Table) - the stub that calls the real execve in libc. So we're at the right place

```bash
(gdb)  printf "exec path: %s\n", (char*) $rdi
exec path: /proc/self/fd/3
(gdb)  printf "argv_ptr = 0x%lx\n", $rsi
argv_ptr = 0x7fffffffdf20
(gdb) x/8gx $rsi
0x7fffffffdf20:	0x000055555555601c	0x00007fffffffe399
0x7fffffffdf30:	0x00007fffffffe020	0x210e4bb9b14b5900
0x7fffffffdf40:	0x00007fffffffdfe0	0x00007ffff7c2a1ca
0x7fffffffdf50:	0x00007fffffffdf90	0x00007fffffffe068
(gdb) x/s 0x000055555555601c
0x55555555601c:	""
(gdb) x/s 0x00007fffffffe399
0x7fffffffe399:	""
(gdb) x/s 0x00007fffffffe020
0x7fffffffe020:	"\320PUUUU"
(gdb) x/s 0x210e4bb9b14b5900
0x210e4bb9b14b5900:	<error: Cannot access memory at address 0x210e4bb9b14b5900>
```

This confirms the garbage value in `argv`. 

Let's understand what happened here 

**GDB x Command (Examine Memory)**

Format: `x/[count][format][size] address`

- count = how many units to display
- format = how to display (x=hex, d=decimal, s=string, i=instruction, etc.)
- size = size of each unit (b=byte, h=halfword, w=word, g=giant/8bytes)

**Command 1: x/8gx $rsi**

```
(gdb) x/8gx $rsi
0x7fffffffdf80: 0x000055555555601c 0x00007fffffffe3fa
0x7fffffffdf90: 0x00007fffffffe080 0x4e39f1740a528200
0x7fffffffdfa0: 0x00007fffffffe040 0x00007ffff7c2a1ca
0x7fffffffdfb0: 0x00007fffffffdff0 0x00007fffffffe0c8
```

Breakdown:

- x/ = examine command
- 8 = show 8 units
- g = each unit is giant (8 bytes = 64 bits)
- x = display in hexadecimal
- $rsi = starting address (0x7fffffffdf80)


This displays the argv array as 8 pointers (each 8 bytes on x86-64):

```c
char *argv[] = {
    0x000055555555601c,  // argv[0]
    0x00007fffffffe3fa,  // argv[1]
    0x00007fffffffe080,  // argv[2]
    0x4e39f1740a528200,  // argv[3] ← GARBAGE!
    0x00007fffffffe040,  // argv[4]
    0x00007ffff7c2a1ca,  // argv[5]
    0x00007fffffffdff0,  // argv[6]
    0x00007fffffffe0c8   // argv[7]
};
```

**Command 2: x/32bx $rsi**

```
(gdb) x/32bx $rsi       
0x7fffffffdf80: 0x1c 0x60 0x55 0x55 0x55 0x55 0x00 0x00
0x7fffffffdf88: 0xfa 0xe3 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdf90: 0x80 0xe0 0xff 0xff 0xff 0x7f 0x00 0x00
0x7fffffffdf98: 0x00 0x82 0x52 0x0a 0x74 0xf1 0x39 0x4e
```

**Breakdown:**
- `32` = show **32 units**
- `b` = each unit is **byte** (1 byte = 8 bits)
- `x` = display in **hexadecimal**

**What it shows:**
The **same data** but displayed as individual bytes (little-endian format):
```
Bytes:    0x1c 0x60 0x55 0x55 0x55 0x55 0x00 0x00
          └────────────────────────────────────┘
          Becomes: 0x000055555555601c (pointer)

Bytes:    0xfa 0xe3 0xff 0xff 0xff 0x7f 0x00 0x00
          └────────────────────────────────────┘
          Becomes: 0x00007fffffffe3fa (pointer)
```

**Command 3: x/s <address>**

```c
(gdb) x/s 0x000055555555601c
0x55555555601c: ""

(gdb) x/s 0x00007fffffffe3fa
0x7fffffffe3fa: ""
```

**Breakdown:**
- `s` = display as **string** (null-terminated)
- Reads bytes until it hits `\0`

**What it shows:**
- Follow the pointer to see **what string it points to**
- `0x000055555555601c` → points to empty string `""`
- `0x00007fffffffe3fa` → also points to empty string `""`

---

Visual Summary
```
Memory Layout:

Stack (argv array):
┌─────────────────────────────────────┐
│ 0x7fffffffdf80: 0x000055555555601c │ ← argv[0] (pointer)
│ 0x7fffffffdf88: 0x00007fffffffe3fa │ ← argv[1] (pointer)
│ 0x7fffffffdf90: 0x00007fffffffe080 │ ← argv[2] (pointer)
│ 0x7fffffffdf98: 0x4e39f1740a528200 │ ← argv[3] (INVALID!)
└─────────────────────────────────────┘
                 │
                 │ (follow pointer)
                 ↓
Heap/Data:
┌─────────────────────────┐
│ 0x55555555601c: 0x00    │ ← Empty string ""
└─────────────────────────┘
```

The program crashing here could be intentional or accident. 

But one of the logs from strace shows this line

```
39319 write(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300\20\0\0\0\0\0\0@\0\0\0\0\0\0\0\340\242\0\0\0\0\0\0\0\0\0\0@\08\0\16\0@\0\34\0\33\0\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\20\3\0\0\0\0\0\0\20\3\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0\264\3\0\0\0\0\0\0\264\3\0\0\0\0\0\0\264\3\0\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\1\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 40960) = 40960
```

It shows the valid ELF signature, which means the cypher was succesfully decrypted, since the crashign is occuring at `execve`, it means the program has successfully written this content to the file stream already. Let's try to retrieve it

First let's get the process's pid

```
(gdb) info inferiors 
  Num  Description       Connection           Executable        
* 1    process 39550     1 (native)           /home/sanketh/ctf/matryoshka_ctf/matryoshka 
```

`info inferiors` prints the details of program being run by gdb. Inferior = A process being debugged by GDB - Think of it as: "the program under the debugger's control"

It shows only 1 here, but gdb can debug multiple programs simultaneously, example when using `fork()` call.

Then we can extract the contents of file descriptor like this

```bash
sanketh@sanketh-81de:/tmp$ ls -l /proc/39550/fd
total 0
lrwx------ 1 sanketh sanketh 64 Nov  3 18:18 0 -> /dev/pts/1
lrwx------ 1 sanketh sanketh 64 Nov  3 18:18 1 -> /dev/pts/1
lrwx------ 1 sanketh sanketh 64 Nov  3 18:18 2 -> /dev/pts/1
lrwx------ 1 sanketh sanketh 64 Nov  3 18:18 3 -> '/memfd: (deleted)'
sanketh@sanketh-81de:/tmp$ cp /proc/39550/fd/3 /tmp/magic_blob.bin
```

**What is `/proc`?**

`/proc` is a virtual filesystem (not on disk!) that provides an interface to kernel data structures. It's like a "window" into the running kernel and processes.

Understanding /proc/$pid/fd/

```
ls -l /proc/$pid/fd
```

This directory contains symbolic links representing all open file descriptors for that process.

What we Saw

```
lrwx------ 1 sanketh sanketh 64 Nov  3 18:18 3 -> '/memfd: (deleted)'
```

Breakdown:

- `3` = File descriptor number
- `->` = Symbolic link
- `'/memfd: (deleted)'` = What it points to (an anonymous memory file)

Why Can we Copy From It?
Here's the magic: /proc/$pid/fd/$fd isn't just a symbolic link - it's a special link that lets you access the actual file content!

If we examine `magic_blob.bin`, its actually a valid ELF, when we decompile it we see similar code 

```c
ulong main(ulong param_1,int64_t param_2)

{
    int iVar1;
    int64_t in_FS_OFFSET;
    ulong uStack_28;
    int64_t iStack_20;
    int64_t iStack_10;
    
    iStack_10 = *(in_FS_OFFSET + 0x28);
    uStack_28 = 0x2004;
    iStack_20 = *(param_2 + 8) + 1;
    iVar1 = fcn.00001318(str.tNGM_t_n_n_v_v_v_v_v_v_v_v_v_b_v5_v_n_v_v_v,*0xb1b8,**(param_2 + 8) + -0x57,&uStack_28);
    if (iVar1 == -1) {
        fcn.00001400();
    }
    if (iStack_10 != *(in_FS_OFFSET + 0x28)) {
    //WARNING: Subroutine does not return
        sym.imp.__stack_chk_fail();
    }
    return 0;
}
```

The only difference here is the magic string passed to `fcn.00001318` is different!

We can solve the same xor puzzle again, after solving it for 2 more times and peeling the ELF layers, we end up with the final ELF file

```c
[0x000010e0]> pdg @ main

ulong main(ulong param_1,int64_t param_2)

{
    int iVar1;
    
    iVar1 = sym.imp.atoi(*(param_2 + 8));
    if (iVar1 == 9) {
        sym.imp.puts("u win good job!!!!");
    }
    else {
        fcn.000013d0();
    }
    return 0;
}
```

This can be cracked by 

```bash
 ./magic_blob3.bin 9
u win good job!!!!
```

Its just checkign the value of `argv[1]`