---
title:  "80286 Manual Chapter 2 Summary"
date:   2025-08-17
draft: true
categories: ["cpu"]
tags: ["cpu", "80286"]
author: Sanketh
references:
---

# Chapter 2: 80286 Base Architecture

---

This chapter describes the 80286 application programming environment as seen by assembly language programmers. It is intended to introduce the programmer to those features of the 80286 architecture that directly affect the design and implementation of 80286 application programs.

## 2.1 Memory Organization and Segmentation

The main memory of an 80286 system makes up its physical address space. This address space is organized as a sequence of 8-bit quantities, called bytes. Each byte is assigned a unique address ranging from 0 up to a maximum of 2^(20) (1 megabyte) in Real Address Mode, and up to 2^(24) (16 megabytes) in Protected Mode.

A virtual address space is the organization of memory as viewed by a program. Virtual address space is also organized in units of bytes. (Other addressable units such as words, strings, and BCD digits are described below in section 2.2, "Data Types.") In Real Address Mode, as with the 8086 itself, programs view physical memory directly, inasmuch as they manipulate pure physical addresses. Thus, the virtual address space is identical to the physical address space (1 megabyte).

In Protected Mode, however, programs have no direct access to physical addresses. Instead, memory is viewed as a much larger virtual address space of 2^(30) bytes (1 gigabyte). This 1 gigabyte virtual address is mapped onto the Protected Mode's 16-megabyte physical address space by the address translation mechanisms described in Chapter 6.

The programmer views the virtual address space on the 80286 as a collection of up to sixteen thousand linear subspaces, each with a specified size or length. Each of these linear address spaces is called a segment. A segment is a logical unit of contiguous memory. Segment sizes may range from one byte up to 64K (65,536) bytes.

80286 memory segmentation supports the logical structure of programs and data in memory. Programs are not written as single linear sequences of instructions and data, but rather as modules of code and data. For example, program code may include a main routine and several separate procedures. Data may also be organized into various data structures, some private and some shared with other programs in the system. Run-time stacks constitute yet another data requirement. Each of these several modules of code and data, moreover, may be very different in size or vary dynamically with program execution.

Segmentation supports this logical structure (see figure 2-1). Each meaningful module of a program may be separately contained in individual segments. The degree of modularization, of course, depends on the requirements of a particular application. Use of segmentation benefits almost all applications. Programs execute faster and require less space. Segmentation also simplifies the design of structured software.

## 2.2 Data Types

Bytes and words are the fundamental units in which the 80286 manipulates data, i.e., the fundamental data types.

A **byte** is 8 contiguous bits starting on an addressable byte boundary. The bits are numbered 0 through 7, starting from the right. Bit 7 is the most significant bit:

```
                    7                             0
                   ┌───┬───┬───┬───┬───┬───┬───┬───┐
                   │              BYTE             │
                   └─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘
```

A **word** is defined as two contiguous bytes starting on an arbitrary byte boundary; a word thus contains 16 bits. The bits are numbered 0 through 15, starting from the right. Bit 15 is the most significant bit. The byte containing bit 0 of the word is called the low byte; the byte containing bit 15 is called the high byte.

```
    15                                                             0
    ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
    │           HIGH BYTE           │           LOW BYTE            │
    └─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘
             LOCATION N + 1                    LOCATION N
```

Each byte within a word has its own particular address, and the smaller of the two addresses is used as the address of the word. The byte at this lower address contains the eight least significant bits of the word, while the byte at the higher address contains the eight most significant bits. The arrangement of bytes within words is illustrated in figure 2-2.

Note that a word need not be aligned at an even-numbered byte address. This allows maximum flexibility in data structures (e.g., records containing mixed byte and word entries) and efficiency in memory utilization. Although actual transfers of data between the processor and memory take place at physically aligned word boundaries, the 80286 converts requests for unaligned words into the appropriate sequences of requests acceptable to the memory interface. Such odd aligned word transfers, however, may impact performance by requiring two memory cycles to transfer the word rather than one. Data structures (e.g., stacks) should therefore be designed in such a way that word operands are aligned on word boundaries whenever possible for maximum system performance. Due to instruction prefetching and queueing within the CPU, there is no requirement for instructions to be aligned on word boundaries and no performance loss if they are not.

Although bytes and words are the fundamental data types of operands, the processor also supports additional interpretations on these bytes or words. Depending on the instruction referencing the operand, the following additional data types can be recognized:

- **Integer:** A signed binary numeric value contained in an 8-bit byte or a 16-bit word. All operations assume a 2's complement representation. (Signed 32- and 64-bit integers are supported using the 80287 Numeric Data Processor.)
- **Ordinal:** An unsigned binary numeric value contained in an 8-bit byte or 16-bit word.
- **Pointer:** A 32-bit address quantity composed of a segment selector component and an offset component. Each component is a 16-bit word.
- **String:** A contiguous sequence of bytes or words. A string may contain from 1 byte to 64K bytes.
- **ASCII:** A byte representation of alphanumeric and control characters using the ASCII standard of character representation.
- **BCD:** A byte (unpacked) representation of the decimal digits (0-9).
- **Packed BCD:** A byte (packed) representation of two decimal digits (0-9). One digit is stored in each nibble of the byte.
- **Floating Point:** A signed 32-, 64-, or 80-bit real number representation. (Floating operands are supported using the 80287 Numeric Processor Configuration.)

Figure 2-3 graphically represents the data types supported by the 80286. 80286 arithmetic operations may be performed on five types of numbers: unsigned binary, signed binary (integers), unsigned packed decimal, unsigned unpacked decimal, and floating point. Binary numbers may be 8 or 16 bits long. Decimal numbers are stored in bytes; two digits per byte for packed decimal, one digit per byte for unpacked decimal. The processor always assumes that the operands specified in arithmetic instructions contain data that represent valid numbers for the type of instruction being performed. Invalid data may produce unpredictable results.

**Unsigned binary numbers** may be either 8 or 16 bits long; all bits are considered in determining a number's magnitude. The value range of an 8-bit unsigned binary number is 0-255; 16 bits can represent values from 0 through 65,535. Addition, subtraction, multiplication and division operations are available for unsigned binary numbers.

**Signed binary numbers (integers)** may be either 8 or 16 bits long. The high-order (leftmost) bit is interpreted as the number's sign: 0 = positive and 1 = negative. Negative numbers are represented in standard two's complement notation. Since the high-order bit is used for a sign, the range of an 8-bit integer is -128 through +127; 16-bit integers may range from -32,768 through +32,767. The value zero has a positive sign.

Separate multiplication and division operations are provided for both signed and unsigned binary numbers. The same addition and subtraction instructions are used with signed or unsigned binary values. Conditional jump instructions, as well as an "interrupt on overflow" instruction, can be used following an unsigned operation on an integer to detect overflow into the sign bit.

**Unpacked decimal numbers** are stored as unsigned byte quantities. One digit is stored in each byte. The magnitude of the number is determined from the low-order half-byte; hexadecimal values 0-9 are valid and are interpreted as decimal numbers. The high-order half-byte must be zero for multiplication and division; it may contain any value for addition and subtraction.

Arithmetic on unpacked decimal numbers is performed in two steps. The unsigned binary addition, subtraction and multiplication operations are used to produce an intermediate result. An adjustment instruction then changes the value to a final correct unpacked decimal number. Division is performed similarly, except that the adjustment is carried out on the two digit numerator operand in register AX first, followed by an unsigned binary division instruction that produces a correct result.

Unpacked decimal numbers are similar to the ASCII character representations of the digits 0-9. Note, however, that the high-order half-byte of an ASCII numeral is always 3. Unpacked decimal arithmetic may be performed on ASCII numeric characters under the following conditions:

- The high-order half-byte of an ASCII numeral must be set to 0H prior to multiplication or division.
- Unpacked decimal arithmetic leaves the high-order half-byte set to 0H; it must be set to 3 to produce a valid ASCII numeral.

**Packed decimal numbers** are stored as unsigned byte quantities. The byte is treated as having one decimal digit in each half-byte (nibble); the digit in the high-order half-byte is the most significant. Values 0-9 are valid in each half-byte, and the range of a packed decimal number is 0-99. Additions and subtractions are performed in two steps. First, an addition or subtraction instruction is used to produce an intermediate result. Then, an adjustment operation is performed which changes the intermediate value to a final correct packed decimal result. Multiplication and division
adjustments are only available for unpacked decimal numbers.

**Pointers and addresses** are described below in section 2.3.3, "Index, Pointer, and Base Registers," and in section 3.8, "Address Manipulation Instructions."

**Strings** are contiguous bytes or words from 1 to 64K bytes in length. They generally contain ASCII or other character data representations. The 80286 provides string manipulation instructions to move, examine, or modify a string (see section 3.7, "Character Translation and String Instructions").

If the 80287 numeric processor extension (NPX) is present in the system (see the 80287 NPX book) the 80286 architecture also supports floating point numbers, 32- and 64-bit integers, and 18-digit BCD data types.

The 80287 Numeric Data Processor supports and stores real numbers in a three-field binary format as required by IEEE standard 754 for floating point numerics (see figure 2-3). The number's significant digits are held in the significand field, the exponent field locates the binary point within the significant digits (and therefore determines the number's magnitude), and the sign field indicates whether the number is positive or negative. (The exponent and significand are analogous to the terms "characteristic" and "mantissa," typically used to describe floating point numbers on some
computers.) This format is used by the 80287 with various length significands and exponents to support single precision, double precision and extended (80-bit) precision floating point data types. Negative numbers differ from positive numbers only in their sign bits.

**Figure 2-1. Segmented Virtual Memory**
```
┌──────────────────┐
│ 20000┌──────────┐│      8000┌──────────┐      8600┌──────────┐
│      │CS        ││   │      │          │   │      │          │
│      │   MAIN   ││          │PROCEDURE A          │PROCEDURE │
│      │ PROCEDURE││   │      │          │          │    B     │
│     0└──────────┘│         0└──────────┘         0└──────────┘
│                  │
│      ┌──────────┐│     72535┌──────────┐          ┌──────────┐
│      │DS        ││   │      │          │          │          │
│      │ DATA(MAIN)          │ DATA (A) │          │ DATA (B) │
│     0└──────────┘│   │     0└──────────┘         0└──────────┘
│  2000┌──────────┐│
│      │SS PROCESS││   │
│      │   STACK  ││
│     0└──────────┘│   │
│      ┌──────────┐│
│      │ES PROCESS-WIDE   │
│      │    DATA  ││
│     0└──────────┘│   │
└──────────────────┘
    CURRENTLY ACCESSIBLE
```

**Figure 2-2. Bytes and Words in Memory**
```
BYTE
ADDRESS
All values in hexadecimal.     MEMORY VALUES
       ┌───────────────────────┐
     E │                       │
       ├───────────────────────┤
     D │                       │
       ├───────────────────────┤
     C │          FE           │<┐
       ├───────────────────────┤ ├─ WORD AT ADDRESS B CONTAINS FE06
     B │          06           │<┘
       ├───────────────────────┤
     A │                       │
       ├───────────────────────┤<┐
     9 │          1F           │ ├─BYTE AT ADDRESS 9 CONTAINS 1F
       ├───────────────────────┤<┘
     8 │                       │
       ├───────────────────────┤
     7 │          23           │<┐
       ├───────────────────────┤ ├─ WORD AT ADDRESS 6 CONTAINS 23OB
     6 │          OB           │<┘
       ├───────────────────────┤
     5 │                       │
       ├───────────────────────┤
     4 │                       │
       ├───────────────────────┤
     3 │          74           │ <┐
       ├───────────────────────┤<┐├─ WORD AT ADDRESS 2 CONTAINS 74CB
     2 │          CB           │ <┘
       ├───────────────────────┤ ├─ WORD AT ADDRESS 1 CONTAINS CB31
     1 │          31           │ │
       ├───────────────────────┤<┘
     0 │                       │
       └───────────────────────┘
```

**Figure 2-3. 80286/80287 Supported Data Types**
```
                                                           +1       0
          7       0              7       0            15 14    8 7      0
   SIGNED ┌───────┐     UNSIGNED ┌───────┐       SIGNED ┌───────────────┐
     BYTE │S│ MAG │         BYTE │  MAG  │         WORD │S│  MAGNITUDE  │
          └─┴─────┘              └───────┘              └─┴───────┴─────┘
  SIGN BIT│                      │                       SIGN BIT│
           MAGNITUDE             └MSB                            └MSB

                          +3      +2      +1       0
                        31            16 15             0
   SIGNED DOUBLE WORD
Supported by 80287 numeric data processor configuration.
                       ┌───────────────────────────────┐
                       │S│         MAGNITUDE           │
                       └─┴─────────────────────────────┘
               SIGN BIT│
                        └MSB

                         +7  +6  +5  +4  +3  +2  +1   0
                       63    48 47   32 31   16 15     0
     SIGNED QUAD WORD
Supported by 80287 numeric data processor configuration.
                       ┌───────────────────────────────┐
                       │S│         MAGNITUDE           │
                       └─┴─────────────────────────────┘
               SIGN BIT│
                        └MSB

                          +1       0
                       15              0
         UNSIGNED WORD ┌───────────────┐
                       │   MAGNITUDE   │
                       └───────────────┘
                        └MSB

                          +N                +1       0
                       7       0         7      0 7      0
  BINARY CODED DECIMAL ┌───────┐         ┌───┬───┬───┬───┐
         (BCD)         │  BCD  │         │BCD│BCD│BCD│BCD│
                       └───────┘         └───┴───┴───┴───┘
                        DIGIT N           DIGIT 1  DIGIT 0

                          +N                +1       0
                       7       0         7      0 7      0
                 ASCII ┌───────┐         ┌───┬───┬───┬───┐
                       │ ASCII │         │ASC│ASC│ASC│ASC│
                       └───────┘         └───┴───┴───┴───┘
                      CHARACTER[N]   CHARACTER{1} CHARACTER{0}

                          +N                +1       0
                       7       0         7      0 7      0
            PACKED BCD ┌───────┐         ┌───┬───┬───┬───┐
                       │P. BCD │         │P.B│P.B│P.B│P.B│
                       └───────┘         └───┴───┴───┴───┘
                       └───┘                         └───┘
                       MOST                          LEAST
                       SIGNIFICANT             SIGNIFICANT
                       DIGIT                         DIGIT

                          +N                +1       0
                       7/15    0         7/15   0 7/15   0
                STRING ┌───────┐         ┌───┬───┬───┬───┐
                       │ STR   │         │STR│STR│STR│STR│
                       └───────┘         └───┴───┴───┴───┘
                      BYTE/WORD N       BYTE/WORD BYTE/WORD
                                            1         0

                          +3      +2      +1       0
                       31            16 15             0
               POINTER ┌───────────────────────────────┐
                       │      SELECTOR     │  OFFSET   │
                       └───────────────────┴───────────┘

                         +9  +8  +7  +6  +5  +4  +3  +2  +1   0
                       79                                       0
       FLOATING POINT
Supported by 80287 numeric data processor configuration.
                       ┌───────────────────────────────────────┐
                       │S│      EXPONENT     │    MAGNITUDE    │
                       └─┴───────────────────┴─────────────────┘
               SIGN BIT│
```

## 2.3 Registers

The 80286 contains a total of fourteen registers that are of interest to the application programmer. (Five additional registers used by system programmers are covered in section 10.1.) As shown in figure 2-4, these registers may be grouped into four basic categories:

- **General registers.** These eight 16-bit general-purpose registers are used primarily to contain operands for arithmetic and logical operations.
- **Segment registers.** These four special-purpose registers determine, at any given time, which segments of memory are currently addressable.
- **Status and Control registers.** These three special-purpose registers are used to record and alter certain aspects of the 80286 processor state.

### 2.3.1 General Registers

The general registers of the 80286 are the 16-bit registers AX, BX, CX, DX, SP, BP, SI, and DI. These registers are used interchangeably to contain the operands of logical and arithmetic operations.

Some instructions and addressing modes (see section 2.4), however, dedicate certain general registers to specific uses. BX and BP are often used to contain the base address of data structures in memory (for example, the starting address of an array); for this reason, they are often referred to as the base registers. Similarly, SI and DI are often used to contain an index value that will be incremented to step through a data structure; these two registers are called the index registers. Finally, SP and BP are used for stack manipulation. Both SP and BP normally contain offsets into the current stack. SP generally contains the offset of the top of the stack and BP contains the offset or base address of the current stack frame. The use of these general-purpose registers for operand addressing is discussed in section 2.3.3, "Index, Pointer, and Base Registers." Register usage for individual instructions is discussed in chapters 3 and 4.

As shown in figure 2-4, eight byte registers overlap four of the 16-bit general registers. These registers are named AH, BH, CH, and DH (high bytes); and AL, BL, CL, and DL (low bytes); they overlap AX, BX, CX, and DX. These registers can be used either in their entirety or as individual 8-bit registers. This dual interpretation simplifies the handling of both 8- and 16-bit data elements.

**Figure 2-4. 80286 Base Architecture Register Set**
```
                      16-BIT                 SPECIAL
                     REGISTER                REGISTER
                       NAME                  FUNCTIONS
GENERAL REGISTERS           7    0 7    0
                      ┌───┌──────┬──────┐──┐
                      │ AX│  AH  │  AL  │  │
                 BYTE │   ├──────┼──────┤ ├─MULTIPLY/DIVIDE
          ADDRESSABLE │ DX│  DH  │  DL  │ │ I/O INSTRUCTIONS
               (8-BIT─┤   ├──────┼──────┤─┤
             REGISTER │ CX│  CH  │  CL  │ ├─LOOP/SHIFT/REPEAT COUNT
                NAMES │   ├──────┼──────┤─┤
               SHOWN) │ BX│  BH  │  BL  │ │
                      └───├──────┴──────┤ ├─BASE REGISTERS
                        BP│             │ │
                          ├─────────────┤─┤
                        SI│             │ │
                          ├─────────────┤ ├─INDEX REGISTERS
                        DI│             │ │
                          ├─────────────┤─┤
                        SP│             │ ├─STACK POINTER
                          └─────────────┘─┘
                            15          0

SEGMENT REGISTERS           15          0
                           ┌─────────────┐
                        CS │             │ CODE SEGMENT SELECTOR
                           ├─────────────┤
                        DS │             │ DATA SEGMENT SELECTOR
                           ├─────────────┤
                        SS │             │ STACK SEGMENT SELECTOR
                           ├─────────────┤
                        ES │             │ EXTRA SEGMENT SELECTOR
                           └─────────────┘

STATUS AND CONTROL          15          0
    REGISTERS              ┌─────────────┐
                         F │             │ FLAGS
                           ├─────────────┤
                        IP │             │ INSTRUCTION POINTER
                           ├─────────────┤
                       MSW │             │ MACHINE STATUS WORD
                           └─────────────┘
```

### 2.3.2 Memory Segmentation and Segment Registers

Complete programs generally consist of many different code modules (or segments), and different types of data segments. However, at any given time during program execution, only a small subset of a program's segments are actually in use. Generally, this subset will include code, data, and possibly a stack. The 80286 architecture takes advantage of this by providing mechanisms to support direct access to the working set of a program's execution environment and access to additional segments on demand.

At any given instant, four segments of memory are immediately accessible to an executing 80286 program. The segment registers DS, ES, SS, and CS are used to identify these four current segments. Each of these registers specifies a particular kind of segment, as characterized by the associated mnemonics ("code," "stack," "data," or "extra") shown in figure 2-4.

An executing program is provided with concurrent access to the four individual segments of memory -- a code segment, a stack segment, and two data segments -- by means of the four segment registers. Each may be said to select a segment, since it uniquely determines the one particular segment from among the numerous segments in memory, which is to be immediately accessible at highest speed. Thus, the 16-bit contents of a segment register is called a segment selector.

Once a segment is selected, a base address is associated with it. To address an element within a segment, a 16-bit offset from the segment's base address must be supplied. The 16-bit segment selector and the 16-bit offset taken together form the high and low order halves, respectively, of a 32-bit virtual address pointer. Once a segment is selected, only the lower 16-bits of the pointer, called the offset, generally need to be specified by an instruction. Simple rules define which segment register is used to form an address when only a 16-bit offset is specified.

An executing program requires, first of all, that its instructions reside somewhere in memory. The segment of memory containing the currently executing sequence of instructions is known as the current code segment; it is specified by means of the CS register. All instructions are fetched from this code segment, using as an offset the contents of the instruction pointer (IP). The CS:IP register combination therefore forms the full 32-bit pointer for the next sequential program instruction. The CS register is manipulated indirectly. Transitions from one code segment to another (e.g., a procedure call) are effected implicitly as the result of control-transfer instructions, interrupts, and trap operations.

Stacks play a fundamental role in the 80286 architecture; subroutine calls, for example, involve a number of implicit stack operations. Thus, an executing program will generally require a region of memory for its stack. The segment containing this region is known as the current stack segment, and it is specified by means of the SS register. All stack operations are performed within this segment, usually in terms of address offsets contained in the stack pointer (SP) and stack frame base (BP) registers. Unlike CS, the SS register can be loaded explicitly for dynamic stack definition.

Beyond their code and stack requirements, most programs must also fetch and store data in memory. The DS and ES registers allow the specification of two data segments, each addressable by the currently executing program. Accessibility to two separate data areas supports differentiation and access requirements like local procedure data and global process data. An operand within a data segment is addressed by specifying its offset either directly in an instruction or indirectly via index and/or base registers (described in the next subsection).

Depending on the data structure (e.g., the way data is parceled into one or more segments), a program may require access to multiple data segments. To access additional segments, the DS and ES registers can be loaded under program control during the course of a program's execution. This simply requires loading the appropriate data pointer prior to accessing the data.

The interpretation of segment selector values depends on the operating mode of the processor. In Real Address Mode, a segment selector is a physical address (figure 2-5). In Protected Mode, a segment selector selects a segment of the user's virtual address space (figure 2-6). An intervening level of logical-to-physical address translation converts the logical address to a physical memory address. Chapter 6, "Memory Management," provides a detailed discussion of Protected Mode addressing. In general, considerations of selector formats and the details of memory mapping need not concern the application programmer.

### 2.3.3 Index, Pointer, and Base Registers

Five of the general-purpose registers are available for offset address calculations. These five registers, shown in figure 2-4, are SP, BP, BX, SI, and DI. SP is called a pointer register; BP and BX are called base registers; SI and DI are called index registers.

As described in the previous section, segment registers define the set of four segments currently addressable by a program. A pointer, base, or index register may contain an offset value relative to the start of one of these segments; it thereby points to a particular operand's location within that segment. To allow for efficient computations of effective address offsets, all base and index registers may participate interchangeably as operands in most arithmetical operations.

Stack operations are facilitated by the stack pointer (SP) and stack frame base (BP) registers. By specifying offsets into the current stack segment, each of these registers provides access to data on the stack. The SP register is the customary top-of-stack pointer, addressing the uppermost datum on a push-down stack. It is referenced implicitly by PUSH and POP operations, subroutine calls, and interrupt operations. The BP register provides yet another offset into the stack segment. The existence of this stack relative base register, in conjunction with certain addressing modes described in section 2.4.3, is particularly useful for accessing data structures, variables and dynamically allocated work space within the stack.

Stacks in the 80286 are implemented in memory and are located by the stack segment register (SS) and the stack pointer register (SP). A system may have an unlimited number of stacks, and a stack may be up to 64K bytes long, the maximum length of a segment.

One stack is directly addressable at a time; this is the current stack, often referred to simply as "the" stack. SP contains the current top of the stack (TOS). In other words, SP contains the offset to the top of the push down stack from the stack segment's base address. Note, however, that the stack's base address (contained in SS) is not the "bottom" of the stack (figure 2-7).

80286 stack entries are 16 bits wide. Instructions operate on the stack by adding and removing stack items one word at a time. An item is pushed onto the stack (see figure 2-8) by decrementing SP by 2 and writing the item at the new TOS. An item is popped off the stack by copying it from TOS and then incrementing SP by 2. In other words, the stack grows down in memory toward its base address. Stack operations never move items on the stack; nor do they erase them. The top of the stack changes only as a result of updating the stack pointer.

The stack frame base pointer (BP) is often used to access elements on the stack relative to a fixed point on the stack rather than relative to the current TOS. It typically identifies the base address of the current stack frame established for the current procedure (figure 2-9). If an index register is used relative to BP (e.g., base + index addressing mode using BP as the base), the offset will be calculated automatically in the current stack segment.

Accessing data structures in data segments is facilitated by the BX register, which has the same function in addressing operands within data segments that BP does for stack segments. They are called base registers because they may contain an offset to the base of a data structure. The similar usage of these two registers is especially important when discussing addressing modes (see section 2.4, "Addressing Modes").

Operations on data are also facilitated by the SI and DI registers. By specifying an offset relative to the start of the currently addressable data segment, an index register can be used to address an operand in the segment. If an index register is used in conjunction with the BX base register (i.e., base + index addressing) to form an offset address, the data is also assumed to reside in the current data segment. As a rule, data referenced through an index register or BX is presumed to reside in the current data segment. That is, if an instruction invokes addressing for one of its operands using either BX, DI, SI, or BX with SI or DI, the contents of the register(s) (BX, DI, or SI) implicitly specify an offset in the current data segment. As previously mentioned, data referenced via SP, BP or BP with SI or DI implicitly specify an operand in the current stack segment (refer to table 2-1).

There are two exceptions to the rules listed above. The first concerns the operation of certain 80286 string instructions. For the most flexibility, these instructions assume that the DI register addresses destination strings not in the data segment, but rather in the extra segment (ES register). This allows movement of strings between different segments. This has led to the descriptive names "source index" and "destination index." In all cases other than string instructions, however, the SI and DI registers may be used
interchangeably to reference either source or destination operands.

A second more general override capability allows the programmer complete control of which segment is used for a specific operation. Segment-override prefixes, discussed in section 2.4.3, allow the index and base registers to address data in any of the four currently addressable segments.

**Table 2-1. Implied Segment Usage by Index, Pointer, and Base Registers**
| Register      | Implied Segment             |
|---------------|-----------------------------|
| SP            | SS                          |
| BP            | SS                          |
| BX            | DS                          |
| DI            | DS, ES for String Operations|
| BP + SI, DI   | SS                          |
| BX + SI, DI   | DS                          |

> **NOTE**
> All implied Segment usage, except SP to SS and DI to ES for String Operations, may be explicitly specified with a segment override prefix for any of the four segments. The prefix precedes the instruction for which explicit reference is desired.

**Figure 2-5. Real Address Mode Segment Selector Interpretation**
```
                                       ┌───────────────┐<┐
                                       │               │ │
                                       │               │ │
                                     ┌─├───────────────┤ │  1 MEGABYTE
              SEGMENT     64K BYTES <┤ │     SEG 1     │ ├─ PHYSICAL
             ┌───────────────────────┼─├───────────────┤ │  ADDRESS
             │     BASE ADDRESS      │ │               │ │  SPACE
             │                       │ │               │ │
       ┌─────┴──────┬──────┐         │               │ │
       │  SELECTOR  │ 0000 │         └───────────────┘<┘
       └────────────┴──────┘
```
> **NOTES:**
> 1. The selector identifies a segment in physical memory.
> 2. A selector specifies the segments base address, Modulo 16, within the 1 Megabyte address space.
> 3. The selector is the 16 most significant bits of a segments physical base address.
> 4. The values of selectors determines the amount they overlap in real memory.
> 5. Segments may overlap by increments of 16 bytes. Overlap ranges from complete (SEG 1 = SEG 1) to none (SEG 1 != SEG 2, dist > 64K).

**Figure 2-6. Protected Mode Segment Selector Interpretation**
```
                                        ┌────────────┐<┐
                                        │  SEG 3FFF  │ │
                                        ├────────────┤ │
                                        │  SEG 3FFE  │ │
           ┌────────────────────────────┼────────────┤ │
   ┌───────┴──────┐                     │  SEG 3FFD  │ │
   │   SELECTOR   │                   ┌─├────────────┤ │
   └──────────────┘    1 TO 64K BYTES<┤ │  SEG 3FFC  │ │
                                      └─├────────────┤ │
                                        │  SEG 3FFB  │ │
                                        ├────────────┤ │  1 GIGABYTE
                                        │    ...     │ ├─ VIRTUAL
                                        ├────────────┤ │  ADDRESS
                                        │   SEG 4    │ │  SPACE
                                        ├────────────┤ │
                                        │   SEG 3    │ │
                                        ├────────────┤ │
                                        │   SEG 2    │ │
                                        ├────────────┤ │
                                        │   SEG 1    │ │
                                        ├────────────┤ │
                                        │   SEG 0    │ │
                                        └────────────┘<┘
```
> **NOTES:**
> 1. A selector uniquely identifies (names) one of 16K possible segments in the task's virtual address space.
> 2. The selector value does not specify the segment's location in physical memory.
> 3. The selector does not imply any overlap with other segments (This depends on the base address of the segment via the memory management and protection information).

**Figure 2-7. 80286 Stack**
```
                          ┌─────────────────┐     LOGICAL
                          │                 │<--- BOTTOM OF STACK
                          ├─────────────────┤     (initial SP value)
                          │                 │
                          ├─────────────────┤
                          │                 │
                          ├─────────────────┤
                          │                 │  ^  POP-UP
                          ├─────────────────┤  │
             ┌────────────┤                 │<--- LOGICAL TOP OF STACK
             │            ├─────────────────┤  │
             │            │                 │  v  PUSH-DOWN
  ┌──────┬───┴──┐         │                 │
  │  SS  │  SP  │         │                 │
  └──────┴──────┘         │                 │
     │                    │                 │
     │                    │                 │
     │                    │                 │
     └────────────────────┴─────────────────┘  STACK SEGMENT BASE ADDRESS
```

**Figure 2-8. Stack Operation**
```
  STACK OPERATION FOR CODE SEQUENCE:
  PUSH AX                                    STACK
  POP AX                                    SEGMENT
  POP BX         ┌──────────────┐
                 │EXISTING STACK│
                 │ BEFORE PUSH  │    1062 ┌─────────┐
                 └──────────────┘         ├─────────┤
                                     1060 │ 1 1 1 1 │
                                          ├─────────┤
                                     105E │ 2 2 2 2 │
                                          ├─────────┤
                                     105C │ 3 3 3 3 │
                                          ├─────────┤
                                     105A │ 4 4 4 4 │
                                          ├─────────┤
                   ┌──────────────   1058 │ 5 5 5 5 │
  SS               │   SP                 ├─────────┤<┐
  ┌─────────┬──────┴───┐            1056 │ 6 6 6 6 │ │
  │ SELECTOR│  OFFSET  │                 ├─────────┤ │  NOT
  └─────────┴──────────┘            1054 │ 7 7 7 7 │ ├─ PRESENTLY
       │                                  ├─────────┤ │  USED
       │                             1052 │ 8 8 8 8 │ │
       │                                  ├─────────┤<┘
       │                             1050 │ 9 9 9 9 │
       │                                  │   ...   │
       └───────────────────────────   0000 ├─────────┤

                                             STACK
                                            SEGMENT
                                          ┌─────────┐
                                     1062 │ 0 0 0 0 │
                                          ├─────────┤
                                     1060 │ 1 1 1 1 │
                                          ├─────────┤
                                     105E │ 2 2 2 2 │
                                          ├─────────┤
                                     105C │ 3 3 3 3 │
                                          ├─────────┤
                                     105A │ 4 4 4 4 │  PUSH AX
                                          ├─────────┤┌─────────┐
                   ┌──────────────   1058 │ 5 5 5 5 ││ A A A A │
  SS               │   SP                 ├─────────┤└────┬────┘
  ┌─────────┬──────┴───┐            1056 │ A A A A │<────┘
  │ SELECTOR│  OFFSET  │                 ├─────────┤
  └─────────┴──────────┘            1054 │ 7 7 7 7 │
       │                                  ├─────────┤
       │                             1052 │ 8 8 8 8 │
       │                                  ├─────────┤
       │                             1050 │ 9 9 9 9 │
       │                                  │   ...   │
       └───────────────────────────   0000 ├─────────┤

                                             STACK
                                            SEGMENT
                                          ┌─────────┐
                                     1062 │ 0 0 0 0 │
                                          ├─────────┤
                                     1060 │ 1 1 1 1 │
                                          ├─────────┤
                                     105E │ 2 2 2 2 │
                                          ├─────────┤   POP BX
                                     105C │ 3 3 3 3 │ ┌─────────┐
                                          ├─────────┤ │ 5 5 5 5 │
                                     105A │ 4 4 4 4 │ └─────────┘
                                          ├─────────┤      ^
                   ┌──────────────   1058 │ 5 5 5 5 │<─────┘
  SS               │   SP                 ├─────────┤
  ┌─────────┬──────┴───┐            1056 │ A A A A │<─────┐
  │ SELECTOR│  OFFSET  │                 ├─────────┤      v
  └─────────┴──────────┘            1054 │ 7 7 7 7 │ ┌─────────┐
       │                                  ├─────────┤ │ A A A A │
       │                             1052 │ 8 8 8 8 │ └─────────┘
       │                                  ├─────────┤   POP AX
       │                             1050 │ 9 9 9 9 │
       │                                  │   ...   │
       └───────────────────────────   0000 ├─────────┤
```

**Figure 2-9. BP Usage as a Stack Frame Base Pointer**
```
BP is a constant pointer to stack based variables and work space. All
references use BP and are independent of SP, which may vary during a routine
execution.

PROC N
  PUSH AX
  PUSH ARRAY_SIZE
  CALL PROC_N 1 <─────── PROC_N+1
                v───────┐    PUSH BP
                        │    PUSH CX
                        │    MOVE BP, SP
                        │    SUB SP, WORK_SPACE
                        │         .
                        │         .
                        │         .
                        │   "PROCEDURE BODY"
                        │         .
                        │         .
                        │         .
                        │    MOV SP, BP
                        │    POP CX
                        │    POP BP
                        └──── RET

                              ┌─────────────┐<┐
                              │  PARAMETERS │ │
                              ├─────────────┤ │
                              │ RETURN ADDR │ │
                              ├─────────────┤ ├─PROCEDURE N
              ┌───┐           │  REGISTERS  │ │ STACK FRAME
                BP  ──────────┼─────────────┤ │
              └───┘           │             │ │  PROCEDURE
                            ^ │  WORK_SPACE │ │  N+1 STACK
                     BOTTOM │ ├─────────────┤─┤    FRAME
                     OF     │ │  PARAMETERS │ ├<───┘
                     STACK  │ ├─────────────┤ │ DYNAMICALLY
                              │ RETURN ADDR │ │ ALLOCATED
                              ├─────────────┤ │ ON DEMAND
              ┌───┐           │  REGISTERS  │ │ RATHER THAN
              │ BP ├──────────┼─────────────┤ │<STATICALLY
              └───┘           │             │ │<───┘
                              │  WORK_SPACE │ ││
                ┌─────────────┼─────────────┤<┘┘ <──┐
                ├─────────────┤             │    TOP OF STACK
     ┌──────┬───┴──┐          │             │
     │  SS  │  SP  │          └─────────────┘ STACK SEGMENT BASE
     └──────┴──────┘
```

### 2.3.4 Status and Control Registers

Two status and control registers are of immediate concern to applications programmers: the instruction pointer and the FLAGS registers.

The **instruction pointer register (IP)** contains the offset address, relative to the start of the current code segment, of the next sequential instruction to be executed. Together, the CS:IP registers thus define a 32-bit program-counter. The instruction pointer is not directly visible to the programmer; it is controlled implicitly, by interrupts, traps, and control-transfer operations.

The **FLAGS register** encompasses eleven flag fields, mostly one-bit wide, as shown in figure 2-10. Six of the flags are status flags that record processor status information. The status flags are affected by the execution of arithmetic and logical instructions. The carry flag is also modifiable with instructions that will clear, set or complement this flag bit. See Chapters 3 and 4.

- The **carry flag (CF)** generally indicates a carry or borrow out of the most significant bit of an 8- or 16-bit operand after performing an arithmetic operation; this flag is also useful for bit manipulation operations involving the shift and rotate instructions.
- The **zero flag (ZF)** indicates a zero result when set.
- The **sign flag (SF)** indicates whether the result was negative (SF=1) or positive (SF=0).
- The **overflow flag (OF)** indicates whether an operation results in a carry into the high order bit of the result but not a carry out of the high-order bit, or vice versa.
- The **parity flag (PF)** indicates whether the modulo 2 sum of the low-order eight bits of the operation is even (PF=0) or odd (PF=1) parity.
- The **auxiliary carry flag (AF)** represents a carry out of or borrow into the least significant 4-bit digit when performing binary coded decimal (BCD) arithmetic.

The FLAGS register also contains three control flags that are used, under program control, to direct certain processor operations.
- The **interrupt-enable flag (IF)**, if set, enables external interrupts; otherwise, interrupts are disabled.
- The **trap flag (TF)**, if set, puts the processor into a single-step mode for debugging purposes where the target program is automatically interrupted to a user supplied debug routine after the execution of each target program instruction.
- The **direction flag (DF)** controls the forward or backward direction of string operations: 0 = forward or auto increment the address register(s) (SI, DI or SI and DI), 1 = backward or auto-decrement the address register(s) (SI, DI or SI and DI).

In general, the interrupt enable flag may be set or reset with special instructions (STI = set, CLI = clear) or by placing the flags on the stack, modifying the stack, and returning the flag image from the stack to the flag register. If operating in Protected Mode, the ability to alter the IF bit is subject to protection checks to prevent non-privileged programs from effecting the interrupt state of the CPU. This applies to both instruction and stack options for modifying the IF bit.

The TF flag may only be modified by copying the flag register to the stack, setting the TF bit in the stack image, and returning the modified stack image to the flag register. The trap interrupt occurs on completion of the next instruction. Entry to the single step routine saves the flag register on the stack with the TF bit set, and resets the TF bit in the register. After completion of the single step routine, the TF bit is automatically set on return to the program being single stepped to interrupt the program again after completion of the next instruction. Use of TF is not inhibited by the protection mechanism in Protected Mode.

The DF flag, like the IF flag, is controlled by instructions (CLD = clear, STD = set) or flag register modification through the stack. Typically, routines that use string instructions will save the flags on the stack, modify DF as necessary via the instructions provided, and restore DF to its original state by restoring the Flag register from the stack before returning. Access or control of the DF flag is not inhibited by the protection mechanism in Protected Mode.

The Special Fields bits are only relevant in Protected Mode. Real Address Mode programs should treat these bits as don't-care's, making no assumption about their status. Attempts to modify the IOPL and NT fields are subject to protection checking in Protected Mode. In general, the application's programmer will not be able to and should not attempt to modify these bits. (See section 10.3, "Privileged and Trusted Instructions" for more details.)

**Figure 2-10. Flags Register**
```
    STATUS FLAGS:
     CARRY<───────────────────────────────────────────────┐
     PARITY<─────────────────────────────────────────┐     │
     AUXILLIARY CARRY<───────────────────────────┐     │     │
     ZERO<─────────────────────────────────┐     │     │     │
     SIGN<───────────────────────────┐  │     │     │     │
     OVERFLOW<─────────────┐           │  │     │     │     │
                         │           │  │     │     │     │
              15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
            ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
      FLAGS:│  │NT│IOPL │OF│DF│IF│TF│SF│ZF│  │AF│  │PF│  │CF│
            └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
                 ^   ^       ^  ^  ^
                 │   │       │  │  │          CONTROL FLAGS:
                 │   │       │  │  └───────────TRAP FLAG
                 │   │       │  └──────────────INTERRUPT ENABLE
                 │   │       └──────────────────DIRECTION FLAG
                 │   │                        SPECIAL FIELDS:
                 │   └──────────────────────────I/O PRIVILEGE LEVEL
                 └──────────────────────────────NESTED TASK FLAG
```

## 2.4 Addressing Modes

The information encoded in an 80286 instruction includes a specification of the operation to be performed, the type of the operands to be manipulated, and the location of these operands. If an operand is located in memory, the instruction must also select, explicitly or implicitly, which of the currently addressable segments contains the operand. This section covers the operand addressing mechanisms; 80286 operators are discussed in Chapter 3.

The five elements of a general instruction are briefly described below. The exact format of 80286 instructions is specified in Appendix B.

- The **opcode** is present in all instructions; in fact, it is the only required element. Its principal function is the specification of the operation performed by the instruction.
- A **register specifier**.
- The **addressing mode specifier**, when present, is used to specify the addressing mode of an operand for referencing data or performing indirect calls or jumps.
- The **displacement**, when present, is used to compute the effective address of an operand in memory.
- The **immediate operand**, when present, directly specifies one operand of the instruction.

Of the four elements, only one, the opcode, is always present. The other elements may or may not be present, depending on the particular operation involved and on the location and type of the operands.

### 2.4.1 Operands

Generally speaking, an instruction is an operation performed on zero, one, or two operands, which are the data manipulated by the instruction. An operand can be located either in a register (AX, BX, CX, DX, SI, DI, SP, or BP in the case of 16-bit operands; AH, AL, BH, BL, CH, CL, DH, or DL in the case of 8-bit operands; the FLAG register for flag operations in the instruction itself (as an immediate operand)), or in memory or an I/O port. Immediate operands and operands in registers can be accessed more rapidly than operands in memory since memory operands must be fetched from memory while immediate and register operands are available in the processor.

An 80286 instruction can reference zero, one, or two operands. The three forms are as follows:

- **Zero-operand instructions**, such as RET, NOP, and HLT. Consult Appendix B.
- **One-operand instructions**, such as INC or DEC. The location of the single operand can be specified implicitly, as in AAM (where the register AX contains the operand), or explicitly, as in INC (where the operand can be in any register or memory location). Explicitly specified operands are accessed via one of the addressing modes described in section 2.4.2.
- **Two operand instructions** such as MOV, ADD, XOR, etc., generally overwrite one of the two participating operands with the result. A distinction can thus be made between the source operand (the one left unaffected by the operation) and the destination operand (the one overwritten by the result). Like one-operand instructions, two-operand instructions can specify the location of operands either explicitly or implicitly. If an instruction contains two explicitly specified operands, only one of them -- either the source or the destination -- can be in a register or memory location. The other operand must be in a register or be an immediate source operand. Special cases of
two-operand instructions are the string instructions and stack manipulation. Both operands of some string instructions are in memory and are explicitly specified. Push and pop stack operations allow transfer between memory operands and the memory based stack.

Thus, the two-operand instructions of the 80286 permit operations of the following sort:

- Register-to-register
- Register-to-memory
- Memory-to-register
- Immediate-to-register
- Immediate-to-memory
- Memory-to-memory

Instructions can specify the location of their operands by means of eight addressing modes, which are described in sections 2.4.2 and 2.4.3.

### 2.4.2 Register and Immediate Modes

Two addressing modes are used to reference operands contained in registers and instructions:

- **Register Operand Mode.** The operand is located in one of the 16-bit registers (AX, BX, CX, DX, SI, DI, SP, or BP) or in one of the 8-bit general registers (AH, BH, CH, DH, AL, BL, CL, or DL).

Special instructions are also included for referencing the CS, DS, ES, SS, and Flag registers as operands also.

- **Immediate Operand Mode.** The operand is part of the instruction itself (the immediate operand element).

### 2.4.3 Memory Addressing Modes

Six modes are used to access operands in memory. Memory operands are accessed by means of a pointer consisting of a segment selector (see section 2.3.2) and an offset, which specifies the operand's displacement in bytes from the beginning of the segment in which it resides. Both the segment selector component and the offset component are 16-bit values. (See section 2.1 for a discussion of segmentation.) Only some instructions use a full 32-bit address.

Most memory references do not require the instruction to specify a full 32-bit pointer address. Operands that are located within one of the currently addressable segments, as determined by the four segment registers (see section 2.3.2, "Segment Registers"), can be referenced very efficiently simply by means of the 16-bit offset. This form of address is called by short address. The choice of segment (CS, DS, ES, or SS) is either implicit within the instruction itself or explicitly specified by means of a segment override prefix (see below).

See figure 2-11 for a diagram of the addressing process.

#### 2.4.3.1 Segment Selection

All instructions that address operands in memory must specify the segment and the offset. For speed and compact instruction encoding, segment selectors are usually stored in the high speed segment registers. An instruction need specify only the desired segment register and an offset in order to address a memory operand.

Most instructions need not explicitly specify which segment register is used. The correct segment register is automatically chosen according to the rules of table 2-1 and table 2-2. These rules follow the way programs are written (see figure 2-12) as independent modules that require areas for code and data, a stack, and access to external data areas.

There is a close connection between the type of memory reference and the segment in which that operand resides (see the next section for a discussion of how memory addressing mode calculations are performed). As a rule, a memory reference implies the current data segment (i.e., the implicit segment selector is in DS) unless the BP register is involved in the address specification, in which case the current stack segment is implied (i.e, SS contains the selector).

The 80286 instruction set defines special instruction prefix elements (see Appendix B). One of these is SEG, the segment-override prefix. Segment-override prefixes allow an explicit segment selection. Only in two special cases -- namely, the use of DI to reference destination strings in the ES segment, and the use of SP to reference stack locations in the SS segment -- is there an implied segment selection which cannot be overridden. The format of segment override prefixes is shown in Appendix B.

**Table 2-2. Segment Register Selection Rules**
| Memory Reference Needed | Segment Register Used | Implicit Segment Selection Rule                               |
|-------------------------|-----------------------|---------------------------------------------------------------|
| Instructions            | Code (CS)             | Automatic with instruction prefetch.                          |
| Stack                   | Stack (SS)            | All stack pushes and pops. Any memory reference which uses BP as a base register. |
| Local Data              | Data (DS)             | All data references except when relative to stack or string destination. |
| External (Global) Data  | Extra (ES)            | Alternate data segment and destination of string operation.   |

**Figure 2-11. Two-Component Address**
```
                                            ┌─────────────┐
              POINTER                       │             │
     ┌───────────┬───────────┐              ├─────────────┤<┐
     │  SEGMENT  │  OFFSET   │              │             │ │
     └───────────┴───────────┘              │             │ │
      31       16 15        0               ├─────────────┤ │
      └─────┬─────┘ └─────┬─────┘               │   OPERAND   │ │  SELECTED
           │           │                    │   SELECTED  │ ├─ SEGMENT
           │           └────────────────────┼─────────────┤ │
           │                                │             │ │
           │                                │             │ │
           │                                │             │ │
           │                                │             │ │
           └────────────────────────────────┼─────────────┤<┘
                                            │             │
                                            │   MEMORY    │
```

#### 2.4.3.2 Offset Computation

The offset within the desired segment is calculated in accordance with the desired addressing mode. The offset is calculated by taking the sum of up to three components:

- the **displacement** element in the instruction
- the **base** (contents of BX or BP -- a base register)
- the **index** (contents of SI or DI -- an index register)

Each of the three components of an offset may be either a positive or negative value. Offsets are calculated modulo 2^16.

The six memory addressing modes are generated using various combinations of these three components. The six modes are used for accessing different types of data stored in memory:

| Addressing Mode                 | Offset Calculation                  |
|---------------------------------|-------------------------------------|
| direct address                  | displacement alone                  |
| register indirect               | base or index alone                 |
| based                           | base + displacement                 |
| indexed                         | index + displacement                |
| based indexed                   | base + index                        |
| based indexed with displacement | base + index + disp                 |

In all six modes, the operand is located at the specified offset within the selected segment. All displacements, except direct address mode, are optionally 8- or 16-bit values. 8-bit displacements are automatically sign-extended to 16 bits. The six addressing modes are described and demonstrated in the following section on memory addressing modes.

**Figure 2-12. Use of Memory Segmentation**
```
                                              ┌──────┐
                                              │ CODE │
                                              ├──────┤  MODULE A
                                              │ DATA │
                                              └──────┘
            CPU                               │      │
       ┌───────────┐                          ┌──────┐
       │ ┌───────┐ │                          │ CODE │
       │ │ CODE  ├─┼──────────────────────────┼──────┤  MODULE B
       │ ├───────┤ │                          │ DATA │
       │ │ DATA  ├─┼──────────────────────────└──────┘
       │ ├───────┤ │                          │      │
       │ │ STACK ├─┼───────────────┐          ┌──────┐
       │ ├───────┤ │               │          │      │  PROCESS STACK
       │ │ EXTRA ├─┼───────────┐   └──────────└──────┘
       │ └───────┘ │           │              │      │
       │  SEGMENT  │           │              ┌──────┐  PROCESS
       │ REGISTERS │           │              │      │  DATA
       └───────────┘           └──────────────└──────┘  BLOCK 1
                                              │      │
                                              ┌──────┐  PROCESS
                                              │      │  DATA
                                              └──────┘  BLOCK 2
                                              └──────┘
                                               MEMORY
```

#### 2.4.3.3 Memory Mode

Two modes are used for simple scalar operands located in memory:

- **Direct Address Mode.** The offset of the operand is contained in the instruction as the displacement element. The offset is a 16-bit quantity.
- **Register Indirect Mode.** The offset of the operand is in one of the registers SI, DI, or BX. (BP is excluded; if BP is used as a stack frame base, it requires an index or displacement component to reference either parameters passed on the stack or temporary variables allocated on the stack. The instruction level bit encoding for the BP only address mode is used to specify Direct Address mode.)

The following four modes are used for accessing complex data structures in memory (see figure 2-13):

- **Based Mode.** The operand is located within the selected segment at an offset computed as the sum of the displacement and the contents of a base register (BX or BP). Based mode is often used to access the same field in different copies of a structure (often called a record). The base register points to the base of the structure (hence the term "base" register), and the displacement selects a particular field. Corresponding fields within a collection of structures can be accessed simply by changing the base register. (See figure 2-13, example 1.)
- **Indexed Mode.** The operand is located within the selected segment at an offset computed as the sum of the displacement and the contents of an index register (SI or DI). Indexed mode is often used to access elements in a static array (e.g., an array whose starting location is fixed at translation time). The displacement locates the beginning of the array, and the value of the index register selects one element. Since all array elements are the same length, simple arithmetic on the index register will select any element. (See figure 2-13, example 2.)
- **Based Indexed Mode.** The operand is located within the selected segment at an offset computed as the sum of the base register's contents and an index register's contents. Based Indexed mode is often used to access elements of a dynamic array (i.e., an array whose base address can change during execution). The base register points to the base of the array, and the value of the index register is used to select one element. (See figure 2-13, example 3.)
- **Based Indexed Mode with Displacement.** The operand is located with the selected segment at an offset computed as the sum of a base register's contents, an index register's contents, and the displacement. This mode is often used to access elements of an array within a structure. For example, the structure could be an activation record (i.e., a region of the stack containing the register contents, parameters, and variables associated with one instance of a procedure); and one variable could be an array. The base register points to the start of the activation record, the displacement expresses the distance from the start of the record to the beginning of the array variable, and the index register selects a particular element of the array. (See figure 2-13, example 4.)

Table 2-3 gives a summary of all memory operand addressing options.

**Table 2-3. Memory Operand Addressing Modes**
| Addressing Mode                | Offset Calculation                               |
|--------------------------------|--------------------------------------------------|
| Direct                         | 16-bit Displacement in the instruction           |
| Register Indirect              | BX, SI, DI                                       |
| Based                          | (BX or BP) + Displacement                        |
|                                | The displacement can be a 0, 8 or 16-bit value.  |
| Indexed                        | (SI or DI) + Displacement                        |
|                                | The displacement can be a 0, 8 or 16-bit value.  |
| Based Indexed                  | (BX or BP) + (SI or DI)                          |
| Based Indexed + Displacement   | (BX or BP) + (SI or DI) + Displacement           |
|                                | The displacement can be a 0, 8 or 16-bit value.  |

**Figure 2-13. Complex Addressing Modes**
```
1. BASED MODE                         2. INDEXED MODE

MOV AX, [BP + DATE_CODE]              MOV ID[SI], DX
ADD[BX + BALANCE], CX                 SUB BX, DATA_TBL[SI]

                  ┌───────────┐<┐                       ┌───────────┐<┐ F
                  │           │ │                       │           │ │ I
┌───────────┐     ├───────────┤ │     ┌───────────┐     ├───────────┤ │ X
│   DISPL   ├─────┤  OPERAND  │ ├─    │   INDEX   ├─────┤  OPERAND  │ ├─E D
└───────────┘     ├───────────┤ │     └───────────┘     ├───────────┤ │
      +           │           │ │           +           │           │ │ A
┌───────────┐ ┌───┼───────────┤<┘     ┌───────────┐ ┌───┼───────────┤<┘ R
│   BASE    ├─┘   │           │       │   DISPL   ├─┘   │           │   R
└───────────┘     │           │       └───────────┘     │           │   A
      +           │           │             +           │           │   Y
┌───────────┐     │           │       ┌───────────┐     │           │
│  SEGMENT  ├─────└───────────┘       │  SEGMENT  ├─────└───────────┘
└───────────┘                         └───────────┘

3. BASED INDEXED                      4. BASED INDEXED MODE
                                         WITH DISPLACEMENT             BASED
MOV DX, [BP][DI]                                                   STRUCTURE
AND [BX + SI], 3FFH                   MOV CX, [BP][SI + CNT]      CONTAINING
                                      SHR[BX + DI + MASK]              ARRAY
                  ┌───────────┐<┐ B                     ┌───────────┐    <┐
                  │           │ │ A                     │           │   <┐│
                  │           │ │ S                     │           │     ││
┌───────────┐     ├───────────┤ │ E   ┌───────────┐     ├───────────┤<┐   ││
│   INDEX   ├─────┤  OPERAND  │ ├─D   │   INDEX   ├─────┤▒▒▒▒▒▒▒▒▒▒▒│ │ A ││
└───────────┘     ├───────────┤ │     └───────────┘   │ ├───────────┤ │ R ││
      +           │           │ │ A         +         └─┤  OPERAND  │ ├─R <┘
┌───────────┐ ┌───┼───────────┤<┘ R   ┌───────────┐ ┌───┼───────────┤ │ A │
│   BASE    ├─┘   │           │   R   │   DISPL   ├─┘   │▒▒▒▒▒▒▒▒▒▒▒│ │ Y │
└───────────┘     │           │   A   └───────────┘   ┌─┼───────────┤<┘   │
      +           │           │   Y         +         │ │           │     │
┌───────────┐     │           │       ┌───────────┐   │ ├───────────┤   <┘
│  SEGMENT  ├─────└───────────┘       │   BASE    ├───┘ │           │
└───────────┘                         └───────────┘     │           │
                                            +           │           │
                                      ┌───────────┐     │           │
                                      │  SEGMENT  ├─────└───────────┘
                                      └───────────┘
```

## 2.5 Input/Output

The 80286 allows input/output to be performed in either of two ways: by means of a separate I/O address space (using specific I/O instructions) or by means of memory-mapped I/O (using general-purpose operand manipulation instructions).

### 2.5.1 I/O Address Space

The 80286 provides a separate I/O address space, distinct from physical memory, to address the input/output ports that are used for external devices. The I/O address space consists of 2^16 (64K) individually addressable 8-bit ports. Any two consecutive 8-bit ports can be treated as a 16-bit port. Thus, the I/O address space can accommodate up to 64K 8-bit ports or up to 32K 16-bit ports. I/O port addresses 00F8H to 00FFH are reserved by Intel.

The 80286 can transfer either 8 or 16 bits at a time to a device located in the I/O space. Like words in memory, 16-bit ports should be aligned at even-numbered addresses so that the 16 bits will be transferred in a single access. An 8-bit port may be located at either an even or odd address. The internal registers in a given peripheral controller device should be assigned addresses as shown below.

| Port Register        | Port Addresses        | Example     |
|----------------------|-----------------------|-------------|
| 16-bit               | even word addresses   | `OUT FE,AX` |
| 8-bit; device on lower half of 16-bit data bus | even byte addresses | `IN AL,FE`  |
| 8-bit; device on upper half of 16-bit data bus | odd byte addresses  | `OUT FF,AL` |

The I/O instructions `IN` and `OUT` (described in section 3.11.3) are provided to move data between I/O ports and the AX (16-bit I/O) or AL (8-bit I/O) general registers. The block I/O instructions `INS` and `OUTS` (described in section 4.1) move blocks of data between I/O ports and memory space (as shown below). In Protected Mode, an operating system may prevent a program from executing these I/O instructions. Otherwise, the function of the I/O instructions and the structure of the I/O space are identical for both modes of operation.

```
INS  es:byte ptr [di], DX
OUTS DX, byte ptr [si]
```

`IN` and `OUT` instructions address I/O with either a direct address to one of up to 256 port addresses, or indirectly via the DX register to one of up to 64K port addresses. Block I/O uses the DX register to specify the I/O address and either SI or DI to designate the source or destination memory address. For each transfer, SI or DI are either incremented or decremented as specified by the direction bit in the flag word while DX is constant to select the I/O device.

### 2.5.2 Memory-Mapped I/O

I/O devices also may be placed in the 80286 memory address space. So long as the devices respond like memory components, they are indistinguishable to the processor.

Memory-mapped I/O provides additional programming flexibility. Any instruction that references memory may be used to access an I/O port located in the memory space. For example, the `MOV` instruction can transfer data between any register and a port; and the `AND`, `OR`, and `TEST` instructions may be used to manipulate bits in the internal registers of a device (see figure 2-14). Memory-mapped I/O performed via the full instruction set maintains the full complement of addressing modes for selecting the desired I/O device.

Memory-mapped I/O, like any other memory reference, is subject to access protection and control when executing in protected mode.

**Figure 2-14. Memory-Mapped I/O**
```
                MEMORY
             ADDRESS SPACE
          ┌────────────────┐                     I/O DEVICE 1
          │                │                ┌─────────────────────┐
          │                │                │  INTERNAL REGISTER  │
          ├────────────────┤<───────────────┼─┌─────────────────┐─┤
          │                │                │ │                 │ │
          ├────────────────┤<───────────────┼─└─────────────────┘─┤
          │                │                └─────────────────────┘
          │                │
          │                │                     I/O DEVICE 2
          │                │                ┌─────────────────────┐
          │                │                │  INTERNAL REGISTER  │
          │────────────────│<───────────────┼─┌─────────────────┐─┤
          │                │                │ │                 │ │
          │────────────────│<───────────────┼─└─────────────────┘─┤
          │                │                └─────────────────────┘
          │                │
          └────────────────┘
```

## 2.6 Interrupts and Exceptions

The 80286 architecture supports several mechanisms for interrupting program execution. Internal interrupts are synchronous events that are the responses of the CPU to certain events detected during the execution of an instruction. External interrupts are asynchronous events typically triggered by external devices needing attention. The 80286 supports both maskable (controlled by the IF flag) and non-maskable interrupts. They cause the processor to temporarily suspend its present program execution in order to service the requesting device. The major distinction between these two kinds of interrupts is their origin: an internal interrupt is always reproducible by re-executing with the program and data that caused the interrupt, whereas an external interrupt is generally independent of the currently executing task.

Interrupts 0-31 are reserved by Intel.

Application programmers will normally not be concerned with servicing external interrupts. More information on external interrupts for system programmers may be found in Chapter 5, section 5.2, "Interrupt Handling for Real Address Mode," and in Chapter 9, "Interrupts, Traps and Faults for Protected Virtual Address Mode."

In Real Address Mode, the application programmer is affected by two kinds of internal interrupts. (Internal interrupts are the result of executing an instruction which causes the interrupt.) One type of interrupt is called an exception because the interrupt only occurs if a particular fault condition exists. The other type of interrupt generates the interrupt every time the instruction is executed.

The exceptions are: divide error, INTO detected overflow, bounds check, segment overrun, invalid operation code, and processor extension error (see table 2-4).
- A **divide error exception** results when the instructions DIV or IDIV are executed with a zero denominator; otherwise, the quotient will be too large for the destination operand (see section 3.3.4 for a discussion of DIV and IDIV).
- An **overflow exception** results when the INTO instruction is executed and the OF flag is set (after an arithmetic operation that set the overflow (OF) flag). (See section 3.6.3, "Software Generated Interrupts," for a discussion of INTO.)
- A **bounds check exception** results when the BOUND instruction is executed and the array index it checks falls outside the bounds of the array. (See section 4.2 for a discussion of the BOUND instruction.)
- The **segment overrun exception** occurs when a word memory reference is attempted which extends beyond the end of a segment.
- An **invalid operation code exception** occurs if an attempt is made to execute an undefined instruction operation code.
- A **processor extension error** is generated when a processor extension detects an illegal operation. Refer to Chapter 5 for a more complete description of these exception conditions.

The instruction `INT` generates an internal interrupt whenever it is
executed. The effects of this interrupt (and the effects of all interrupts)
is determined by the interrupt handler routines provided by the application
program or as part of the system software (provided by system programmers).
See Chapter 5 for more on this topic. The `INT` instruction itself is
discussed in section 3.6.3.

In Protected Mode, many more fault conditions are detected and result in
internal interrupts. Protected Mode interrupts and faults are discussed in
Chapter 9.

## 2.7 Hierarchy of Instruction Sets

For descriptive purposes, the 80286 instruction set is partitioned into
three distinct subsets: the Basic Instruction Set, the Extended Instruction
Set, and the System Control Instruction Set. The "hierarchy" of instruction
sets defined by this partitioning helps to clarify the relationships
between the various processors in the 8086 family (see figure 2-15).

- The **Basic Instruction Set**, presented in Chapter 3, comprises the common subset of instructions found on all processors of the 8086 family. Included are instructions for logical and arithmetic operations, data movement, input/output, string manipulation, and transfer of control.
- The **Extended Instruction Set**, presented in Chapter 4, consists of those instructions found only on the 80186, 80188, and 80286 processors. Included are instructions for block structured procedure entry and exit, parameter validation, and block I/O transfers.
- The **System Control Instruction Set**, presented in Chapter 10, consists of those instructions unique to the 80286. These instructions control the memory management and protection mechanisms of the 80286.

**Table 2-4. 80286 Interrupt Vector Assignments (Real Address Mode)**
| Interrupt Number | Function                               | Related Instructions                 | Return Address Before Instruction Causing Exception? |
|------------------|----------------------------------------|--------------------------------------|------------------------------------------------------|
| 0                | Divide error exception                 | DIV, IDIV                            | Yes                                                  |
| 1                | Single step interrupt                  | All                                  |                                                      |
| 2                | NMI interrupt                          | All                                  |                                                      |
| 3                | Breakpoint interrupt                   | INT                                  |                                                      |
| 4                | INTO detected overflow exception       | INTO                                 | No                                                   |
| 5                | BOUND range exceeded exception         | BOUND                                | Yes                                                  |
| 6                | Invalid opcode exception               | Any undefined opcode                 | Yes                                                  |
| 7                | Processor extension not available exception | ESC or WAIT                      | Yes                                                  |
| 8                | Interrupt table limit too small exception | INT vector is not within table limit | Yes                                                  |
| 9                | Processor extension segment overrun interrupt | ESC with memory operand extending beyond offset FFFF(H) | No |
| 10-12            | Reserved                               |                                      |                                                      |
| 13               | Segment overrun exception              | Word memory reference with offset = FFFF(H) or an attempt to execute past the end of a segment | Yes |
| 14, 15           | Reserved                               |                                      |                                                      |
| 16               | Processor extension error interrupt    | ESC or WAIT                          |                                                      |
| 17-31            | Reserved                               |                                      |                                                      |
| 32-255           | User defined                           |                                      |                                                      |

**Figure 2-15. Hierarchy of Instructions**
```
             ┌───────────────────────┐
             │                       │
             │                       │
             │  ┌─────────────────┐  │
             │  │                 │  │
             │  │  ┌───────────┐  │  │
             │  │  │   8086    ├<─┼──┼──BASIC INSTRUCTION SET
             │  │  │   8088    │  │  │
             │  │  └───────────┘  │  │
             │  │      80186 <───┼──┼──EXTENDED INSTRUCTION SET
             │  │      80188      │  │
             │  └─────────────────┘  │
             │         80286 <───────┼──SYSTEM CONTROL INSTRUCTION SET
             │                       │
             └───────────────────────┘
```

