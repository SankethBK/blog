---
title:  "80286 Manual Chapter 5 Summary "
date:   2025-08-18
draft: true
categories: ["cpu"]
tags: ["cpu", "80286"]
author: Sanketh
references:
---

# Chapter 5: Real Address Mode

The 80286 can be operated in either of two modes according to the status of
the Protection Enabled bit of the MSW status register. In contrast to the
"modes" and "mode bits" of some processors, however, the 80286 modes do not
represent a radical transition between conflicting architectures. Instead,
the setting of the Protection Enabled bit simply determines whether certain
advanced features, in addition to the baseline architecture of the 80286,
are to be made available to system designers and programmers.

If the Protection Enabled (PE) bit is set by the programmer, the processor
changes into Protected Virtual Address Mode. In this mode of operation,
memory addressing is performed in terms of virtual addresses, with on-chip
mapping mechanisms performing the virtual-to-physical translation. Only in
this mode can the system designer make use of the advanced architectural
features of the 80286: virtual memory support, system-wide protection, and
built-in multitasking mechanisms are among the new features provided in this
mode of operation. Refer to Part II of this book (Chapters 6, 7, 8, 9,
10, and 11) for details on Protected Mode operation.

Initially, upon system reset, the processor starts up in Real Address Mode.
In this mode of operation, all memory addressing is performed in terms of
real physical addresses. In effect, the architecture of the 80286 in
this mode is identical to that of the 8086 and other processors in the 8086
family. The principal features of this baseline architecture have already
been discussed throughout Part I (Chapters 2, 3, and 4) of this book.
This chapter discusses certain additional topicsÄÄaddressing, interrupt
handling, and system initializationÄÄthat complete the system programmer's
view of the 80286 in Real Address Mode.


## 5.1 Addressing and Segmentation

Like other processors in the 8086 family, the 80286 provides a one-megabyte
memory space (2^(20) bytes) when operated in Real Address Mode. Physical
addresses are the 20-bit values that uniquely identify each byte location in
this address space. Physical addresses, therefore, may range from 0 through
FFFFFH. Address bits A20-A23 may not always be zero in Real Address Mode.
A20-A23 should not be used by the system while the 80286 is operating in
Real Address Mode.

An address is specified by a 32-bit pointer containing two components: (1)
a 16-bit effective address offset that determines the displacement, in
bytes, of a particular location within a segment; and (2) a 16-bit segment
selector component that determines the starting address of the segment.
Both components of an address may be referenced explicitly by an instruction
(such as JMP, LES, LDS, or CALL); more often, however, the segment selector
is simply the contents of a segment register.

The interpretation of the first component, the effective address offset, is
straight-forward. Segments are at most 64K (2^(16)) bytes in length, so an
unsigned 16-bit quantity is sufficient to address any arbitrary byte
location with a segment. The lowest-addressed byte within a segment has an
offset of 0, and the highest-addressed byte has an offset of FFFFH. Data
operands must be completely contained within a segment and must be
contiguous. (These rules apply in both modes.)

A segment selector is the second component of a logical address. This
16-bit quantity specifies the starting address of a segment within a
physical address space of 2^(20) bytes.

Whenever the 80286 accesses memory in Real Address Mode, it generates a
20-bit physical address from a segment selector and offset value. The
segment selector value is left-shifted four bit positions to form the
segment base address. The offset is extended with 4 high order zeroes and
added to the base to form the physical address (see figure 5-1).

Therefore, every segment is required to start at a byte address that is
evenly divisible by 16; thus, each segment is positioned at a 20-bit
physical address whose least significant four bits are zeroes. This
arrangement allows the 80286 to interpret a segment selector as the
high-order 16 bits of a 20-bit segment base address.

No limit or access checks are performed by the 80286 in the Real Address
Mode. All segments are readable, writable, executable, and have a limit of
0FFFFH (65,535 bytes). To save physical memory, you can use unused portions
of a segment as another segment by overlapping the two (see figure 5-2).
The Intel 8086 software development tools support this feature via the
segment override and group operators. However, programs that access segment
B from segment A become incompatible in the protected virtual address mode.


### Figure 5-1a. Forming the Segment Base Address

                      16 BIT SEGMENT SELECTOR
         ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
         15                                              0
         ÉÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑ Í Í Í Í Í »
         º  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³0 ³0 ³0 ³0
         ÈÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏ Í Í Í Í Í ¼
         19                                                          0


### Figure 5-1b. Forming the 20-bit Physical Address in the Real Address Mode

               ÉÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑ Í Í Í Í Í »
 SEGMENT BASE  º  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³0 ³0 ³0 ³0
               ÈÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏ Í Í Í Í Í ¼
               19                                                          0
       +
               É Í Í Í Í Í ÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍ»
    OFFSET      0 ³0 ³0 ³0 ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  º
               È Í Í Í Í Í ÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍ¼
               19          15                                              0
       =
               ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ÉÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍÑÍÍ»
   PHYSICAL    º  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  º
   ADDRESS     ÈÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍÏÍÍ¼
               19                                                          0


### Figure 5-2. Overlapping Segments to Save Physical Memory

                                           
                            º               º
                            ÇÄ ÄÄ ÄÄ ÄÄ ÄÄ Ä× ÄÄÄ
                            º               º  
                            º               º  ³
                            º               º 64K SEGMENT B
                            º               º  ³
                        ÄÄÄ ×Ä ÄÄ ÄÄ ÄÄ ÄÄ Ä×  ³
                           º    OVERLAP    º  
                         ³  ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ÄÄÄÄÄ BASE OF
              SEGMENT A 64K º               º     SEGMENT B
                         ³  º               º
                         ³  º               º
                           º               º
                        ÄÄÄ ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ÄÄÄÄÄ BASE OF
                            º               º     SEGMENT A
                                           


## 5.2 Interrupt Handling

Program interrupts may be generated in either of two distinct ways. An
internal interrupt is caused directly by the currently executing program.
The execution of a particular instruction results in the occurrence of an
interrupt, whether intentionally (e.g., an INT n instruction) or as an
unanticipated exception (e.g., invalid opcode). On the other hand, an
external interrupt occurs asynchronously as the result of an event
external to the processor, and bears no necessary relationship with the
currently executing program. The INTR and NMI pins of the 80286 provide the
means by which external hardware signals the occurrence of such events.


### 5.2.1 Interrupt Vector Table

Whatever its origin, whether internal or external, an interrupt demands
immediate attention from an associated service routine. Control must be
transferred, at least for the moment, from the currently executing program
to the appropriate interrupt service routine. By means of interrupt
vectors, the 80286 handles such control transfers uniformly for both kinds
of interrupts.

An interrupt vector is an unsigned integer in the range of 0-255; every
interrupt is assigned such a vector. In some cases, the assignment is
predetermined and fixed: for example, an external NMI interrupt is
invariably associated with vector 2, while an internal divide exception is
always associated with vector 0. In most cases, however, the association of
an interrupt and a vector is established dynamically. An external INTR
interrupt, for example, supplies a vector in response to an interrupt
acknowledge bus cycle, while the INT n instruction supplies a vector
incorporated within the instruction itself. The vector is shifted two places
left to form a byte address into the table (see figure 5-3).

In any case, the 80286 uses the interrupt vector as an index into a table
in order to determine the address of the corresponding interrupt service
routine. For Real Address Mode, this table is known as the Interrupt Vector
Table. Its format is illustrated in figure 5-3.

The Interrupt Vector Table consists of as many as 256 consecutive entries,
each four bytes long. Each entry defines the address of a service routine to
be associated with the correspondingly numbered interrupt vector code.
Within each entry, an address is specified by a full 32-bit pointer that
consists of a 16-bit offset and a 16-bit segment selector. Interrupts 0-31
are reserved by Intel.

In Real Address Mode, the interrupt table can be accessed directly at
physical memory location 0 through 1023. In the protected virtual address
mode, however, the interrupt vector table has no fixed physical address and
cannot be directly accessed. Therefore, Real Address mode programs that
directly manipulate the interrupt vector table will not work in the
protected virtual address mode.


#### Table 5-1. Interrupt Processing Order

Order     Interrupt
1.        Instruction exception
2.        Single step
3.        NMI
4.        Processor extension segment overrun
5.        INTR


#### Figure 5-3. Interrupt Vector Table for Real Address Mode

     POWER TO
 INTERRUPT HANDLER                    PHYSICAL
       FOR:                           ADDRESS

                   ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
  INTERRUPT 255    º    POINTER    º   1020
                   ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
  INTERRUPT 254    º    POINTER    º   1018
                   ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
  INTERRUPT 253    º    POINTER    º¿ 1012
                   ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   º               º   ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÏÍÍÍÍÍÍÍÍÍÍÍÑÍÑÍ»
                   º               º   º0 ù ù ù ù ù ù ù 0³   VECTOR   ³0³0º
                   ÷               ÷   ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÏÍÏÍ¼
                   º               º   19              10 9           2 1 0
                   º               º
                   ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
  INTERRUPT 1      º    POINTER    º   4
                   ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
  INTERRUPT 0      º    POINTER    º   0
                   ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼


#### 5.2.1.1 Interrupt Priorities

When simultaneous interrupt requests occur, they are processed in a fixed
order as shown in table 5-1. Interrupt processing involves saving the
flags, the return address, and setting CS:IP to point at the first
instruction of the interrupt handler. If other interrupts remain enabled,
they are processed before the first instruction of the current interrupt
handler is executed. The last interrupt processed is therefore the first one
serviced.


### 5.2.2 Interrupt Procedures

When an interrupt occurs in Real Address Mode, the 8086 performs the
following sequence of steps. First, the FLAGS register, as well as the old
values of CS and IP, are pushed onto the stack (see figure 5-4). The IF and
TF flag bits are cleared. The vector number is then used to read the
address of the interrupt service routine from the interrupt table. Execution
begins at this address.

Thus, when control is passed to an interrupt service routine, the return
linkage is placed on the stack, interrupts are disabled, and single-step
trace (if in effect) is turned off. The IRET instruction at the end of the
interrupt service routine will reverse these steps before transferring
control to the program that was interrupted.

An interrupt service routine may affect registers other than other IP, CS,
and FLAGS. It is the responsibility of an interrupt routine to save
additional context information before proceeding so that the state of the
machine can be restored upon completion of the interrupt service routine
(PUSHA and POPA instructions are intended for these operations). Finally,
execution of the IRET instruction pops the old IP, CS, and FLAGS from the
stack and resumes the execution of the interrupted program.


#### Figure 5-4. Stack Structure after Interrupt (Real Address Mode)
 
                               º               º
                               ÷               ÷
                              ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
                             ³ º   OLD FLAGS   º
                 INCREASING  ³ ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
                 ADDRESSES   ³ º    OLD CS     º
                             ³ ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
                             ³ º    OLD IP     ºÄÄ <SS:SP>
                             ³ ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹
                               º              º
                               ÷              ÷
                               º              º


### 5.2.3 Reserved and Dedicated Interrupt Vectors

In general, the system designer is free to use almost any interrupt vectors
for any given purpose. Some of the lowest-numbered vectors, however, are
reserved by Intel for dedicated functions; their use is specifically implied
by certain types of exceptions. None of the first 32 vectors should be
defined by the user; these vectors are either invoked by pre-defined
exceptions or reserved by Intel for future expansion. Table 5-2 shows the
dedicated and reserved vectors of the 80286 in Real Address Mode.

The purpose and function of the dedicated interrupt vectors may be
summarized as follows (the saved value of CS:IP will include all leading
prefixes):

  þ  Divide error (Interrupt 0). This exception will occur if the quotient
     is too large or an attempt is made to divide by zero using either the
     DIV or IDIV instruction. The saved CS:IP points at the first byte of
     the failing instruction. DX and AX are unchanged.

  þ  Single-Step (Interrupt 1). This interrupt will occur after
     each instruction if the Trap Flag (TF) bit of the FLAGS register is
     set. Of course, TF is cleared upon entry to this or any other interrupt
     to prevent infinite recursion. The saved value of CS:IP will point to
     the next instruction.

  þ  Nonmaskable (Interrupt 2). This interrupt will occur upon receipt of
     an external signal on the NMI pin. Typically, the nonmaskable interrupt
     is used to implement power-fail/auto-restart procedures. The saved
     value of CS:IP will point to the first byte of the interrupted
     instruction.

  þ  Breakpoint (Interrupt 3). Execution of the one-byte breakpoint
     instruction causes this interrupt to occur. This instruction is useful
     for the implementation of software debuggers since it requires only one
     code byte and can be substituted for any instruction opcode byte. The
     saved value of CS:IP will point to the next instruction.

  þ  INTO Detected Overflow (Interrupt 4). Execution of the INTO
     conditional software interrupt instruction will cause this interrupt
     to occur if the overflow bit (OF) of the FLAGS register is set. The
     saved value of CS:IP will point to the next instruction.

  þ  BOUND Range Exceeded (Interrupt 5). Execution of the BOUND instruction
     will cause this interrupt to occur if the specified array index is
     found to be invalid with respect to the given array bounds. The saved
     value of CS:IP will point to the first byte of the BOUND instruction.

  þ  Invalid Opcode (Interrupt 6). This exception will occur if execution
     of an invalid opcode is attempted. (In Real Address Mode, most of the
     Protected Virtual Address Mode instructions are classified as invalid
     and should not be used). This interrupt can also occur if the
     effective address given by certain instructions, notably BOUND, LDS,
     LES, and LIDT, specifies a register rather than a memory location. The
     saved value of CS:IP will point to the first byte of the
     invalid instruction or opcode.

  þ  Processor Extension Not Available (Interrupt 7). Execution of the ESC
     instruction will cause this interrupt to occur if the status bits of
     the MSW indicate that processor extension functions are to be emulated
     in software. Refer to section 10.2.1 for more details. The saved value
     of CS:IP will point to the first byte of the ESC or the WAIT
     instruction.

  þ  Interrupt Table Limit Too Small (Interrupt 8). This interrupt will
     occur if the limit of the interrupt vector table was changed from 3FFH
     by the LIDT instruction and an interrupt whose vector is outside the
     limit occurs. The saved value of CS:IP will point to the first byte of
     the instruction that caused the interrupt or that was ready to execute
     before an external interrupt occurred. No error code is pushed.

  þ  Processor Extension Segment Overrun Interrupt (Interrupt 9). The
     interrupt will occur if a processor extension memory operand does not
     fit in a segment. The saved CS:IP will point at the first byte of the
     instruction that caused the interrupt.

  þ  Segment Overrun Exception (Interrupt 13). This interrupt will occur if
     a memory operand does not fit in a segment. In Real Mode this will
     occur only when a word operand begins at segment offset 0FFFFH. The
     saved CS:IP will point at the first byte of the instruction that
     caused the interrupt. No error code is pushed.

  þ  Processor Extension Error (Interrupt 16). This interrupt occurs after
     the numeric instruction that caused the error. It can only occur while
     executing a subsequent WAIT or ESC. The saved value of CS:IP will point
     to the first byte of the ESC or the WAIT instruction. The address of
     the failed numeric instruction is saved in the NPX.


#### Table 5-2. Dedicated and Reserved Interrupt Vectors in Real Address Mode


Function                  Interrupt   Related Instructions    Return Address
                          Number                              Before Instruction
                                                              Causing Exception?
Divide error exception        0       DIV, IDIV               Yes
Single step interrupt         1       All                     N/A
NMI interrupt                 2       All                     N/A
Breakpoint interrupt          3       INT                     N/A
INTO detected overflow        4       INTO                    No
exception
BOUND range exceeded          5       BOUND                   Yes
exception
Invalid opcode exception      6       Any undefined opcode    Yes
Processor extension           7       ESC or WAIT             Yes
not available exception
Interrupt table               8       LIDT                    Yes
limit too small
Processor extension           9       ESC                     Yes
segment overrun interrupt
Segment overrun exception     13      Any memory reference    Yes
                                      instruction that
                                      attempts to reference
                                      16-bit word at
                                      offset 0FFFFH.
Reserved                      10-12,
                              14, 15
Processor extension           16      ESC or WAIT             N/A
error interrupt
Reserved                      17-31
User defined                  32-255

N/A = Not Applicable


## 5.3 System Initialization

The 80286 provides an orderly way to start or restart an executing system.
Upon receipt of the RESET signal, certain processor registers go into the
determinate state shown in table 5-3.

Since the CS register contains F000 (thus specifying a code segment
starting at physical address F0000) and the instruction pointer contains
FFF0, the processor will execute its first instruction at physical address
FFFF0H. The uppermost 16 bytes of physical memory are therefore reserved
for initial startup logic. Ordinarily, this location contains an
intersegment direct JMP instruction whose target is the actual beginning of
a system initialization or restart program.

Some of the steps normally performed by a system initialization routine are
as follows:

  þ  Allocate a stack.

  þ  Load programs and data from secondary storage into memory.

  þ  Initialize external devices.

  þ  Enable interrupts (i.e., set the IF bit of the FLAGS register). Set
     any other desired FLAGS bit as well.

  þ  Set the appropriate MSW flags if a processor extension is present, or
     if processor extension functions are to be emulated by software.

  þ  Set other registers, as appropriate, to the desired initial values.

  þ  Execute. (Ordinarily, this last step is performed as an intersegment
     JMP to the main system program.)


### Table 5-3. Processor State after RESET

Register     Contents
FLAGS        0002
MSW          FFF0
IP           FFF0
CS           F000
DS           0000
SS           0000
ES           0000
