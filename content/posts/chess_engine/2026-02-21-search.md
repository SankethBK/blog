---
title:  "Search"
date:   2026-02-21
draft: true
categories: ["chess engines"]
tags: ["search"]
author: Sanketh

---

# Search

## Thread::search() - Iterative Deepening Loop

This is the top-level search function - it orchestrates everything!

```
Thread::search()
├─ Iterative deepening loop (depth 1, 2, 3, ...)
│  ├─ For each depth:
│  │  ├─ Set aspiration windows
│  │  ├─ Call main search() function
│  │  ├─ Handle fail-high/fail-low
│  │  └─ Update best move
│  │
│  └─ Time management decisions
│
└─ Return best move
```

This function doesn't DO the search - it MANAGES the search!

### Step 1 — Initialize Node

```cpp
    // Step 1. Initialize node
    Thread* thisThread = pos.this_thread();
    inCheck = pos.checkers();
    moveCount = quietCount =  ss->moveCount = 0;
    ss->history = VALUE_ZERO;
    bestValue = -VALUE_INFINITE;
    ss->ply = (ss-1)->ply + 1;

    // Check for the available remaining time
    if (thisThread->resetCalls.load(std::memory_order_relaxed))
    {
        thisThread->resetCalls = false;
        thisThread->callsCnt = 0;
    }
    if (++thisThread->callsCnt > 4096)
    {
        for (Thread* th : Threads)
            th->resetCalls = true;

        check_time();
    }

    // Used to send selDepth info to GUI
    if (PvNode && thisThread->maxPly < ss->ply)
        thisThread->maxPly = ss->ply;

        if (!rootNode)
        {
```

```cpp
Thread* thisThread = pos.this_thread();
```

Each search thread has its own:
- Node counter
- History tables
- TT writer
- Time control data

Search is multi-threaded, so this grabs the current thread context.

Check if we are in check

```cpp
inCheck = pos.checkers();
```

Stores whether side to move is in check.

This affects:
- Extensions
- Pruning rules
- Null move
- Move generation stage

**Reset move counters**

```cpp
moveCount = quietCount = ss->moveCount = 0;
```

Three counters:
- moveCount → total moves tried at this node
- quietCount → quiet moves tried
- ss->moveCount → stored in stack (used by LMR, pruning decisions)

Each node tracks how many moves have been searched so far.

**Reset history signal**

```cpp
ss->history = VALUE_ZERO;
```

This accumulates history bonuses for current move.

Used later for updating history tables.

**Initialize bestValue**

```cpp
bestValue = -VALUE_INFINITE;
```

Standard alpha-beta initialization.

We haven’t searched anything yet.

**Compute ply**

```cpp
ss->ply = (ss-1)->ply + 1;
```

This tracks:

> Distance from root.

Used for:
- Mate distance adjustments
- Pruning depth scaling
- History scaling
- Reporting selDepth

Important:
This is search depth, not move number.

#### Time Management Section

This part prevents checking the clock every node.

**Reset call counter if flagged**

```cpp
if (thisThread->resetCalls.load(...))
```

If some thread signaled:

> “Reset time checking counters”

Then reset.

This is inter-thread coordination.

**Count calls**

```cpp
if (++thisThread->callsCnt > 4096)
```

Every 4096 nodes:
- Trigger time check
- Signal other threads

This avoids expensive check_time() every node.

Time checking is costly.

So it’s batched.

**Signal all threads**

```cpp
for (Thread* th : Threads)
    th->resetCalls = true;
```

Tell all threads:

> “Time check just happened, reset your counters.”

**Actually check time**

```cpp
check_time();
```

This may:
- Stop search
- Adjust limits
- Abort iteration

#### Update selDepth

```cpp
if (PvNode && thisThread->maxPly < ss->ply)
    thisThread->maxPly = ss->ply;
```

selDepth = selective depth.

This is:

> Deepest ply reached so far in search.

Sent to GUI.

Only updated on PV nodes to avoid noise.

### Step 2 — Early Termination Conditions

```cpp
        // Step 2. Check for aborted search and immediate draw
        if (Signals.stop.load(std::memory_order_relaxed) || pos.is_draw() || ss->ply >= MAX_PLY)
            return ss->ply >= MAX_PLY && !inCheck ? evaluate(pos)
                                                  : DrawValue[pos.side_to_move()];
```

If any of these are true → immediately return.


#### Signals.stop

```cpp
Signals.stop.load(...)
```

This is the global stop flag.

It is set when:
- Time is up
- GUI sends stop
- Search should terminate (mate found, etc.)

Because multiple threads exist,
this must be atomic.

memory_order_relaxed is used because:
- We only care if it eventually becomes true
- No strict ordering is required
- Faster atomic read

If stop is true:

→ immediately return

No more search.

#### pos.is_draw()

This checks:
- Threefold repetition
- 50-move rule
- Insufficient material

If position is drawn:

Return draw value immediately.

No reason to search further.

#### ss->ply >= MAX_PLY

This prevents infinite recursion.

MAX_PLY is typically 246 or similar.

Why needed?

Because:
- Extensions can increase depth
- Recursive search might exceed bounds
- We must prevent stack overflow

So if we hit maximum allowed depth:

We stop.

#### What Does It Return?

```cpp
return ss->ply >= MAX_PLY && !inCheck
       ? evaluate(pos)
       : DrawValue[pos.side_to_move()];
```

This ternary has two branches.

**Case A: We hit MAX_PLY AND not in check**

```cpp
evaluate(pos)
```

Why?

If we are not in check,
we can safely evaluate the position statically.

This is like a forced leaf node.

**Case B: Otherwise**

Return:

```cpp
DrawValue[pos.side_to_move()]
```

Which is typically 0 (or slight contempt-adjusted value).

This covers:
- Stop flag
- Draw
- MAX_PLY while in check