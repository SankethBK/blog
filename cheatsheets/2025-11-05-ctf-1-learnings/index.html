<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CTF Learnings: Matryoshka | Sanketh's Blog</title><meta name=keywords content="reverse-engineering,elf,gdb,radare2"><meta name=description content="Learnings from CTF Challenge: Matryoshka
This document summarizes the key tools, commands, and concepts from the Matryoshka crackme challenge.
1. Static Analysis
Commands to gather information without executing the binary.

  
      
          Command
          Description
      
  
  
      
          file ./binary
          Identifies file type, architecture, and if it&rsquo;s stripped.
      
      
          strings ./binary
          Extracts human-readable strings. Use -n <length> for longer strings.
      
      
          checksec ./binary
          Checks for security mitigations like Canary, PIE, NX, and RELRO.
      
      
          readelf -h ./binary
          Displays the ELF header. Good for finding the entry point.
      
      
          readelf -l ./binary
          Displays the program headers. Can find the INTERP segment.
      
      
          readelf -r ./binary
          Shows relocation entries, revealing which library functions are used.
      
  

2. Dynamic Analysis & Debugging
strace
Traces system calls made by a process."><meta name=author content="Gemini"><link rel=canonical href=https://sankethbk.github.io/blog/cheatsheets/2025-11-05-ctf-1-learnings/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.deee627d8b8d9065acc54b2c9d901e601e142335047d242a93ba7bce86f41f19.css integrity="sha256-3u5ifYuNkGWsxUssnZAeYB4UIzUEfSQqk7p7zob0Hxk=" rel="preload stylesheet" as=style><link rel=icon href=https://sankethbk.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sankethbk.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sankethbk.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://sankethbk.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://sankethbk.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sankethbk.github.io/blog/cheatsheets/2025-11-05-ctf-1-learnings/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sankethbk.github.io/blog/cheatsheets/2025-11-05-ctf-1-learnings/"><meta property="og:site_name" content="Sanketh's Blog"><meta property="og:title" content="CTF Learnings: Matryoshka"><meta property="og:description" content="Learnings from CTF Challenge: Matryoshka This document summarizes the key tools, commands, and concepts from the Matryoshka crackme challenge.
1. Static Analysis Commands to gather information without executing the binary.
Command Description file ./binary Identifies file type, architecture, and if it’s stripped. strings ./binary Extracts human-readable strings. Use -n <length> for longer strings. checksec ./binary Checks for security mitigations like Canary, PIE, NX, and RELRO. readelf -h ./binary Displays the ELF header. Good for finding the entry point. readelf -l ./binary Displays the program headers. Can find the INTERP segment. readelf -r ./binary Shows relocation entries, revealing which library functions are used. 2. Dynamic Analysis & Debugging strace Traces system calls made by a process."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="cheatsheets"><meta property="article:published_time" content="2025-11-04T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-04T00:00:00+00:00"><meta property="article:tag" content="Reverse-Engineering"><meta property="article:tag" content="Elf"><meta property="article:tag" content="Gdb"><meta property="article:tag" content="Radare2"><meta name=twitter:card content="summary"><meta name=twitter:title content="CTF Learnings: Matryoshka"><meta name=twitter:description content="Learnings from CTF Challenge: Matryoshka
This document summarizes the key tools, commands, and concepts from the Matryoshka crackme challenge.
1. Static Analysis
Commands to gather information without executing the binary.

  
      
          Command
          Description
      
  
  
      
          file ./binary
          Identifies file type, architecture, and if it&rsquo;s stripped.
      
      
          strings ./binary
          Extracts human-readable strings. Use -n <length> for longer strings.
      
      
          checksec ./binary
          Checks for security mitigations like Canary, PIE, NX, and RELRO.
      
      
          readelf -h ./binary
          Displays the ELF header. Good for finding the entry point.
      
      
          readelf -l ./binary
          Displays the program headers. Can find the INTERP segment.
      
      
          readelf -r ./binary
          Shows relocation entries, revealing which library functions are used.
      
  

2. Dynamic Analysis & Debugging
strace
Traces system calls made by a process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cheatsheets","item":"https://sankethbk.github.io/blog/cheatsheets/"},{"@type":"ListItem","position":2,"name":"CTF Learnings: Matryoshka","item":"https://sankethbk.github.io/blog/cheatsheets/2025-11-05-ctf-1-learnings/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CTF Learnings: Matryoshka","name":"CTF Learnings: Matryoshka","description":"Learnings from CTF Challenge: Matryoshka This document summarizes the key tools, commands, and concepts from the Matryoshka crackme challenge.\n1. Static Analysis Commands to gather information without executing the binary.\nCommand Description file ./binary Identifies file type, architecture, and if it\u0026rsquo;s stripped. strings ./binary Extracts human-readable strings. Use -n \u0026lt;length\u0026gt; for longer strings. checksec ./binary Checks for security mitigations like Canary, PIE, NX, and RELRO. readelf -h ./binary Displays the ELF header. Good for finding the entry point. readelf -l ./binary Displays the program headers. Can find the INTERP segment. readelf -r ./binary Shows relocation entries, revealing which library functions are used. 2. Dynamic Analysis \u0026amp; Debugging strace Traces system calls made by a process.\n","keywords":["reverse-engineering","elf","gdb","radare2"],"articleBody":"Learnings from CTF Challenge: Matryoshka This document summarizes the key tools, commands, and concepts from the Matryoshka crackme challenge.\n1. Static Analysis Commands to gather information without executing the binary.\nCommand Description file ./binary Identifies file type, architecture, and if it’s stripped. strings ./binary Extracts human-readable strings. Use -n for longer strings. checksec ./binary Checks for security mitigations like Canary, PIE, NX, and RELRO. readelf -h ./binary Displays the ELF header. Good for finding the entry point. readelf -l ./binary Displays the program headers. Can find the INTERP segment. readelf -r ./binary Shows relocation entries, revealing which library functions are used. 2. Dynamic Analysis \u0026 Debugging strace Traces system calls made by a process.\n# Trace the program, follow forks (-f), show long strings (-s 200), and output to a file (-o) strace -f -s 200 -o trace.log ./binary Look for failed execve calls or other errors (-1 EFAULT).\nGDB (GNU Debugger) Powerful for inspecting a program’s state at runtime.\nGDB Command Description gdb ./binary Start debugging. break Set a breakpoint (e.g., break execve). run Execute the program with arguments. info inferiors List the processes being debugged to get the PID. p/x $register Print the value of a register in hex (e.g., p/x $rsi). x/[N][F][S] Examine memory. x/8gx $rsi (examine 8 giant words in hex from RSI). x/s Examine memory as a null-terminated string. GDB Workflow Example:\ngdb ./matryoshka break execve run f info inferiors (get PID) printf \"argv_ptr = 0x%lx\\n\", $rsi (inspect execve arguments) x/8gx $rsi (examine the argv array) x/s (examine the string content of an argv entry) 3. Reverse Engineering with Radare2 A powerful framework for reverse engineering.\nCore Analysis Commands r2 Command Description r2 ./binary Open the binary for analysis. aaa Analyze All Automatically. Finds functions, symbols, etc. afl Analyze Function List. Shows all identified functions. s Seek to a specific address or function name (e.g., s main). pdf Print Disassembled Function. Shows assembly code. pdg Print Decompiled Ghidra. Shows decompiled C-like code. afv Analyze Function Variables. Shows local variables, arguments, and their stack offsets. Additional Useful Commands r2 Command Description i Show general information about the binary (imports, exports, strings). ps Print a summary of the binary’s sections. V Enter visual mode for interactive navigation. VV Enter visual graph mode to see the control flow graph. ? / ?? Get help on commands. 4. Key Syscalls \u0026 Library Functions Function Purpose \u0026 Relevance memfd_create() Creates an anonymous file descriptor in RAM. The file behaves like a regular file (it can be written to, mapped, etc.) but lives in volatile memory. It is automatically released when all references are dropped. The file path shows up in /proc/self/fd/ with a memfd: prefix, which is a strong indicator of in-memory execution. execve() Executes a program. The arguments are (path, argv, envp). A common target for breakpoints to see what new process is being spawned. __libc_start_main() A standard C library function that sets up the environment and calls main. __stack_chk_fail() Called when a stack canary detects a buffer overflow. 5. Core Concepts Concept Description Nested/Packed Binary An executable hidden inside another. The outer binary’s job is to decrypt or unpack the inner one and execute it. XOR Cipher A simple symmetric encryption. If you know part of the plaintext (like the ELF magic \\x7fELF), you can XOR it with the ciphertext to find the key. /proc Filesystem A virtual filesystem in Linux that exposes kernel and process information. Crucial for forensics and debugging. /proc/[pid]/fd/[fd] A special path to access the content of a process’s open file descriptors. Used to extract the in-memory ELF file. PIE (Position-Indep. Executable) The binary’s memory addresses are randomized at runtime. This means you work with offsets, not absolute addresses. 6. CTF Pattern: In-Memory Execution Identify: The program uses memfd_create, write, and execve. Intercept: Set a breakpoint in GDB on execve. Run: Run the program with the correct input to trigger the decryption. Extract: When the breakpoint hits, get the process PID (info inferiors). Copy the in-memory file to disk: cp /proc//fd/ ./extracted_binary. Repeat: Analyze the extracted_binary. Repeat the process if it’s another layer. ","wordCount":"687","inLanguage":"en","datePublished":"2025-11-04T00:00:00Z","dateModified":"2025-11-04T00:00:00Z","author":{"@type":"Person","name":"Gemini"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sankethbk.github.io/blog/cheatsheets/2025-11-05-ctf-1-learnings/"},"publisher":{"@type":"Organization","name":"Sanketh's Blog","logo":{"@type":"ImageObject","url":"https://sankethbk.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sankethbk.github.io/blog/ accesskey=h title="Sanketh's Blog (Alt + H)">Sanketh's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CTF Learnings: Matryoshka</h1><div class=post-meta><span title='2025-11-04 00:00:00 +0000 UTC'>November 4, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Gemini&nbsp;|&nbsp;<a href=https://github.com/SankethBK/blog/edit/main/content/cheatsheets/2025-11-05-ctf-1-learnings.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#learnings-from-ctf-challenge-matryoshka aria-label="Learnings from CTF Challenge: Matryoshka">Learnings from CTF Challenge: Matryoshka</a><ul><li><a href=#1-static-analysis aria-label="1. Static Analysis">1. Static Analysis</a></li><li><a href=#2-dynamic-analysis--debugging aria-label="2. Dynamic Analysis & Debugging">2. Dynamic Analysis & Debugging</a><ul><li><a href=#strace aria-label=strace>strace</a></li><li><a href=#gdb-gnu-debugger aria-label="GDB (GNU Debugger)">GDB (GNU Debugger)</a></li></ul></li><li><a href=#3-reverse-engineering-with-radare2 aria-label="3. Reverse Engineering with Radare2">3. Reverse Engineering with Radare2</a><ul><li><a href=#core-analysis-commands aria-label="Core Analysis Commands">Core Analysis Commands</a></li><li><a href=#additional-useful-commands aria-label="Additional Useful Commands">Additional Useful Commands</a></li></ul></li><li><a href=#4-key-syscalls--library-functions aria-label="4. Key Syscalls & Library Functions">4. Key Syscalls & Library Functions</a></li><li><a href=#5-core-concepts aria-label="5. Core Concepts">5. Core Concepts</a></li><li><a href=#6-ctf-pattern-in-memory-execution aria-label="6. CTF Pattern: In-Memory Execution">6. CTF Pattern: In-Memory Execution</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=learnings-from-ctf-challenge-matryoshka>Learnings from CTF Challenge: Matryoshka<a hidden class=anchor aria-hidden=true href=#learnings-from-ctf-challenge-matryoshka>#</a></h1><p>This document summarizes the key tools, commands, and concepts from the Matryoshka crackme challenge.</p><h2 id=1-static-analysis>1. Static Analysis<a hidden class=anchor aria-hidden=true href=#1-static-analysis>#</a></h2><p>Commands to gather information without executing the binary.</p><table><thead><tr><th style=text-align:left>Command</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>file ./binary</code></td><td style=text-align:left>Identifies file type, architecture, and if it&rsquo;s stripped.</td></tr><tr><td style=text-align:left><code>strings ./binary</code></td><td style=text-align:left>Extracts human-readable strings. Use <code>-n &lt;length></code> for longer strings.</td></tr><tr><td style=text-align:left><code>checksec ./binary</code></td><td style=text-align:left>Checks for security mitigations like Canary, PIE, NX, and RELRO.</td></tr><tr><td style=text-align:left><code>readelf -h ./binary</code></td><td style=text-align:left>Displays the ELF header. Good for finding the entry point.</td></tr><tr><td style=text-align:left><code>readelf -l ./binary</code></td><td style=text-align:left>Displays the program headers. Can find the <code>INTERP</code> segment.</td></tr><tr><td style=text-align:left><code>readelf -r ./binary</code></td><td style=text-align:left>Shows relocation entries, revealing which library functions are used.</td></tr></tbody></table><h2 id=2-dynamic-analysis--debugging>2. Dynamic Analysis & Debugging<a hidden class=anchor aria-hidden=true href=#2-dynamic-analysis--debugging>#</a></h2><h3 id=strace>strace<a hidden class=anchor aria-hidden=true href=#strace>#</a></h3><p>Traces system calls made by a process.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Trace the program, follow forks (-f), show long strings (-s 200), and output to a file (-o)</span>
</span></span><span style=display:flex><span>strace -f -s <span style=color:#ae81ff>200</span> -o trace.log ./binary &lt;args&gt;
</span></span></code></pre></div><p>Look for failed <code>execve</code> calls or other errors (<code>-1 EFAULT</code>).</p><h3 id=gdb-gnu-debugger>GDB (GNU Debugger)<a hidden class=anchor aria-hidden=true href=#gdb-gnu-debugger>#</a></h3><p>Powerful for inspecting a program&rsquo;s state at runtime.</p><table><thead><tr><th style=text-align:left>GDB Command</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>gdb ./binary</code></td><td style=text-align:left>Start debugging.</td></tr><tr><td style=text-align:left><code>break &lt;address/symbol></code></td><td style=text-align:left>Set a breakpoint (e.g., <code>break execve</code>).</td></tr><tr><td style=text-align:left><code>run &lt;args></code></td><td style=text-align:left>Execute the program with arguments.</td></tr><tr><td style=text-align:left><code>info inferiors</code></td><td style=text-align:left>List the processes being debugged to get the PID.</td></tr><tr><td style=text-align:left><code>p/x $register</code></td><td style=text-align:left>Print the value of a register in hex (e.g., <code>p/x $rsi</code>).</td></tr><tr><td style=text-align:left><code>x/[N][F][S] &lt;address></code></td><td style=text-align:left>Examine memory. <code>x/8gx $rsi</code> (examine 8 giant words in hex from RSI).</td></tr><tr><td style=text-align:left><code>x/s &lt;address></code></td><td style=text-align:left>Examine memory as a null-terminated string.</td></tr></tbody></table><p><strong>GDB Workflow Example:</strong></p><ol><li><code>gdb ./matryoshka</code></li><li><code>break execve</code></li><li><code>run f</code></li><li><code>info inferiors</code> (get PID)</li><li><code>printf "argv_ptr = 0x%lx\n", $rsi</code> (inspect <code>execve</code> arguments)</li><li><code>x/8gx $rsi</code> (examine the <code>argv</code> array)</li><li><code>x/s &lt;address_from_above></code> (examine the string content of an <code>argv</code> entry)</li></ol><h2 id=3-reverse-engineering-with-radare2>3. Reverse Engineering with Radare2<a hidden class=anchor aria-hidden=true href=#3-reverse-engineering-with-radare2>#</a></h2><p>A powerful framework for reverse engineering.</p><h3 id=core-analysis-commands>Core Analysis Commands<a hidden class=anchor aria-hidden=true href=#core-analysis-commands>#</a></h3><table><thead><tr><th style=text-align:left>r2 Command</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>r2 ./binary</code></td><td style=text-align:left>Open the binary for analysis.</td></tr><tr><td style=text-align:left><code>aaa</code></td><td style=text-align:left><strong>A</strong>nalyze <strong>A</strong>ll <strong>A</strong>utomatically. Finds functions, symbols, etc.</td></tr><tr><td style=text-align:left><code>afl</code></td><td style=text-align:left><strong>A</strong>nalyze <strong>F</strong>unction <strong>L</strong>ist. Shows all identified functions.</td></tr><tr><td style=text-align:left><code>s &lt;address/name></code></td><td style=text-align:left><strong>S</strong>eek to a specific address or function name (e.g., <code>s main</code>).</td></tr><tr><td style=text-align:left><code>pdf</code></td><td style=text-align:left><strong>P</strong>rint <strong>D</strong>isassembled <strong>F</strong>unction. Shows assembly code.</td></tr><tr><td style=text-align:left><code>pdg</code></td><td style=text-align:left><strong>P</strong>rint <strong>D</strong>ecompiled <strong>G</strong>hidra. Shows decompiled C-like code.</td></tr><tr><td style=text-align:left><code>afv</code></td><td style=text-align:left><strong>A</strong>nalyze <strong>F</strong>unction <strong>V</strong>ariables. Shows local variables, arguments, and their stack offsets.</td></tr></tbody></table><h3 id=additional-useful-commands>Additional Useful Commands<a hidden class=anchor aria-hidden=true href=#additional-useful-commands>#</a></h3><table><thead><tr><th style=text-align:left>r2 Command</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>i</code></td><td style=text-align:left>Show general information about the binary (imports, exports, strings).</td></tr><tr><td style=text-align:left><code>ps</code></td><td style=text-align:left>Print a summary of the binary&rsquo;s sections.</td></tr><tr><td style=text-align:left><code>V</code></td><td style=text-align:left>Enter visual mode for interactive navigation.</td></tr><tr><td style=text-align:left><code>VV</code></td><td style=text-align:left>Enter visual graph mode to see the control flow graph.</td></tr><tr><td style=text-align:left><code>?</code> / <code>??</code></td><td style=text-align:left>Get help on commands.</td></tr></tbody></table><h2 id=4-key-syscalls--library-functions>4. Key Syscalls & Library Functions<a hidden class=anchor aria-hidden=true href=#4-key-syscalls--library-functions>#</a></h2><table><thead><tr><th style=text-align:left>Function</th><th style=text-align:left>Purpose & Relevance</th></tr></thead><tbody><tr><td style=text-align:left><code>memfd_create()</code></td><td style=text-align:left><strong>Creates an anonymous file descriptor in RAM.</strong> The file behaves like a regular file (it can be written to, mapped, etc.) but lives in volatile memory. It is automatically released when all references are dropped. The file path shows up in <code>/proc/self/fd/</code> with a <code>memfd:</code> prefix, which is a strong indicator of in-memory execution.</td></tr><tr><td style=text-align:left><code>execve()</code></td><td style=text-align:left>Executes a program. The arguments are <code>(path, argv, envp)</code>. A common target for breakpoints to see what new process is being spawned.</td></tr><tr><td style=text-align:left><code>__libc_start_main()</code></td><td style=text-align:left>A standard C library function that sets up the environment and calls <code>main</code>.</td></tr><tr><td style=text-align:left><code>__stack_chk_fail()</code></td><td style=text-align:left>Called when a stack canary detects a buffer overflow.</td></tr></tbody></table><h2 id=5-core-concepts>5. Core Concepts<a hidden class=anchor aria-hidden=true href=#5-core-concepts>#</a></h2><table><thead><tr><th style=text-align:left>Concept</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><strong>Nested/Packed Binary</strong></td><td style=text-align:left>An executable hidden inside another. The outer binary&rsquo;s job is to decrypt or unpack the inner one and execute it.</td></tr><tr><td style=text-align:left><strong>XOR Cipher</strong></td><td style=text-align:left>A simple symmetric encryption. If you know part of the plaintext (like the ELF magic <code>\x7fELF</code>), you can XOR it with the ciphertext to find the key.</td></tr><tr><td style=text-align:left><strong>/proc Filesystem</strong></td><td style=text-align:left>A virtual filesystem in Linux that exposes kernel and process information. Crucial for forensics and debugging.</td></tr><tr><td style=text-align:left><strong>/proc/[pid]/fd/[fd]</strong></td><td style=text-align:left>A special path to access the content of a process&rsquo;s open file descriptors. Used to extract the in-memory ELF file.</td></tr><tr><td style=text-align:left><strong>PIE (Position-Indep. Executable)</strong></td><td style=text-align:left>The binary&rsquo;s memory addresses are randomized at runtime. This means you work with offsets, not absolute addresses.</td></tr></tbody></table><h2 id=6-ctf-pattern-in-memory-execution>6. CTF Pattern: In-Memory Execution<a hidden class=anchor aria-hidden=true href=#6-ctf-pattern-in-memory-execution>#</a></h2><ol><li><strong>Identify</strong>: The program uses <code>memfd_create</code>, <code>write</code>, and <code>execve</code>.</li><li><strong>Intercept</strong>: Set a breakpoint in GDB on <code>execve</code>.</li><li><strong>Run</strong>: Run the program with the correct input to trigger the decryption.</li><li><strong>Extract</strong>: When the breakpoint hits, get the process PID (<code>info inferiors</code>). Copy the in-memory file to disk: <code>cp /proc/&lt;PID>/fd/&lt;FD_NUM> ./extracted_binary</code>.</li><li><strong>Repeat</strong>: Analyze the <code>extracted_binary</code>. Repeat the process if it&rsquo;s another layer.</li></ol><pre tabindex=0><code></code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://sankethbk.github.io/blog/tags/reverse-engineering/>Reverse-Engineering</a></li><li><a href=https://sankethbk.github.io/blog/tags/elf/>Elf</a></li><li><a href=https://sankethbk.github.io/blog/tags/gdb/>Gdb</a></li><li><a href=https://sankethbk.github.io/blog/tags/radare2/>Radare2</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sankethbk.github.io/blog/>Sanketh's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>